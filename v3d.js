// Verge3D 4.11.0 Â© 2017-2025 Soft8Soft - v3d.net/eula
!function(t,e){"object"==typeof exports&&"undefined"!=typeof module?e(exports):"function"==typeof define&&define.amd?define(["exports"],e):e((t="undefined"!=typeof globalThis?globalThis:t||self).v3d={})}(this,function(t){"use strict";var e="undefined"!=typeof document?document.currentScript:null;const n="4.11.0",o="BLENDER",i={BLENDER:"4.11.0",MAX:"4.9.0",MAYA:"4.9.0"},r="__V3DL__0000000000",s={LEFT:0,MIDDLE:1,RIGHT:2,ROTATE:0,DOLLY:1,PAN:2},a=100,l=101,c=102,u=200,h=201,f=202,d=203,A=204,v=205,m=206,p=207,g=208,_=209,E=210,C=300,w=301,x=302,I=303,M=304,S=306,b=1e3,y=1001,R=1002,T=1003,B=1004,L=1005,N=1006,D=1007,P=1008,O=1009,F=1012,U=1013,V=1014,G=1015,Q=1016,z=1017,k=1018,H=1020,W=1023,Y=1026,X=1027,K=1028,j=1029,Z=1030,q=1031,J=1033,$=33776,tt=33777,et=33778,nt=33779,ot=35840,it=35841,rt=35842,st=35843,at=36196,lt=37492,ct=37496,ut=37808,ht=37809,ft=37810,dt=37811,At=37812,vt=37813,mt=37814,pt=37815,gt=37816,_t=37817,Et=37818,Ct=37819,wt=37820,xt=37821,It=36492,Mt=2200,St=2201,bt=2202,yt=2300,Rt=2301,Tt=2302,Bt=2400,Lt=2401,Nt=2402,Dt=2500,Pt=2501,Ot=3e3,Ft=3001,Ut=3201,Vt=3202,Gt=3301,Qt="srgb",zt="srgb-linear",kt=7680,Ht=7681,Wt=34055,Yt=34056,Xt=35044,Kt="300 es",jt=1035;class Zt{addEventListener(t,e){void 0===this.t&&(this.t={});const n=this.t;void 0===n[t]&&(n[t]=[]),-1===n[t].indexOf(e)&&n[t].push(e)}hasEventListener(t,e){if(void 0===this.t)return!1;const n=this.t;return void 0!==n[t]&&-1!==n[t].indexOf(e)}removeEventListener(t,e){if(void 0===this.t)return;const n=this.t[t];if(void 0!==n){const t=n.indexOf(e);-1!==t&&n.splice(t,1)}}dispatchEvent(t){if(void 0===this.t)return;const e=this.t[t.type];if(void 0!==e){t.target=this;const n=e.slice(0);for(let e=0,o=n.length;e<o;e++)n[e].call(this,t);t.target=null}}}const qt=new RegExp("^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}$"),Jt=Math.PI/180,$t=180/Math.PI,te=["00","01","02","03","04","05","06","07","08","09","0a","0b","0c","0d","0e","0f","10","11","12","13","14","15","16","17","18","19","1a","1b","1c","1d","1e","1f","20","21","22","23","24","25","26","27","28","29","2a","2b","2c","2d","2e","2f","30","31","32","33","34","35","36","37","38","39","3a","3b","3c","3d","3e","3f","40","41","42","43","44","45","46","47","48","49","4a","4b","4c","4d","4e","4f","50","51","52","53","54","55","56","57","58","59","5a","5b","5c","5d","5e","5f","60","61","62","63","64","65","66","67","68","69","6a","6b","6c","6d","6e","6f","70","71","72","73","74","75","76","77","78","79","7a","7b","7c","7d","7e","7f","80","81","82","83","84","85","86","87","88","89","8a","8b","8c","8d","8e","8f","90","91","92","93","94","95","96","97","98","99","9a","9b","9c","9d","9e","9f","a0","a1","a2","a3","a4","a5","a6","a7","a8","a9","aa","ab","ac","ad","ae","af","b0","b1","b2","b3","b4","b5","b6","b7","b8","b9","ba","bb","bc","bd","be","bf","c0","c1","c2","c3","c4","c5","c6","c7","c8","c9","ca","cb","cc","cd","ce","cf","d0","d1","d2","d3","d4","d5","d6","d7","d8","d9","da","db","dc","dd","de","df","e0","e1","e2","e3","e4","e5","e6","e7","e8","e9","ea","eb","ec","ed","ee","ef","f0","f1","f2","f3","f4","f5","f6","f7","f8","f9","fa","fb","fc","fd","fe","ff"];let ee=1234567;function ne(){const t=4294967295*Math.random()|0,e=4294967295*Math.random()|0,n=4294967295*Math.random()|0,o=4294967295*Math.random()|0;return(te[255&t]+te[t>>8&255]+te[t>>16&255]+te[t>>24&255]+"-"+te[255&e]+te[e>>8&255]+"-"+te[e>>16&15|64]+te[e>>24&255]+"-"+te[63&n|128]+te[n>>8&255]+"-"+te[n>>16&255]+te[n>>24&255]+te[255&o]+te[o>>8&255]+te[o>>16&255]+te[o>>24&255]).toLowerCase()}function oe(t){return qt.test(t)}function ie(t,e=0,n=1){return Math.max(e,Math.min(n,t))}function re(t,e){return(t%e+e)%e}function se(t,e,n){return(1-n)*t+n*e}function ae(t,e,n){return t<=e?0:t>=n?1:(t=(t-e)/(n-e))*t*t*(t*(6*t-15)+10)}function le(t){return t*Jt}function ce(t){return t*$t}function ue(t){return!(t&t-1)&&0!==t}function he(t){return Math.pow(2,Math.ceil(Math.log(t)/Math.LN2))}function fe(t){return Math.pow(2,Math.floor(Math.log(t)/Math.LN2))}function de(t,e){switch(e.constructor){case Float32Array:return t;case Uint16Array:return t/65535;case Uint8Array:return t/255;case Int16Array:return Math.max(t/32767,-1);case Int8Array:return Math.max(t/127,-1);default:throw new Error("Invalid component type.")}}function Ae(t,e){switch(e.constructor){case Float32Array:return t;case Uint16Array:return Math.round(65535*t);case Uint8Array:return Math.round(255*t);case Int16Array:return Math.round(32767*t);case Int8Array:return Math.round(127*t);default:throw new Error("Invalid component type.")}}function ve(t){let e=5381,n=t.length;for(;n;)e=33*e^t.charCodeAt(--n);return e>>>0}function me(t,e,n,o){let i=Math.exp(-n/o);return t*i+(1-i)*e}function pe(t,e,n,o,i){let r=me(t,e,n,o);return Math.abs(t-e)<i&&(r=e),r}function ge(t){return ie(t-2*Math.PI*Math.floor(t/(2*Math.PI)),0,2*Math.PI)}function _e(t){let e=t+Math.PI;return e%=2*Math.PI,e+=2*Math.PI,e%=2*Math.PI,e-=Math.PI,e}function Ee(t,e,n){let o=ge(t-e),i=ge(n-e);return o>i&&(o=o<i/2+Math.PI?i:0),o+e}var Ce=Object.freeze({__proto__:null,DEG2RAD:Jt,RAD2DEG:$t,angleToRange_0_2Pi:ge,angleToRange_mPi_Pi:_e,ceilPowerOfTwo:he,checkUUID:oe,clamp:ie,clampAngle:Ee,damp:function(t,e,n,o){return se(t,e,1-Math.exp(-n*o))},degToRad:le,denormalize:de,euclideanModulo:re,expAverage:me,expAverageClamp:pe,floorPowerOfTwo:fe,generateUUID:ne,hashString:ve,inverseLerp:function(t,e,n){return t!==e?(n-t)/(e-t):0},isPowerOfTwo:ue,lerp:se,mapLinear:function(t,e,n,o,i){return o+(t-e)*(i-o)/(n-e)},normalize:Ae,pingpong:function(t,e=1){return e-Math.abs(re(t,2*e)-e)},radToDeg:ce,randFloat:function(t,e){return t+Math.random()*(e-t)},randFloatSpread:function(t){return t*(.5-Math.random())},randInt:function(t,e){return t+Math.floor(Math.random()*(e-t+1))},seededRandom:function(t){void 0!==t&&(ee=t);let e=ee+=1831565813;return e=Math.imul(e^e>>>15,1|e),e^=e+Math.imul(e^e>>>7,61|e),((e^e>>>14)>>>0)/4294967296},setQuaternionFromProperEuler:function(t,e,n,o,i){const r=Math.cos,s=Math.sin,a=r(n/2),l=s(n/2),c=r((e+o)/2),u=s((e+o)/2),h=r((e-o)/2),f=s((e-o)/2),d=r((o-e)/2),A=s((o-e)/2);switch(i){case"XYX":t.set(a*u,l*h,l*f,a*c);break;case"YZY":t.set(l*f,a*u,l*h,a*c);break;case"ZXZ":t.set(l*h,l*f,a*u,a*c);break;case"XZX":t.set(a*u,l*A,l*d,a*c);break;case"YXY":t.set(l*d,a*u,l*A,a*c);break;case"ZYZ":t.set(l*A,l*d,a*u,a*c);break;default:console.warn("v3d.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: "+i)}},smootherstep:ae,smoothstep:function(t,e,n){return t<=e?0:t>=n?1:(t=(t-e)/(n-e))*t*(3-2*t)}});class we{constructor(t=0,e=0){we.prototype.isVector2=!0,this.x=t,this.y=e}get width(){return this.x}set width(t){this.x=t}get height(){return this.y}set height(t){this.y=t}set(t,e){return this.x=t,this.y=e,this}setScalar(t){return this.x=t,this.y=t,this}setX(t){return this.x=t,this}setY(t){return this.y=t,this}setComponent(t,e){switch(t){case 0:this.x=e;break;case 1:this.y=e;break;default:throw new Error("index is out of range: "+t)}return this}getComponent(t){switch(t){case 0:return this.x;case 1:return this.y;default:throw new Error("index is out of range: "+t)}}clone(){return new this.constructor(this.x,this.y)}copy(t){return this.x=t.x,this.y=t.y,this}add(t){return this.x+=t.x,this.y+=t.y,this}addScalar(t){return this.x+=t,this.y+=t,this}addVectors(t,e){return this.x=t.x+e.x,this.y=t.y+e.y,this}addScaledVector(t,e){return this.x+=t.x*e,this.y+=t.y*e,this}sub(t){return this.x-=t.x,this.y-=t.y,this}subScalar(t){return this.x-=t,this.y-=t,this}subVectors(t,e){return this.x=t.x-e.x,this.y=t.y-e.y,this}multiply(t){return this.x*=t.x,this.y*=t.y,this}multiplyScalar(t){return this.x*=t,this.y*=t,this}divide(t){return this.x/=t.x,this.y/=t.y,this}divideScalar(t){return this.multiplyScalar(1/t)}applyMatrix3(t){const e=this.x,n=this.y,o=t.elements;return this.x=o[0]*e+o[3]*n+o[6],this.y=o[1]*e+o[4]*n+o[7],this}min(t){return this.x=Math.min(this.x,t.x),this.y=Math.min(this.y,t.y),this}max(t){return this.x=Math.max(this.x,t.x),this.y=Math.max(this.y,t.y),this}clamp(t,e){return this.x=Math.max(t.x,Math.min(e.x,this.x)),this.y=Math.max(t.y,Math.min(e.y,this.y)),this}clampScalar(t,e){return this.x=Math.max(t,Math.min(e,this.x)),this.y=Math.max(t,Math.min(e,this.y)),this}clampLength(t,e){const n=this.length();return this.divideScalar(n||1).multiplyScalar(Math.max(t,Math.min(e,n)))}floor(){return this.x=Math.floor(this.x),this.y=Math.floor(this.y),this}ceil(){return this.x=Math.ceil(this.x),this.y=Math.ceil(this.y),this}round(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this}roundToZero(){return this.x=this.x<0?Math.ceil(this.x):Math.floor(this.x),this.y=this.y<0?Math.ceil(this.y):Math.floor(this.y),this}negate(){return this.x=-this.x,this.y=-this.y,this}dot(t){return this.x*t.x+this.y*t.y}cross(t){return this.x*t.y-this.y*t.x}lengthSq(){return this.x*this.x+this.y*this.y}length(){return Math.sqrt(this.x*this.x+this.y*this.y)}manhattanLength(){return Math.abs(this.x)+Math.abs(this.y)}normalize(){return this.divideScalar(this.length()||1)}angle(){return Math.atan2(-this.y,-this.x)+Math.PI}distanceTo(t){return Math.sqrt(this.distanceToSquared(t))}distanceToSquared(t){const e=this.x-t.x,n=this.y-t.y;return e*e+n*n}manhattanDistanceTo(t){return Math.abs(this.x-t.x)+Math.abs(this.y-t.y)}setLength(t){return this.normalize().multiplyScalar(t)}lerp(t,e){return this.x+=(t.x-this.x)*e,this.y+=(t.y-this.y)*e,this}lerpVectors(t,e,n){return this.x=t.x+(e.x-t.x)*n,this.y=t.y+(e.y-t.y)*n,this}equals(t){return t.x===this.x&&t.y===this.y}fromArray(t,e=0){return this.x=t[e],this.y=t[e+1],this}toArray(t=[],e=0){return t[e]=this.x,t[e+1]=this.y,t}fromBufferAttribute(t,e){return this.x=t.getX(e),this.y=t.getY(e),this}rotateAround(t,e){const n=Math.cos(e),o=Math.sin(e),i=this.x-t.x,r=this.y-t.y;return this.x=i*n-r*o+t.x,this.y=i*o+r*n+t.y,this}random(){return this.x=Math.random(),this.y=Math.random(),this}*[Symbol.iterator](){yield this.x,yield this.y}}class xe{constructor(){xe.prototype.isMatrix3=!0,this.elements=[1,0,0,0,1,0,0,0,1]}set(t,e,n,o,i,r,s,a,l){const c=this.elements;return c[0]=t,c[1]=o,c[2]=s,c[3]=e,c[4]=i,c[5]=a,c[6]=n,c[7]=r,c[8]=l,this}identity(){return this.set(1,0,0,0,1,0,0,0,1),this}copy(t){const e=this.elements,n=t.elements;return e[0]=n[0],e[1]=n[1],e[2]=n[2],e[3]=n[3],e[4]=n[4],e[5]=n[5],e[6]=n[6],e[7]=n[7],e[8]=n[8],this}extractBasis(t,e,n){return t.setFromMatrix3Column(this,0),e.setFromMatrix3Column(this,1),n.setFromMatrix3Column(this,2),this}setFromMatrix4(t){const e=t.elements;return this.set(e[0],e[4],e[8],e[1],e[5],e[9],e[2],e[6],e[10]),this}multiply(t){return this.multiplyMatrices(this,t)}premultiply(t){return this.multiplyMatrices(t,this)}multiplyMatrices(t,e){const n=t.elements,o=e.elements,i=this.elements,r=n[0],s=n[3],a=n[6],l=n[1],c=n[4],u=n[7],h=n[2],f=n[5],d=n[8],A=o[0],v=o[3],m=o[6],p=o[1],g=o[4],_=o[7],E=o[2],C=o[5],w=o[8];return i[0]=r*A+s*p+a*E,i[3]=r*v+s*g+a*C,i[6]=r*m+s*_+a*w,i[1]=l*A+c*p+u*E,i[4]=l*v+c*g+u*C,i[7]=l*m+c*_+u*w,i[2]=h*A+f*p+d*E,i[5]=h*v+f*g+d*C,i[8]=h*m+f*_+d*w,this}multiplyScalar(t){const e=this.elements;return e[0]*=t,e[3]*=t,e[6]*=t,e[1]*=t,e[4]*=t,e[7]*=t,e[2]*=t,e[5]*=t,e[8]*=t,this}determinant(){const t=this.elements,e=t[0],n=t[1],o=t[2],i=t[3],r=t[4],s=t[5],a=t[6],l=t[7],c=t[8];return e*r*c-e*s*l-n*i*c+n*s*a+o*i*l-o*r*a}invert(){const t=this.elements,e=t[0],n=t[1],o=t[2],i=t[3],r=t[4],s=t[5],a=t[6],l=t[7],c=t[8],u=c*r-s*l,h=s*a-c*i,f=l*i-r*a,d=e*u+n*h+o*f;if(0===d)return this.set(0,0,0,0,0,0,0,0,0);const A=1/d;return t[0]=u*A,t[1]=(o*l-c*n)*A,t[2]=(s*n-o*r)*A,t[3]=h*A,t[4]=(c*e-o*a)*A,t[5]=(o*i-s*e)*A,t[6]=f*A,t[7]=(n*a-l*e)*A,t[8]=(r*e-n*i)*A,this}transpose(){let t;const e=this.elements;return t=e[1],e[1]=e[3],e[3]=t,t=e[2],e[2]=e[6],e[6]=t,t=e[5],e[5]=e[7],e[7]=t,this}getNormalMatrix(t){return this.setFromMatrix4(t).invert().transpose()}transposeIntoArray(t){const e=this.elements;return t[0]=e[0],t[1]=e[3],t[2]=e[6],t[3]=e[1],t[4]=e[4],t[5]=e[7],t[6]=e[2],t[7]=e[5],t[8]=e[8],this}setUvTransform(t,e,n,o,i,r,s){const a=Math.cos(i),l=Math.sin(i);return this.set(n*a,n*l,-n*(a*r+l*s)+r+t,-o*l,o*a,-o*(-l*r+a*s)+s+e,0,0,1),this}scale(t,e){return this.premultiply(Ie.makeScale(t,e)),this}rotate(t){return this.premultiply(Ie.makeRotation(-t)),this}translate(t,e){return this.premultiply(Ie.makeTranslation(t,e)),this}makeTranslation(t,e){return this.set(1,0,t,0,1,e,0,0,1),this}makeRotation(t){const e=Math.cos(t),n=Math.sin(t);return this.set(e,-n,0,n,e,0,0,0,1),this}makeScale(t,e){return this.set(t,0,0,0,e,0,0,0,1),this}equals(t){const e=this.elements,n=t.elements;for(let t=0;t<9;t++)if(e[t]!==n[t])return!1;return!0}fromArray(t,e=0){for(let n=0;n<9;n++)this.elements[n]=t[n+e];return this}toArray(t=[],e=0){const n=this.elements;return t[e]=n[0],t[e+1]=n[1],t[e+2]=n[2],t[e+3]=n[3],t[e+4]=n[4],t[e+5]=n[5],t[e+6]=n[6],t[e+7]=n[7],t[e+8]=n[8],t}clone(){return(new this.constructor).fromArray(this.elements)}}const Ie=new xe;function Me(t){if(0===t.length)return-1/0;let e=t[0];for(let n=1,o=t.length;n<o;++n)t[n]>e&&(e=t[n]);return e}function Se(t){for(let e=t.length-1;e>=0;--e)if(t[e]>=65535)return!0;return!1}function be(t){return document.createElementNS("http://www.w3.org/1999/xhtml",t)}function ye(t){return void 0!==t}function Re(t,e,n){for(let o=0;o<t.length;o++)t[o]=ie(t[o],e,n);return t}function Te(t){return t.charAt(0).toUpperCase()+t.slice(1).toLowerCase()}function Be(t){return t.toLowerCase().replace(/_([a-zA-Z])/g,function(t){return t[1].toUpperCase()})}function Le(){switch(o){case"BLENDER":return"for Blender";case"MAX":return"for 3ds Max";case"MAYA":return"for Maya";case"ALL":return"Ultimate";default:return"Unknown"}}function Ne(t){var e,n;const o=null!=(e=t.match(/^[a-zA-Z38 ]*(\d+).(\d+).(\d+)(?: (.*))?$/))?e:[];let i=Number(o[1]),r=Number(o[2]),s=Number(o[3]);i=Number.isNaN(i)?0:i,r=Number.isNaN(r)?0:r,s=Number.isNaN(s)?0:s;return{major:i,minor:r,patch:s,pre:null!=(n=o[4])?n:""}}function De(t){var e;if(""===t)return 1/0;const n=null!=(e=t.match(/^pre(\d+)$/))?e:[];let o=Number(n[1]);return o=Number.isNaN(o)?0:o,o}function Pe(t,e,n=3){const o=Ne(t),i=Ne(e);let r=i.major-o.major;return 0===r&&n>1&&(r=i.minor-o.minor,0===r&&n>2&&(r=i.patch-o.patch,0===r&&n>3&&(r=De(i.pre)-De(o.pre),isNaN(r)&&(r=0)))),Math.sign(r)}function Oe(t){return`${t%1?t:`${t}.0`}`}function Fe(){return"undefined"!=typeof window?window:"undefined"!=typeof self?self:global}const Ue={};function Ve(t=""){const e=document.getElementsByTagName("script");let n=t;for(let o=e.length-1;o>=0;--o){const i=e[o].src,r=i.search(/\/v3d[\w.]+js/);r>-1&&(n=i.substr(0,r)+"/"+t)}return n}function Ge(t,e=function(t){},n=function(t){}){Ue[t]=Ue[t]||{status:0,loadCallbacks:[],errorCallbacks:[]};const o=Ue[t];if(4==o.status)return void e(t);if(o.loadCallbacks.push(e),o.errorCallbacks.push(n),o.status>0)return;let i=Ve(t);const r=document.createElement("script");r.type="text/javascript",r.src=i,function(t){r.onload=function(){Ue[t].loadCallbacks.forEach(function(e){e(t)}),Ue[t].status=4},r.onerror=function(){Ue[t].errorCallbacks.forEach(function(e){e(t)}),Ue[t].status=0}}(t),document.getElementsByTagName("head")[0].appendChild(r),o.status=3}function Qe(t,e,n=0){const o=function(t,o,i,r){const s=performance.now();return e(t,o,i),s-r>n?(r=s,new Promise(function(t){setTimeout(function(){t(r)},1)})):r};let i=Promise.resolve(performance.now());return t.forEach(function(t,e,n){i=i.then(o.bind(null,t,e,n))}),i}function ze(){return"undefined"!=typeof __V3D_DEVTOOLS__}function ke(t,e){ze()&&__V3D_DEVTOOLS__.dispatchEvent(new CustomEvent(t,{detail:e}))}function He(t){return t<.04045?.0773993808*t:Math.pow(.9478672986*t+.0521327014,2.4)}function We(t){return t<.0031308?12.92*t:1.055*Math.pow(t,.41666)-.055}const Ye={[Qt]:{[zt]:He},[zt]:{[Qt]:We}},Xe={legacyMode:!0,get workingColorSpace(){return zt},set workingColorSpace(t){console.warn("v3d.ColorManagement: .workingColorSpace is readonly.")},convert:function(t,e,n){if(this.legacyMode||e===n||!e||!n)return t;if(Ye[e]&&void 0!==Ye[e][n]){const o=Ye[e][n];return t.r=o(t.r),t.g=o(t.g),t.b=o(t.b),t}throw new Error("Unsupported color space conversion.")},fromWorkingColorSpace:function(t,e){return this.convert(t,this.workingColorSpace,e)},toWorkingColorSpace:function(t,e){return this.convert(t,e,this.workingColorSpace)}},Ke={aliceblue:15792383,antiquewhite:16444375,aqua:65535,aquamarine:8388564,azure:15794175,beige:16119260,bisque:16770244,black:0,blanchedalmond:16772045,blue:255,blueviolet:9055202,brown:10824234,burlywood:14596231,cadetblue:6266528,chartreuse:8388352,chocolate:13789470,coral:16744272,cornflowerblue:6591981,cornsilk:16775388,crimson:14423100,cyan:65535,darkblue:139,darkcyan:35723,darkgoldenrod:12092939,darkgray:11119017,darkgreen:25600,darkgrey:11119017,darkkhaki:12433259,darkmagenta:9109643,darkolivegreen:5597999,darkorange:16747520,darkorchid:10040012,darkred:9109504,darksalmon:15308410,darkseagreen:9419919,darkslateblue:4734347,darkslategray:3100495,darkslategrey:3100495,darkturquoise:52945,darkviolet:9699539,deeppink:16716947,deepskyblue:49151,dimgray:6908265,dimgrey:6908265,dodgerblue:2003199,firebrick:11674146,floralwhite:16775920,forestgreen:2263842,fuchsia:16711935,gainsboro:14474460,ghostwhite:16316671,gold:16766720,goldenrod:14329120,gray:8421504,green:32768,greenyellow:11403055,grey:8421504,honeydew:15794160,hotpink:16738740,indianred:13458524,indigo:4915330,ivory:16777200,khaki:15787660,lavender:15132410,lavenderblush:16773365,lawngreen:8190976,lemonchiffon:16775885,lightblue:11393254,lightcoral:15761536,lightcyan:14745599,lightgoldenrodyellow:16448210,lightgray:13882323,lightgreen:9498256,lightgrey:13882323,lightpink:16758465,lightsalmon:16752762,lightseagreen:2142890,lightskyblue:8900346,lightslategray:7833753,lightslategrey:7833753,lightsteelblue:11584734,lightyellow:16777184,lime:65280,limegreen:3329330,linen:16445670,magenta:16711935,maroon:8388608,mediumaquamarine:6737322,mediumblue:205,mediumorchid:12211667,mediumpurple:9662683,mediumseagreen:3978097,mediumslateblue:8087790,mediumspringgreen:64154,mediumturquoise:4772300,mediumvioletred:13047173,midnightblue:1644912,mintcream:16121850,mistyrose:16770273,moccasin:16770229,navajowhite:16768685,navy:128,oldlace:16643558,olive:8421376,olivedrab:7048739,orange:16753920,orangered:16729344,orchid:14315734,palegoldenrod:15657130,palegreen:10025880,paleturquoise:11529966,palevioletred:14381203,papayawhip:16773077,peachpuff:16767673,peru:13468991,pink:16761035,plum:14524637,powderblue:11591910,purple:8388736,rebeccapurple:6697881,red:16711680,rosybrown:12357519,royalblue:4286945,saddlebrown:9127187,salmon:16416882,sandybrown:16032864,seagreen:3050327,seashell:16774638,sienna:10506797,silver:12632256,skyblue:8900331,slateblue:6970061,slategray:7372944,slategrey:7372944,snow:16775930,springgreen:65407,steelblue:4620980,tan:13808780,teal:32896,thistle:14204888,tomato:16737095,turquoise:4251856,violet:15631086,wheat:16113331,white:16777215,whitesmoke:16119285,yellow:16776960,yellowgreen:10145074},je={r:0,g:0,b:0},Ze={h:0,s:0,l:0},qe={h:0,s:0,l:0};function Je(t,e,n){return n<0&&(n+=1),n>1&&(n-=1),n<1/6?t+6*(e-t)*n:n<.5?e:n<2/3?t+6*(e-t)*(2/3-n):t}function $e(t,e){return e.r=t.r,e.g=t.g,e.b=t.b,e}class tn{constructor(t,e,n){return this.isColor=!0,this.r=1,this.g=1,this.b=1,void 0===e&&void 0===n?this.set(t):this.setRGB(t,e,n)}set(t){return t&&t.isColor?this.copy(t):"number"==typeof t?this.setHex(t):"string"==typeof t&&this.setStyle(t),this}setScalar(t){return this.r=t,this.g=t,this.b=t,this}setHex(t,e=Qt){return t=Math.floor(t),this.r=(t>>16&255)/255,this.g=(t>>8&255)/255,this.b=(255&t)/255,Xe.toWorkingColorSpace(this,e),this}setRGB(t,e,n,o=Xe.workingColorSpace){return this.r=t,this.g=e,this.b=n,Xe.toWorkingColorSpace(this,o),this}setHSL(t,e,n,o=Xe.workingColorSpace){if(t=re(t,1),e=ie(e,0,1),n=ie(n,0,1),0===e)this.r=this.g=this.b=n;else{const o=n<=.5?n*(1+e):n+e-n*e,i=2*n-o;this.r=Je(i,o,t+1/3),this.g=Je(i,o,t),this.b=Je(i,o,t-1/3)}return Xe.toWorkingColorSpace(this,o),this}setStyle(t,e=Qt){function n(e){void 0!==e&&parseFloat(e)<1&&console.warn("v3d.Color: Alpha component of "+t+" will be ignored.")}let o;if(o=/^((?:rgb|hsl)a?)\(([^\)]*)\)/.exec(t)){let t;const i=o[1],r=o[2];switch(i){case"rgb":case"rgba":if(t=/^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(r))return this.r=Math.min(255,parseInt(t[1],10))/255,this.g=Math.min(255,parseInt(t[2],10))/255,this.b=Math.min(255,parseInt(t[3],10))/255,Xe.toWorkingColorSpace(this,e),n(t[4]),this;if(t=/^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(r))return this.r=Math.min(100,parseInt(t[1],10))/100,this.g=Math.min(100,parseInt(t[2],10))/100,this.b=Math.min(100,parseInt(t[3],10))/100,Xe.toWorkingColorSpace(this,e),n(t[4]),this;break;case"hsl":case"hsla":if(t=/^\s*(\d*\.?\d+)\s*,\s*(\d*\.?\d+)\%\s*,\s*(\d*\.?\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(r)){const o=parseFloat(t[1])/360,i=parseFloat(t[2])/100,r=parseFloat(t[3])/100;return n(t[4]),this.setHSL(o,i,r,e)}}}else if(o=/^\#([A-Fa-f\d]+)$/.exec(t)){const t=o[1],n=t.length;if(3===n)return this.r=parseInt(t.charAt(0)+t.charAt(0),16)/255,this.g=parseInt(t.charAt(1)+t.charAt(1),16)/255,this.b=parseInt(t.charAt(2)+t.charAt(2),16)/255,Xe.toWorkingColorSpace(this,e),this;if(6===n)return this.r=parseInt(t.charAt(0)+t.charAt(1),16)/255,this.g=parseInt(t.charAt(2)+t.charAt(3),16)/255,this.b=parseInt(t.charAt(4)+t.charAt(5),16)/255,Xe.toWorkingColorSpace(this,e),this}return t&&t.length>0?this.setColorName(t,e):this}setColorName(t,e=Qt){const n=Ke[t.toLowerCase()];return void 0!==n?this.setHex(n,e):console.warn("v3d.Color: Unknown color "+t),this}clone(){return new this.constructor(this.r,this.g,this.b)}copy(t){return this.r=t.r,this.g=t.g,this.b=t.b,this}copySRGBToLinear(t){return this.r=He(t.r),this.g=He(t.g),this.b=He(t.b),this}copyLinearToSRGB(t){return this.r=We(t.r),this.g=We(t.g),this.b=We(t.b),this}convertSRGBToLinear(){return this.copySRGBToLinear(this),this}convertLinearToSRGB(){return this.copyLinearToSRGB(this),this}getHex(t=Qt){return Xe.fromWorkingColorSpace($e(this,je),t),ie(255*je.r,0,255)<<16^ie(255*je.g,0,255)<<8^ie(255*je.b,0,255)}getHexString(t=Qt){return("000000"+this.getHex(t).toString(16)).slice(-6)}getHSL(t,e=Xe.workingColorSpace){Xe.fromWorkingColorSpace($e(this,je),e);const n=je.r,o=je.g,i=je.b,r=Math.max(n,o,i),s=Math.min(n,o,i);let a,l;const c=(s+r)/2;if(s===r)a=0,l=0;else{const t=r-s;switch(l=c<=.5?t/(r+s):t/(2-r-s),r){case n:a=(o-i)/t+(o<i?6:0);break;case o:a=(i-n)/t+2;break;case i:a=(n-o)/t+4}a/=6}return t.h=a,t.s=l,t.l=c,t}getRGB(t,e=Xe.workingColorSpace){return Xe.fromWorkingColorSpace($e(this,je),e),t.r=je.r,t.g=je.g,t.b=je.b,t}getStyle(t=Qt){return Xe.fromWorkingColorSpace($e(this,je),t),t!==Qt?`color(${t} ${je.r} ${je.g} ${je.b})`:`rgb(${255*je.r|0},${255*je.g|0},${255*je.b|0})`}offsetHSL(t,e,n){return this.getHSL(Ze),Ze.h+=t,Ze.s+=e,Ze.l+=n,this.setHSL(Ze.h,Ze.s,Ze.l),this}add(t){return this.r+=t.r,this.g+=t.g,this.b+=t.b,this}addColors(t,e){return this.r=t.r+e.r,this.g=t.g+e.g,this.b=t.b+e.b,this}addScalar(t){return this.r+=t,this.g+=t,this.b+=t,this}sub(t){return this.r=Math.max(0,this.r-t.r),this.g=Math.max(0,this.g-t.g),this.b=Math.max(0,this.b-t.b),this}multiply(t){return this.r*=t.r,this.g*=t.g,this.b*=t.b,this}multiplyScalar(t){return this.r*=t,this.g*=t,this.b*=t,this}lerp(t,e){return this.r+=(t.r-this.r)*e,this.g+=(t.g-this.g)*e,this.b+=(t.b-this.b)*e,this}lerpColors(t,e,n){return this.r=t.r+(e.r-t.r)*n,this.g=t.g+(e.g-t.g)*n,this.b=t.b+(e.b-t.b)*n,this}lerpHSL(t,e){this.getHSL(Ze),t.getHSL(qe);const n=se(Ze.h,qe.h,e),o=se(Ze.s,qe.s,e),i=se(Ze.l,qe.l,e);return this.setHSL(n,o,i),this}equals(t){return t.r===this.r&&t.g===this.g&&t.b===this.b}fromArray(t,e=0){return this.r=t[e],this.g=t[e+1],this.b=t[e+2],this}toArray(t=[],e=0){return t[e]=this.r,t[e+1]=this.g,t[e+2]=this.b,t}fromBufferAttribute(t,e){return this.r=t.getX(e),this.g=t.getY(e),this.b=t.getZ(e),this}*[Symbol.iterator](){yield this.r,yield this.g,yield this.b}}let en;tn.NAMES=Ke;class nn{static getDataURL(t){if(/^data:/i.test(t.src))return t.src;if("undefined"==typeof HTMLCanvasElement)return t.src;let e;if(t instanceof HTMLCanvasElement)e=t;else{void 0===en&&(en=be("canvas")),en.width=t.width,en.height=t.height;const n=en.getContext("2d");t instanceof ImageData?n.putImageData(t,0,0):n.drawImage(t,0,0,t.width,t.height),e=en}return e.width>2048||e.height>2048?(console.warn("v3d.ImageUtils.getDataURL: Image converted to jpg for performance reasons",t),e.toDataURL("image/jpeg",.6)):e.toDataURL("image/png")}static sRGBToLinear(t){if("undefined"!=typeof HTMLImageElement&&t instanceof HTMLImageElement||"undefined"!=typeof HTMLCanvasElement&&t instanceof HTMLCanvasElement||"undefined"!=typeof ImageBitmap&&t instanceof ImageBitmap){const e=be("canvas");e.width=t.width,e.height=t.height;const n=e.getContext("2d");n.drawImage(t,0,0,t.width,t.height);const o=n.getImageData(0,0,t.width,t.height),i=o.data;for(let t=0;t<i.length;t++)i[t]=255*He(i[t]/255);return n.putImageData(o,0,0),e}if(t.data){const e=t.data.slice(0);for(let t=0;t<e.length;t++)e instanceof Uint8Array||e instanceof Uint8ClampedArray?e[t]=Math.floor(255*He(e[t]/255)):e[t]=He(e[t]);return{data:e,width:t.width,height:t.height}}return console.warn("v3d.ImageUtils.sRGBToLinear(): Unsupported image type. No color space conversion applied."),t}}let on=0;class rn{constructor(t=null){this.isSource=!0,Object.defineProperty(this,"id",{value:on++}),this.uuid=ne(),this.data=t,this.version=0}set needsUpdate(t){!0===t&&this.version++}}let sn=0;class an extends Zt{constructor(t=an.DEFAULT_IMAGE,e=an.DEFAULT_MAPPING,n=1001,o=1001,i=1006,r=1008,s=1023,a=1009,l=an.DEFAULT_ANISOTROPY,c=3e3){super(),this.isTexture=!0,Object.defineProperty(this,"id",{value:sn++}),this.uuid=ne(),this.name="",this.source=new rn(t),this.mipmaps=[],this.mapping=e,this.wrapS=n,this.wrapT=o,this.magFilter=i,this.minFilter=r,this.anisotropy=l,this.format=s,this.internalFormat=null,this.type=a,this.offset=new we(0,0),this.repeat=new we(1,1),this.center=new we(0,0),this.rotation=0,this.matrixAutoUpdate=!0,this.matrix=new xe,this.generateMipmaps=!0,this.premultiplyAlpha=!1,this.flipY=!0,this.unpackAlignment=4,this.encoding=c,this.userData={},this.version=0,this.onUpdate=null,this.isRenderTargetTexture=!1,this.needsPMREMUpdate=!1}get image(){return this.source.data}set image(t){this.source.data=t}updateMatrix(){this.matrix.setUvTransform(this.offset.x,this.offset.y,this.repeat.x,this.repeat.y,this.rotation,this.center.x,this.center.y)}clone(){return(new this.constructor).copy(this)}copy(t){return this.name=t.name,this.source=t.source,this.mipmaps=t.mipmaps.slice(0),this.mapping=t.mapping,this.wrapS=t.wrapS,this.wrapT=t.wrapT,this.magFilter=t.magFilter,this.minFilter=t.minFilter,this.anisotropy=t.anisotropy,this.format=t.format,this.internalFormat=t.internalFormat,this.type=t.type,this.offset.copy(t.offset),this.repeat.copy(t.repeat),this.center.copy(t.center),this.rotation=t.rotation,this.matrixAutoUpdate=t.matrixAutoUpdate,this.matrix.copy(t.matrix),this.generateMipmaps=t.generateMipmaps,this.premultiplyAlpha=t.premultiplyAlpha,this.flipY=t.flipY,this.unpackAlignment=t.unpackAlignment,this.encoding=t.encoding,this.userData=JSON.parse(JSON.stringify(t.userData)),this.needsUpdate=!0,this}dispose(){this.dispatchEvent({type:"dispose"})}transformUv(t){if(this.mapping!==C)return t;if(t.applyMatrix3(this.matrix),t.x<0||t.x>1)switch(this.wrapS){case b:t.x=t.x-Math.floor(t.x);break;case y:t.x=t.x<0?0:1;break;case R:1===Math.abs(Math.floor(t.x)%2)?t.x=Math.ceil(t.x)-t.x:t.x=t.x-Math.floor(t.x)}if(t.y<0||t.y>1)switch(this.wrapT){case b:t.y=t.y-Math.floor(t.y);break;case y:t.y=t.y<0?0:1;break;case R:1===Math.abs(Math.floor(t.y)%2)?t.y=Math.ceil(t.y)-t.y:t.y=t.y-Math.floor(t.y)}return this.flipY&&(t.y=1-t.y),t}set needsUpdate(t){!0===t&&(this.version++,this.source.needsUpdate=!0)}}an.DEFAULT_IMAGE=null,an.DEFAULT_MAPPING=C,an.DEFAULT_ANISOTROPY=1;class ln{constructor(t=0,e=0,n=0,o=1){ln.prototype.isVector4=!0,this.x=t,this.y=e,this.z=n,this.w=o}get width(){return this.z}set width(t){this.z=t}get height(){return this.w}set height(t){this.w=t}set(t,e,n,o){return this.x=t,this.y=e,this.z=n,this.w=o,this}setScalar(t){return this.x=t,this.y=t,this.z=t,this.w=t,this}setX(t){return this.x=t,this}setY(t){return this.y=t,this}setZ(t){return this.z=t,this}setW(t){return this.w=t,this}setComponent(t,e){switch(t){case 0:this.x=e;break;case 1:this.y=e;break;case 2:this.z=e;break;case 3:this.w=e;break;default:throw new Error("index is out of range: "+t)}return this}getComponent(t){switch(t){case 0:return this.x;case 1:return this.y;case 2:return this.z;case 3:return this.w;default:throw new Error("index is out of range: "+t)}}clone(){return new this.constructor(this.x,this.y,this.z,this.w)}copy(t){return this.x=t.x,this.y=t.y,this.z=t.z,this.w=void 0!==t.w?t.w:1,this}add(t){return this.x+=t.x,this.y+=t.y,this.z+=t.z,this.w+=t.w,this}addScalar(t){return this.x+=t,this.y+=t,this.z+=t,this.w+=t,this}addVectors(t,e){return this.x=t.x+e.x,this.y=t.y+e.y,this.z=t.z+e.z,this.w=t.w+e.w,this}addScaledVector(t,e){return this.x+=t.x*e,this.y+=t.y*e,this.z+=t.z*e,this.w+=t.w*e,this}sub(t){return this.x-=t.x,this.y-=t.y,this.z-=t.z,this.w-=t.w,this}subScalar(t){return this.x-=t,this.y-=t,this.z-=t,this.w-=t,this}subVectors(t,e){return this.x=t.x-e.x,this.y=t.y-e.y,this.z=t.z-e.z,this.w=t.w-e.w,this}multiply(t){return this.x*=t.x,this.y*=t.y,this.z*=t.z,this.w*=t.w,this}multiplyScalar(t){return this.x*=t,this.y*=t,this.z*=t,this.w*=t,this}applyMatrix4(t){const e=this.x,n=this.y,o=this.z,i=this.w,r=t.elements;return this.x=r[0]*e+r[4]*n+r[8]*o+r[12]*i,this.y=r[1]*e+r[5]*n+r[9]*o+r[13]*i,this.z=r[2]*e+r[6]*n+r[10]*o+r[14]*i,this.w=r[3]*e+r[7]*n+r[11]*o+r[15]*i,this}divideScalar(t){return this.multiplyScalar(1/t)}setAxisAngleFromQuaternion(t){this.w=2*Math.acos(t.w);const e=Math.sqrt(1-t.w*t.w);return e<1e-4?(this.x=1,this.y=0,this.z=0):(this.x=t.x/e,this.y=t.y/e,this.z=t.z/e),this}setAxisAngleFromRotationMatrix(t){let e,n,o,i;const r=.01,s=.1,a=t.elements,l=a[0],c=a[4],u=a[8],h=a[1],f=a[5],d=a[9],A=a[2],v=a[6],m=a[10];if(Math.abs(c-h)<r&&Math.abs(u-A)<r&&Math.abs(d-v)<r){if(Math.abs(c+h)<s&&Math.abs(u+A)<s&&Math.abs(d+v)<s&&Math.abs(l+f+m-3)<s)return this.set(1,0,0,0),this;e=Math.PI;const t=(l+1)/2,a=(f+1)/2,p=(m+1)/2,g=(c+h)/4,_=(u+A)/4,E=(d+v)/4;return t>a&&t>p?t<r?(n=0,o=.707106781,i=.707106781):(n=Math.sqrt(t),o=g/n,i=_/n):a>p?a<r?(n=.707106781,o=0,i=.707106781):(o=Math.sqrt(a),n=g/o,i=E/o):p<r?(n=.707106781,o=.707106781,i=0):(i=Math.sqrt(p),n=_/i,o=E/i),this.set(n,o,i,e),this}let p=Math.sqrt((v-d)*(v-d)+(u-A)*(u-A)+(h-c)*(h-c));return Math.abs(p)<.001&&(p=1),this.x=(v-d)/p,this.y=(u-A)/p,this.z=(h-c)/p,this.w=Math.acos((l+f+m-1)/2),this}min(t){return this.x=Math.min(this.x,t.x),this.y=Math.min(this.y,t.y),this.z=Math.min(this.z,t.z),this.w=Math.min(this.w,t.w),this}max(t){return this.x=Math.max(this.x,t.x),this.y=Math.max(this.y,t.y),this.z=Math.max(this.z,t.z),this.w=Math.max(this.w,t.w),this}clamp(t,e){return this.x=Math.max(t.x,Math.min(e.x,this.x)),this.y=Math.max(t.y,Math.min(e.y,this.y)),this.z=Math.max(t.z,Math.min(e.z,this.z)),this.w=Math.max(t.w,Math.min(e.w,this.w)),this}clampScalar(t,e){return this.x=Math.max(t,Math.min(e,this.x)),this.y=Math.max(t,Math.min(e,this.y)),this.z=Math.max(t,Math.min(e,this.z)),this.w=Math.max(t,Math.min(e,this.w)),this}clampLength(t,e){const n=this.length();return this.divideScalar(n||1).multiplyScalar(Math.max(t,Math.min(e,n)))}floor(){return this.x=Math.floor(this.x),this.y=Math.floor(this.y),this.z=Math.floor(this.z),this.w=Math.floor(this.w),this}ceil(){return this.x=Math.ceil(this.x),this.y=Math.ceil(this.y),this.z=Math.ceil(this.z),this.w=Math.ceil(this.w),this}round(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this.z=Math.round(this.z),this.w=Math.round(this.w),this}roundToZero(){return this.x=this.x<0?Math.ceil(this.x):Math.floor(this.x),this.y=this.y<0?Math.ceil(this.y):Math.floor(this.y),this.z=this.z<0?Math.ceil(this.z):Math.floor(this.z),this.w=this.w<0?Math.ceil(this.w):Math.floor(this.w),this}negate(){return this.x=-this.x,this.y=-this.y,this.z=-this.z,this.w=-this.w,this}dot(t){return this.x*t.x+this.y*t.y+this.z*t.z+this.w*t.w}lengthSq(){return this.x*this.x+this.y*this.y+this.z*this.z+this.w*this.w}length(){return Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z+this.w*this.w)}manhattanLength(){return Math.abs(this.x)+Math.abs(this.y)+Math.abs(this.z)+Math.abs(this.w)}normalize(){return this.divideScalar(this.length()||1)}setLength(t){return this.normalize().multiplyScalar(t)}lerp(t,e){return this.x+=(t.x-this.x)*e,this.y+=(t.y-this.y)*e,this.z+=(t.z-this.z)*e,this.w+=(t.w-this.w)*e,this}lerpVectors(t,e,n){return this.x=t.x+(e.x-t.x)*n,this.y=t.y+(e.y-t.y)*n,this.z=t.z+(e.z-t.z)*n,this.w=t.w+(e.w-t.w)*n,this}equals(t){return t.x===this.x&&t.y===this.y&&t.z===this.z&&t.w===this.w}fromArray(t,e=0){return this.x=t[e],this.y=t[e+1],this.z=t[e+2],this.w=t[e+3],this}toArray(t=[],e=0){return t[e]=this.x,t[e+1]=this.y,t[e+2]=this.z,t[e+3]=this.w,t}fromBufferAttribute(t,e){return this.x=t.getX(e),this.y=t.getY(e),this.z=t.getZ(e),this.w=t.getW(e),this}random(){return this.x=Math.random(),this.y=Math.random(),this.z=Math.random(),this.w=Math.random(),this}*[Symbol.iterator](){yield this.x,yield this.y,yield this.z,yield this.w}}class cn extends Zt{constructor(t=1,e=1,n={}){super(),this.isWebGLRenderTarget=!0,this.width=t,this.height=e,this.depth=1,this.scissor=new ln(0,0,t,e),this.scissorTest=!1,this.viewport=new ln(0,0,t,e);const o={width:t,height:e,depth:1};this.texture=new an(o,n.mapping,n.wrapS,n.wrapT,n.magFilter,n.minFilter,n.format,n.type,n.anisotropy,n.encoding),this.texture.isRenderTargetTexture=!0,this.texture.flipY=!1,this.texture.generateMipmaps=void 0!==n.generateMipmaps&&n.generateMipmaps,this.texture.internalFormat=void 0!==n.internalFormat?n.internalFormat:null,this.texture.minFilter=void 0!==n.minFilter?n.minFilter:N,this.depthBuffer=void 0===n.depthBuffer||n.depthBuffer,this.stencilBuffer=void 0!==n.stencilBuffer&&n.stencilBuffer,this.depthTexture=void 0!==n.depthTexture?n.depthTexture:null,this.samples=void 0!==n.samples?n.samples:0}setSize(t,e,n=1){this.width===t&&this.height===e&&this.depth===n||(this.width=t,this.height=e,this.depth=n,this.texture.image.width=t,this.texture.image.height=e,this.texture.image.depth=n,this.dispose()),this.viewport.set(0,0,t,e),this.scissor.set(0,0,t,e)}clone(){return(new this.constructor).copy(this)}copy(t){this.width=t.width,this.height=t.height,this.depth=t.depth,this.viewport.copy(t.viewport),this.texture=t.texture.clone(),this.texture.isRenderTargetTexture=!0;const e=Object.assign({},t.texture.image);return this.texture.source=new rn(e),this.depthBuffer=t.depthBuffer,this.stencilBuffer=t.stencilBuffer,null!==t.depthTexture&&(this.depthTexture=t.depthTexture.clone()),this.samples=t.samples,this}dispose(){this.dispatchEvent({type:"dispose"})}}class un extends an{constructor(t=null,e=1,n=1,o=1){super(null),this.isDataArrayTexture=!0,this.image={data:t,width:e,height:n,depth:o},this.magFilter=T,this.minFilter=T,this.wrapR=y,this.generateMipmaps=!1,this.flipY=!1,this.unpackAlignment=1}}class hn extends an{constructor(t=null,e=1,n=1,o=1){super(null),this.isData3DTexture=!0,this.image={data:t,width:e,height:n,depth:o},this.magFilter=T,this.minFilter=T,this.wrapR=y,this.generateMipmaps=!1,this.flipY=!1,this.unpackAlignment=1}}class fn extends cn{constructor(t=1,e=1,n=1,o={}){super(t,e,o),this.isWebGLMultipleRenderTargets=!0;const i=this.texture;this.texture=[];for(let t=0;t<n;t++)this.texture[t]=i.clone(),this.texture[t].isRenderTargetTexture=!0}setSize(t,e,n=1){if(this.width!==t||this.height!==e||this.depth!==n){this.width=t,this.height=e,this.depth=n;for(let o=0,i=this.texture.length;o<i;o++)this.texture[o].image.width=t,this.texture[o].image.height=e,this.texture[o].image.depth=n;this.dispose()}return this.viewport.set(0,0,t,e),this.scissor.set(0,0,t,e),this}copy(t){this.dispose(),this.width=t.width,this.height=t.height,this.depth=t.depth,this.viewport.set(0,0,this.width,this.height),this.scissor.set(0,0,this.width,this.height),this.depthBuffer=t.depthBuffer,this.stencilBuffer=t.stencilBuffer,null!==t.depthTexture&&(this.depthTexture=t.depthTexture.clone()),this.texture.length=0;for(let e=0,n=t.texture.length;e<n;e++)this.texture[e]=t.texture[e].clone(),this.texture[e].isRenderTargetTexture=!0;return this}}class dn{constructor(t=0,e=0,n=0,o=1){this.isQuaternion=!0,this._=t,this.$=e,this.tt=n,this.et=o}static slerpFlat(t,e,n,o,i,r,s){let a=n[o+0],l=n[o+1],c=n[o+2],u=n[o+3];const h=i[r+0],f=i[r+1],d=i[r+2],A=i[r+3];if(0===s)return t[e+0]=a,t[e+1]=l,t[e+2]=c,void(t[e+3]=u);if(1===s)return t[e+0]=h,t[e+1]=f,t[e+2]=d,void(t[e+3]=A);if(u!==A||a!==h||l!==f||c!==d){let t=1-s;const e=a*h+l*f+c*d+u*A,n=e>=0?1:-1,o=1-e*e;if(o>Number.EPSILON){const i=Math.sqrt(o),r=Math.atan2(i,e*n);t=Math.sin(t*r)/i,s=Math.sin(s*r)/i}const i=s*n;if(a=a*t+h*i,l=l*t+f*i,c=c*t+d*i,u=u*t+A*i,t===1-s){const t=1/Math.sqrt(a*a+l*l+c*c+u*u);a*=t,l*=t,c*=t,u*=t}}t[e]=a,t[e+1]=l,t[e+2]=c,t[e+3]=u}static multiplyQuaternionsFlat(t,e,n,o,i,r){const s=n[o],a=n[o+1],l=n[o+2],c=n[o+3],u=i[r],h=i[r+1],f=i[r+2],d=i[r+3];return t[e]=s*d+c*u+a*f-l*h,t[e+1]=a*d+c*h+l*u-s*f,t[e+2]=l*d+c*f+s*h-a*u,t[e+3]=c*d-s*u-a*h-l*f,t}get x(){return this._}set x(t){this._=t,this.nt()}get y(){return this.$}set y(t){this.$=t,this.nt()}get z(){return this.tt}set z(t){this.tt=t,this.nt()}get w(){return this.et}set w(t){this.et=t,this.nt()}set(t,e,n,o){return this._=t,this.$=e,this.tt=n,this.et=o,this.nt(),this}clone(){return new this.constructor(this._,this.$,this.tt,this.et)}copy(t){return this._=t.x,this.$=t.y,this.tt=t.z,this.et=t.w,this.nt(),this}setFromEuler(t,e){const n=t._,o=t.$,i=t.tt,r=t.ot,s=Math.cos,a=Math.sin,l=s(n/2),c=s(o/2),u=s(i/2),h=a(n/2),f=a(o/2),d=a(i/2);switch(r){case"XYZ":this._=h*c*u+l*f*d,this.$=l*f*u-h*c*d,this.tt=l*c*d+h*f*u,this.et=l*c*u-h*f*d;break;case"YXZ":this._=h*c*u+l*f*d,this.$=l*f*u-h*c*d,this.tt=l*c*d-h*f*u,this.et=l*c*u+h*f*d;break;case"ZXY":this._=h*c*u-l*f*d,this.$=l*f*u+h*c*d,this.tt=l*c*d+h*f*u,this.et=l*c*u-h*f*d;break;case"ZYX":this._=h*c*u-l*f*d,this.$=l*f*u+h*c*d,this.tt=l*c*d-h*f*u,this.et=l*c*u+h*f*d;break;case"YZX":this._=h*c*u+l*f*d,this.$=l*f*u+h*c*d,this.tt=l*c*d-h*f*u,this.et=l*c*u-h*f*d;break;case"XZY":this._=h*c*u-l*f*d,this.$=l*f*u-h*c*d,this.tt=l*c*d+h*f*u,this.et=l*c*u+h*f*d;break;default:console.warn("v3d.Quaternion: .setFromEuler() encountered an unknown order: "+r)}return!1!==e&&this.nt(),this}setFromAxisAngle(t,e){const n=e/2,o=Math.sin(n);return this._=t.x*o,this.$=t.y*o,this.tt=t.z*o,this.et=Math.cos(n),this.nt(),this}setFromRotationMatrix(t){const e=t.elements,n=e[0],o=e[4],i=e[8],r=e[1],s=e[5],a=e[9],l=e[2],c=e[6],u=e[10],h=n+s+u;if(h>0){const t=.5/Math.sqrt(h+1);this.et=.25/t,this._=(c-a)*t,this.$=(i-l)*t,this.tt=(r-o)*t}else if(n>s&&n>u){const t=2*Math.sqrt(1+n-s-u);this.et=(c-a)/t,this._=.25*t,this.$=(o+r)/t,this.tt=(i+l)/t}else if(s>u){const t=2*Math.sqrt(1+s-n-u);this.et=(i-l)/t,this._=(o+r)/t,this.$=.25*t,this.tt=(a+c)/t}else{const t=2*Math.sqrt(1+u-n-s);this.et=(r-o)/t,this._=(i+l)/t,this.$=(a+c)/t,this.tt=.25*t}return this.nt(),this}setFromUnitVectors(t,e){let n=t.dot(e)+1;return n<Number.EPSILON?(n=0,Math.abs(t.x)>Math.abs(t.z)?(this._=-t.y,this.$=t.x,this.tt=0,this.et=n):(this._=0,this.$=-t.z,this.tt=t.y,this.et=n)):(this._=t.y*e.z-t.z*e.y,this.$=t.z*e.x-t.x*e.z,this.tt=t.x*e.y-t.y*e.x,this.et=n),this.normalize()}angleTo(t){return 2*Math.acos(Math.abs(ie(this.dot(t),-1,1)))}rotateTowards(t,e){const n=this.angleTo(t);if(0===n)return this;const o=Math.min(1,e/n);return this.slerp(t,o),this}identity(){return this.set(0,0,0,1)}invert(){return this.conjugate()}conjugate(){return this._*=-1,this.$*=-1,this.tt*=-1,this.nt(),this}dot(t){return this._*t._+this.$*t.$+this.tt*t.tt+this.et*t.et}lengthSq(){return this._*this._+this.$*this.$+this.tt*this.tt+this.et*this.et}length(){return Math.sqrt(this._*this._+this.$*this.$+this.tt*this.tt+this.et*this.et)}normalize(){let t=this.length();return 0===t?(this._=0,this.$=0,this.tt=0,this.et=1):(t=1/t,this._=this._*t,this.$=this.$*t,this.tt=this.tt*t,this.et=this.et*t),this.nt(),this}multiply(t){return this.multiplyQuaternions(this,t)}premultiply(t){return this.multiplyQuaternions(t,this)}multiplyQuaternions(t,e){const n=t._,o=t.$,i=t.tt,r=t.et,s=e._,a=e.$,l=e.tt,c=e.et;return this._=n*c+r*s+o*l-i*a,this.$=o*c+r*a+i*s-n*l,this.tt=i*c+r*l+n*a-o*s,this.et=r*c-n*s-o*a-i*l,this.nt(),this}slerp(t,e){if(0===e)return this;if(1===e)return this.copy(t);const n=this._,o=this.$,i=this.tt,r=this.et;let s=r*t.et+n*t._+o*t.$+i*t.tt;if(s<0?(this.et=-t.et,this._=-t._,this.$=-t.$,this.tt=-t.tt,s=-s):this.copy(t),s>=1)return this.et=r,this._=n,this.$=o,this.tt=i,this;const a=1-s*s;if(a<=Number.EPSILON){const t=1-e;return this.et=t*r+e*this.et,this._=t*n+e*this._,this.$=t*o+e*this.$,this.tt=t*i+e*this.tt,this.normalize(),this.nt(),this}const l=Math.sqrt(a),c=Math.atan2(l,s),u=Math.sin((1-e)*c)/l,h=Math.sin(e*c)/l;return this.et=r*u+this.et*h,this._=n*u+this._*h,this.$=o*u+this.$*h,this.tt=i*u+this.tt*h,this.nt(),this}slerpQuaternions(t,e,n){return this.copy(t).slerp(e,n)}random(){const t=Math.random(),e=Math.sqrt(1-t),n=Math.sqrt(t),o=2*Math.PI*Math.random(),i=2*Math.PI*Math.random();return this.set(e*Math.cos(o),n*Math.sin(i),n*Math.cos(i),e*Math.sin(o))}equals(t){return t._===this._&&t.$===this.$&&t.tt===this.tt&&t.et===this.et}fromArray(t,e=0){return this._=t[e],this.$=t[e+1],this.tt=t[e+2],this.et=t[e+3],this.nt(),this}toArray(t=[],e=0){return t[e]=this._,t[e+1]=this.$,t[e+2]=this.tt,t[e+3]=this.et,t}fromBufferAttribute(t,e){return this._=t.getX(e),this.$=t.getY(e),this.tt=t.getZ(e),this.et=t.getW(e),this}it(t){return this.nt=t,this}nt(){}*[Symbol.iterator](){yield this._,yield this.$,yield this.tt,yield this.et}}class An{constructor(t=0,e=0,n=0){An.prototype.isVector3=!0,this.x=t,this.y=e,this.z=n}set(t,e,n){return void 0===n&&(n=this.z),this.x=t,this.y=e,this.z=n,this}setScalar(t){return this.x=t,this.y=t,this.z=t,this}setX(t){return this.x=t,this}setY(t){return this.y=t,this}setZ(t){return this.z=t,this}setComponent(t,e){switch(t){case 0:this.x=e;break;case 1:this.y=e;break;case 2:this.z=e;break;default:throw new Error("index is out of range: "+t)}return this}getComponent(t){switch(t){case 0:return this.x;case 1:return this.y;case 2:return this.z;default:throw new Error("index is out of range: "+t)}}clone(){return new this.constructor(this.x,this.y,this.z)}copy(t){return this.x=t.x,this.y=t.y,this.z=t.z,this}add(t){return this.x+=t.x,this.y+=t.y,this.z+=t.z,this}addScalar(t){return this.x+=t,this.y+=t,this.z+=t,this}addVectors(t,e){return this.x=t.x+e.x,this.y=t.y+e.y,this.z=t.z+e.z,this}addScaledVector(t,e){return this.x+=t.x*e,this.y+=t.y*e,this.z+=t.z*e,this}sub(t){return this.x-=t.x,this.y-=t.y,this.z-=t.z,this}subScalar(t){return this.x-=t,this.y-=t,this.z-=t,this}subVectors(t,e){return this.x=t.x-e.x,this.y=t.y-e.y,this.z=t.z-e.z,this}multiply(t){return this.x*=t.x,this.y*=t.y,this.z*=t.z,this}multiplyScalar(t){return this.x*=t,this.y*=t,this.z*=t,this}multiplyVectors(t,e){return this.x=t.x*e.x,this.y=t.y*e.y,this.z=t.z*e.z,this}applyEuler(t){return this.applyQuaternion(mn.setFromEuler(t))}applyAxisAngle(t,e){return this.applyQuaternion(mn.setFromAxisAngle(t,e))}applyMatrix3(t){const e=this.x,n=this.y,o=this.z,i=t.elements;return this.x=i[0]*e+i[3]*n+i[6]*o,this.y=i[1]*e+i[4]*n+i[7]*o,this.z=i[2]*e+i[5]*n+i[8]*o,this}applyNormalMatrix(t){return this.applyMatrix3(t).normalize()}applyMatrix4(t){const e=this.x,n=this.y,o=this.z,i=t.elements,r=1/(i[3]*e+i[7]*n+i[11]*o+i[15]);return this.x=(i[0]*e+i[4]*n+i[8]*o+i[12])*r,this.y=(i[1]*e+i[5]*n+i[9]*o+i[13])*r,this.z=(i[2]*e+i[6]*n+i[10]*o+i[14])*r,this}applyQuaternion(t){const e=this.x,n=this.y,o=this.z,i=t.x,r=t.y,s=t.z,a=t.w,l=a*e+r*o-s*n,c=a*n+s*e-i*o,u=a*o+i*n-r*e,h=-i*e-r*n-s*o;return this.x=l*a+h*-i+c*-s-u*-r,this.y=c*a+h*-r+u*-i-l*-s,this.z=u*a+h*-s+l*-r-c*-i,this}project(t){return this.applyMatrix4(t.matrixWorldInverse).applyMatrix4(t.projectionMatrix)}unproject(t){return this.applyMatrix4(t.projectionMatrixInverse).applyMatrix4(t.matrixWorld)}transformDirection(t){const e=this.x,n=this.y,o=this.z,i=t.elements;return this.x=i[0]*e+i[4]*n+i[8]*o,this.y=i[1]*e+i[5]*n+i[9]*o,this.z=i[2]*e+i[6]*n+i[10]*o,this.normalize()}divide(t){return this.x/=t.x,this.y/=t.y,this.z/=t.z,this}divideScalar(t){return this.multiplyScalar(1/t)}min(t){return this.x=Math.min(this.x,t.x),this.y=Math.min(this.y,t.y),this.z=Math.min(this.z,t.z),this}max(t){return this.x=Math.max(this.x,t.x),this.y=Math.max(this.y,t.y),this.z=Math.max(this.z,t.z),this}clamp(t,e){return this.x=Math.max(t.x,Math.min(e.x,this.x)),this.y=Math.max(t.y,Math.min(e.y,this.y)),this.z=Math.max(t.z,Math.min(e.z,this.z)),this}clampScalar(t,e){return this.x=Math.max(t,Math.min(e,this.x)),this.y=Math.max(t,Math.min(e,this.y)),this.z=Math.max(t,Math.min(e,this.z)),this}clampLength(t,e){const n=this.length();return this.divideScalar(n||1).multiplyScalar(Math.max(t,Math.min(e,n)))}floor(){return this.x=Math.floor(this.x),this.y=Math.floor(this.y),this.z=Math.floor(this.z),this}ceil(){return this.x=Math.ceil(this.x),this.y=Math.ceil(this.y),this.z=Math.ceil(this.z),this}round(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this.z=Math.round(this.z),this}roundToZero(){return this.x=this.x<0?Math.ceil(this.x):Math.floor(this.x),this.y=this.y<0?Math.ceil(this.y):Math.floor(this.y),this.z=this.z<0?Math.ceil(this.z):Math.floor(this.z),this}negate(){return this.x=-this.x,this.y=-this.y,this.z=-this.z,this}dot(t){return this.x*t.x+this.y*t.y+this.z*t.z}lengthSq(){return this.x*this.x+this.y*this.y+this.z*this.z}length(){return Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z)}manhattanLength(){return Math.abs(this.x)+Math.abs(this.y)+Math.abs(this.z)}normalize(){return this.divideScalar(this.length()||1)}setLength(t){return this.normalize().multiplyScalar(t)}lerp(t,e){return this.x+=(t.x-this.x)*e,this.y+=(t.y-this.y)*e,this.z+=(t.z-this.z)*e,this}lerpVectors(t,e,n){return this.x=t.x+(e.x-t.x)*n,this.y=t.y+(e.y-t.y)*n,this.z=t.z+(e.z-t.z)*n,this}cross(t){return this.crossVectors(this,t)}crossVectors(t,e){const n=t.x,o=t.y,i=t.z,r=e.x,s=e.y,a=e.z;return this.x=o*a-i*s,this.y=i*r-n*a,this.z=n*s-o*r,this}projectOnVector(t){const e=t.lengthSq();if(0===e)return this.set(0,0,0);const n=t.dot(this)/e;return this.copy(t).multiplyScalar(n)}projectOnPlane(t){return vn.copy(this).projectOnVector(t),this.sub(vn)}reflect(t){return this.sub(vn.copy(t).multiplyScalar(2*this.dot(t)))}angleTo(t){const e=Math.sqrt(this.lengthSq()*t.lengthSq());if(0===e)return Math.PI/2;const n=this.dot(t)/e;return Math.acos(ie(n,-1,1))}distanceTo(t){return Math.sqrt(this.distanceToSquared(t))}distanceToSquared(t){const e=this.x-t.x,n=this.y-t.y,o=this.z-t.z;return e*e+n*n+o*o}manhattanDistanceTo(t){return Math.abs(this.x-t.x)+Math.abs(this.y-t.y)+Math.abs(this.z-t.z)}setFromSpherical(t){return this.setFromSphericalCoords(t.radius,t.phi,t.theta)}setFromSphericalCoords(t,e,n){const o=Math.sin(e)*t;return this.x=o*Math.sin(n),this.y=Math.cos(e)*t,this.z=o*Math.cos(n),this}setFromCylindrical(t){return this.setFromCylindricalCoords(t.radius,t.theta,t.y)}setFromCylindricalCoords(t,e,n){return this.x=t*Math.sin(e),this.y=n,this.z=t*Math.cos(e),this}setFromMatrixPosition(t){const e=t.elements;return this.x=e[12],this.y=e[13],this.z=e[14],this}setFromMatrixScale(t){const e=this.setFromMatrixColumn(t,0).length(),n=this.setFromMatrixColumn(t,1).length(),o=this.setFromMatrixColumn(t,2).length();return this.x=e,this.y=n,this.z=o,this}setFromMatrixColumn(t,e){return this.fromArray(t.elements,4*e)}setFromMatrix3Column(t,e){return this.fromArray(t.elements,3*e)}setFromEuler(t){return this.x=t._,this.y=t.$,this.z=t.tt,this}equals(t){return t.x===this.x&&t.y===this.y&&t.z===this.z}fromArray(t,e=0){return this.x=t[e],this.y=t[e+1],this.z=t[e+2],this}toArray(t=[],e=0){return t[e]=this.x,t[e+1]=this.y,t[e+2]=this.z,t}fromBufferAttribute(t,e){return this.x=t.getX(e),this.y=t.getY(e),this.z=t.getZ(e),this}random(){return this.x=Math.random(),this.y=Math.random(),this.z=Math.random(),this}randomDirection(){const t=2*(Math.random()-.5),e=Math.random()*Math.PI*2,n=Math.sqrt(1-t**2);return this.x=n*Math.cos(e),this.y=n*Math.sin(e),this.z=t,this}*[Symbol.iterator](){yield this.x,yield this.y,yield this.z}}const vn=new An,mn=new dn;class pn{constructor(t=new An(1/0,1/0,1/0),e=new An(-1/0,-1/0,-1/0)){this.isBox3=!0,this.min=t,this.max=e}set(t,e){return this.min.copy(t),this.max.copy(e),this}setFromArray(t){let e=1/0,n=1/0,o=1/0,i=-1/0,r=-1/0,s=-1/0;for(let a=0,l=t.length;a<l;a+=3){const l=t[a],c=t[a+1],u=t[a+2];l<e&&(e=l),c<n&&(n=c),u<o&&(o=u),l>i&&(i=l),c>r&&(r=c),u>s&&(s=u)}return this.min.set(e,n,o),this.max.set(i,r,s),this}setFromBufferAttribute(t){let e=1/0,n=1/0,o=1/0,i=-1/0,r=-1/0,s=-1/0;for(let a=0,l=t.count;a<l;a++){const l=t.getX(a),c=t.getY(a),u=t.getZ(a);l<e&&(e=l),c<n&&(n=c),u<o&&(o=u),l>i&&(i=l),c>r&&(r=c),u>s&&(s=u)}return this.min.set(e,n,o),this.max.set(i,r,s),this}setFromPoints(t){this.makeEmpty();for(let e=0,n=t.length;e<n;e++)this.expandByPoint(t[e]);return this}setFromCenterAndSize(t,e){const n=_n.copy(e).multiplyScalar(.5);return this.min.copy(t).sub(n),this.max.copy(t).add(n),this}setFromObject(t,e=!1){return this.makeEmpty(),this.expandByObject(t,e)}clone(){return(new this.constructor).copy(this)}copy(t){return this.min.copy(t.min),this.max.copy(t.max),this}makeEmpty(){return this.min.x=this.min.y=this.min.z=1/0,this.max.x=this.max.y=this.max.z=-1/0,this}isEmpty(){return this.max.x<this.min.x||this.max.y<this.min.y||this.max.z<this.min.z}getCenter(t){return this.isEmpty()?t.set(0,0,0):t.addVectors(this.min,this.max).multiplyScalar(.5)}getSize(t){return this.isEmpty()?t.set(0,0,0):t.subVectors(this.max,this.min)}expandByPoint(t){return this.min.min(t),this.max.max(t),this}expandByVector(t){return this.min.sub(t),this.max.add(t),this}expandByScalar(t){return this.min.addScalar(-t),this.max.addScalar(t),this}expandByObject(t,e=!1){t.updateWorldMatrix(!1,!1);const n=t.geometry;if(void 0!==n)if(e&&null!=n.attributes&&void 0!==n.attributes.position){const e=n.attributes.position;for(let n=0,o=e.count;n<o;n++)_n.fromBufferAttribute(e,n).applyMatrix4(t.matrixWorld),this.expandByPoint(_n)}else null===n.boundingBox&&n.computeBoundingBox(),En.copy(n.boundingBox),En.applyMatrix4(t.matrixWorld),this.union(En);const o=t.children;for(let t=0,n=o.length;t<n;t++)this.expandByObject(o[t],e);return this}containsPoint(t){return!(t.x<this.min.x||t.x>this.max.x||t.y<this.min.y||t.y>this.max.y||t.z<this.min.z||t.z>this.max.z)}containsBox(t){return this.min.x<=t.min.x&&t.max.x<=this.max.x&&this.min.y<=t.min.y&&t.max.y<=this.max.y&&this.min.z<=t.min.z&&t.max.z<=this.max.z}getParameter(t,e){return e.set((t.x-this.min.x)/(this.max.x-this.min.x),(t.y-this.min.y)/(this.max.y-this.min.y),(t.z-this.min.z)/(this.max.z-this.min.z))}intersectsBox(t){return!(t.max.x<this.min.x||t.min.x>this.max.x||t.max.y<this.min.y||t.min.y>this.max.y||t.max.z<this.min.z||t.min.z>this.max.z)}intersectsSphere(t){return this.clampPoint(t.center,_n),_n.distanceToSquared(t.center)<=t.radius*t.radius}intersectsPlane(t){let e,n;return t.normal.x>0?(e=t.normal.x*this.min.x,n=t.normal.x*this.max.x):(e=t.normal.x*this.max.x,n=t.normal.x*this.min.x),t.normal.y>0?(e+=t.normal.y*this.min.y,n+=t.normal.y*this.max.y):(e+=t.normal.y*this.max.y,n+=t.normal.y*this.min.y),t.normal.z>0?(e+=t.normal.z*this.min.z,n+=t.normal.z*this.max.z):(e+=t.normal.z*this.max.z,n+=t.normal.z*this.min.z),e<=-t.constant&&n>=-t.constant}intersectsTriangle(t){if(this.isEmpty())return!1;this.getCenter(bn),yn.subVectors(this.max,bn),Cn.subVectors(t.a,bn),wn.subVectors(t.b,bn),xn.subVectors(t.c,bn),In.subVectors(wn,Cn),Mn.subVectors(xn,wn),Sn.subVectors(Cn,xn);let e=[0,-In.z,In.y,0,-Mn.z,Mn.y,0,-Sn.z,Sn.y,In.z,0,-In.x,Mn.z,0,-Mn.x,Sn.z,0,-Sn.x,-In.y,In.x,0,-Mn.y,Mn.x,0,-Sn.y,Sn.x,0];return!!Bn(e,Cn,wn,xn,yn)&&(e=[1,0,0,0,1,0,0,0,1],!!Bn(e,Cn,wn,xn,yn)&&(Rn.crossVectors(In,Mn),e=[Rn.x,Rn.y,Rn.z],Bn(e,Cn,wn,xn,yn)))}clampPoint(t,e){return e.copy(t).clamp(this.min,this.max)}distanceToPoint(t){return _n.copy(t).clamp(this.min,this.max).sub(t).length()}getBoundingSphere(t){return this.getCenter(t.center),t.radius=.5*this.getSize(_n).length(),t}intersect(t){return this.min.max(t.min),this.max.min(t.max),this.isEmpty()&&this.makeEmpty(),this}union(t){return this.min.min(t.min),this.max.max(t.max),this}applyMatrix4(t){return this.isEmpty()||(gn[0].set(this.min.x,this.min.y,this.min.z).applyMatrix4(t),gn[1].set(this.min.x,this.min.y,this.max.z).applyMatrix4(t),gn[2].set(this.min.x,this.max.y,this.min.z).applyMatrix4(t),gn[3].set(this.min.x,this.max.y,this.max.z).applyMatrix4(t),gn[4].set(this.max.x,this.min.y,this.min.z).applyMatrix4(t),gn[5].set(this.max.x,this.min.y,this.max.z).applyMatrix4(t),gn[6].set(this.max.x,this.max.y,this.min.z).applyMatrix4(t),gn[7].set(this.max.x,this.max.y,this.max.z).applyMatrix4(t),this.setFromPoints(gn)),this}translate(t){return this.min.add(t),this.max.add(t),this}equals(t){return t.min.equals(this.min)&&t.max.equals(this.max)}scale(t){return this.getCenter(bn),yn.subVectors(this.max,bn),yn.multiply(t),this.min.copy(bn).sub(yn),this.max.copy(bn).add(yn),this}}const gn=[new An,new An,new An,new An,new An,new An,new An,new An],_n=new An,En=new pn,Cn=new An,wn=new An,xn=new An,In=new An,Mn=new An,Sn=new An,bn=new An,yn=new An,Rn=new An,Tn=new An;function Bn(t,e,n,o,i){for(let r=0,s=t.length-3;r<=s;r+=3){Tn.fromArray(t,r);const s=i.x*Math.abs(Tn.x)+i.y*Math.abs(Tn.y)+i.z*Math.abs(Tn.z),a=e.dot(Tn),l=n.dot(Tn),c=o.dot(Tn);if(Math.max(-Math.max(a,l,c),Math.min(a,l,c))>s)return!1}return!0}const Ln=new pn,Nn=new An,Dn=new An;class Pn{constructor(t=new An,e=-1){this.center=t,this.radius=e}set(t,e){return this.center.copy(t),this.radius=e,this}setFromPoints(t,e){const n=this.center;void 0!==e?n.copy(e):Ln.setFromPoints(t).getCenter(n);let o=0;for(let e=0,i=t.length;e<i;e++)o=Math.max(o,n.distanceToSquared(t[e]));return this.radius=Math.sqrt(o),this}copy(t){return this.center.copy(t.center),this.radius=t.radius,this}isEmpty(){return this.radius<0}makeEmpty(){return this.center.set(0,0,0),this.radius=-1,this}containsPoint(t){return t.distanceToSquared(this.center)<=this.radius*this.radius}distanceToPoint(t){return t.distanceTo(this.center)-this.radius}intersectsSphere(t){const e=this.radius+t.radius;return t.center.distanceToSquared(this.center)<=e*e}intersectsBox(t){return t.intersectsSphere(this)}intersectsPlane(t){return Math.abs(t.distanceToPoint(this.center))<=this.radius}clampPoint(t,e){const n=this.center.distanceToSquared(t);return e.copy(t),n>this.radius*this.radius&&(e.sub(this.center).normalize(),e.multiplyScalar(this.radius).add(this.center)),e}getBoundingBox(t){return this.isEmpty()?(t.makeEmpty(),t):(t.set(this.center,this.center),t.expandByScalar(this.radius),t)}applyMatrix4(t){return this.center.applyMatrix4(t),this.radius=this.radius*t.getMaxScaleOnAxis(),this}translate(t){return this.center.add(t),this}expandByPoint(t){if(this.isEmpty())return this.center.copy(t),this.radius=0,this;Nn.subVectors(t,this.center);const e=Nn.lengthSq();if(e>this.radius*this.radius){const t=Math.sqrt(e),n=.5*(t-this.radius);this.center.addScaledVector(Nn,n/t),this.radius+=n}return this}union(t){return t.isEmpty()?this:this.isEmpty()?(this.copy(t),this):(!0===this.center.equals(t.center)?this.radius=Math.max(this.radius,t.radius):(Dn.subVectors(t.center,this.center).setLength(t.radius),this.expandByPoint(Nn.copy(t.center).add(Dn)),this.expandByPoint(Nn.copy(t.center).sub(Dn))),this)}equals(t){return t.center.equals(this.center)&&t.radius===this.radius}clone(){return(new this.constructor).copy(this)}}const On=new An,Fn=new An,Un=new An,Vn=new An,Gn=new An,Qn=new An,zn=new An;class kn{constructor(t=new An,e=new An(0,0,-1)){this.origin=t,this.direction=e}set(t,e){return this.origin.copy(t),this.direction.copy(e),this}copy(t){return this.origin.copy(t.origin),this.direction.copy(t.direction),this}at(t,e){return e.copy(this.direction).multiplyScalar(t).add(this.origin)}lookAt(t){return this.direction.copy(t).sub(this.origin).normalize(),this}recast(t){return this.origin.copy(this.at(t,On)),this}closestPointToPoint(t,e){e.subVectors(t,this.origin);const n=e.dot(this.direction);return n<0?e.copy(this.origin):e.copy(this.direction).multiplyScalar(n).add(this.origin)}distanceToPoint(t){return Math.sqrt(this.distanceSqToPoint(t))}distanceSqToPoint(t){const e=On.subVectors(t,this.origin).dot(this.direction);return e<0?this.origin.distanceToSquared(t):(On.copy(this.direction).multiplyScalar(e).add(this.origin),On.distanceToSquared(t))}distanceSqToSegment(t,e,n,o){Fn.copy(t).add(e).multiplyScalar(.5),Un.copy(e).sub(t).normalize(),Vn.copy(this.origin).sub(Fn);const i=.5*t.distanceTo(e),r=-this.direction.dot(Un),s=Vn.dot(this.direction),a=-Vn.dot(Un),l=Vn.lengthSq(),c=Math.abs(1-r*r);let u,h,f,d;if(c>0)if(u=r*a-s,h=r*s-a,d=i*c,u>=0)if(h>=-d)if(h<=d){const t=1/c;u*=t,h*=t,f=u*(u+r*h+2*s)+h*(r*u+h+2*a)+l}else h=i,u=Math.max(0,-(r*h+s)),f=-u*u+h*(h+2*a)+l;else h=-i,u=Math.max(0,-(r*h+s)),f=-u*u+h*(h+2*a)+l;else h<=-d?(u=Math.max(0,-(-r*i+s)),h=u>0?-i:Math.min(Math.max(-i,-a),i),f=-u*u+h*(h+2*a)+l):h<=d?(u=0,h=Math.min(Math.max(-i,-a),i),f=h*(h+2*a)+l):(u=Math.max(0,-(r*i+s)),h=u>0?i:Math.min(Math.max(-i,-a),i),f=-u*u+h*(h+2*a)+l);else h=r>0?-i:i,u=Math.max(0,-(r*h+s)),f=-u*u+h*(h+2*a)+l;return n&&n.copy(this.direction).multiplyScalar(u).add(this.origin),o&&o.copy(Un).multiplyScalar(h).add(Fn),f}intersectSphere(t,e){On.subVectors(t.center,this.origin);const n=On.dot(this.direction),o=On.dot(On)-n*n,i=t.radius*t.radius;if(o>i)return null;const r=Math.sqrt(i-o),s=n-r,a=n+r;return s<0&&a<0?null:s<0?this.at(a,e):this.at(s,e)}intersectsSphere(t){return this.distanceSqToPoint(t.center)<=t.radius*t.radius}distanceToPlane(t){const e=t.normal.dot(this.direction);if(0===e)return 0===t.distanceToPoint(this.origin)?0:null;const n=-(this.origin.dot(t.normal)+t.constant)/e;return n>=0?n:null}intersectPlane(t,e){const n=this.distanceToPlane(t);return null===n?null:this.at(n,e)}intersectsPlane(t){const e=t.distanceToPoint(this.origin);if(0===e)return!0;return t.normal.dot(this.direction)*e<0}intersectBox(t,e){let n,o,i,r,s,a;const l=1/this.direction.x,c=1/this.direction.y,u=1/this.direction.z,h=this.origin;return l>=0?(n=(t.min.x-h.x)*l,o=(t.max.x-h.x)*l):(n=(t.max.x-h.x)*l,o=(t.min.x-h.x)*l),c>=0?(i=(t.min.y-h.y)*c,r=(t.max.y-h.y)*c):(i=(t.max.y-h.y)*c,r=(t.min.y-h.y)*c),n>r||i>o?null:((i>n||isNaN(n))&&(n=i),(r<o||isNaN(o))&&(o=r),u>=0?(s=(t.min.z-h.z)*u,a=(t.max.z-h.z)*u):(s=(t.max.z-h.z)*u,a=(t.min.z-h.z)*u),n>a||s>o?null:((s>n||n!=n)&&(n=s),(a<o||o!=o)&&(o=a),o<0?null:this.at(n>=0?n:o,e)))}intersectsBox(t){return null!==this.intersectBox(t,On)}intersectTriangle(t,e,n,o,i){Gn.subVectors(e,t),Qn.subVectors(n,t),zn.crossVectors(Gn,Qn);let r,s=this.direction.dot(zn);if(s>0){if(o)return null;r=1}else{if(!(s<0))return null;r=-1,s=-s}Vn.subVectors(this.origin,t);const a=r*this.direction.dot(Qn.crossVectors(Vn,Qn));if(a<0)return null;const l=r*this.direction.dot(Gn.cross(Vn));if(l<0)return null;if(a+l>s)return null;const c=-r*Vn.dot(zn);return c<0?null:this.at(c/s,i)}applyMatrix4(t){return this.origin.applyMatrix4(t),this.direction.transformDirection(t),this}equals(t){return t.origin.equals(this.origin)&&t.direction.equals(this.direction)}clone(){return(new this.constructor).copy(this)}}class Hn{constructor(){Hn.prototype.isMatrix4=!0,this.elements=[1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1]}set(t,e,n,o,i,r,s,a,l,c,u,h,f,d,A,v){const m=this.elements;return m[0]=t,m[4]=e,m[8]=n,m[12]=o,m[1]=i,m[5]=r,m[9]=s,m[13]=a,m[2]=l,m[6]=c,m[10]=u,m[14]=h,m[3]=f,m[7]=d,m[11]=A,m[15]=v,this}identity(){return this.set(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1),this}clone(){return(new Hn).fromArray(this.elements)}copy(t){const e=this.elements,n=t.elements;return e[0]=n[0],e[1]=n[1],e[2]=n[2],e[3]=n[3],e[4]=n[4],e[5]=n[5],e[6]=n[6],e[7]=n[7],e[8]=n[8],e[9]=n[9],e[10]=n[10],e[11]=n[11],e[12]=n[12],e[13]=n[13],e[14]=n[14],e[15]=n[15],this}copyPosition(t){const e=this.elements,n=t.elements;return e[12]=n[12],e[13]=n[13],e[14]=n[14],this}setFromMatrix3(t){const e=t.elements;return this.set(e[0],e[3],e[6],0,e[1],e[4],e[7],0,e[2],e[5],e[8],0,0,0,0,1),this}extractBasis(t,e,n){return t.setFromMatrixColumn(this,0),e.setFromMatrixColumn(this,1),n.setFromMatrixColumn(this,2),this}makeBasis(t,e,n){return this.set(t.x,e.x,n.x,0,t.y,e.y,n.y,0,t.z,e.z,n.z,0,0,0,0,1),this}extractRotation(t){const e=this.elements,n=t.elements,o=1/Wn.setFromMatrixColumn(t,0).length(),i=1/Wn.setFromMatrixColumn(t,1).length(),r=1/Wn.setFromMatrixColumn(t,2).length();return e[0]=n[0]*o,e[1]=n[1]*o,e[2]=n[2]*o,e[3]=0,e[4]=n[4]*i,e[5]=n[5]*i,e[6]=n[6]*i,e[7]=0,e[8]=n[8]*r,e[9]=n[9]*r,e[10]=n[10]*r,e[11]=0,e[12]=0,e[13]=0,e[14]=0,e[15]=1,this}makeRotationFromEuler(t){const e=this.elements,n=t.x,o=t.y,i=t.z,r=Math.cos(n),s=Math.sin(n),a=Math.cos(o),l=Math.sin(o),c=Math.cos(i),u=Math.sin(i);if("XYZ"===t.order){const t=r*c,n=r*u,o=s*c,i=s*u;e[0]=a*c,e[4]=-a*u,e[8]=l,e[1]=n+o*l,e[5]=t-i*l,e[9]=-s*a,e[2]=i-t*l,e[6]=o+n*l,e[10]=r*a}else if("YXZ"===t.order){const t=a*c,n=a*u,o=l*c,i=l*u;e[0]=t+i*s,e[4]=o*s-n,e[8]=r*l,e[1]=r*u,e[5]=r*c,e[9]=-s,e[2]=n*s-o,e[6]=i+t*s,e[10]=r*a}else if("ZXY"===t.order){const t=a*c,n=a*u,o=l*c,i=l*u;e[0]=t-i*s,e[4]=-r*u,e[8]=o+n*s,e[1]=n+o*s,e[5]=r*c,e[9]=i-t*s,e[2]=-r*l,e[6]=s,e[10]=r*a}else if("ZYX"===t.order){const t=r*c,n=r*u,o=s*c,i=s*u;e[0]=a*c,e[4]=o*l-n,e[8]=t*l+i,e[1]=a*u,e[5]=i*l+t,e[9]=n*l-o,e[2]=-l,e[6]=s*a,e[10]=r*a}else if("YZX"===t.order){const t=r*a,n=r*l,o=s*a,i=s*l;e[0]=a*c,e[4]=i-t*u,e[8]=o*u+n,e[1]=u,e[5]=r*c,e[9]=-s*c,e[2]=-l*c,e[6]=n*u+o,e[10]=t-i*u}else if("XZY"===t.order){const t=r*a,n=r*l,o=s*a,i=s*l;e[0]=a*c,e[4]=-u,e[8]=l*c,e[1]=t*u+i,e[5]=r*c,e[9]=n*u-o,e[2]=o*u-n,e[6]=s*c,e[10]=i*u+t}return e[3]=0,e[7]=0,e[11]=0,e[12]=0,e[13]=0,e[14]=0,e[15]=1,this}makeRotationFromQuaternion(t){return this.compose(Xn,t,Kn)}lookAt(t,e,n){const o=this.elements;return qn.subVectors(t,e),0===qn.lengthSq()&&(qn.z=1),qn.normalize(),jn.crossVectors(n,qn),0===jn.lengthSq()&&(1===Math.abs(n.z)?qn.x+=1e-4:qn.z+=1e-4,qn.normalize(),jn.crossVectors(n,qn)),jn.normalize(),Zn.crossVectors(qn,jn),o[0]=jn.x,o[4]=Zn.x,o[8]=qn.x,o[1]=jn.y,o[5]=Zn.y,o[9]=qn.y,o[2]=jn.z,o[6]=Zn.z,o[10]=qn.z,this}multiply(t){return this.multiplyMatrices(this,t)}premultiply(t){return this.multiplyMatrices(t,this)}multiplyMatrices(t,e){const n=t.elements,o=e.elements,i=this.elements,r=n[0],s=n[4],a=n[8],l=n[12],c=n[1],u=n[5],h=n[9],f=n[13],d=n[2],A=n[6],v=n[10],m=n[14],p=n[3],g=n[7],_=n[11],E=n[15],C=o[0],w=o[4],x=o[8],I=o[12],M=o[1],S=o[5],b=o[9],y=o[13],R=o[2],T=o[6],B=o[10],L=o[14],N=o[3],D=o[7],P=o[11],O=o[15];return i[0]=r*C+s*M+a*R+l*N,i[4]=r*w+s*S+a*T+l*D,i[8]=r*x+s*b+a*B+l*P,i[12]=r*I+s*y+a*L+l*O,i[1]=c*C+u*M+h*R+f*N,i[5]=c*w+u*S+h*T+f*D,i[9]=c*x+u*b+h*B+f*P,i[13]=c*I+u*y+h*L+f*O,i[2]=d*C+A*M+v*R+m*N,i[6]=d*w+A*S+v*T+m*D,i[10]=d*x+A*b+v*B+m*P,i[14]=d*I+A*y+v*L+m*O,i[3]=p*C+g*M+_*R+E*N,i[7]=p*w+g*S+_*T+E*D,i[11]=p*x+g*b+_*B+E*P,i[15]=p*I+g*y+_*L+E*O,this}multiplyScalar(t){const e=this.elements;return e[0]*=t,e[4]*=t,e[8]*=t,e[12]*=t,e[1]*=t,e[5]*=t,e[9]*=t,e[13]*=t,e[2]*=t,e[6]*=t,e[10]*=t,e[14]*=t,e[3]*=t,e[7]*=t,e[11]*=t,e[15]*=t,this}determinant(){const t=this.elements,e=t[0],n=t[4],o=t[8],i=t[12],r=t[1],s=t[5],a=t[9],l=t[13],c=t[2],u=t[6],h=t[10],f=t[14];return t[3]*(+i*a*u-o*l*u-i*s*h+n*l*h+o*s*f-n*a*f)+t[7]*(+e*a*f-e*l*h+i*r*h-o*r*f+o*l*c-i*a*c)+t[11]*(+e*l*u-e*s*f-i*r*u+n*r*f+i*s*c-n*l*c)+t[15]*(-o*s*c-e*a*u+e*s*h+o*r*u-n*r*h+n*a*c)}transpose(){const t=this.elements;let e;return e=t[1],t[1]=t[4],t[4]=e,e=t[2],t[2]=t[8],t[8]=e,e=t[6],t[6]=t[9],t[9]=e,e=t[3],t[3]=t[12],t[12]=e,e=t[7],t[7]=t[13],t[13]=e,e=t[11],t[11]=t[14],t[14]=e,this}setPosition(t,e,n){const o=this.elements;return t.isVector3?(o[12]=t.x,o[13]=t.y,o[14]=t.z):(o[12]=t,o[13]=e,o[14]=n),this}invert(){const t=this.elements,e=t[0],n=t[1],o=t[2],i=t[3],r=t[4],s=t[5],a=t[6],l=t[7],c=t[8],u=t[9],h=t[10],f=t[11],d=t[12],A=t[13],v=t[14],m=t[15],p=u*v*l-A*h*l+A*a*f-s*v*f-u*a*m+s*h*m,g=d*h*l-c*v*l-d*a*f+r*v*f+c*a*m-r*h*m,_=c*A*l-d*u*l+d*s*f-r*A*f-c*s*m+r*u*m,E=d*u*a-c*A*a-d*s*h+r*A*h+c*s*v-r*u*v,C=e*p+n*g+o*_+i*E;if(0===C)return this.set(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);const w=1/C;return t[0]=p*w,t[1]=(A*h*i-u*v*i-A*o*f+n*v*f+u*o*m-n*h*m)*w,t[2]=(s*v*i-A*a*i+A*o*l-n*v*l-s*o*m+n*a*m)*w,t[3]=(u*a*i-s*h*i-u*o*l+n*h*l+s*o*f-n*a*f)*w,t[4]=g*w,t[5]=(c*v*i-d*h*i+d*o*f-e*v*f-c*o*m+e*h*m)*w,t[6]=(d*a*i-r*v*i-d*o*l+e*v*l+r*o*m-e*a*m)*w,t[7]=(r*h*i-c*a*i+c*o*l-e*h*l-r*o*f+e*a*f)*w,t[8]=_*w,t[9]=(d*u*i-c*A*i-d*n*f+e*A*f+c*n*m-e*u*m)*w,t[10]=(r*A*i-d*s*i+d*n*l-e*A*l-r*n*m+e*s*m)*w,t[11]=(c*s*i-r*u*i-c*n*l+e*u*l+r*n*f-e*s*f)*w,t[12]=E*w,t[13]=(c*A*o-d*u*o+d*n*h-e*A*h-c*n*v+e*u*v)*w,t[14]=(d*s*o-r*A*o-d*n*a+e*A*a+r*n*v-e*s*v)*w,t[15]=(r*u*o-c*s*o+c*n*a-e*u*a-r*n*h+e*s*h)*w,this}scale(t){const e=this.elements,n=t.x,o=t.y,i=t.z;return e[0]*=n,e[4]*=o,e[8]*=i,e[1]*=n,e[5]*=o,e[9]*=i,e[2]*=n,e[6]*=o,e[10]*=i,e[3]*=n,e[7]*=o,e[11]*=i,this}getMaxScaleOnAxis(){const t=this.elements,e=t[0]*t[0]+t[1]*t[1]+t[2]*t[2],n=t[4]*t[4]+t[5]*t[5]+t[6]*t[6],o=t[8]*t[8]+t[9]*t[9]+t[10]*t[10];return Math.sqrt(Math.max(e,n,o))}makeTranslation(t,e,n){return this.set(1,0,0,t,0,1,0,e,0,0,1,n,0,0,0,1),this}makeRotationX(t){const e=Math.cos(t),n=Math.sin(t);return this.set(1,0,0,0,0,e,-n,0,0,n,e,0,0,0,0,1),this}makeRotationY(t){const e=Math.cos(t),n=Math.sin(t);return this.set(e,0,n,0,0,1,0,0,-n,0,e,0,0,0,0,1),this}makeRotationZ(t){const e=Math.cos(t),n=Math.sin(t);return this.set(e,-n,0,0,n,e,0,0,0,0,1,0,0,0,0,1),this}makeRotationAxis(t,e){const n=Math.cos(e),o=Math.sin(e),i=1-n,r=t.x,s=t.y,a=t.z,l=i*r,c=i*s;return this.set(l*r+n,l*s-o*a,l*a+o*s,0,l*s+o*a,c*s+n,c*a-o*r,0,l*a-o*s,c*a+o*r,i*a*a+n,0,0,0,0,1),this}makeScale(t,e,n){return this.set(t,0,0,0,0,e,0,0,0,0,n,0,0,0,0,1),this}makeShear(t,e,n,o,i,r){return this.set(1,n,i,0,t,1,r,0,e,o,1,0,0,0,0,1),this}compose(t,e,n){const o=this.elements,i=e._,r=e.$,s=e.tt,a=e.et,l=i+i,c=r+r,u=s+s,h=i*l,f=i*c,d=i*u,A=r*c,v=r*u,m=s*u,p=a*l,g=a*c,_=a*u,E=n.x,C=n.y,w=n.z;return o[0]=(1-(A+m))*E,o[1]=(f+_)*E,o[2]=(d-g)*E,o[3]=0,o[4]=(f-_)*C,o[5]=(1-(h+m))*C,o[6]=(v+p)*C,o[7]=0,o[8]=(d+g)*w,o[9]=(v-p)*w,o[10]=(1-(h+A))*w,o[11]=0,o[12]=t.x,o[13]=t.y,o[14]=t.z,o[15]=1,this}decompose(t,e,n){const o=this.elements;let i=Wn.set(o[0],o[1],o[2]).length();const r=Wn.set(o[4],o[5],o[6]).length(),s=Wn.set(o[8],o[9],o[10]).length();this.determinant()<0&&(i=-i),t.x=o[12],t.y=o[13],t.z=o[14],Yn.copy(this);const a=1/i,l=1/r,c=1/s;return Yn.elements[0]*=a,Yn.elements[1]*=a,Yn.elements[2]*=a,Yn.elements[4]*=l,Yn.elements[5]*=l,Yn.elements[6]*=l,Yn.elements[8]*=c,Yn.elements[9]*=c,Yn.elements[10]*=c,e.setFromRotationMatrix(Yn),n.x=i,n.y=r,n.z=s,this}makePerspective(t,e,n,o,i,r){const s=this.elements,a=2*i/(e-t),l=2*i/(n-o),c=(e+t)/(e-t),u=(n+o)/(n-o),h=-(r+i)/(r-i),f=-2*r*i/(r-i);return s[0]=a,s[4]=0,s[8]=c,s[12]=0,s[1]=0,s[5]=l,s[9]=u,s[13]=0,s[2]=0,s[6]=0,s[10]=h,s[14]=f,s[3]=0,s[7]=0,s[11]=-1,s[15]=0,this}makeOrthographic(t,e,n,o,i,r){const s=this.elements,a=1/(e-t),l=1/(n-o),c=1/(r-i),u=(e+t)*a,h=(n+o)*l,f=(r+i)*c;return s[0]=2*a,s[4]=0,s[8]=0,s[12]=-u,s[1]=0,s[5]=2*l,s[9]=0,s[13]=-h,s[2]=0,s[6]=0,s[10]=-2*c,s[14]=-f,s[3]=0,s[7]=0,s[11]=0,s[15]=1,this}equals(t){const e=this.elements,n=t.elements;for(let t=0;t<16;t++)if(e[t]!==n[t])return!1;return!0}fromArray(t,e=0){for(let n=0;n<16;n++)this.elements[n]=t[n+e];return this}toArray(t=[],e=0){const n=this.elements;return t[e]=n[0],t[e+1]=n[1],t[e+2]=n[2],t[e+3]=n[3],t[e+4]=n[4],t[e+5]=n[5],t[e+6]=n[6],t[e+7]=n[7],t[e+8]=n[8],t[e+9]=n[9],t[e+10]=n[10],t[e+11]=n[11],t[e+12]=n[12],t[e+13]=n[13],t[e+14]=n[14],t[e+15]=n[15],t}composeE(t,e,n){const o=this.elements;this.makeRotationFromEuler(e);const i=n.x,r=n.y,s=n.z;return o[0]*=i,o[1]*=i,o[2]*=i,o[3]=0,o[4]*=r,o[5]*=r,o[6]*=r,o[7]=0,o[8]*=s,o[9]*=s,o[10]*=s,o[11]=0,o[12]=t.x,o[13]=t.y,o[14]=t.z,o[15]=1,this}decomposeE(t,e,n,o=e.order){const i=this.elements;let r=Wn.set(i[0],i[1],i[2]).length();const s=Wn.set(i[4],i[5],i[6]).length(),a=Wn.set(i[8],i[9],i[10]).length();this.determinant()<0&&(r=-r),t.x=i[12],t.y=i[13],t.z=i[14],Yn.copy(this);const l=1/r,c=1/s,u=1/a;return Yn.elements[0]*=l,Yn.elements[1]*=l,Yn.elements[2]*=l,Yn.elements[4]*=c,Yn.elements[5]*=c,Yn.elements[6]*=c,Yn.elements[8]*=u,Yn.elements[9]*=u,Yn.elements[10]*=u,e.setFromRotationMatrix(Yn,o),n.x=r,n.y=s,n.z=a,this}}const Wn=new An,Yn=new Hn,Xn=new An(0,0,0),Kn=new An(1,1,1),jn=new An,Zn=new An,qn=new An,Jn=new Hn,$n=new dn;class to{constructor(t=0,e=0,n=0,o=to.DefaultOrder){this.isEuler=!0,this._=t,this.$=e,this.tt=n,this.ot=o}get x(){return this._}set x(t){this._=t,this.nt()}get y(){return this.$}set y(t){this.$=t,this.nt()}get z(){return this.tt}set z(t){this.tt=t,this.nt()}get order(){return this.ot}set order(t){this.ot=t,this.nt()}set(t,e,n,o=this.ot){return this._=t,this.$=e,this.tt=n,this.ot=o,this.nt(),this}clone(){return new this.constructor(this._,this.$,this.tt,this.ot)}copy(t){return this._=t._,this.$=t.$,this.tt=t.tt,this.ot=t.ot,this.nt(),this}setFromRotationMatrix(t,e=this.ot,n=!0){const o=t.elements,i=o[0],r=o[4],s=o[8],a=o[1],l=o[5],c=o[9],u=o[2],h=o[6],f=o[10];switch(e){case"XYZ":this.$=Math.asin(ie(s,-1,1)),Math.abs(s)<.9999999?(this._=Math.atan2(-c,f),this.tt=Math.atan2(-r,i)):(this._=Math.atan2(h,l),this.tt=0);break;case"YXZ":this._=Math.asin(-ie(c,-1,1)),Math.abs(c)<.9999999?(this.$=Math.atan2(s,f),this.tt=Math.atan2(a,l)):(this.$=Math.atan2(-u,i),this.tt=0);break;case"ZXY":this._=Math.asin(ie(h,-1,1)),Math.abs(h)<.9999999?(this.$=Math.atan2(-u,f),this.tt=Math.atan2(-r,l)):(this.$=0,this.tt=Math.atan2(a,i));break;case"ZYX":this.$=Math.asin(-ie(u,-1,1)),Math.abs(u)<.9999999?(this._=Math.atan2(h,f),this.tt=Math.atan2(a,i)):(this._=0,this.tt=Math.atan2(-r,l));break;case"YZX":this.tt=Math.asin(ie(a,-1,1)),Math.abs(a)<.9999999?(this._=Math.atan2(-c,l),this.$=Math.atan2(-u,i)):(this._=0,this.$=Math.atan2(s,f));break;case"XZY":this.tt=Math.asin(-ie(r,-1,1)),Math.abs(r)<.9999999?(this._=Math.atan2(h,l),this.$=Math.atan2(s,i)):(this._=Math.atan2(-c,f),this.$=0);break;default:console.warn("v3d.Euler: .setFromRotationMatrix() encountered an unknown order: "+e)}return this.ot=e,!0===n&&this.nt(),this}setFromQuaternion(t,e,n){return Jn.makeRotationFromQuaternion(t),this.setFromRotationMatrix(Jn,e,n)}setFromVector3(t,e=this.ot){return this.set(t.x,t.y,t.z,e)}reorder(t){return $n.setFromEuler(this),this.setFromQuaternion($n,t)}equals(t){return t._===this._&&t.$===this.$&&t.tt===this.tt&&t.ot===this.ot}fromArray(t){return this._=t[0],this.$=t[1],this.tt=t[2],void 0!==t[3]&&(this.ot=t[3]),this.nt(),this}toArray(t=[],e=0){return t[e]=this._,t[e+1]=this.$,t[e+2]=this.tt,t[e+3]=this.ot,t}it(t){return this.nt=t,this}nt(){}*[Symbol.iterator](){yield this._,yield this.$,yield this.tt,yield this.ot}toVector3(t){return console.warn("v3d.Euler: .toVector3() has been removed. Use Vector3.setFromEuler() instead"),t?t.set(this._,this.$,this.tt):new An(this._,this.$,this.tt)}makeAlternative(){var t="X"===this.ot[1]?-1:1,e="Y"===this.ot[1]?-1:1,n="Z"===this.ot[1]?-1:1;return this._=_e(t*(this._+Math.PI)),this.$=_e(e*(this.$+Math.PI)),this.tt=_e(n*(this.tt+Math.PI)),this}equalsEps(t,e){return Math.abs(this._-t._)<e&&Math.abs(this.$-t.$)<e&&Math.abs(this.tt-t.tt)<e&&this.ot===t.ot}}to.DefaultOrder="XYZ",to.RotationOrders=["XYZ","YZX","ZXY","XZY","YXZ","ZYX"];class eo{constructor(){this.mask=1}set(t){this.mask=1<<t>>>0}enable(t){this.mask|=1<<t}enableAll(){this.mask=-1}toggle(t){this.mask^=1<<t}disable(t){this.mask&=~(1<<t)}disableAll(){this.mask=0}test(t){return 0!==(this.mask&t.mask)}isEnabled(t){return!!(this.mask&1<<t)}}let no=0;const oo=new An,io=new dn,ro=new Hn,so=new An,ao=new An,lo=new An,co=new dn,uo=new An(1,0,0),ho=new An(0,1,0),fo=new An(0,0,1),Ao={type:"added"},vo={type:"removed"};class mo extends Zt{constructor(){super(),this.isObject3D=!0,Object.defineProperty(this,"id",{value:no++}),this.uuid=ne(),this.name="",this.type="Object3D",this.parent=null,this.children=[],this.up=mo.DefaultUp.clone();const t=new An,e=new to,n=new dn,o=new An(1,1,1);e.it(function(){n.setFromEuler(e,!1)}),n.it(function(){e.setFromQuaternion(n,void 0,!1)}),Object.defineProperties(this,{position:{configurable:!0,enumerable:!0,value:t},rotation:{configurable:!0,enumerable:!0,value:e},quaternion:{configurable:!0,enumerable:!0,value:n},scale:{configurable:!0,enumerable:!0,value:o},modelViewMatrix:{value:new Hn},normalMatrix:{value:new xe}}),this.matrix=new Hn,this.matrixWorld=new Hn,this.matrixAutoUpdate=mo.DefaultMatrixAutoUpdate,this.matrixWorldNeedsUpdate=!1,this.matrixWorldAutoUpdate=mo.DefaultMatrixWorldAutoUpdate,this.layers=new eo,this.castShadow=!1,this.receiveShadow=!1,this.frustumCulled=!0,this.renderOrder=0,this.animations=[],this.userData={},this.internVisible=!0,this.externVisible=!0,this.constraints=[],this.disableChildRendering=!1,this.hidpiCompositing=!1,this.groupNames=[],this.objectIndex=0,this.objectColor=new tn,this.objectAlpha=1}set visible(t){this.externVisible=t}get visible(){return this.internVisible&&this.externVisible}onBeforeRender(){}onAfterRender(){}applyMatrix4(t){this.matrixAutoUpdate&&this.updateMatrix(),this.matrix.premultiply(t),this.matrix.decompose(this.position,this.quaternion,this.scale)}applyQuaternion(t){return this.quaternion.premultiply(t),this}setRotationFromAxisAngle(t,e){this.quaternion.setFromAxisAngle(t,e)}setRotationFromEuler(t){this.quaternion.setFromEuler(t,!0)}setRotationFromMatrix(t){this.quaternion.setFromRotationMatrix(t)}setRotationFromQuaternion(t){this.quaternion.copy(t)}rotateOnAxis(t,e){return io.setFromAxisAngle(t,e),this.quaternion.multiply(io),this}rotateOnWorldAxis(t,e){return io.setFromAxisAngle(t,e),this.quaternion.premultiply(io),this}rotateX(t){return this.rotateOnAxis(uo,t)}rotateY(t){return this.rotateOnAxis(ho,t)}rotateZ(t){return this.rotateOnAxis(fo,t)}translateOnAxis(t,e){return oo.copy(t).applyQuaternion(this.quaternion),this.position.add(oo.multiplyScalar(e)),this}translateX(t){return this.translateOnAxis(uo,t)}translateY(t){return this.translateOnAxis(ho,t)}translateZ(t){return this.translateOnAxis(fo,t)}localToWorld(t){return this.updateWorldMatrix(!0,!1),t.applyMatrix4(this.matrixWorld)}worldToLocal(t){return this.updateWorldMatrix(!0,!1),t.applyMatrix4(ro.copy(this.matrixWorld).invert())}lookAt(t,e,n){t.isVector3?so.copy(t):so.set(t,e,n);const o=this.parent;this.updateWorldMatrix(!0,!1),ao.setFromMatrixPosition(this.matrixWorld),this.isCamera||this.isLight?ro.lookAt(ao,so,this.up):ro.lookAt(so,ao,this.up),this.quaternion.setFromRotationMatrix(ro),o&&(ro.extractRotation(o.matrixWorld),io.setFromRotationMatrix(ro),this.quaternion.premultiply(io.invert()))}add(t){if(arguments.length>1){for(let t=0;t<arguments.length;t++)this.add(arguments[t]);return this}return t===this?(console.error("v3d.Object3D.add: object can't be added as a child of itself.",t),this):(t&&t.isObject3D?(null!==t.parent&&t.parent.remove(t),t.parent=this,this.children.push(t),t.dispatchEvent(Ao)):console.error("v3d.Object3D.add: object not an instance of v3d.Object3D.",t),this)}remove(t){if(arguments.length>1){for(let t=0;t<arguments.length;t++)this.remove(arguments[t]);return this}const e=this.children.indexOf(t);return-1!==e&&(t.parent=null,this.children.splice(e,1),t.dispatchEvent(vo)),this}removeFromParent(){const t=this.parent;return null!==t&&t.remove(this),this}clear(){for(let t=0;t<this.children.length;t++){const e=this.children[t];e.parent=null,e.dispatchEvent(vo)}return this.children.length=0,this}attach(t){return this.updateWorldMatrix(!0,!1),ro.copy(this.matrixWorld).invert(),null!==t.parent&&(t.parent.updateWorldMatrix(!0,!1),ro.multiply(t.parent.matrixWorld)),t.applyMatrix4(ro),this.add(t),t.updateWorldMatrix(!1,!0),this}getObjectById(t){return this.getObjectByProperty("id",t)}getObjectByName(t){return this.getObjectByProperty("name",t)}getObjectByProperty(t,e){if(this[t]===e)return this;for(let n=0,o=this.children.length;n<o;n++){const o=this.children[n].getObjectByProperty(t,e);if(void 0!==o)return o}}getObjectsByProperty(t,e){let n=[];this[t]===e&&n.push(this);for(let o=0,i=this.children.length;o<i;o++){const i=this.children[o].getObjectsByProperty(t,e);i.length>0&&(n=n.concat(i))}return n}getWorldPosition(t){return this.updateWorldMatrix(!0,!1),t.setFromMatrixPosition(this.matrixWorld)}getWorldQuaternion(t){return this.updateWorldMatrix(!0,!1),this.matrixWorld.decompose(ao,t,lo),t}getWorldScale(t){return this.updateWorldMatrix(!0,!1),this.matrixWorld.decompose(ao,co,t),t}getWorldDirection(t){this.updateWorldMatrix(!0,!1);const e=this.matrixWorld.elements;return t.set(e[4],e[5],e[6]).normalize()}raycast(){}traverse(t){t(this);const e=this.children;for(let n=0,o=e.length;n<o;n++)e[n].traverse(t)}traverseVisible(t){if(!1===this.visible)return;t(this);const e=this.children;for(let n=0,o=e.length;n<o;n++)e[n].traverseVisible(t)}traverseAncestors(t){const e=this.parent;null!==e&&(t(e),e.traverseAncestors(t))}updateMatrix(){this.updateConstraints(),this.matrix.compose(this.position,this.quaternion,this.scale),this.matrixWorldNeedsUpdate=!0}updateMatrixWorld(t){this.matrixAutoUpdate&&this.updateMatrix(),(this.matrixWorldNeedsUpdate||t)&&(null===this.parent?this.matrixWorld.copy(this.matrix):this.matrixWorld.multiplyMatrices(this.parent.matrixWorld,this.matrix),this.matrixWorldNeedsUpdate=!1,t=!0);const e=this.children;for(let n=0,o=e.length;n<o;n++){const o=e[n];!0!==o.matrixWorldAutoUpdate&&!0!==t||o.updateMatrixWorld(t)}}updateWorldMatrix(t,e){const n=this.parent;if(!0===t&&null!==n&&n.updateWorldMatrix(!0,!1),this.matrixAutoUpdate&&this.updateMatrix(),null===this.parent?this.matrixWorld.copy(this.matrix):this.matrixWorld.multiplyMatrices(this.parent.matrixWorld,this.matrix),!0===e){const t=this.children;for(let e=0,n=t.length;e<n;e++){t[e].updateWorldMatrix(!1,!0)}}}clone(t){return(new this.constructor).copy(this,t)}copy(t,e=!0){this.name=t.name,this.up.copy(t.up),this.position.copy(t.position),this.rotation.order=t.rotation.order,this.quaternion.copy(t.quaternion),this.scale.copy(t.scale),this.matrix.copy(t.matrix),this.matrixWorld.copy(t.matrixWorld),this.matrixAutoUpdate=t.matrixAutoUpdate,this.matrixWorldNeedsUpdate=t.matrixWorldNeedsUpdate,this.matrixWorldAutoUpdate=t.matrixWorldAutoUpdate,this.layers.mask=t.layers.mask,this.visible=t.visible,this.disableChildRendering=t.disableChildRendering,this.hidpiCompositing=t.hidpiCompositing,this.objectIndex=t.objectIndex,this.objectColor.copy(t.objectColor),this.objectAlpha=t.objectAlpha,this.constraints=[];for(let e=0;e<t.constraints.length;e++)this.constraints.push(t.constraints[e].clone());if(this.castShadow=t.castShadow,this.receiveShadow=t.receiveShadow,this.frustumCulled=t.frustumCulled,this.renderOrder=t.renderOrder,this.userData=JSON.parse(JSON.stringify(t.userData)),!0===e)for(let e=0;e<t.children.length;e++){const n=t.children[e];this.add(n.clone())}return this}copyTransform(t){this.matrix.copy(t.matrixWorld),this.parent&&this.matrix.multiplyMatrices(ro.copy(this.parent.matrixWorld).invert(),this.matrix),this.matrix.decompose(this.position,this.quaternion,this.scale)}isVisible(){return this.visible}updateConstraints(){for(let t=0;t<this.constraints.length;t++)this.constraints[t].update(this)}getWorldPositionNU(t){return t.setFromMatrixPosition(this.matrixWorld)}getLocalDirection(t){const e=this.matrix.elements;return this.isCamera||this.isLight?t.set(-e[8],-e[9],-e[10]).normalize():t.set(e[8],e[9],e[10]).normalize()}lookAtLocal(t,e,n){t.isVector3?so.copy(t):so.set(t,e,n),ao.setFromMatrixPosition(this.matrix),this.isCamera||this.isLight?ro.lookAt(ao,so,this.up):ro.lookAt(so,ao,this.up),this.quaternion.setFromRotationMatrix(ro)}findRoot(){let t=this;return this.traverseAncestors(function(e){t=e}),t}resolveMultiMaterial(){const t=[];for(let e=0;e<this.children.length;e++){const n=this.children[e];n.isMesh&&n.isMaterialGeneratedMesh&&t.push(n)}return t.length||t.push(this),t}getAuxClippingMeshes(){const t=[];for(let e=0;e<this.children.length;e++){const n=this.children[e];n.isMesh&&n.isAuxClippingMesh&&t.push(n)}return t}getWorldEuler(t,e=t.ot){return this.updateWorldMatrix(!0,!1),this.matrixWorld.decomposeE(ao,t,lo,e),t}}mo.DefaultUp=new An(0,1,0),mo.DefaultMatrixAutoUpdate=!0,mo.DefaultMatrixWorldAutoUpdate=!0;const po=new An,go=new An,_o=new An,Eo=new An,Co=new An,wo=new An,xo=new An,Io=new An,Mo=new An,So=new An,bo=new ln,yo=new ln,Ro=new ln;class To{constructor(t=new An,e=new An,n=new An){this.a=t,this.b=e,this.c=n}static getNormal(t,e,n,o){o.subVectors(n,e),po.subVectors(t,e),o.cross(po);const i=o.lengthSq();return i>0?o.multiplyScalar(1/Math.sqrt(i)):o.set(0,0,0)}static getBarycoord(t,e,n,o,i){po.subVectors(o,e),go.subVectors(n,e),_o.subVectors(t,e);const r=po.dot(po),s=po.dot(go),a=po.dot(_o),l=go.dot(go),c=go.dot(_o),u=r*l-s*s;if(0===u)return i.set(0,0,0),null;const h=1/u,f=(l*a-s*c)*h,d=(r*c-s*a)*h;return i.set(1-f-d,d,f)}static containsPoint(t,e,n,o){return null!==this.getBarycoord(t,e,n,o,Eo)&&(Eo.x>=0&&Eo.y>=0&&Eo.x+Eo.y<=1)}static getInterpolation(t,e,n,o,i,r,s,a){return null===this.getBarycoord(t,e,n,o,Eo)?(a.x=0,a.y=0,"z"in a&&(a.z=0),"w"in a&&(a.w=0),null):(a.setScalar(0),a.addScaledVector(i,Eo.x),a.addScaledVector(r,Eo.y),a.addScaledVector(s,Eo.z),a)}static getInterpolatedAttribute(t,e,n,o,i,r){return bo.setScalar(0),yo.setScalar(0),Ro.setScalar(0),bo.fromBufferAttribute(t,e),yo.fromBufferAttribute(t,n),Ro.fromBufferAttribute(t,o),r.setScalar(0),r.addScaledVector(bo,i.x),r.addScaledVector(yo,i.y),r.addScaledVector(Ro,i.z),r}static isFrontFacing(t,e,n,o){return po.subVectors(n,e),go.subVectors(t,e),po.cross(go).dot(o)<0}set(t,e,n){return this.a.copy(t),this.b.copy(e),this.c.copy(n),this}setFromPointsAndIndices(t,e,n,o){return this.a.copy(t[e]),this.b.copy(t[n]),this.c.copy(t[o]),this}setFromAttributeAndIndices(t,e,n,o){return this.a.fromBufferAttribute(t,e),this.b.fromBufferAttribute(t,n),this.c.fromBufferAttribute(t,o),this}clone(){return(new this.constructor).copy(this)}copy(t){return this.a.copy(t.a),this.b.copy(t.b),this.c.copy(t.c),this}getArea(){return po.subVectors(this.c,this.b),go.subVectors(this.a,this.b),.5*po.cross(go).length()}getMidpoint(t){return t.addVectors(this.a,this.b).add(this.c).multiplyScalar(1/3)}getNormal(t){return To.getNormal(this.a,this.b,this.c,t)}getPlane(t){return t.setFromCoplanarPoints(this.a,this.b,this.c)}getBarycoord(t,e){return To.getBarycoord(t,this.a,this.b,this.c,e)}getInterpolation(t,e,n,o,i){return To.getInterpolation(t,this.a,this.b,this.c,e,n,o,i)}containsPoint(t){return To.containsPoint(t,this.a,this.b,this.c)}isFrontFacing(t){return To.isFrontFacing(this.a,this.b,this.c,t)}intersectsBox(t){return t.intersectsTriangle(this)}closestPointToPoint(t,e){const n=this.a,o=this.b,i=this.c;let r,s;Co.subVectors(o,n),wo.subVectors(i,n),Io.subVectors(t,n);const a=Co.dot(Io),l=wo.dot(Io);if(a<=0&&l<=0)return e.copy(n);Mo.subVectors(t,o);const c=Co.dot(Mo),u=wo.dot(Mo);if(c>=0&&u<=c)return e.copy(o);const h=a*u-c*l;if(h<=0&&a>=0&&c<=0)return r=a/(a-c),e.copy(n).addScaledVector(Co,r);So.subVectors(t,i);const f=Co.dot(So),d=wo.dot(So);if(d>=0&&f<=d)return e.copy(i);const A=f*l-a*d;if(A<=0&&l>=0&&d<=0)return s=l/(l-d),e.copy(n).addScaledVector(wo,s);const v=c*d-f*u;if(v<=0&&u-c>=0&&f-d>=0)return xo.subVectors(i,o),s=(u-c)/(u-c+(f-d)),e.copy(o).addScaledVector(xo,s);const m=1/(v+A+h);return r=A*m,s=h*m,e.copy(n).addScaledVector(Co,r).addScaledVector(wo,s)}equals(t){return t.a.equals(this.a)&&t.b.equals(this.b)&&t.c.equals(this.c)}}let Bo=0;class Lo extends Zt{constructor(){super(),this.isMaterial=!0,Object.defineProperty(this,"id",{value:Bo++}),this.uuid=ne(),this.name="",this.type="Material",this.blending=1,this.side=0,this.vertexColors=!1,this.opacity=1,this.transparent=!1,this.blendSrc=A,this.blendDst=v,this.blendEquation=a,this.blendSrcAlpha=null,this.blendDstAlpha=null,this.blendEquationAlpha=null,this.depthFunc=3,this.depthTest=!0,this.depthWrite=!0,this.stencilWriteMask=255,this.stencilFunc=519,this.stencilRef=0,this.stencilFuncMask=255,this.stencilFail=kt,this.stencilZFail=kt,this.stencilZPass=kt,this.stencilWrite=!1,this.clippingPlanes=null,this.clipIntersection=!1,this.clipShadows=!1,this.shadowSide=0,this.colorWrite=!0,this.precision=null,this.polygonOffset=!1,this.polygonOffsetFactor=0,this.polygonOffsetUnits=0,this.dithering=!1,this.alphaToCoverage=!1,this.premultipliedAlpha=!1,this.visible=!0,this.toneMapped=!0,this.userData={},this.version=0,this.rt=0,this.depthPrepass=!1,this.receiveShadow=!1,this.castShadow=!1,this.profile="",this.defines={},this.definesFragOnly=new Set,this.DefaultEnvMapAutoAssign=!0,this.envMapAutoAssign=this.DefaultEnvMapAutoAssign,this.gtaoVisible=!0}get alphaTest(){return this.rt}set alphaTest(t){this.rt>0!=t>0&&this.version++,this.rt=t}onBuild(){}onBeforeRender(){}onBeforeCompile(){}customProgramCacheKey(){return this.onBeforeCompile.toString()}setValues(t){if(void 0!==t)for(const e in t){const n=t[e];if(void 0===n){console.warn("v3d.Material: '"+e+"' parameter is undefined.");continue}const o=this[e];void 0!==o?o&&o.isColor?o.set(n):o&&o.isVector3&&n&&n.isVector3?o.copy(n):this[e]=n:console.warn("v3d."+this.type+": '"+e+"' is not a property of this material.")}}clone(){return(new this.constructor).copy(this)}copy(t){this.name=t.name,this.blending=t.blending,this.side=t.side,this.vertexColors=t.vertexColors,this.opacity=t.opacity,this.transparent=t.transparent,this.blendSrc=t.blendSrc,this.blendDst=t.blendDst,this.blendEquation=t.blendEquation,this.blendSrcAlpha=t.blendSrcAlpha,this.blendDstAlpha=t.blendDstAlpha,this.blendEquationAlpha=t.blendEquationAlpha,this.depthFunc=t.depthFunc,this.depthTest=t.depthTest,this.depthWrite=t.depthWrite,this.stencilWriteMask=t.stencilWriteMask,this.stencilFunc=t.stencilFunc,this.stencilRef=t.stencilRef,this.stencilFuncMask=t.stencilFuncMask,this.stencilFail=t.stencilFail,this.stencilZFail=t.stencilZFail,this.stencilZPass=t.stencilZPass,this.stencilWrite=t.stencilWrite;const e=t.clippingPlanes;let n=null;if(null!==e){const t=e.length;n=new Array(t);for(let o=0;o!==t;++o)n[o]=e[o].clone()}return this.clippingPlanes=n,this.clipIntersection=t.clipIntersection,this.clipShadows=t.clipShadows,this.shadowSide=t.shadowSide,this.colorWrite=t.colorWrite,this.precision=t.precision,this.polygonOffset=t.polygonOffset,this.polygonOffsetFactor=t.polygonOffsetFactor,this.polygonOffsetUnits=t.polygonOffsetUnits,this.dithering=t.dithering,this.alphaTest=t.alphaTest,this.alphaToCoverage=t.alphaToCoverage,this.premultipliedAlpha=t.premultipliedAlpha,this.visible=t.visible,this.toneMapped=t.toneMapped,this.userData=JSON.parse(JSON.stringify(t.userData)),this.depthPrepass=t.depthPrepass,this.defines=Object.assign({},t.defines),this.definesFragOnly=new Set(t.definesFragOnly),this.receiveShadow=t.receiveShadow,this.castShadow=t.castShadow,this.profile=t.profile,this.envMapAutoAssign=t.envMapAutoAssign,this.gtaoVisible=t.gtaoVisible,this}dispose(){this.dispatchEvent({type:"dispose"})}set needsUpdate(t){!0===t&&this.version++}get needsUpdate(){return 0!=this.version}}class No extends Lo{constructor(t){super(),this.isMeshBasicMaterial=!0,this.type="MeshBasicMaterial",this.color=new tn(16777215),this.map=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.alphaMap=null,this.envMap=null,this.combine=0,this.reflectivity=1,this.refractionRatio=.98,this.wireframe=!1,this.wireframeLinewidth=1,this.fog=!0,this.setValues(t)}copy(t){return super.copy(t),this.color.copy(t.color),this.map=t.map,this.lightMap=t.lightMap,this.lightMapIntensity=t.lightMapIntensity,this.aoMap=t.aoMap,this.aoMapIntensity=t.aoMapIntensity,this.alphaMap=t.alphaMap,this.envMap=t.envMap,this.combine=t.combine,this.reflectivity=t.reflectivity,this.refractionRatio=t.refractionRatio,this.wireframe=t.wireframe,this.wireframeLinewidth=t.wireframeLinewidth,this.fog=t.fog,this}}const Do=new An,Po=new we;class Oo{constructor(t,e,n=!1){if(Array.isArray(t))throw new TypeError("v3d.BufferAttribute: array should be a Typed Array.");this.isBufferAttribute=!0,this.name="",this.array=t,this.itemSize=e,this.count=void 0!==t?t.length/e:0,this.normalized=n,this.usage=Xt,this.updateRange={offset:0,count:-1},this.gpuType=G,this.version=0}onUploadCallback(){}set needsUpdate(t){!0===t&&this.version++}setUsage(t){return this.usage=t,this}copy(t){return this.name=t.name,this.array=new t.array.constructor(t.array),this.itemSize=t.itemSize,this.count=t.count,this.normalized=t.normalized,this.usage=t.usage,this.gpuType=t.gpuType,this}copyAt(t,e,n){t*=this.itemSize,n*=e.itemSize;for(let o=0,i=this.itemSize;o<i;o++)this.array[t+o]=e.array[n+o];return this}copyArray(t){return this.array.set(t),this}applyMatrix3(t){if(2===this.itemSize)for(let e=0,n=this.count;e<n;e++)Po.fromBufferAttribute(this,e),Po.applyMatrix3(t),this.setXY(e,Po.x,Po.y);else if(3===this.itemSize)for(let e=0,n=this.count;e<n;e++)Do.fromBufferAttribute(this,e),Do.applyMatrix3(t),this.setXYZ(e,Do.x,Do.y,Do.z);return this}applyMatrix4(t){for(let e=0,n=this.count;e<n;e++)Do.fromBufferAttribute(this,e),Do.applyMatrix4(t),this.setXYZ(e,Do.x,Do.y,Do.z);return this}applyNormalMatrix(t){for(let e=0,n=this.count;e<n;e++)Do.fromBufferAttribute(this,e),Do.applyNormalMatrix(t),this.setXYZ(e,Do.x,Do.y,Do.z);return this}transformDirection(t){for(let e=0,n=this.count;e<n;e++)Do.fromBufferAttribute(this,e),Do.transformDirection(t),this.setXYZ(e,Do.x,Do.y,Do.z);return this}set(t,e=0){return this.array.set(t,e),this}getX(t){let e=this.array[t*this.itemSize];return this.normalized&&(e=de(e,this.array)),e}setX(t,e){return this.normalized&&(e=Ae(e,this.array)),this.array[t*this.itemSize]=e,this}getY(t){let e=this.array[t*this.itemSize+1];return this.normalized&&(e=de(e,this.array)),e}setY(t,e){return this.normalized&&(e=Ae(e,this.array)),this.array[t*this.itemSize+1]=e,this}getZ(t){let e=this.array[t*this.itemSize+2];return this.normalized&&(e=de(e,this.array)),e}setZ(t,e){return this.normalized&&(e=Ae(e,this.array)),this.array[t*this.itemSize+2]=e,this}getW(t){let e=this.array[t*this.itemSize+3];return this.normalized&&(e=de(e,this.array)),e}setW(t,e){return this.normalized&&(e=Ae(e,this.array)),this.array[t*this.itemSize+3]=e,this}setXY(t,e,n){return t*=this.itemSize,this.normalized&&(e=Ae(e,this.array),n=Ae(n,this.array)),this.array[t+0]=e,this.array[t+1]=n,this}setXYZ(t,e,n,o){return t*=this.itemSize,this.normalized&&(e=Ae(e,this.array),n=Ae(n,this.array),o=Ae(o,this.array)),this.array[t+0]=e,this.array[t+1]=n,this.array[t+2]=o,this}setXYZW(t,e,n,o,i){return t*=this.itemSize,this.normalized&&(e=Ae(e,this.array),n=Ae(n,this.array),o=Ae(o,this.array),i=Ae(i,this.array)),this.array[t+0]=e,this.array[t+1]=n,this.array[t+2]=o,this.array[t+3]=i,this}onUpload(t){return this.onUploadCallback=t,this}clone(){return new this.constructor(this.array,this.itemSize).copy(this)}}class Fo extends Oo{constructor(t,e,n){super(new Uint16Array(t),e,n)}}class Uo extends Oo{constructor(t,e,n){super(new Uint32Array(t),e,n)}}class Vo extends Oo{constructor(t,e,n){super(new Float32Array(t),e,n)}}let Go=0;const Qo=new Hn,zo=new mo,ko=new An,Ho=new pn,Wo=new pn,Yo=new An;class Xo extends Zt{constructor(){super(),this.isBufferGeometry=!0,Object.defineProperty(this,"id",{value:Go++}),this.uuid=ne(),this.name="",this.type="BufferGeometry",this.index=null,this.attributes={},this.morphAttributes={},this.morphTargetsRelative=!1,this.groups=[],this.boundingBox=null,this.boundingSphere=null,this.boundsTree=null,this.drawRange={start:0,count:1/0},this.userData={}}getIndex(){return this.index}setIndex(t){return Array.isArray(t)?this.index=new Oo(new(Se(t)?Uint32Array:Uint16Array)(t),1):this.index=t,this}getAttribute(t){return this.attributes[t]}setAttribute(t,e){return this.attributes[t]=e,this}deleteAttribute(t){return delete this.attributes[t],this}hasAttribute(t){return void 0!==this.attributes[t]}addGroup(t,e,n=0){this.groups.push({start:t,count:e,materialIndex:n})}clearGroups(){this.groups=[]}setDrawRange(t,e){this.drawRange.start=t,this.drawRange.count=e}applyMatrix4(t){const e=this.attributes.position;void 0!==e&&(e.applyMatrix4(t),e.needsUpdate=!0);const n=this.attributes.normal;if(void 0!==n){const e=(new xe).getNormalMatrix(t);n.applyNormalMatrix(e),n.needsUpdate=!0}const o=this.attributes.tangent;return void 0!==o&&(o.transformDirection(t),o.needsUpdate=!0),null!==this.boundingBox&&this.computeBoundingBox(),null!==this.boundingSphere&&this.computeBoundingSphere(),this}applyQuaternion(t){return Qo.makeRotationFromQuaternion(t),this.applyMatrix4(Qo),this}rotateX(t){return Qo.makeRotationX(t),this.applyMatrix4(Qo),this}rotateY(t){return Qo.makeRotationY(t),this.applyMatrix4(Qo),this}rotateZ(t){return Qo.makeRotationZ(t),this.applyMatrix4(Qo),this}translate(t,e,n){return Qo.makeTranslation(t,e,n),this.applyMatrix4(Qo),this}scale(t,e,n){return Qo.makeScale(t,e,n),this.applyMatrix4(Qo),this}lookAt(t){return zo.lookAt(t),zo.updateMatrix(),this.applyMatrix4(zo.matrix),this}center(){return this.computeBoundingBox(),this.boundingBox.getCenter(ko).negate(),this.translate(ko.x,ko.y,ko.z),this}setFromPoints(t){const e=[];for(let n=0,o=t.length;n<o;n++){const o=t[n];e.push(o.x,o.y,o.z||0)}return this.setAttribute("position",new Vo(e,3)),this}computeBoundingBox(){null===this.boundingBox&&(this.boundingBox=new pn);const t=this.attributes.position,e=this.morphAttributes.position;if(t&&t.isGLBufferAttribute)return console.error('v3d.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box. Alternatively set "mesh.frustumCulled" to "false".',this),void this.boundingBox.set(new An(-1/0,-1/0,-1/0),new An(1/0,1/0,1/0));if(void 0!==t){if(this.boundingBox.setFromBufferAttribute(t),e)for(let t=0,n=e.length;t<n;t++){const n=e[t];Ho.setFromBufferAttribute(n),this.morphTargetsRelative?(Yo.addVectors(this.boundingBox.min,Ho.min),this.boundingBox.expandByPoint(Yo),Yo.addVectors(this.boundingBox.max,Ho.max),this.boundingBox.expandByPoint(Yo)):(this.boundingBox.expandByPoint(Ho.min),this.boundingBox.expandByPoint(Ho.max))}}else this.boundingBox.makeEmpty();(isNaN(this.boundingBox.min.x)||isNaN(this.boundingBox.min.y)||isNaN(this.boundingBox.min.z))&&console.error('v3d.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.',this)}computeBoundingSphere(){null===this.boundingSphere&&(this.boundingSphere=new Pn);const t=this.attributes.position,e=this.morphAttributes.position;if(t&&t.isGLBufferAttribute)return console.error('v3d.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere. Alternatively set "mesh.frustumCulled" to "false".',this),void this.boundingSphere.set(new An,1/0);if(t){const n=this.boundingSphere.center;if(Ho.setFromBufferAttribute(t),e)for(let t=0,n=e.length;t<n;t++){const n=e[t];Wo.setFromBufferAttribute(n),this.morphTargetsRelative?(Yo.addVectors(Ho.min,Wo.min),Ho.expandByPoint(Yo),Yo.addVectors(Ho.max,Wo.max),Ho.expandByPoint(Yo)):(Ho.expandByPoint(Wo.min),Ho.expandByPoint(Wo.max))}Ho.getCenter(n);let o=0;for(let e=0,i=t.count;e<i;e++)Yo.fromBufferAttribute(t,e),o=Math.max(o,n.distanceToSquared(Yo));if(e)for(let i=0,r=e.length;i<r;i++){const r=e[i],s=this.morphTargetsRelative;for(let e=0,i=r.count;e<i;e++)Yo.fromBufferAttribute(r,e),s&&(ko.fromBufferAttribute(t,e),Yo.add(ko)),o=Math.max(o,n.distanceToSquared(Yo))}this.boundingSphere.radius=Math.sqrt(o),isNaN(this.boundingSphere.radius)&&console.error('v3d.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.',this)}}computeTangents(){const t=this.index,e=this.attributes;if(null===t||void 0===e.position||void 0===e.normal||void 0===e.uv)return void console.error("v3d.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)");const n=t.array,o=e.position.array,i=e.normal.array,r=e.uv.array,s=o.length/3;!1===this.hasAttribute("tangent")&&this.setAttribute("tangent",new Oo(new Float32Array(4*s),4));const a=this.getAttribute("tangent").array,l=[],c=[];for(let t=0;t<s;t++)l[t]=new An,c[t]=new An;const u=new An,h=new An,f=new An,d=new we,A=new we,v=new we,m=new An,p=new An;function g(t,e,n){u.fromArray(o,3*t),h.fromArray(o,3*e),f.fromArray(o,3*n),d.fromArray(r,2*t),A.fromArray(r,2*e),v.fromArray(r,2*n),h.sub(u),f.sub(u),A.sub(d),v.sub(d);const i=1/(A.x*v.y-v.x*A.y);isFinite(i)&&(m.copy(h).multiplyScalar(v.y).addScaledVector(f,-A.y).multiplyScalar(i),p.copy(f).multiplyScalar(A.x).addScaledVector(h,-v.x).multiplyScalar(i),l[t].add(m),l[e].add(m),l[n].add(m),c[t].add(p),c[e].add(p),c[n].add(p))}let _=this.groups;0===_.length&&(_=[{start:0,count:n.length}]);for(let t=0,e=_.length;t<e;++t){const e=_[t],o=e.start;for(let t=o,i=o+e.count;t<i;t+=3)g(n[t+0],n[t+1],n[t+2])}const E=new An,C=new An,w=new An,x=new An;function I(t){w.fromArray(i,3*t),x.copy(w);const e=l[t];E.copy(e),E.sub(w.multiplyScalar(w.dot(e))).normalize(),C.crossVectors(x,e);const n=C.dot(c[t])<0?-1:1;a[4*t]=E.x,a[4*t+1]=E.y,a[4*t+2]=E.z,a[4*t+3]=n}for(let t=0,e=_.length;t<e;++t){const e=_[t],o=e.start;for(let t=o,i=o+e.count;t<i;t+=3)I(n[t+0]),I(n[t+1]),I(n[t+2])}}computeVertexNormals(){const t=this.index,e=this.getAttribute("position");if(void 0!==e){let n=this.getAttribute("normal");if(void 0===n)n=new Oo(new Float32Array(3*e.count),3),this.setAttribute("normal",n);else for(let t=0,e=n.count;t<e;t++)n.setXYZ(t,0,0,0);const o=new An,i=new An,r=new An,s=new An,a=new An,l=new An,c=new An,u=new An;if(t)for(let h=0,f=t.count;h<f;h+=3){const f=t.getX(h+0),d=t.getX(h+1),A=t.getX(h+2);o.fromBufferAttribute(e,f),i.fromBufferAttribute(e,d),r.fromBufferAttribute(e,A),c.subVectors(r,i),u.subVectors(o,i),c.cross(u),s.fromBufferAttribute(n,f),a.fromBufferAttribute(n,d),l.fromBufferAttribute(n,A),s.add(c),a.add(c),l.add(c),n.setXYZ(f,s.x,s.y,s.z),n.setXYZ(d,a.x,a.y,a.z),n.setXYZ(A,l.x,l.y,l.z)}else for(let t=0,s=e.count;t<s;t+=3)o.fromBufferAttribute(e,t+0),i.fromBufferAttribute(e,t+1),r.fromBufferAttribute(e,t+2),c.subVectors(r,i),u.subVectors(o,i),c.cross(u),n.setXYZ(t+0,c.x,c.y,c.z),n.setXYZ(t+1,c.x,c.y,c.z),n.setXYZ(t+2,c.x,c.y,c.z);this.normalizeNormals(),n.needsUpdate=!0}}merge(){return console.error("v3d.BufferGeometry.merge() has been removed. Use v3d.BufferGeometryUtils.mergeBufferGeometries() instead."),this}normalizeNormals(){const t=this.attributes.normal;for(let e=0,n=t.count;e<n;e++)Yo.fromBufferAttribute(t,e),Yo.normalize(),t.setXYZ(e,Yo.x,Yo.y,Yo.z)}toNonIndexed(){function t(t,e){const n=t.array,o=t.itemSize,i=t.normalized,r=new n.constructor(e.length*o);let s=0,a=0;for(let t=0,i=e.length;t<i;t++){s=e[t]*o;for(let t=0;t<o;t++)r[a++]=n[s++]}return new Oo(r,o,i)}if(null===this.index)return console.warn("v3d.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed."),this;const e=new Xo,n=this.index.array,o=this.attributes;for(const i in o){const r=t(o[i],n);e.setAttribute(i,r)}const i=this.morphAttributes;for(const o in i){const r=[],s=i[o];for(let e=0,o=s.length;e<o;e++){const o=t(s[e],n);r.push(o)}e.morphAttributes[o]=r}e.morphTargetsRelative=this.morphTargetsRelative;const r=this.groups;for(let t=0,n=r.length;t<n;t++){const n=r[t];e.addGroup(n.start,n.count,n.materialIndex)}return e}clone(){return(new this.constructor).copy(this)}copy(t){this.index=null,this.attributes={},this.morphAttributes={},this.groups=[],this.boundingBox=null,this.boundingSphere=null;const e={};this.name=t.name;const n=t.index;null!==n&&this.setIndex(n.clone(e));const o=t.attributes;for(const t in o){const n=o[t];this.setAttribute(t,n.clone(e))}const i=t.morphAttributes;for(const t in i){const n=[],o=i[t];for(let t=0,i=o.length;t<i;t++)n.push(o[t].clone(e));this.morphAttributes[t]=n}this.morphTargetsRelative=t.morphTargetsRelative;const r=t.groups;for(let t=0,e=r.length;t<e;t++){const e=r[t];this.addGroup(e.start,e.count,e.materialIndex)}const s=t.boundingBox;null!==s&&(this.boundingBox=s.clone());const a=t.boundingSphere;return null!==a&&(this.boundingSphere=a.clone()),this.drawRange.start=t.drawRange.start,this.drawRange.count=t.drawRange.count,this.userData=t.userData,void 0!==t.parameters&&(this.parameters=Object.assign({},t.parameters)),this}dispose(){this.dispatchEvent({type:"dispose"})}}const Ko=new Hn,jo=new kn,Zo=new Pn,qo=new An,Jo=new An,$o=new An,ti=new An,ei=new An,ni=new An,oi=new An,ii=new An,ri=new An,si=new we,ai=new we,li=new we,ci=new An,ui=new An;class hi extends mo{constructor(t=new Xo,e=new No){super(),this.isMesh=!0,this.type="Mesh",this.geometry=t,this.material=e,this.updateMorphTargets(),this.isMaterialGeneratedMesh=!1,this.isAuxClippingMesh=!1}copy(t,e){return super.copy(t,e),void 0!==t.morphTargetInfluences&&(this.morphTargetInfluences=t.morphTargetInfluences.slice()),void 0!==t.morphTargetDictionary&&(this.morphTargetDictionary=Object.assign({},t.morphTargetDictionary)),this.material=t.material,this.geometry=t.geometry,this.isMaterialGeneratedMesh=t.isMaterialGeneratedMesh,this}updateMorphTargets(){const t=this.geometry.morphAttributes,e=Object.keys(t);if(e.length>0){const n=t[e[0]];if(void 0!==n){this.morphTargetInfluences=[],this.morphTargetDictionary={};for(let t=0,e=n.length;t<e;t++){const e=n[t].name||String(t);this.morphTargetInfluences.push(0),this.morphTargetDictionary[e]=t}}}}getVertexPosition(t,e){const n=this.geometry,o=n.attributes.position,i=n.morphAttributes.position,r=n.morphTargetsRelative;e.fromBufferAttribute(o,t);const s=this.morphTargetInfluences;if(i&&s){oi.set(0,0,0);for(let n=0,o=i.length;n<o;n++){const o=s[n],a=i[n];0!==o&&(ti.fromBufferAttribute(a,t),r?oi.addScaledVector(ti,o):oi.addScaledVector(ti.sub(e),o))}e.add(oi)}return this.isSkinnedMesh&&this.boneTransform(t,e),e}raycast(t,e){if(this.isAuxClippingMesh)return;const n=this.geometry,o=this.material,i=this.matrixWorld;if(void 0===o)return;if(null===n.boundingSphere&&n.computeBoundingSphere(),Zo.copy(n.boundingSphere),Zo.applyMatrix4(i),!1===t.ray.intersectsSphere(Zo))return;if(Ko.copy(i).invert(),jo.copy(t.ray).applyMatrix4(Ko),null!==n.boundingBox&&!1===jo.intersectsBox(n.boundingBox))return;let r;const s=n.index,a=n.attributes.position,l=n.morphAttributes.position,c=n.morphTargetsRelative,u=n.attributes.uv,h=n.attributes.uv2,f=n.groups,d=n.drawRange;if(null!==s)if(Array.isArray(o))for(let n=0,i=f.length;n<i;n++){const i=f[n],A=o[i.materialIndex];for(let n=Math.max(i.start,d.start),o=Math.min(s.count,Math.min(i.start+i.count,d.start+d.count));n<o;n+=3){const o=s.getX(n),f=s.getX(n+1),d=s.getX(n+2);r=fi(this,A,t,jo,a,l,c,u,h,o,f,d),r&&(r.faceIndex=Math.floor(n/3),r.face.materialIndex=i.materialIndex,e.push(r))}}else{for(let n=Math.max(0,d.start),i=Math.min(s.count,d.start+d.count);n<i;n+=3){const i=s.getX(n),f=s.getX(n+1),d=s.getX(n+2);r=fi(this,o,t,jo,a,l,c,u,h,i,f,d),r&&(r.faceIndex=Math.floor(n/3),e.push(r))}}else if(void 0!==a)if(Array.isArray(o))for(let n=0,i=f.length;n<i;n++){const i=f[n],s=o[i.materialIndex];for(let n=Math.max(i.start,d.start),o=Math.min(a.count,Math.min(i.start+i.count,d.start+d.count));n<o;n+=3){r=fi(this,s,t,jo,a,l,c,u,h,n,n+1,n+2),r&&(r.faceIndex=Math.floor(n/3),r.face.materialIndex=i.materialIndex,e.push(r))}}else{for(let n=Math.max(0,d.start),i=Math.min(a.count,d.start+d.count);n<i;n+=3){r=fi(this,o,t,jo,a,l,c,u,h,n,n+1,n+2),r&&(r.faceIndex=Math.floor(n/3),e.push(r))}}}clone(){return new this.constructor(this.geometry,this.material).copy(this)}getWorldDirection(t){this.updateWorldMatrix(!0,!1);const e=this.matrixWorld.elements;return t.set(e[8],e[9],e[10]).normalize()}isVisible(){return this.isMaterialGeneratedMesh&&this.parent?this.visible&&this.parent.visible:this.visible}}function fi(t,e,n,o,i,r,s,a,l,c,u,h){qo.fromBufferAttribute(i,c),Jo.fromBufferAttribute(i,u),$o.fromBufferAttribute(i,h);const f=t.morphTargetInfluences;if(r&&f){oi.set(0,0,0),ii.set(0,0,0),ri.set(0,0,0);for(let t=0,e=r.length;t<e;t++){const e=f[t],n=r[t];0!==e&&(ti.fromBufferAttribute(n,c),ei.fromBufferAttribute(n,u),ni.fromBufferAttribute(n,h),s?(oi.addScaledVector(ti,e),ii.addScaledVector(ei,e),ri.addScaledVector(ni,e)):(oi.addScaledVector(ti.sub(qo),e),ii.addScaledVector(ei.sub(Jo),e),ri.addScaledVector(ni.sub($o),e)))}qo.add(oi),Jo.add(ii),$o.add(ri)}t.isSkinnedMesh&&(t.boneTransform(c,qo),t.boneTransform(u,Jo),t.boneTransform(h,$o));const d=function(t,e,n,o,i,r,s,a){let l;if(l=1===e.side?o.intersectTriangle(s,r,i,!0,a):o.intersectTriangle(i,r,s,0===e.side,a),null===l)return null;ui.copy(a),ui.applyMatrix4(t.matrixWorld);const c=n.ray.origin.distanceTo(ui);return c<n.near||c>n.far?null:{distance:c,point:ui.clone(),object:t}}(t,e,n,o,qo,Jo,$o,ci);if(d){a&&(si.fromBufferAttribute(a,c),ai.fromBufferAttribute(a,u),li.fromBufferAttribute(a,h),d.uv=To.getInterpolation(ci,qo,Jo,$o,si,ai,li,new we)),l&&(si.fromBufferAttribute(l,c),ai.fromBufferAttribute(l,u),li.fromBufferAttribute(l,h),d.uv2=To.getInterpolation(ci,qo,Jo,$o,si,ai,li,new we));const t={a:c,b:u,c:h,normal:new An,materialIndex:0};To.getNormal(qo,Jo,$o,t.normal),d.face=t}return d}class di extends Xo{constructor(t=1,e=1,n=1,o=1,i=1,r=1){super(),this.type="BoxGeometry",this.parameters={width:t,height:e,depth:n,widthSegments:o,heightSegments:i,depthSegments:r};const s=this;o=Math.floor(o),i=Math.floor(i),r=Math.floor(r);const a=[],l=[],c=[],u=[];let h=0,f=0;function d(t,e,n,o,i,r,d,A,v,m,p){const g=r/v,_=d/m,E=r/2,C=d/2,w=A/2,x=v+1,I=m+1;let M=0,S=0;const b=new An;for(let r=0;r<I;r++){const s=r*_-C;for(let a=0;a<x;a++){const h=a*g-E;b[t]=h*o,b[e]=s*i,b[n]=w,l.push(b.x,b.y,b.z),b[t]=0,b[e]=0,b[n]=A>0?1:-1,c.push(b.x,b.y,b.z),u.push(a/v),u.push(1-r/m),M+=1}}for(let t=0;t<m;t++)for(let e=0;e<v;e++){const n=h+e+x*t,o=h+e+x*(t+1),i=h+(e+1)+x*(t+1),r=h+(e+1)+x*t;a.push(n,o,r),a.push(o,i,r),S+=6}s.addGroup(f,S,p),f+=S,h+=M}d("z","y","x",-1,-1,n,e,t,r,i,0),d("z","y","x",1,-1,n,e,-t,r,i,1),d("x","z","y",1,1,t,n,e,o,r,2),d("x","z","y",1,-1,t,n,-e,o,r,3),d("x","y","z",1,-1,t,e,n,o,i,4),d("x","y","z",-1,-1,t,e,-n,o,i,5),this.setIndex(a),this.setAttribute("position",new Oo(new Float32Array(l),3)),this.setAttribute("normal",new Oo(new Float32Array(c),3)),this.setAttribute("uv",new Oo(new Float32Array(u),2))}}function Ai(t){const e={};for(const n in t){e[n]={};for(const o in t[n]){const i=t[n][o];i&&(i.isColor||i.isMatrix3||i.isMatrix4||i.isVector2||i.isVector3||i.isVector4||i.isTexture||i.isQuaternion)?e[n][o]=i.clone():Array.isArray(i)?e[n][o]=i.slice():e[n][o]=i}}return e}function vi(t){const e={};for(let n=0;n<t.length;n++){const o=Ai(t[n]);for(const t in o)e[t]=o[t]}return e}function mi(t){return null===t.getRenderTarget()&&t.outputEncoding===Ft?Qt:zt}const pi={clone:Ai,merge:vi};class gi extends Lo{constructor(t){super(),this.isShaderMaterial=!0,this.type="ShaderMaterial",this.defines={},this.uniforms={},this.uniformsGroups=[],this.customPrepTokens={},this.vertexShader="void main(){\ngl_Position=projectionMatrix*modelViewMatrix*vec4(position,1.0);\n}",this.fragmentShader="void main(){\ngl_FragColor=vec4(1.0,0.0,0.0,1.0);\n}",this.linewidth=1,this.wireframe=!1,this.wireframeLinewidth=1,this.fog=!1,this.lights=!1,this.clipping=!1,this.extensions={derivatives:!1,fragDepth:!1},this.defaultAttributeValues={color:[1,1,1],uv:[0,0],uv2:[0,0]},this.index0AttributeName=void 0,this.uniformsNeedUpdate=!1,this.glslVersion=null,void 0!==t&&this.setValues(t)}copy(t){return super.copy(t),this.fragmentShader=t.fragmentShader,this.vertexShader=t.vertexShader,this.uniforms=Ai(t.uniforms),this.uniformsGroups=function(t){const e=[];for(let n=0;n<t.length;n++)e.push(t[n].clone());return e}(t.uniformsGroups),this.defines=Object.assign({},t.defines),this.customPrepTokens=Object.assign({},t.customPrepTokens),this.wireframe=t.wireframe,this.wireframeLinewidth=t.wireframeLinewidth,this.fog=t.fog,this.lights=t.lights,this.clipping=t.clipping,this.extensions=Object.assign({},t.extensions),this.glslVersion=t.glslVersion,this}}class _i extends mo{constructor(){super(),this.isCamera=!0,this.type="Camera",this.matrixWorldInverse=new Hn,this.projectionMatrix=new Hn,this.projectionMatrixInverse=new Hn,this.controlSettings=null,this.viewportFit={type:0,initialAspect:1},this.ignoreShadowLayers=!1}get controls(){return console.warn("v3d.Camera.controls replaced by v3d.Camera.controlSettings"),this.controlSettings}set controls(t){console.warn("v3d.Camera.controls replaced by v3d.Camera.controlSettings"),this.controlSettings=t}copy(t,e){return super.copy(t,e),this.matrixWorldInverse.copy(t.matrixWorldInverse),this.projectionMatrix.copy(t.projectionMatrix),this.projectionMatrixInverse.copy(t.projectionMatrixInverse),t.controlSettings&&(this.controlSettings=t.controlSettings.clone()),this.viewportFit.type=t.viewportFit.type,this.viewportFit.initialAspect=t.viewportFit.initialAspect,this.ignoreShadowLayers=t.ignoreShadowLayers,this}getWorldDirection(t){this.updateWorldMatrix(!0,!1);const e=this.matrixWorld.elements;return t.set(-e[8],-e[9],-e[10]).normalize()}updateMatrixWorld(t){super.updateMatrixWorld(t),this.matrixWorldInverse.copy(this.matrixWorld).invert()}updateWorldMatrix(t,e){super.updateWorldMatrix(t,e),this.matrixWorldInverse.copy(this.matrixWorld).invert()}clone(t){return(new this.constructor).copy(this,t)}}class Ei extends _i{constructor(t=50,e=1,n=.1,o=2e3){super(),this.isPerspectiveCamera=!0,this.type="PerspectiveCamera",this.fov=t,this.zoom=1,this.near=n,this.far=o,this.focus=10,this.aspect=e,this.view=null,this.filmGauge=35,this.filmOffset=0,this.updateProjectionMatrix()}copy(t,e){return super.copy(t,e),this.fov=t.fov,this.zoom=t.zoom,this.near=t.near,this.far=t.far,this.focus=t.focus,this.aspect=t.aspect,this.view=null===t.view?null:Object.assign({},t.view),this.filmGauge=t.filmGauge,this.filmOffset=t.filmOffset,this}setFocalLength(t){const e=.5*this.getFilmHeight()/t;this.fov=2*$t*Math.atan(e),this.updateProjectionMatrix()}getFocalLength(){const t=Math.tan(.5*Jt*this.fov);return.5*this.getFilmHeight()/t}getEffectiveFOV(){return 2*$t*Math.atan(Math.tan(.5*Jt*this.fov)/this.zoom)}getFilmWidth(){return this.filmGauge*Math.min(this.aspect,1)}getFilmHeight(){return this.filmGauge/Math.max(this.aspect,1)}setViewOffset(t,e,n,o,i,r){this.aspect=t/e,null===this.view&&(this.view={enabled:!0,fullWidth:1,fullHeight:1,offsetX:0,offsetY:0,width:1,height:1}),this.view.enabled=!0,this.view.fullWidth=t,this.view.fullHeight=e,this.view.offsetX=n,this.view.offsetY=o,this.view.width=i,this.view.height=r,this.updateProjectionMatrix()}clearViewOffset(){null!==this.view&&(this.view.enabled=!1),this.updateProjectionMatrix()}updateProjectionMatrix(){const t=this.near;let e=t*Math.tan(.5*Jt*this.fov)/this.zoom,n=2*e,o=this.aspect*n,i=-.5*o;const r=this.view;if(null!==this.view&&this.view.enabled){const t=r.fullWidth,s=r.fullHeight;i+=r.offsetX*o/t,e-=r.offsetY*n/s,o*=r.width/t,n*=r.height/s}const s=this.filmOffset;0!==s&&(i+=t*s/this.getFilmWidth()),this.projectionMatrix.makePerspective(i,i+o,e,e-n,t,this.far),this.projectionMatrixInverse.copy(this.projectionMatrix).invert()}}const Ci=-90;class wi extends mo{constructor(t,e,n){super(),this.type="CubeCamera",this.renderTarget=n;const o=new Ei(Ci,1,t,e);o.layers=this.layers,o.up.set(0,1,0),o.lookAt(1,0,0),this.add(o);const i=new Ei(Ci,1,t,e);i.layers=this.layers,i.up.set(0,1,0),i.lookAt(-1,0,0),this.add(i);const r=new Ei(Ci,1,t,e);r.layers=this.layers,r.up.set(0,0,-1),r.lookAt(0,1,0),this.add(r);const s=new Ei(Ci,1,t,e);s.layers=this.layers,s.up.set(0,0,1),s.lookAt(0,-1,0),this.add(s);const a=new Ei(Ci,1,t,e);a.layers=this.layers,a.up.set(0,1,0),a.lookAt(0,0,1),this.add(a);const l=new Ei(Ci,1,t,e);l.layers=this.layers,l.up.set(0,1,0),l.lookAt(0,0,-1),this.add(l)}update(t,e){null===this.parent&&this.updateMatrixWorld();const n=this.renderTarget,[o,i,r,s,a,l]=this.children,c=t.getRenderTarget(),u=t.toneMapping,h=t.xr.enabled;t.toneMapping=0,t.xr.enabled=!1;const f=n.texture.generateMipmaps;n.texture.generateMipmaps=!1,t.setRenderTarget(n,0),t.render(e,o),t.setRenderTarget(n,1),t.render(e,i),t.setRenderTarget(n,2),t.render(e,r),t.setRenderTarget(n,3),t.render(e,s),t.setRenderTarget(n,4),t.render(e,a),n.texture.generateMipmaps=f,t.setRenderTarget(n,5),t.render(e,l),t.setRenderTarget(c),t.toneMapping=u,t.xr.enabled=h,n.texture.needsPMREMUpdate=!0}}class xi extends an{constructor(t,e,n,o,i,r,s,a,l,c){super(t=void 0!==t?t:[],e=void 0!==e?e:w,n,o,i,r,s,a,l,c),this.isCubeTexture=!0,this.flipY=!1}get images(){return this.source.data}set images(t){this.source.data=t}}class Ii extends cn{constructor(t=1,e={}){super(t,t,e),this.isWebGLCubeRenderTarget=!0;const n={width:t,height:t,depth:1},o=[n,n,n,n,n,n];this.texture=new xi(o,e.mapping,e.wrapS,e.wrapT,e.magFilter,e.minFilter,e.format,e.type,e.anisotropy,e.encoding),this.texture.isRenderTargetTexture=!0,this.texture.generateMipmaps=void 0!==e.generateMipmaps&&e.generateMipmaps,this.texture.minFilter=void 0!==e.minFilter?e.minFilter:N}fromEquirectangularTexture(t,e){this.texture.type=e.type,this.texture.encoding=e.encoding,this.texture.generateMipmaps=e.generateMipmaps,this.texture.minFilter=e.minFilter,this.texture.magFilter=e.magFilter;const n={uniforms:{tEquirect:{value:null}},vertexShader:"\n\n                varying vec3 vWorldDirection;\n\n                vec3 transformDirection(in vec3 dir, in mat4 matrix) {\n\n                    return normalize((matrix * vec4(dir, 0.0)).xyz);\n\n                }\n\n                void main() {\n\n                    vWorldDirection = transformDirection(position, modelMatrix);\n\n                    #include <begin_vertex>\n                    #include <project_vertex>\n\n                }\n            ",fragmentShader:"\n\n                uniform sampler2D tEquirect;\n\n                varying vec3 vWorldDirection;\n\n                #include <common>\n\n                void main() {\n\n                    vec3 direction = normalize(vWorldDirection);\n\n                    vec2 sampleUV = equirectUv(direction);\n\n                    gl_FragColor = texture2D(tEquirect, sampleUV);\n\n                }\n            "},o=new di(5,5,5),i=new gi({name:"CubemapFromEquirect",uniforms:Ai(n.uniforms),vertexShader:n.vertexShader,fragmentShader:n.fragmentShader,side:1,blending:0});i.uniforms.tEquirect.value=e;const r=new hi(o,i),s=e.minFilter;e.minFilter===P&&(e.minFilter=N);return new wi(1,10,this).update(t,r),e.minFilter=s,r.geometry.dispose(),r.material.dispose(),this}clear(t,e,n,o){const i=t.getRenderTarget();for(let i=0;i<6;i++)t.setRenderTarget(this,i),t.clear(e,n,o);t.setRenderTarget(i)}}const Mi={checkWebGL:function(){try{const t=document.createElement("canvas");return!(!window.WebGLRenderingContext||!t.getContext("webgl"))}catch(t){return!1}},checkWebGL2:function(){try{const t=document.createElement("canvas");return!(!window.WebGL2RenderingContext||!t.getContext("webgl2"))}catch(t){return!1}},checkWorkers:function(){return!!window.Worker},checkFileAPI:function(){return window.File&&window.FileReader&&window.FileList&&window.Blob},genWebGLErrorMessage:function(t){const e=document.createElement("div");e.setAttribute("class","v3d-webgl-error-container");const n=document.createElement("div");n.setAttribute("class","v3d-webgl-error-image"),e.appendChild(n);const o=document.createElement("div");return o.setAttribute("class","v3d-webgl-error"),o.innerHTML=t,e.appendChild(o),e},showWebGLErrorMessage:function(t,e){(t=t||document.body).appendChild(Mi.genWebGLErrorMessage(e));const n=document.getElementById("v3d_preloader_container");n&&(n.style.visibility="hidden")},checkIOS:function(){return(/iPad|iPhone|iPod/.test(navigator.platform)||"MacIntel"===navigator.platform&&navigator.maxTouchPoints>1)&&!window.MSStream},checkAndroid:function(){return!!navigator.userAgent.match(/Android/i)},checkSafari:function(){return/Safari/.test(navigator.userAgent)&&!/Chrome/.test(navigator.userAgent)},checkFloatTex:function(t,e){const n=t.getContext();return!(!t.capabilities.isWebGL2||!n.getExtension("EXT_color_buffer_float")||e&&!n.getExtension("OES_texture_float_linear"))||!(t.capabilities.isWebGL2||!n.getExtension("OES_texture_float")||e&&!n.getExtension("OES_texture_float_linear"))},checkHalfFloatTex:function(t,e){const n=t.getContext();return!(!t.capabilities.isWebGL2||!n.getExtension("EXT_color_buffer_float"))||!(t.capabilities.isWebGL2||!n.getExtension("OES_texture_half_float")||e&&!n.getExtension("OES_texture_half_float_linear"))},checkHalfFloatReadPixels:function(t){const e=t.getContext(),n=t.capabilities;return!/Firefox/.test(navigator.userAgent)&&!!(e.getExtension("EXT_color_buffer_half_float")||n.isWebGL2&&e.getExtension("EXT_color_buffer_float"))},checkFloatReadPixels:function(t){const e=t.getContext();return!!(t.capabilities.isWebGL2||e.getExtension("OES_texture_float")||e.getExtension("WEBGL_color_buffer_float"))},checkDepthTex:function(t){const e=t.getContext();return!(!t.capabilities.isWebGL2&&!e.getExtension("WEBGL_depth_texture"))},getGPUVendor:function(t){const e=t?t.getContext():document.createElement("canvas").getContext("webgl");if(/Firefox/.test(navigator.userAgent))return e.getParameter(7936);{const t=e.getExtension("WEBGL_debug_renderer_info");return null!=t?e.getParameter(t.UNMASKED_VENDOR_WEBGL):""}},getGPUModel:function(t){const e=t?t.getContext():document.createElement("canvas").getContext("webgl");if(/Firefox/.test(navigator.userAgent))return e.getParameter(7937);{const t=e.getExtension("WEBGL_debug_renderer_info");return null!=t?e.getParameter(t.UNMASKED_RENDERER_WEBGL):""}},checkWebXR:function(t,e,n){"xr"in navigator&&navigator.xr.isSessionSupported?navigator.xr.isSessionSupported(t).then(function(t){t?e():n()}).catch(n):n()},checkSwiftShader:function(t){return"Google SwiftShader"==this.getGPUModel(t)},checkWebAudio:function(){return void 0!==(window.AudioContext||window.webkitAudioContext)},isSafariWithMultisamplingBug:function(){const t=navigator.userAgent;return!(!this.checkSafari()&&!t.match("MicroMessenger"))&&(t.match("Version/15.4")||t.match(/CPU (OS|iPhone OS) (15_4|15_4_1|15_4_2|15_4_3) like Mac OS X/))},isSafariWithUint16Bug:function(){const t=navigator.userAgent;return!(!this.checkSafari()&&!t.match("MicroMessenger"))&&t.match(/CPU (OS|iPhone OS) (11_[0-9][0-9_]*|12_[0-9][0-9_]*) like Mac OS X/)},isTouchDevice:function(){return"ontouchstart"in window||navigator.maxTouchPoints>0||navigator.msMaxTouchPoints>0}},Si=new An,bi=new An,yi=new xe;class Ri{constructor(t=new An(1,0,0),e=0){this.isPlane=!0,this.normal=t,this.constant=e}set(t,e){return this.normal.copy(t),this.constant=e,this}setComponents(t,e,n,o){return this.normal.set(t,e,n),this.constant=o,this}setFromNormalAndCoplanarPoint(t,e){return this.normal.copy(t),this.constant=-e.dot(this.normal),this}setFromCoplanarPoints(t,e,n){const o=Si.subVectors(n,e).cross(bi.subVectors(t,e)).normalize();return this.setFromNormalAndCoplanarPoint(o,t),this}copy(t){return this.normal.copy(t.normal),this.constant=t.constant,this}normalize(){const t=1/this.normal.length();return this.normal.multiplyScalar(t),this.constant*=t,this}negate(){return this.constant*=-1,this.normal.negate(),this}distanceToPoint(t){return this.normal.dot(t)+this.constant}distanceToSphere(t){return this.distanceToPoint(t.center)-t.radius}projectPoint(t,e){return e.copy(this.normal).multiplyScalar(-this.distanceToPoint(t)).add(t)}intersectLine(t,e){const n=t.delta(Si),o=this.normal.dot(n);if(0===o)return 0===this.distanceToPoint(t.start)?e.copy(t.start):null;const i=-(t.start.dot(this.normal)+this.constant)/o;return i<0||i>1?null:e.copy(n).multiplyScalar(i).add(t.start)}intersectsLine(t){const e=this.distanceToPoint(t.start),n=this.distanceToPoint(t.end);return e<0&&n>0||n<0&&e>0}intersectsBox(t){return t.intersectsPlane(this)}intersectsSphere(t){return t.intersectsPlane(this)}coplanarPoint(t){return t.copy(this.normal).multiplyScalar(-this.constant)}applyMatrix4(t,e){const n=e||yi.getNormalMatrix(t),o=this.coplanarPoint(Si).applyMatrix4(t),i=this.normal.applyMatrix3(n).normalize();return this.constant=-o.dot(i),this}translate(t){return this.constant-=t.dot(this.normal),this}equals(t){return t.normal.equals(this.normal)&&t.constant===this.constant}clone(){return(new this.constructor).copy(this)}}const Ti=new Pn,Bi=new An;class Li{constructor(t=new Ri,e=new Ri,n=new Ri,o=new Ri,i=new Ri,r=new Ri){this.planes=[t,e,n,o,i,r]}set(t,e,n,o,i,r){const s=this.planes;return s[0].copy(t),s[1].copy(e),s[2].copy(n),s[3].copy(o),s[4].copy(i),s[5].copy(r),this}copy(t){const e=this.planes;for(let n=0;n<6;n++)e[n].copy(t.planes[n]);return this}setFromProjectionMatrix(t){const e=this.planes,n=t.elements,o=n[0],i=n[1],r=n[2],s=n[3],a=n[4],l=n[5],c=n[6],u=n[7],h=n[8],f=n[9],d=n[10],A=n[11],v=n[12],m=n[13],p=n[14],g=n[15];return e[0].setComponents(s-o,u-a,A-h,g-v).normalize(),e[1].setComponents(s+o,u+a,A+h,g+v).normalize(),e[2].setComponents(s+i,u+l,A+f,g+m).normalize(),e[3].setComponents(s-i,u-l,A-f,g-m).normalize(),e[4].setComponents(s-r,u-c,A-d,g-p).normalize(),e[5].setComponents(s+r,u+c,A+d,g+p).normalize(),this}intersectsObject(t){const e=t.geometry;return null===e.boundingSphere&&e.computeBoundingSphere(),Ti.copy(e.boundingSphere).applyMatrix4(t.matrixWorld),this.intersectsSphere(Ti)}intersectsSprite(t){return Ti.center.set(0,0,0),Ti.radius=.7071067811865476,Ti.applyMatrix4(t.matrixWorld),this.intersectsSphere(Ti)}intersectsSphere(t){const e=this.planes,n=t.center,o=-t.radius;for(let t=0;t<6;t++){if(e[t].distanceToPoint(n)<o)return!1}return!0}intersectsBox(t){const e=this.planes;for(let n=0;n<6;n++){const o=e[n];if(Bi.x=o.normal.x>0?t.max.x:t.min.x,Bi.y=o.normal.y>0?t.max.y:t.min.y,Bi.z=o.normal.z>0?t.max.z:t.min.z,o.distanceToPoint(Bi)<0)return!1}return!0}containsPoint(t){const e=this.planes;for(let n=0;n<6;n++)if(e[n].distanceToPoint(t)<0)return!1;return!0}clone(){return(new this.constructor).copy(this)}}class Ni extends mo{constructor(){super(),this.isScene=!0,this.type="Scene",this.background=null,this.environment=null,this.fog=null,this.backgroundBlurriness=0,this.backgroundIntensity=1,this.overrideMaterial=null,this.backgroundToneMapped=!0,this.postprocessing=[],this.worldMaterial=null,this.worldEnvMapProbe=null,ke("observe",this)}copy(t,e){return super.copy(t,e),null!==t.background&&(this.background=t.background.clone()),null!==t.environment&&(this.environment=t.environment.clone()),null!==t.fog&&(this.fog=t.fog.clone()),this.backgroundBlurriness=t.backgroundBlurriness,this.backgroundIntensity=t.backgroundIntensity,this.backgroundToneMapped=t.backgroundToneMapped,null!==t.overrideMaterial&&(this.overrideMaterial=t.overrideMaterial.clone()),this.matrixAutoUpdate=t.matrixAutoUpdate,this}dispose(){this.dispatchEvent({type:"dispose"})}}function Di(){let t=null,e=!1,n=null,o=null;function i(e,r){n(e,r),o=t.requestAnimationFrame(i)}return{start:function(){!0!==e&&null!==n&&(o=t.requestAnimationFrame(i),e=!0)},stop:function(){t.cancelAnimationFrame(o),e=!1},setAnimationLoop:function(t){n=t},setContext:function(e){t=e}}}function Pi(t,e){const n=e.isWebGL2;let o=new WeakMap;return{get:function(t){return o.get(t)},remove:function(e){const n=o.get(e);n&&(t.deleteBuffer(n.buffer),o.delete(e))},update:function(e,i){if(e.isGLBufferAttribute){const t=o.get(e);return void((!t||t.version<e.version)&&o.set(e,{buffer:e.buffer,type:e.type,bytesPerElement:e.elementSize,version:e.version}))}const r=o.get(e);void 0===r?o.set(e,function(e,o){const i=e.array,r=e.usage,s=t.createBuffer();let a;if(t.bindBuffer(o,s),t.bufferData(o,i,r),e.onUploadCallback(),i instanceof Float32Array)a=5126;else if(i instanceof Uint16Array)if(e.isFloat16BufferAttribute){if(!n)throw new Error("v3d.WebGLAttributes: Usage of Float16BufferAttribute requires WebGL2.");a=5131}else a=5123;else if(i instanceof Int16Array)a=5122;else if(i instanceof Uint32Array)a=5125;else if(i instanceof Int32Array)a=5124;else if(i instanceof Int8Array)a=5120;else if(i instanceof Uint8Array)a=5121;else{if(!(i instanceof Uint8ClampedArray))throw new Error("v3d.WebGLAttributes: Unsupported buffer data format: "+i);a=5121}return{buffer:s,type:a,bytesPerElement:i.BYTES_PER_ELEMENT,version:e.version}}(e,i)):r.version<e.version&&(!function(e,o,i){const r=o.array,s=o.updateRange;t.bindBuffer(i,e),-1===s.count?t.bufferSubData(i,0,r):(n?t.bufferSubData(i,s.offset*r.BYTES_PER_ELEMENT,r,s.offset,s.count):t.bufferSubData(i,s.offset*r.BYTES_PER_ELEMENT,r.subarray(s.offset,s.offset+s.count)),s.count=-1),o.onUploadCallback()}(r.buffer,e,i),r.version=e.version)},dispose:function(){o=new WeakMap}}}class Oi extends Xo{constructor(t=1,e=1,n=1,o=1){super(),this.type="PlaneGeometry",this.parameters={width:t,height:e,widthSegments:n,heightSegments:o};const i=t/2,r=e/2,s=Math.floor(n),a=Math.floor(o),l=s+1,c=a+1,u=t/s,h=e/a,f=[],d=[],A=[],v=[];for(let t=0;t<c;t++){const e=t*h-r;for(let n=0;n<l;n++){const o=n*u-i;d.push(o,-e,0),A.push(0,0,1),v.push(n/s),v.push(1-t/a)}}for(let t=0;t<a;t++)for(let e=0;e<s;e++){const n=e+l*t,o=e+l*(t+1),i=e+1+l*(t+1),r=e+1+l*t;f.push(n,o,r),f.push(o,i,r)}this.setIndex(f),this.setAttribute("position",new Oo(new Float32Array(d),3)),this.setAttribute("normal",new Oo(new Float32Array(A),3)),this.setAttribute("uv",new Oo(new Float32Array(v),2))}}const Fi={alphamap_fragment:"#ifdef USE_ALPHAMAP\ndiffuseColor.a*=texture2D(alphaMap,vUv).g;\n#endif",alphamap_pars_fragment:"#ifdef USE_ALPHAMAP\nuniform sampler2D alphaMap;\n#endif",alphatest_fragment:"#ifdef USE_ALPHATEST\nif (diffuseColor.a<alphaTest)\ndiscard;\nelse\ndiffuseColor.a=1.0;\n#endif",alphatest_pars_fragment:"#ifdef USE_ALPHATEST\nuniform float alphaTest;\n#endif",aomap_fragment:"#ifdef USE_AOMAP\nfloat ambientOcclusion=(texture2D(aoMap,vUv2).r-1.0)*aoMapIntensity+1.0;\nreflectedLight.indirectDiffuse*=ambientOcclusion;\n#if defined(USE_ENVMAP)&&defined(STANDARD)\nfloat dotNV=saturate(dot(geometry.normal,geometry.viewDir));\nreflectedLight.indirectSpecular*=computeSpecularOcclusion(dotNV,ambientOcclusion,material.roughness);\n#endif\n#endif",aomap_pars_fragment:"#ifdef USE_AOMAP\nuniform sampler2D aoMap;\nuniform float aoMapIntensity;\n#endif",begin_vertex:"vec3 transformed=vec3(position);",beginnormal_vertex:"vec3 objectNormal=vec3(normal);\n#ifdef USE_TANGENT\nvec3 objectTangent=vec3(tangent.xyz);\n#endif",bsdfs:"vec3 BRDF_Lambert(const in vec3 diffuseColor){\nreturn RECIPROCAL_PI*diffuseColor;\n}\nvec3 F_Schlick(const in vec3 f0,const in float f90,const in float dotVH){\nfloat fresnel=exp2((-5.55473*dotVH-6.98316)*dotVH);\nreturn f0*(1.0-fresnel)+(f90*fresnel);\n}\nfloat V_GGX_SmithCorrelated(const in float alpha,const in float dotNL,const in float dotNV){\nfloat a2=pow2(alpha);\nfloat gv=dotNL*sqrt(a2+(1.0-a2)*pow2(dotNV));\nfloat gl=dotNV*sqrt(a2+(1.0-a2)*pow2(dotNL));\nreturn 0.5/max(gv+gl,EPSILON);\n}\nfloat D_GGX(const in float alpha,const in float dotNH){\nfloat a2=pow2(alpha);\nfloat denom=pow2(dotNH)*(a2-1.0)+1.0;\nreturn RECIPROCAL_PI*a2/pow2(denom);\n}\nvec3 BRDF_GGX(const in vec3 lightDir,const in vec3 viewDir,const in vec3 normal,const in vec3 f0,const in float f90,const in float roughness){\nfloat alpha=pow2(clamp(roughness,0.04,1.0));\nvec3 halfDir=normalize(lightDir+viewDir);\nfloat dotNL=saturate(dot(normal,lightDir));\nfloat dotNV=saturate(dot(normal,viewDir));\nfloat dotNH=saturate(dot(normal,halfDir));\nfloat dotVH=saturate(dot(viewDir,halfDir));\nvec3 F=F_Schlick(f0,f90,dotVH);\nfloat V=V_GGX_SmithCorrelated(alpha,dotNL,dotNV);\nfloat D=D_GGX(alpha,dotNH);\nreturn F*(V*D);\n}\nvec2 LTC_Uv(const in vec3 N,const in vec3 V,const in float roughness){\nconst float LUT_SIZE=64.0;\nconst float LUT_SCALE=(LUT_SIZE-1.0)/LUT_SIZE;\nconst float LUT_BIAS=0.5/LUT_SIZE;\nfloat dotNV=saturate(dot(N,V));\nvec2 uv=vec2(roughness,sqrt(1.0-dotNV));\nuv=uv*LUT_SCALE+LUT_BIAS;\nreturn uv;\n}\nfloat LTC_ClippedSphereFormFactor(const in vec3 f){\nfloat l=length(f);\nreturn max((l*l+f.z)/(l+1.0),0.0);\n}\nvec3 LTC_EdgeVectorFormFactor(const in vec3 v1,const in vec3 v2){\nfloat x=dot(v1,v2);\nfloat y=abs(x);\nfloat a=0.8543985+(0.4965155+0.0145206*y)*y;\nfloat b=3.4175940+(4.1616724+y)*y;\nfloat v=a/b;\nfloat theta_sintheta=(x>0.0)?v:0.5*inversesqrt(max(1.0-x*x,1e-7))-v;\nreturn cross(v1,v2)*theta_sintheta;\n}\nvec3 LTC_Evaluate(const in vec3 N,const in vec3 V,const in vec3 P,const in mat3 mInv,const in vec3 rectCoords[4]){\nvec3 v1=rectCoords[1]-rectCoords[0];\nvec3 v2=rectCoords[3]-rectCoords[0];\nvec3 lightNormal=cross(v1,v2);\nif(dot(lightNormal,P-rectCoords[0])<0.0)return vec3(0.0);\nvec3 T1,T2;\nT1=normalize(V-N*dot(V,N));\nT2=-cross(N,T1);\nmat3 mat=mInv*transposeMat3(mat3(T1,T2,N));\nvec3 coords[4];\ncoords[0]=mat*(rectCoords[0]-P);\ncoords[1]=mat*(rectCoords[1]-P);\ncoords[2]=mat*(rectCoords[2]-P);\ncoords[3]=mat*(rectCoords[3]-P);\ncoords[0]=normalize(coords[0]);\ncoords[1]=normalize(coords[1]);\ncoords[2]=normalize(coords[2]);\ncoords[3]=normalize(coords[3]);\nvec3 vectorFormFactor=vec3(0.0);\nvectorFormFactor+=LTC_EdgeVectorFormFactor(coords[0],coords[1]);\nvectorFormFactor+=LTC_EdgeVectorFormFactor(coords[1],coords[2]);\nvectorFormFactor+=LTC_EdgeVectorFormFactor(coords[2],coords[3]);\nvectorFormFactor+=LTC_EdgeVectorFormFactor(coords[3],coords[0]);\nfloat result=LTC_ClippedSphereFormFactor(vectorFormFactor);\nreturn vec3(result);\n}\nvec2 integrateSpecularBRDF(const in float dotNV,const in float roughness){\nconst vec4 c0=vec4(-1,-0.0275,-0.572,0.022);\nconst vec4 c1=vec4(1,0.0425,1.04,-0.04);\nvec4 r=roughness*c0+c1;\nfloat a004=min(r.x*r.x,exp2(-9.28*dotNV))*r.x+r.y;\nreturn vec2(-1.04,1.04)*a004+r.zw;\n}\nvec3 BRDF_Specular_GGX_Environment(const in vec3 viewDir,const in vec3 normal,const in vec3 specularColor,const in vec3 specularColor90,const in float roughness){\nfloat dotNV=saturate(dot(normal,viewDir));\nvec2 brdf=integrateSpecularBRDF(dotNV,roughness);\nreturn specularColor*brdf.x+specularColor90*brdf.y;\n}\n#if defined(USE_SHEEN)\nfloat D_Charlie(float roughness,float dotNH){\nfloat alpha=pow2(roughness);\nfloat invAlpha=1.0/alpha;\nfloat cos2h=dotNH*dotNH;\nfloat sin2h=max(1.0-cos2h,0.0078125);\nreturn (2.0+invAlpha)*pow(sin2h,invAlpha*0.5)/(2.0*PI);\n}\nfloat V_Neubelt(float dotNV,float dotNL){\nreturn saturate(1.0/(4.0*(dotNL+dotNV-dotNL*dotNV)));\n}\nvec3 BRDF_Sheen(const in vec3 lightDir,const in vec3 viewDir,const in vec3 normal,vec3 sheenColor,const in float sheenRoughness){\nvec3 halfDir=normalize(lightDir+viewDir);\nfloat dotNL=saturate(dot(normal,lightDir));\nfloat dotNV=saturate(dot(normal,viewDir));\nfloat dotNH=saturate(dot(normal,halfDir));\nfloat D=D_Charlie(sheenRoughness,dotNH);\nfloat V=V_Neubelt(dotNV,dotNL);\nreturn sheenColor*(D*V);\n}\n#endif",bumpmap_pars_fragment:"#ifdef USE_BUMPMAP\nuniform sampler2D bumpMap;\nuniform float bumpScale;\nvec2 dHdxy_fwd(){\nvec2 dSTdx=dFdx(vUv);\nvec2 dSTdy=dFdy(vUv);\nfloat Hll=bumpScale*texture2D(bumpMap,vUv).x;\nfloat dBx=bumpScale*texture2D(bumpMap,vUv+dSTdx).x-Hll;\nfloat dBy=bumpScale*texture2D(bumpMap,vUv+dSTdy).x-Hll;\nreturn vec2(dBx,dBy);\n}\nvec3 perturbNormalArb(vec3 surf_pos,vec3 surf_norm,vec2 dHdxy,float faceDirection){\nvec3 vSigmaX=dFdx(surf_pos.xyz);\nvec3 vSigmaY=dFdy(surf_pos.xyz);\nvec3 vN=surf_norm;\nvec3 R1=cross(vSigmaY,vN);\nvec3 R2=cross(vN,vSigmaX);\nfloat fDet=dot(vSigmaX,R1)*faceDirection;\nvec3 vGrad=sign(fDet)*(dHdxy.x*R1+dHdxy.y*R2);\nreturn normalize(abs(fDet)*surf_norm-vGrad);\n}\n#endif",clipping_planes_fragment:"#if NUM_CLIPPING_PLANES>0\nvec4 plane;\n#pragma unroll_loop\nfor (int i=0;i<UNION_CLIPPING_PLANES;i++){\nplane=clippingPlanes[i];\nif (dot(vClipPosition,plane.xyz)>plane.w)discard;\n}\n#if UNION_CLIPPING_PLANES<NUM_CLIPPING_PLANES\nbool clipped=true;\n#pragma unroll_loop\nfor (int i=UNION_CLIPPING_PLANES;i<NUM_CLIPPING_PLANES;i++){\nplane=clippingPlanes[i];\nclipped=(dot(vClipPosition,plane.xyz)>plane.w)&&clipped;\n}\nif (clipped)discard;\n#endif\n#endif",clipping_planes_pars_fragment:"#if NUM_CLIPPING_PLANES>0\nvarying vec3 vClipPosition;\nuniform vec4 clippingPlanes[NUM_CLIPPING_PLANES];\n#endif",clipping_planes_pars_vertex:"#if NUM_CLIPPING_PLANES>0\nvarying vec3 vClipPosition;\n#endif",clipping_planes_vertex:"#if NUM_CLIPPING_PLANES>0\nvClipPosition=-mvPosition.xyz;\n#endif",color_fragment:"#if defined(USE_COLOR_ALPHA)\ndiffuseColor*=vColor;\n#elif defined(USE_COLOR)\ndiffuseColor.rgb*=vColor;\n#endif",color_pars_fragment:"#if defined(USE_COLOR_ALPHA)\nvarying vec4 vColor;\n#elif defined(USE_COLOR)\nvarying vec3 vColor;\n#endif",color_pars_vertex:"#if defined(USE_COLOR_ALPHA)\nvarying vec4 vColor;\n#elif defined(USE_COLOR)||defined(USE_INSTANCING_COLOR)\nvarying vec3 vColor;\n#endif",color_vertex:"#if defined(USE_COLOR_ALPHA)\nvColor=vec4(1.0);\n#elif defined(USE_COLOR)||defined(USE_INSTANCING_COLOR)\nvColor=vec3(1.0);\n#endif\n#ifdef USE_COLOR\nvColor*=color;\n#endif\n#ifdef USE_INSTANCING_COLOR\nvColor.xyz*=instanceColor.xyz;\n#endif",common:"#define PI 3.141592653589793\n#define PI2 6.283185307179586\n#define PI_HALF 1.5707963267948966\n#define RECIPROCAL_PI 0.3183098861837907\n#define RECIPROCAL_PI2 0.15915494309189535\n#define EPSILON 1e-6\n#ifndef saturate\n#define saturate(a)clamp(a,0.0,1.0)\n#endif\nfloat pow2(const in float x){return x*x;}\nvec3 pow2(const in vec3 x){return x*x;}\nfloat pow3(const in float x){return x*x*x;}\nfloat pow4(const in float x){float x2=x*x;return x2*x2;}\nfloat max3(const in vec3 v){return max(max(v.x,v.y),v.z);}\nfloat average(const in vec3 v){return dot(v,vec3(0.3333333));}\nhighp float rand(const in vec2 uv){\nconst highp float a=12.9898,b=78.233,c=43758.5453;\nhighp float dt=dot(uv.xy,vec2(a,b)),sn=mod(dt,PI);\nreturn fract(sin(sn)*c);\n}\nstruct IncidentLight {\nvec3 color;\nvec3 direction;\nbool visible;\n};\nstruct ReflectedLight {\nvec3 directDiffuse;\nvec3 directSpecular;\nvec3 indirectDiffuse;\nvec3 indirectSpecular;\n};\nstruct GeometricContext {\nvec3 position;\nvec3 normal;\nvec3 viewDir;\nvec3 probeNormal;\n#ifdef USE_CLEARCOAT\nvec3 clearcoatNormal;\n#endif\n};\nvec3 transformDirection(in vec3 dir,in mat4 matrix){\nreturn normalize((matrix*vec4(dir,0.0)).xyz);\n}\nvec3 inverseTransformDirection(in vec3 dir,in mat4 matrix){\nreturn normalize((vec4(dir,0.0)*matrix).xyz);\n}\nmat3 transposeMat3(const in mat3 m){\nmat3 tmp;\ntmp[0]=vec3(m[0].x,m[1].x,m[2].x);\ntmp[1]=vec3(m[0].y,m[1].y,m[2].y);\ntmp[2]=vec3(m[0].z,m[1].z,m[2].z);\nreturn tmp;\n}\nfloat linearToRelativeLuminance(const in vec3 color){\nconst vec3 weights=vec3(0.2126729,0.7151522,0.0721750);\nreturn dot(weights,color.rgb);\n}\nbool isPerspectiveMatrix(mat4 m){\nreturn m[2][3]==-1.0;\n}\nvec2 equirectUv(in vec3 dir){\nfloat u=atan(dir.z,dir.x)*RECIPROCAL_PI2+0.5;\nfloat v=asin(clamp(dir.y,-1.0,1.0))*RECIPROCAL_PI+0.5;\nreturn vec2(u,v);\n}\nvec3 octUVToCubeVec(vec2 octUV,vec2 texelSize){\noctUV=(1.0+2.0*texelSize)*octUV-texelSize;\noctUV=octUV*2.0-1.0;\nfloat x=octUV.x;\nfloat z=-octUV.y;\nfloat absX=abs(x);\nfloat absZ=abs(z);\nvec3 cubeVec=vec3(x,1.0-absX-absZ,z);\nif (absX+absZ>1.0){\ncubeVec.xz=-(vec2(absZ,absX)-1.0)*sign(vec2(x,z));\n}\nreturn cubeVec;\n}\nvec2 cubeVecToOctUV(vec3 cubeVec,vec2 texelSize){\ncubeVec/=dot(vec3(1.0),abs(cubeVec));\nvec2 octUV=vec2(cubeVec.x,-cubeVec.z);\nif (cubeVec.y<0.0){\noctUV=sign(octUV)*(1.0-abs(octUV.ts));\n}\noctUV=(octUV+1.0)/2.0;\noctUV=(1.0-2.0*texelSize)*octUV+texelSize;\nreturn octUV;\n}\nvec3 vec3RotateAxisAngle(vec3 vector,vec3 axis,float angle){\nvec3 axisNorm=normalize(axis);\nfloat x=axisNorm.x,y=axisNorm.y,z=axisNorm.z;\nfloat s=sin(angle),c=cos(angle);\nreturn mat3(x*x*(1.0-c)+c,x*y*(1.0-c)+z*s,x*z*(1.0-c)-y*s,x*y*(1.0-c)-z*s,y*y*(1.0-c)+c,y*z*(1.0-c)+x*s,x*z*(1.0-c)+y*s,y*z*(1.0-c)-x*s,z*z*(1.0-c)+c\n)*vector;\n}",cube_uv_reflection_fragment:"#ifdef ENVMAP_TYPE_CUBE_UV\nfloat getFace(vec3 direction){\nvec3 absDirection=abs(direction);\nfloat face=-1.0;\nif (absDirection.x>absDirection.z){\nif (absDirection.x>absDirection.y){\nface=direction.x>0.0?0.0:3.0;\n} else {\nface=direction.y>0.0?1.0:4.0;\n}\n} else {\nif (absDirection.z>absDirection.y){\nface=direction.z>0.0?2.0:5.0;\n} else {\nface=direction.y>0.0?1.0:4.0;\n}\n}\nreturn face;\n}\nvec2 getUV(vec3 direction,float face){\nvec2 uv;\nif (face==0.0){\nuv=vec2(-direction.z,direction.y)/abs(direction.x);\n} else if (face==1.0){\nuv=vec2(direction.x,-direction.z)/abs(direction.y);\n} else if (face==2.0){\nuv=direction.xy/abs(direction.z);\n} else if (face==3.0){\nuv=vec2(direction.z,direction.y)/abs(direction.x);\n} else if (face==4.0){\nuv=direction.xz/abs(direction.y);\n} else {\nuv=vec2(-direction.x,direction.y)/abs(direction.z);\n}\nreturn 0.5*(uv+1.0);\n}\n#ifndef cubeUV_maxTileSize\n#define cubeUV_maxTileSize 256.0\n#endif\n#define cubeUV_lodIdxMin 0.0\n#define cubeUV_lodIdxLastDownscaled 4.0\n#define cubeUV_lodIdxMax 10.0\n#define cubeUV_minTileSize (cubeUV_maxTileSize/exp2(cubeUV_lodIdxLastDownscaled))\nfloat getLodTileSize(float lodIdx){\nreturn cubeUV_maxTileSize/exp2(min(lodIdx,cubeUV_lodIdxLastDownscaled));\n}\nfloat getLodFilterLevel(float lodIdx){\nreturn max(lodIdx-cubeUV_lodIdxLastDownscaled,0.0);\n}\nvec2 fixCubeUVSeams(vec2 uv,float faceSize){\nfloat BORDER_WIDTH_PX=max(cubeUV_maxTileSize/256.0-1.0,0.0);\nfloat scale=(faceSize-BORDER_WIDTH_PX)/faceSize;\nfloat offset=0.5*BORDER_WIDTH_PX/faceSize;\nreturn uv*scale+offset;\n}\nvec2 getUVPixels(vec3 direction,float lodIdx){\nfloat face=getFace(direction);\nfloat faceSize=getLodTileSize(lodIdx);\nfloat filterLevel=getLodFilterLevel(lodIdx);\nvec2 uv=getUV(direction,face);\nuv=fixCubeUVSeams(uv,faceSize);\nuv*=(faceSize-1.0);\nif (face>2.0){\nuv.y+=faceSize;\nface-=3.0;\n}\nuv.x+=face*faceSize;\nif (lodIdx>0.0){\nuv.y+=2.0*cubeUV_maxTileSize;\n}\nuv.y+=filterLevel*2.0*cubeUV_minTileSize;\nuv.x+=3.0*max(0.0,cubeUV_maxTileSize-2.0*faceSize);\nreturn uv;\n}\nvec3 bilinearCubeUV(sampler2D envMap,vec3 direction,float lodIdx){\nfloat texelSize=1.0/(3.0*cubeUV_maxTileSize);\nvec2 uv=getUVPixels(direction,lodIdx);\nvec2 f=fract(uv);\nuv+=0.5-f;\nuv*=texelSize;\nvec3 tl=texture2D(envMap,uv).rgb;\nuv.x+=texelSize;\nvec3 tr=texture2D(envMap,uv).rgb;\nuv.y+=texelSize;\nvec3 br=texture2D(envMap,uv).rgb;\nuv.x-=texelSize;\nvec3 bl=texture2D(envMap,uv).rgb;\nvec3 tm=mix(tl,tr,f.x);\nvec3 bm=mix(bl,br,f.x);\nreturn mix(tm,bm,f.y);\n}\nvec3 sampleCubeUV(sampler2D envMap,vec3 direction,float lodIdx){\nfloat texelSize=1.0/(3.0*cubeUV_maxTileSize);\nvec2 uv=getUVPixels(direction,lodIdx);\nuv+=0.5;\nuv*=texelSize;\nreturn texture2D(envMap,uv).rgb;\n}\nfloat roughnessToMip(float roughness){\nfloat r=roughness;\nfloat r2=r*r;\nfloat r3=r2*r;\nroughness=-1.20278049*r3+1.86860137*r2+0.32478081*r+0.0098139;\nreturn roughness*(cubeUV_lodIdxMax-cubeUV_lodIdxMin);\n}\nvec4 textureCubeUV(sampler2D envMap,vec3 sampleDir,float roughness){\nfloat lodIdx=clamp(roughnessToMip(roughness),cubeUV_lodIdxMin,cubeUV_lodIdxMax);\nfloat lodIdxF=fract(lodIdx);\nfloat lodIdxI=floor(lodIdx);\nvec3 color0=sampleCubeUV(envMap,sampleDir,lodIdxI);\nif (lodIdxF==0.0){\nreturn vec4(color0,1.0);\n} else {\nvec3 color1=sampleCubeUV(envMap,sampleDir,lodIdxI+1.0);\nreturn vec4(mix(color0,color1,lodIdxF),1.0);\n}\n}\n#endif",defaultnormal_vertex:"vec3 transformedNormal=objectNormal;\n#ifdef USE_INSTANCING\nmat3 m=mat3(instanceMatrix);\ntransformedNormal/=vec3(dot(m[0],m[0]),dot(m[1],m[1]),dot(m[2],m[2]));\ntransformedNormal=m*transformedNormal;\n#endif\ntransformedNormal=normalMatrix*transformedNormal;\n#ifdef FLIP_SIDED\ntransformedNormal=-transformedNormal;\n#endif\n#ifdef USE_TANGENT\nvec3 transformedTangent=(modelViewMatrix*vec4(objectTangent,0.0)).xyz;\n#ifdef FLIP_SIDED\ntransformedTangent=-transformedTangent;\n#endif\n#endif",displacementmap_pars_vertex:"#ifdef USE_DISPLACEMENTMAP\nuniform sampler2D displacementMap;\nuniform float displacementScale;\nuniform float displacementBias;\n#endif",displacementmap_vertex:"#ifdef USE_DISPLACEMENTMAP\ntransformed+=normalize(objectNormal)*(texture2D(displacementMap,vUv).x*displacementScale+displacementBias);\n#endif",emissivemap_fragment:"#ifdef USE_EMISSIVEMAP\nvec4 emissiveColor=texture2D(emissiveMap,vUv);\ntotalEmissiveRadiance*=emissiveColor.rgb;\n#endif",emissivemap_pars_fragment:"#ifdef USE_EMISSIVEMAP\nuniform sampler2D emissiveMap;\n#endif",encodings_fragment:"gl_FragColor=linearToOutputTexel(gl_FragColor);",encodings_pars_fragment:"vec4 LinearToLinear(in vec4 value){\nreturn value;\n}\nvec4 LinearTosRGB(in vec4 value){\nreturn vec4(mix(pow(value.rgb,vec3(0.41666))*1.055-vec3(0.055),value.rgb*12.92,vec3(lessThanEqual(value.rgb,vec3(0.0031308)))),value.a);\n}",envmap_fragment:"#ifdef USE_ENVMAP\n#ifdef ENV_WORLDPOS\nvec3 cameraToFrag;\nif (isOrthographic){\ncameraToFrag=normalize(vec3(-viewMatrix[0][2],-viewMatrix[1][2],-viewMatrix[2][2]));\n} else {\ncameraToFrag=normalize(vWorldPosition-cameraPosition);\n}\nvec3 worldNormal=inverseTransformDirection(normal,viewMatrix);\n#ifdef ENVMAP_MODE_REFLECTION\nvec3 reflectVec=reflect(cameraToFrag,worldNormal);\n#else\nvec3 reflectVec=refract(cameraToFrag,worldNormal,refractionRatio);\n#endif\n#else\nvec3 reflectVec=vReflect;\n#endif\n#ifdef ENVMAP_TYPE_CUBE\nvec4 envColor=textureCube(envMap,vec3(flipEnvMap*reflectVec.x,reflectVec.yz));\n#else\nvec4 envColor=vec4(0.0);\n#endif\n#ifdef ENVMAP_BLENDING_MULTIPLY\noutgoingLight=mix(outgoingLight,outgoingLight*envColor.xyz,reflectivity);\n#elif defined(ENVMAP_BLENDING_MIX)\noutgoingLight=mix(outgoingLight,envColor.xyz,reflectivity);\n#elif defined(ENVMAP_BLENDING_ADD)\noutgoingLight+=envColor.xyz*reflectivity;\n#endif\n#endif",envmap_common_pars_fragment:"#ifdef USE_ENVMAP\nuniform float envMapIntensity;\nuniform float flipEnvMap;\n#ifdef ENVMAP_TYPE_CUBE\nuniform samplerCube envMap;\n#else\nuniform sampler2D envMap;\n#endif\n#if defined(ENVMAP_TYPE_CUBE)&&defined(NODE)||defined(ENVMAP_TYPE_CUBE_UV)\nfloat calcGeometryRoughness(vec3 geometryNormal){\nvec3 dxy=max(abs(dFdx(geometryNormal)),abs(dFdy(geometryNormal)));\nreturn max(max(dxy.x,dxy.y),dxy.z);\n}\nfloat calcCubeUVAdjustedRoughness(float origRoughness,float geomRoughness){\nreturn min(max(origRoughness,0.0525)+geomRoughness,1.0);\n}\n#endif\n#endif",envmap_pars_fragment:"#ifdef USE_ENVMAP\nuniform float reflectivity;\n#if defined(USE_BUMPMAP)||defined(USE_NORMALMAP)||defined(LAMBERT)\n#define ENV_WORLDPOS\n#endif\n#ifdef ENV_WORLDPOS\nvarying vec3 vWorldPosition;\nuniform float refractionRatio;\n#else\nvarying vec3 vReflect;\n#endif\n#endif",envmap_pars_vertex:"#ifdef USE_ENVMAP\n#if defined(USE_BUMPMAP)||defined(USE_NORMALMAP)||defined(LAMBERT)\n#define ENV_WORLDPOS\n#endif\n#ifdef ENV_WORLDPOS\nvarying vec3 vWorldPosition;\n#else\nvarying vec3 vReflect;\nuniform float refractionRatio;\n#endif\n#endif",envmap_physical_pars_fragment:"#if defined(USE_ENVMAP)\n#define ENVMAP_PARALLAX_INFINITE 0\n#define ENVMAP_PARALLAX_SPHERE 1\n#define ENVMAP_PARALLAX_BOX 2\nuniform int envMapParallaxType;\nuniform mat4 envMapParallaxMatrix;\nuniform mat4 envMapParallaxMatrixInv;\nvec3 correctParallax(vec3 directionVecWorld,vec3 posWorld,int parallaxType){\nvec3 posProbe=(envMapParallaxMatrix*vec4(posWorld,1.0)).xyz;\nvec3 reflectVecProbe=transformDirection(directionVecWorld,envMapParallaxMatrix);\nif (parallaxType==ENVMAP_PARALLAX_SPHERE){\nfloat b=2.0*dot(reflectVecProbe,posProbe);\nfloat c=dot(posProbe,posProbe)-1.0;\nfloat D=b*b-4.0*c;\nif (D>=0.0){\nfloat x=(sqrt(D)-b)/2.0;\nreflectVecProbe=posProbe+x*reflectVecProbe;\n}\n} else if (parallaxType==ENVMAP_PARALLAX_BOX){\nvec3 scalePos=(vec3(1.0)-posProbe)/reflectVecProbe;\nvec3 scaleNeg=(vec3(-1.0)-posProbe)/reflectVecProbe;\nvec3 scalePosNeg=mix(scaleNeg,scalePos,step(vec3(0.0),reflectVecProbe));\nfloat x=min(scalePosNeg.x,min(scalePosNeg.y,scalePosNeg.z));\nreflectVecProbe=posProbe+x*reflectVecProbe;\n}\nvec3 directionVecWorldCorrected=transformDirection(reflectVecProbe,envMapParallaxMatrixInv);\nreturn directionVecWorldCorrected;\n}\nvec3 getIBLIrradiance(const in vec3 normal){\n#if defined(ENVMAP_TYPE_CUBE_UV)\nvec3 worldNormal=inverseTransformDirection(normal,viewMatrix);\nvec4 envMapColor=textureCubeUV(envMap,worldNormal,1.0);\nreturn PI*envMapColor.rgb*envMapIntensity;\n#else\nreturn vec3(0.0);\n#endif\n}\nvec3 getIBLRadiance(const in vec3 viewDir,const in vec3 normal,const in float roughness,vec3 position){\n#if defined(ENVMAP_TYPE_CUBE_UV)\nvec3 reflectVec=reflect(-viewDir,normal);\nreflectVec=inverseTransformDirection(reflectVec,viewMatrix);\nif (envMapParallaxType != ENVMAP_PARALLAX_INFINITE){\nvec3 posWorld=(invViewMatrix*vec4(position,1.0)).xyz;\nreflectVec=correctParallax(reflectVec,posWorld,envMapParallaxType);\n}\nvec4 envMapColor=textureCubeUV(envMap,reflectVec,roughness);\nreturn envMapColor.rgb*envMapIntensity;\n#else\nreturn vec3(0.0);\n#endif\n}\nvec3 getIBLRefraction(const in vec3 viewDir,const in vec3 normal,const in float roughness,const float refrRatio,vec3 position){\n#if defined(ENVMAP_TYPE_CUBE_UV)\nvec3 refractVec=refract(-viewDir,normal,refrRatio);\nrefractVec=inverseTransformDirection(refractVec,viewMatrix);\nif (envMapParallaxType != ENVMAP_PARALLAX_INFINITE){\nvec3 posWorld=(invViewMatrix*vec4(position,1.0)).xyz;\nrefractVec=correctParallax(refractVec,posWorld,envMapParallaxType);\n}\nvec4 envMapColor=textureCubeUV(envMap,refractVec,roughness);\nreturn envMapColor.rgb*envMapIntensity;\n#else\nreturn vec3(0.0);\n#endif\n}\n#endif",envmap_vertex:"#ifdef USE_ENVMAP\n#ifdef ENV_WORLDPOS\nvWorldPosition=worldPosition.xyz;\n#else\nvec3 cameraToVertex;\nif (isOrthographic){\ncameraToVertex=normalize(vec3(-viewMatrix[0][2],-viewMatrix[1][2],-viewMatrix[2][2]));\n} else {\ncameraToVertex=normalize(worldPosition.xyz-cameraPosition);\n}\nvec3 worldNormal=inverseTransformDirection(transformedNormal,viewMatrix);\n#ifdef ENVMAP_MODE_REFLECTION\nvReflect=reflect(cameraToVertex,worldNormal);\n#else\nvReflect=refract(cameraToVertex,worldNormal,refractionRatio);\n#endif\n#endif\n#endif",fog_vertex:"#ifdef USE_FOG\nvFogDepth=-mvPosition.z;\n#endif",fog_pars_vertex:"#ifdef USE_FOG\nvarying float vFogDepth;\n#endif",fog_fragment:"#ifdef USE_FOG\n#ifdef FOG_EXP2\nfloat fogFactor=1.0-exp(-fogDensity*fogDensity*vFogDepth*vFogDepth);\n#else\nfloat fogFactor=smoothstep(fogNear,fogFar,vFogDepth);\n#endif\ngl_FragColor.rgb=mix(gl_FragColor.rgb,fogColor,fogFactor);\n#endif",fog_pars_fragment:"#ifdef USE_FOG\nuniform vec3 fogColor;\nvarying float vFogDepth;\n#ifdef FOG_EXP2\nuniform float fogDensity;\n#else\nuniform float fogNear;\nuniform float fogFar;\n#endif\n#endif",lightmap_fragment:"#ifdef USE_LIGHTMAP\nvec4 lightMapTexel=texture2D(lightMap,vUv2);\nvec3 lightMapIrradiance=lightMapTexel.rgb*lightMapIntensity;\nreflectedLight.indirectDiffuse+=lightMapIrradiance;\n#endif",lightmap_pars_fragment:"#ifdef USE_LIGHTMAP\nuniform sampler2D lightMap;\nuniform float lightMapIntensity;\n#endif",lights_lambert_fragment:"LambertMaterial material;\nmaterial.diffuseColor=diffuseColor.rgb;",lights_lambert_pars_fragment:"varying vec3 vViewPosition;\nstruct LambertMaterial {\nvec3 diffuseColor;\n};\nvoid RE_Direct_Lambert(const in IncidentLight directLight,const in GeometricContext geometry,const in LambertMaterial material,inout ReflectedLight reflectedLight){\nfloat dotNL=saturate(dot(geometry.normal,directLight.direction));\nvec3 irradiance=dotNL*directLight.color;\nreflectedLight.directDiffuse+=irradiance*BRDF_Lambert(material.diffuseColor);\n}\nvoid RE_IndirectDiffuse_Lambert(const in vec3 irradiance,const in GeometricContext geometry,const in LambertMaterial material,inout ReflectedLight reflectedLight){\nreflectedLight.indirectDiffuse+=irradiance*BRDF_Lambert(material.diffuseColor);\n}\n#define RE_Direct RE_Direct_Lambert\n#define RE_IndirectDiffuse RE_IndirectDiffuse_Lambert",lights_pars_begin:"uniform bool receiveShadow;\nuniform vec3 ambientLightColor;\nuniform vec3 lightProbe[9];\nvec3 shGetIrradianceAt(in vec3 normal,in vec3 shCoefficients[9]){\nfloat x=normal.x,y=normal.y,z=normal.z;\nvec3 result=shCoefficients[0]*0.886227;\nresult+=shCoefficients[1]*2.0*0.511664*y;\nresult+=shCoefficients[2]*2.0*0.511664*z;\nresult+=shCoefficients[3]*2.0*0.511664*x;\nresult+=shCoefficients[4]*2.0*0.429043*x*y;\nresult+=shCoefficients[5]*2.0*0.429043*y*z;\nresult+=shCoefficients[6]*(0.743125*z*z-0.247708);\nresult+=shCoefficients[7]*2.0*0.429043*x*z;\nresult+=shCoefficients[8]*0.429043*(x*x-y*y);\nreturn result;\n}\nvec3 getLightProbeIrradiance(const in vec3 lightProbe[9],const in vec3 normal){\nvec3 worldNormal=inverseTransformDirection(normal,viewMatrix);\nvec3 irradiance=shGetIrradianceAt(worldNormal,lightProbe);\nreturn irradiance;\n}\nvec3 getAmbientLightIrradiance(const in vec3 ambientLightColor){\nvec3 irradiance=ambientLightColor;\nreturn irradiance;\n}\nfloat getDistanceAttenuation(float lightDistance,const in float cutoffDistance,const in float decayExponent){\nlightDistance=UNITS_SCALE_FACTOR*lightDistance;\n#ifdef MT_MAYA\nfloat distanceFalloff=1.0/pow(lightDistance+1.0,decayExponent);\n#else\nfloat distanceFalloff=1.0/max(pow(lightDistance,decayExponent),0.01);\n#endif\nif (cutoffDistance>0.0){\ndistanceFalloff*=pow2(saturate(1.0-pow4(lightDistance/(UNITS_SCALE_FACTOR*cutoffDistance))));\n}\nreturn distanceFalloff;\n}\nfloat getSpotAttenuation(const in float coneCosine,const in float penumbraCosine,const in float angleCosine){\nreturn smoothstep(coneCosine,penumbraCosine,angleCosine);\n}\n#if NUM_DIR_LIGHTS>0\nstruct DirectionalLight {\nvec3 direction;\nvec3 color;\n};\nuniform DirectionalLight directionalLights[NUM_DIR_LIGHTS];\nvoid getDirectionalLightInfo(const in DirectionalLight directionalLight,const in GeometricContext geometry,out IncidentLight light){\nlight.color=directionalLight.color;\nlight.direction=directionalLight.direction;\nlight.visible=true;\n}\n#endif\n#if NUM_POINT_LIGHTS>0\nstruct PointLight {\nvec3 position;\nvec3 color;\nfloat distance;\nfloat decay;\n};\nuniform PointLight pointLights[NUM_POINT_LIGHTS];\nvoid getPointLightInfo(const in PointLight pointLight,const in GeometricContext geometry,out IncidentLight light){\nvec3 lVector=pointLight.position-geometry.position;\nlight.direction=normalize(lVector);\nfloat lightDistance=length(lVector);\nlight.color=pointLight.color;\nlight.color*=getDistanceAttenuation(lightDistance,pointLight.distance,pointLight.decay);\nlight.visible=(light.color != vec3(0.0));\n}\n#endif\n#if NUM_SPOT_LIGHTS>0\nstruct SpotLight {\nvec3 position;\nvec3 direction;\nvec3 color;\nfloat distance;\nfloat decay;\nfloat coneCos;\nfloat penumbraCos;\n};\nuniform SpotLight spotLights[NUM_SPOT_LIGHTS];\nvoid getSpotLightInfo(const in SpotLight spotLight,const in GeometricContext geometry,out IncidentLight light){\nvec3 lVector=spotLight.position-geometry.position;\nlight.direction=normalize(lVector);\nfloat angleCos=dot(light.direction,spotLight.direction);\n#if defined(MT_MAX)\nfloat coneCosDecayed=2.0*spotLight.coneCos-spotLight.penumbraCos;\nif (angleCos>coneCosDecayed){\nfloat spotAttenuation=pow(max(angleCos,0.0),log(0.5)/log(spotLight.penumbraCos)-1.0);\nif (angleCos<spotLight.coneCos){\nfloat decayFac=1.0+(spotLight.coneCos-angleCos)\n/ (spotLight.coneCos-spotLight.penumbraCos);\nspotAttenuation*=pow2(decayFac)*(3.0-2.0*decayFac);\n}\nfloat lightDistance=length(lVector);\nlight.color=spotLight.color*spotAttenuation;\nlight.color*=getDistanceAttenuation(lightDistance,spotLight.distance,spotLight.decay);\nlight.visible=true;\n} else {\nlight.color=vec3(0.0);\nlight.visible=false;\n}\n#else\nfloat spotAttenuation=getSpotAttenuation(spotLight.coneCos,spotLight.penumbraCos,angleCos);\nif (spotAttenuation>0.0){\nfloat lightDistance=length(lVector);\nlight.color=spotLight.color*spotAttenuation;\nlight.color*=getDistanceAttenuation(lightDistance,spotLight.distance,spotLight.decay);\nlight.visible=true;\n} else {\nlight.color=vec3(0.0);\nlight.visible=false;\n}\n#endif\n}\n#endif\n#if NUM_RECT_AREA_LIGHTS>0\nstruct RectAreaLight {\nvec3 color;\nvec3 position;\nvec3 halfWidth;\nvec3 halfHeight;\n};\nuniform sampler2D ltc_1;\nuniform sampler2D ltc_2;\nuniform RectAreaLight rectAreaLights[NUM_RECT_AREA_LIGHTS];\n#endif",lights_physical_fragment:"PhysicalMaterial material;\nmaterial.diffuseColor=diffuseColor.rgb*(1.0-metalnessFactor);\nvec3 dxy=max(abs(dFdx(geometryNormal)),abs(dFdy(geometryNormal)));\nfloat geometryRoughness=max(max(dxy.x,dxy.y),dxy.z);\nmaterial.roughness=max(roughnessFactor,0.0525);\nmaterial.roughness+=geometryRoughness;\nmaterial.roughness=min(material.roughness,1.0);\nmaterial.specularColor=mix(vec3(0.04),diffuseColor.rgb,metalnessFactor);\nmaterial.specularF90=1.0;",lights_physical_pars_fragment:"struct PhysicalMaterial {\nvec3 diffuseColor;\nfloat roughness;\nvec3 specularColor;\nfloat specularF90;\n};\nvec2 DFGApprox(const in vec3 normal,const in vec3 viewDir,const in float roughness){\nfloat dotNV=saturate(dot(normal,viewDir));\nconst vec4 c0=vec4(- 1,-0.0275,-0.572,0.022);\nconst vec4 c1=vec4(1,0.0425,1.04,-0.04);\nvec4 r=roughness*c0+c1;\nfloat a004=min(r.x*r.x,exp2(- 9.28*dotNV))*r.x+r.y;\nvec2 fab=vec2(- 1.04,1.04)*a004+r.zw;\nreturn fab;\n}\nvec3 EnvironmentBRDF(const in vec3 normal,const in vec3 viewDir,const in vec3 specularColor,const in float specularF90,const in float roughness){\nvec2 fab=DFGApprox(normal,viewDir,roughness);\nreturn specularColor*fab.x+specularF90*fab.y;\n}\nvoid computeMultiscattering(const in vec3 normal,const in vec3 viewDir,const in vec3 specularColor,const in float specularF90,const in float roughness,inout vec3 singleScatter,inout vec3 multiScatter){\nvec2 fab=DFGApprox(normal,viewDir,roughness);\nvec3 Fr=specularColor;\nvec3 FssEss=Fr*fab.x+specularF90*fab.y;\nfloat Ess=fab.x+fab.y;\nfloat Ems=1.0-Ess;\nvec3 Favg=Fr+(1.0-Fr)*0.047619;\nvec3 Fms=FssEss*Favg/(1.0-Ems*Favg);\nsingleScatter+=FssEss;\nmultiScatter+=Fms*Ems;\n}\n#if NUM_RECT_AREA_LIGHTS>0\nvoid RE_Direct_RectArea_Physical(const in RectAreaLight rectAreaLight,const in GeometricContext geometry,const in PhysicalMaterial material,inout ReflectedLight reflectedLight){\nvec3 normal=geometry.normal;\nvec3 viewDir=geometry.viewDir;\nvec3 position=geometry.position;\nvec3 lightPos=rectAreaLight.position;\nvec3 halfWidth=rectAreaLight.halfWidth;\nvec3 halfHeight=rectAreaLight.halfHeight;\nvec3 lightColor=rectAreaLight.color;\nfloat roughness=material.roughness;\nvec3 rectCoords[4];\nrectCoords[0]=lightPos+halfWidth-halfHeight;\nrectCoords[1]=lightPos-halfWidth-halfHeight;\nrectCoords[2]=lightPos-halfWidth+halfHeight;\nrectCoords[3]=lightPos+halfWidth+halfHeight;\nvec2 uv=LTC_Uv(normal,viewDir,roughness);\nvec4 t1=texture2D(ltc_1,uv);\nvec4 t2=texture2D(ltc_2,uv);\nmat3 mInv=mat3(vec3(t1.x,0,t1.y),vec3( 0,1,0),vec3(t1.z,0,t1.w)\n);\nvec3 fresnel=(material.specularColor*t2.x+(vec3(1.0)-material.specularColor)*t2.y);\nreflectedLight.directSpecular+=lightColor*fresnel*LTC_Evaluate(normal,viewDir,position,mInv,rectCoords);\nreflectedLight.directDiffuse+=lightColor*material.diffuseColor*LTC_Evaluate(normal,viewDir,position,mat3(1.0),rectCoords);\n}\n#endif\nvoid RE_Direct_Physical(const in IncidentLight directLight,const in GeometricContext geometry,const in PhysicalMaterial material,inout ReflectedLight reflectedLight){\nfloat dotNL=saturate(dot(geometry.normal,directLight.direction));\nvec3 irradiance=dotNL*directLight.color;\nreflectedLight.directSpecular+=irradiance*BRDF_GGX(directLight.direction,geometry.viewDir,geometry.normal,material.specularColor,material.specularF90,material.roughness);\nreflectedLight.directDiffuse+=irradiance*BRDF_Lambert(material.diffuseColor);\n}\nvoid RE_IndirectDiffuse_Physical(const in vec3 irradiance,const in GeometricContext geometry,const in PhysicalMaterial material,inout ReflectedLight reflectedLight){\nreflectedLight.indirectDiffuse+=irradiance*BRDF_Lambert(material.diffuseColor);\n}\nvoid RE_IndirectSpecular_Physical(const in vec3 radiance,const in vec3 irradiance,const in vec3 clearcoatRadiance,const in GeometricContext geometry,const in PhysicalMaterial material,inout ReflectedLight reflectedLight){\nvec3 singleScattering=vec3(0.0);\nvec3 multiScattering=vec3(0.0);\nvec3 cosineWeightedIrradiance=irradiance*RECIPROCAL_PI;\ncomputeMultiscattering(geometry.normal,geometry.viewDir,material.specularColor,material.specularF90,material.roughness,singleScattering,multiScattering);\nvec3 totalScattering=singleScattering+multiScattering;\nvec3 diffuse=material.diffuseColor*(1.0-max(max(totalScattering.r,totalScattering.g),totalScattering.b));\nreflectedLight.indirectSpecular+=radiance*singleScattering;\nreflectedLight.indirectSpecular+=multiScattering*cosineWeightedIrradiance;\nreflectedLight.indirectDiffuse+=diffuse*cosineWeightedIrradiance;\n}\n#define RE_Direct RE_Direct_Physical\n#define RE_Direct_RectArea RE_Direct_RectArea_Physical\n#define RE_IndirectDiffuse RE_IndirectDiffuse_Physical\n#define RE_IndirectSpecular RE_IndirectSpecular_Physical\nfloat computeSpecularOcclusion(const in float dotNV,const in float ambientOcclusion,const in float roughness){\nreturn saturate(pow(abs(dotNV+ambientOcclusion),exp2(- 16.0*roughness-1.0))-1.0+ambientOcclusion);\n}",lights_fragment_begin:"\nGeometricContext geometry;\ngeometry.position=-vViewPosition;\ngeometry.normal=normal;\ngeometry.viewDir=(isOrthographic)?vec3(0,0,1):normalize(vViewPosition);\n#ifdef USE_CLEARCOAT\ngeometry.clearcoatNormal=clearcoatNormal;\n#endif\n#ifdef PROBE_NORMAL\ngeometry.probeNormal=PROBE_NORMAL;\n#else\ngeometry.probeNormal=normal;\n#endif\nIncidentLight directLight;\n#if (NUM_POINT_LIGHTS>0)&&defined(RE_Direct)\nPointLight pointLight;\n#if defined(USE_SHADOWMAP)&&NUM_POINT_LIGHT_SHADOWS>0\nPointLightShadow pointLightShadow;\n#endif\n#pragma unroll_loop\nfor (int i=0;i<NUM_POINT_LIGHTS;i++){\npointLight=pointLights[i];\ngetPointLightInfo(pointLight,geometry,directLight);\n#if defined(USE_SHADOWMAP)&&((i)<NUM_POINT_LIGHT_SHADOWS)\npointLightShadow=pointLightShadows[i];\ndirectLight.color*=(directLight.visible&&receiveShadow)?getPointShadow(pointLightShadow,pointShadowMap[i],vPointShadowCoord[i]):1.0;\n#endif\nRE_Direct(directLight,geometry,material,reflectedLight);\n}\n#endif\n#if (NUM_SPOT_LIGHTS>0)&&defined(RE_Direct)\nSpotLight spotLight;\n#if defined(USE_SHADOWMAP)&&NUM_SPOT_LIGHT_SHADOWS>0\nSpotLightShadow spotLightShadow;\n#endif\n#pragma unroll_loop\nfor (int i=0;i<NUM_SPOT_LIGHTS;i++){\nspotLight=spotLights[i];\ngetSpotLightInfo(spotLight,geometry,directLight);\n#if defined(USE_SHADOWMAP)&&((i)<NUM_SPOT_LIGHT_SHADOWS)\nspotLightShadow=spotLightShadows[i];\nif (directLight.visible&&receiveShadow){\nif (spotLightShadow.shadow==1){\nfloat distWorld=0.0;\n#if defined(SHADOWMAP_TYPE_ESM)\ndistWorld=length((invViewMatrix*vec4(spotLight.position\n- geometry.position,0.0)).xyz);\n#endif\ndirectLight.color*=getSpotShadow(spotLightShadow,spotShadowMap[i],vSpotShadowCoord[i],distWorld);\n} else if (spotLightShadow.shadow==2){\ndirectLight.color*=getSpotOmniShadow(spotLightShadow,spotShadowMap[i],vSpotShadowCoord[i]);\n}\n}\n#endif\nRE_Direct(directLight,geometry,material,reflectedLight);\n}\n#endif\n#if (NUM_DIR_LIGHTS>0)&&defined(RE_Direct)\nDirectionalLight directionalLight;\n#if defined(USE_SHADOWMAP)&&NUM_DIR_LIGHT_SHADOWS_CSM>0\nDirectionalLightShadowCSM directionalLightShadowCSM;\nDirectionalLightShadowCascade dirShadowCascade;\nvec2 cascade;\nfloat cascadeCenter;\nfloat closestEdge;\nfloat margin;\nfloat csmx,csmy;\nfloat linearDepth;\nint maxCascadeIdx;\n#pragma unroll_loop\nfor (int i=0;i<NUM_DIR_LIGHT_SHADOW_CASCADES_CSM;i++){\ndirShadowCascade=directionalLightShadowsCSMCascade[i];\n#if defined(LUT_DIR_LIGHT_SHADOWS_CSM)\ndirectionalLightShadowCSM=directionalLightShadowsCSM[LUT_DIR_LIGHT_SHADOWS_CSM[i]];\ndirectionalLight=directionalLights[LUT_DIR_LIGHT_SHADOWS_CSM[i]];\ngetDirectionalLightInfo(directionalLight,geometry,directLight);\n#else\nif (dirShadowCascade.csmIdx==0){\ndirectionalLightShadowCSM=directionalLightShadowsCSM[0];\ndirectionalLight=directionalLights[0];\ngetDirectionalLightInfo(directionalLight,geometry,directLight);\n}\n#if NUM_DIR_LIGHT_SHADOWS_CSM>=2\nelse if (dirShadowCascade.csmIdx==1){\ndirectionalLightShadowCSM=directionalLightShadowsCSM[1];\ndirectionalLight=directionalLights[1];\ngetDirectionalLightInfo(directionalLight,geometry,directLight);\n}\n#endif\n#if NUM_DIR_LIGHT_SHADOWS_CSM>=3\nelse if (dirShadowCascade.csmIdx==2){\ndirectionalLightShadowCSM=directionalLightShadowsCSM[2];\ndirectionalLight=directionalLights[2];\ngetDirectionalLightInfo(directionalLight,geometry,directLight);\n}\n#endif\n#if NUM_DIR_LIGHT_SHADOWS_CSM>=4\nelse if (dirShadowCascade.csmIdx==3){\ndirectionalLightShadowCSM=directionalLightShadowsCSM[3];\ndirectionalLight=directionalLights[3];\ngetDirectionalLightInfo(directionalLight,geometry,directLight);\n}\n#endif\n#if NUM_DIR_LIGHT_SHADOWS_CSM>=5\nelse if (dirShadowCascade.csmIdx==4){\ndirectionalLightShadowCSM=directionalLightShadowsCSM[4];\ndirectionalLight=directionalLights[4];\ngetDirectionalLightInfo(directionalLight,geometry,directLight);\n}\n#endif\n#endif\nmaxCascadeIdx=directionalLightShadowCSM.cascadeIdxEnd;\nlinearDepth=(vViewPosition.z)/(directionalLightShadowCSM.shadowFar-directionalLightShadowCSM.cameraNear);\ncascade=dirShadowCascade.cascade;\n#if (i)<NUM_DIR_LIGHT_SHADOWS_CSM_WITH_FADE\ncascadeCenter=(cascade.x+cascade.y)/2.0;\nclosestEdge=linearDepth<cascadeCenter?cascade.x:cascade.y;\nmargin=directionalLightShadowCSM.fade*pow(closestEdge,2.0);\ncsmx=cascade.x-margin/2.0;\ncsmy=cascade.y+margin/2.0;\nif (linearDepth>=csmx&&(linearDepth<csmy||(i)==maxCascadeIdx-1)){\nfloat dist=min(linearDepth-csmx,csmy-linearDepth);\nfloat ratio=clamp(dist/margin,0.0,1.0);\nvec3 prevColor=directLight.color;\nfloat distWorld=0.0;\n#if defined(SHADOWMAP_TYPE_ESM)\ndistWorld=length((invViewMatrix*vec4(dirShadowCascade.position\n- directionalLight.direction*dirShadowCascade.shadowCameraNear\n- geometry.position,0.0)).xyz);\n#endif\ndirectLight.color*=(directLight.visible&&receiveShadow)?\ngetDirShadowCSM(dirShadowCascade,directionalShadowCSMMap[i],vDirectionalShadowCSMCoord[i],distWorld)\n: 1.0;\nbool shouldFadeLastCascade=(i)==maxCascadeIdx-1&&linearDepth>cascadeCenter;\ndirectLight.color=mix(prevColor,directLight.color,shouldFadeLastCascade?ratio:1.0);\nReflectedLight prevLight=reflectedLight;\nRE_Direct(directLight,geometry,material,reflectedLight);\nbool shouldBlend=(i)!= maxCascadeIdx-1||((i)==maxCascadeIdx-1&&linearDepth<cascadeCenter);\nfloat blendRatio=shouldBlend?ratio:1.0;\nreflectedLight.directDiffuse=mix(prevLight.directDiffuse,reflectedLight.directDiffuse,blendRatio);\nreflectedLight.directSpecular=mix(prevLight.directSpecular,reflectedLight.directSpecular,blendRatio);\nreflectedLight.indirectDiffuse=mix(prevLight.indirectDiffuse,reflectedLight.indirectDiffuse,blendRatio);\nreflectedLight.indirectSpecular=mix(prevLight.indirectSpecular,reflectedLight.indirectSpecular,blendRatio);\n}\n#else\nif (linearDepth>=cascade.x&&(linearDepth<cascade.y||(i)==maxCascadeIdx-1)){\nif (directLight.visible&&receiveShadow){\nfloat distWorld=0.0;\n#if defined(SHADOWMAP_TYPE_ESM)\ndistWorld=length((invViewMatrix*vec4(dirShadowCascade.position\n- directionalLight.direction*dirShadowCascade.shadowCameraNear\n- geometry.position,0.0)).xyz);\n#endif\ndirectLight.color*=getDirShadowCSM(dirShadowCascade,directionalShadowCSMMap[i],vDirectionalShadowCSMCoord[i],distWorld);\n}\nRE_Direct(directLight,geometry,material,reflectedLight);\n}\n#endif\n}\n#endif\n#pragma unroll_loop\nfor (int i=NUM_DIR_LIGHT_SHADOWS_CSM;i<NUM_DIR_LIGHTS;i++){\ndirectionalLight=directionalLights[i];\ngetDirectionalLightInfo(directionalLight,geometry,directLight);\nRE_Direct(directLight,geometry,material,reflectedLight);\n}\n#endif\n#if (NUM_RECT_AREA_LIGHTS>0)&&defined(RE_Direct_RectArea)\nRectAreaLight rectAreaLight;\n#if defined(USE_SHADOWMAP)&&NUM_RECT_AREA_LIGHT_SHADOWS>0\nRectAreaLightShadow rectAreaLightShadow;\n#endif\n#pragma unroll_loop\nfor (int i=0;i<NUM_RECT_AREA_LIGHTS;i++){\nrectAreaLight=rectAreaLights[i];\n#if defined(USE_SHADOWMAP)&&((i)<NUM_RECT_AREA_LIGHT_SHADOWS)\nrectAreaLightShadow=rectAreaLightShadows[i];\nrectAreaLight.color*=receiveShadow ?\ngetRectAreaShadow(rectAreaLightShadow,rectAreaShadowMap[i],vRectAreaShadowCoord[i]):1.0;\n#endif\nRE_Direct_RectArea(rectAreaLight,geometry,material,reflectedLight);\n}\n#endif\n#if defined(RE_IndirectDiffuse)\nvec3 iblIrradiance=vec3(0.0);\nvec3 irradiance=getAmbientLightIrradiance(ambientLightColor);\nirradiance+=getLightProbeIrradiance(lightProbe,geometry.probeNormal);\n#endif\n#if defined(RE_IndirectSpecular)\nvec3 radiance=vec3(0.0);\nvec3 clearcoatRadiance=vec3(0.0);\n#endif\n#if defined(RE_Refraction)\nvec3 refraction=vec3(0.0);\n#endif",lights_fragment_maps:"#if defined(RE_IndirectDiffuse)\n#ifdef USE_LIGHTMAP\nvec4 lightMapTexel=texture2D(lightMap,vUv2);\nvec3 lightMapIrradiance=lightMapTexel.rgb*lightMapIntensity;\nirradiance+=lightMapIrradiance;\n#endif\n#if defined(USE_ENVMAP)&&(defined(STANDARD)||defined(NODE))&&defined(ENVMAP_TYPE_CUBE_UV)\niblIrradiance+=getIBLIrradiance(geometry.probeNormal);\n#endif\n#endif\n#if defined(USE_ENVMAP)&&defined(RE_IndirectSpecular)\nradiance+=getIBLRadiance(geometry.viewDir,geometry.normal,material.roughness,geometry.position);\n#if defined(USE_SSR)&&!defined(USE_SSR_REFRACT)\nradiance=computeSSR(radiance,geometry.normal,0.0);\n#endif\n#if defined(USE_PLANE_REFLECTION)\nradiance=computePlaneReflection(radiance,material.roughness,geometry.position,geometry.normal,modelMatrix);\n#endif\n#ifdef USE_CLEARCOAT\nclearcoatRadiance+=getIBLRadiance(geometry.viewDir,geometry.clearcoatNormal,material.clearcoatRoughness,geometry.position);\n#endif\n#endif\n#if defined(USE_ENVMAP)&&defined(RE_Refraction)\nrefraction+=getIBLRefraction(geometry.viewDir,geometry.normal,material.refractionRoughness,1.0/material.refractionIOR,geometry.position);\n#ifdef USE_SSR_REFRACT\nrefraction=computeSSR(refraction,geometry.normal,material.refractionIOR);\n#endif\n#endif",lights_fragment_end:"#if defined(RE_IndirectDiffuse)\n#ifdef NODE\nirradiance+=iblIrradiance;\n#endif\nRE_IndirectDiffuse(irradiance,geometry,material,reflectedLight);\n#endif\n#if defined(RE_IndirectSpecular)\nRE_IndirectSpecular(radiance,iblIrradiance,clearcoatRadiance,geometry,material,reflectedLight);\n#endif\n#if defined(RE_Refraction)\nRE_Refraction(refraction,material,refractedLight);\n#endif",logdepthbuf_fragment:"#if defined(USE_LOGDEPTHBUF)&&defined(USE_LOGDEPTHBUF_EXT)\ngl_FragDepthEXT=vIsPerspective==0.0?gl_FragCoord.z:log2(vFragDepth)*logDepthBufFC*0.5;\n#endif",logdepthbuf_pars_fragment:"#if defined(USE_LOGDEPTHBUF)&&defined(USE_LOGDEPTHBUF_EXT)\nuniform float logDepthBufFC;\nvarying float vFragDepth;\nvarying float vIsPerspective;\n#endif",logdepthbuf_pars_vertex:"#ifdef USE_LOGDEPTHBUF\n#ifdef USE_LOGDEPTHBUF_EXT\nvarying float vFragDepth;\nvarying float vIsPerspective;\n#else\nuniform float logDepthBufFC;\n#endif\n#endif",logdepthbuf_vertex:"#ifdef USE_LOGDEPTHBUF\n#ifdef USE_LOGDEPTHBUF_EXT\nvFragDepth=1.0+gl_Position.w;\nvIsPerspective=float(isPerspectiveMatrix(projectionMatrix));\n#else\nif (isPerspectiveMatrix(projectionMatrix)){\ngl_Position.z=log2(max(EPSILON,gl_Position.w+1.0))*logDepthBufFC-1.0;\ngl_Position.z*=gl_Position.w;\n}\n#endif\n#endif",map_fragment:"#ifdef USE_MAP\nvec4 sampledDiffuseColor=texture2D(map,vUv);\n#ifdef DECODE_VIDEO_TEXTURE\nsampledDiffuseColor=vec4(mix(pow(sampledDiffuseColor.rgb*0.9478672986+vec3(0.0521327014),vec3(2.4)),sampledDiffuseColor.rgb*0.0773993808,vec3(lessThanEqual(sampledDiffuseColor.rgb,vec3(0.04045)))),sampledDiffuseColor.w);\n#endif\ndiffuseColor*=sampledDiffuseColor;\n#endif",map_pars_fragment:"#ifdef USE_MAP\nuniform sampler2D map;\n#endif",map_particle_fragment:"#if defined(USE_MAP)||defined(USE_ALPHAMAP)\nvec2 uv=(uvTransform*vec3(gl_PointCoord.x,1.0-gl_PointCoord.y,1)).xy;\n#endif\n#ifdef USE_MAP\ndiffuseColor*=texture2D(map,uv);\n#endif\n#ifdef USE_ALPHAMAP\ndiffuseColor.a*=texture2D(alphaMap,uv).g;\n#endif",map_particle_pars_fragment:"#if defined(USE_MAP)||defined(USE_ALPHAMAP)\nuniform mat3 uvTransform;\n#endif\n#ifdef USE_MAP\nuniform sampler2D map;\n#endif\n#ifdef USE_ALPHAMAP\nuniform sampler2D alphaMap;\n#endif",metalnessmap_fragment:"float metalnessFactor=metalness;\n#ifdef USE_METALNESSMAP\nvec4 texelMetalness=texture2D(metalnessMap,vUv);\nmetalnessFactor*=texelMetalness.b;\n#endif",metalnessmap_pars_fragment:"#ifdef USE_METALNESSMAP\nuniform sampler2D metalnessMap;\n#endif",morphnormal_vertex:"#ifdef USE_MORPHNORMALS\nobjectNormal*=morphTargetBaseInfluence;\n#ifdef MORPHTARGETS_TEXTURE\nfor (int i=0;i<MORPHTARGETS_COUNT;i++){\nif (morphTargetInfluences[i] != 0.0)objectNormal+=getMorph(gl_VertexID,i,1).xyz*morphTargetInfluences[i];\n}\n#else\n#if MORPHTARGETS_COUNT>0\nobjectNormal+=morphNormal0*morphTargetInfluences[0];\n#endif\n#if MORPHTARGETS_COUNT>1\nobjectNormal+=morphNormal1*morphTargetInfluences[1];\n#endif\n#if MORPHTARGETS_COUNT>2\nobjectNormal+=morphNormal2*morphTargetInfluences[2];\n#endif\n#if MORPHTARGETS_COUNT>3\nobjectNormal+=morphNormal3*morphTargetInfluences[3];\n#endif\n#if MORPHTARGETS_COUNT>4\nobjectNormal+=morphNormal4*morphTargetInfluences[4];\n#endif\n#if MORPHTARGETS_COUNT>5\nobjectNormal+=morphNormal5*morphTargetInfluences[5];\n#endif\n#endif\n#endif",morphtarget_pars_vertex:"#ifdef USE_MORPHTARGETS\nuniform float morphTargetBaseInfluence;\n#ifdef MORPHTARGETS_TEXTURE\nuniform float morphTargetInfluences[MORPHTARGETS_COUNT];\nuniform sampler2DArray morphTargetsTexture;\nuniform ivec2 morphTargetsTextureSize;\nvec4 getMorph(const in int vertexIndex,const in int morphTargetIndex,const in int offset){\nint texelIndex=vertexIndex*MORPHTARGETS_TEXTURE_STRIDE+offset;\nint y=texelIndex/morphTargetsTextureSize.x;\nint x=texelIndex-y*morphTargetsTextureSize.x;\nivec3 morphUV=ivec3(x,y,morphTargetIndex);\nreturn texelFetch(morphTargetsTexture,morphUV,0);\n}\n#else\n#ifndef USE_MORPHNORMALS\nuniform float morphTargetInfluences[12];\n#else\nuniform float morphTargetInfluences[6];\n#endif\n#endif\n#endif",morphtarget_vertex:"#ifdef USE_MORPHTARGETS\ntransformed*=morphTargetBaseInfluence;\n#ifdef MORPHTARGETS_TEXTURE\nfor (int i=0;i<MORPHTARGETS_COUNT;i++){\nif (morphTargetInfluences[i] != 0.0)transformed+=getMorph(gl_VertexID,i,0).xyz*morphTargetInfluences[i];\n}\n#else\n#if MORPHTARGETS_COUNT>0\ntransformed+=morphTarget0*morphTargetInfluences[0];\n#endif\n#if MORPHTARGETS_COUNT>1\ntransformed+=morphTarget1*morphTargetInfluences[1];\n#endif\n#if MORPHTARGETS_COUNT>2\ntransformed+=morphTarget2*morphTargetInfluences[2];\n#endif\n#if MORPHTARGETS_COUNT>3\ntransformed+=morphTarget3*morphTargetInfluences[3];\n#endif\n#if MORPHTARGETS_COUNT>4\ntransformed+=morphTarget4*morphTargetInfluences[4];\n#endif\n#if MORPHTARGETS_COUNT>5\ntransformed+=morphTarget5*morphTargetInfluences[5];\n#endif\n#ifndef USE_MORPHNORMALS\n#if MORPHTARGETS_COUNT>6\ntransformed+=morphTarget6*morphTargetInfluences[6];\n#endif\n#if MORPHTARGETS_COUNT>7\ntransformed+=morphTarget7*morphTargetInfluences[7];\n#endif\n#if MORPHTARGETS_COUNT>8\ntransformed+=morphTarget8*morphTargetInfluences[8];\n#endif\n#if MORPHTARGETS_COUNT>9\ntransformed+=morphTarget9*morphTargetInfluences[9];\n#endif\n#if MORPHTARGETS_COUNT>10\ntransformed+=morphTarget10*morphTargetInfluences[10];\n#endif\n#if MORPHTARGETS_COUNT>11\ntransformed+=morphTarget1*morphTargetInfluences[11];\n#endif\n#endif\n#endif\n#endif",normal_fragment_begin:"float faceDirection=gl_FrontFacing?1.0:-1.0;\n#ifdef FLAT_SHADED\nvec3 fdx=dFdx(vViewPosition);\nvec3 fdy=dFdy(vViewPosition);\nvec3 normal=normalize(cross(fdx,fdy));\n#else\nvec3 normal=normalize(vNormal);\n#ifdef DOUBLE_SIDED\nnormal=normal*faceDirection;\n#endif\n#ifdef USE_TANGENT\nvec3 tangent=normalize(vTangent);\nvec3 bitangent=normalize(vBitangent);\n#ifdef DOUBLE_SIDED\ntangent=tangent*faceDirection;\nbitangent=bitangent*faceDirection;\n#endif\n#if defined(TANGENTSPACE_NORMALMAP)\nmat3 vTBN=mat3(tangent,bitangent,normal);\n#endif\n#endif\n#endif\nvec3 geometryNormal=normal;",normal_fragment_maps:"#ifdef OBJECTSPACE_NORMALMAP\nnormal=texture2D(normalMap,vUv).xyz*2.0-1.0;\n#ifdef FLIP_SIDED\nnormal=-normal;\n#endif\n#ifdef DOUBLE_SIDED\nnormal=normal*faceDirection;\n#endif\nnormal=normalize(normalMatrix*normal);\n#elif defined(TANGENTSPACE_NORMALMAP)\nvec3 mapN=texture2D(normalMap,vUv).xyz*2.0-1.0;\nmapN.xy*=normalScale;\n#ifdef USE_TANGENT\nnormal=normalize(vTBN*mapN);\n#else\nnormal=perturbNormal2Arb(-vViewPosition,normal,mapN,faceDirection);\n#endif\n#elif defined(USE_BUMPMAP)\nnormal=perturbNormalArb(-vViewPosition,normal,dHdxy_fwd(),faceDirection);\n#endif",normal_pars_fragment:"#ifndef FLAT_SHADED\nvarying vec3 vNormal;\n#ifdef USE_TANGENT\nvarying vec3 vTangent;\nvarying vec3 vBitangent;\n#endif\n#endif",normal_pars_vertex:"#ifndef FLAT_SHADED\nvarying vec3 vNormal;\n#ifdef USE_TANGENT\nvarying vec3 vTangent;\nvarying vec3 vBitangent;\n#endif\n#endif",normal_vertex:"#ifndef FLAT_SHADED\nvNormal=normalize(transformedNormal);\n#ifdef USE_TANGENT\nvTangent=normalize(transformedTangent);\nvBitangent=normalize(cross(vNormal,vTangent)*tangent.w);\n#endif\n#endif",normalmap_pars_fragment:"#ifdef USE_NORMALMAP\nuniform sampler2D normalMap;\nuniform vec2 normalScale;\n#endif\n#ifdef OBJECTSPACE_NORMALMAP\nuniform mat3 normalMatrix;\n#endif\n#if !defined (USE_TANGENT)&&defined (TANGENTSPACE_NORMALMAP)\nvec3 perturbNormal2Arb(vec3 eye_pos,vec3 surf_norm,vec3 mapN,float faceDirection){\nvec3 q0=dFdx(eye_pos.xyz);\nvec3 q1=dFdy(eye_pos.xyz);\nvec2 st0=dFdx(vUv.st);\nvec2 st1=dFdy(vUv.st);\nvec3 N=surf_norm;\nvec3 q1perp=cross(q1,N);\nvec3 q0perp=cross(N,q0);\nvec3 T=q1perp*st0.x+q0perp*st1.x;\nvec3 B=q1perp*st0.y+q0perp*st1.y;\nfloat det=max(dot(T,T),dot(B,B));\nfloat scale=(det==0.0)?0.0:faceDirection*inversesqrt(det);\nreturn normalize(T*(mapN.x*scale)+B*(mapN.y*scale)+N*mapN.z);\n}\n#endif",output_fragment:"#ifdef OPAQUE\ndiffuseColor.a=1.0;\n#endif\ngl_FragColor=vec4(outgoingLight,diffuseColor.a);",packing:"vec3 packNormalToRGB(const in vec3 normal){\nreturn normalize(normal)*0.5+0.5;\n}\nvec3 unpackRGBToNormal(const in vec3 rgb){\nreturn 2.0*rgb.xyz-1.0;\n}\nconst float PackUpscale=256./255.;\nconst float UnpackDownscale=255./256.;\nconst vec3 PackFactors=vec3(256.*256.*256.,256.*256.,256.);\nconst vec4 UnpackFactors=UnpackDownscale/vec4(PackFactors,1.);\nconst float ShiftRight8=1./256.;\nvec4 packDepthToRGBA(const in float v){\nvec4 r=vec4(fract(v*PackFactors),v);\nr.yzw-=r.xyz*ShiftRight8;\nreturn r*PackUpscale;\n}\nfloat unpackRGBAToDepth(const in vec4 v){\nreturn dot(v,UnpackFactors);\n}\nvec2 packDepthToRG(in highp float v){\nreturn packDepthToRGBA(v).yx;\n}\nfloat unpackRGToDepth(const in highp vec2 v){\nreturn unpackRGBAToDepth(vec4(v.xy,0.0,0.0));\n}\nvec4 pack2HalfToRGBA(vec2 v){\nvec4 r=vec4(v.x,fract(v.x*255.0),v.y,fract(v.y*255.0));\nreturn vec4(r.x-r.y/255.0,r.y,r.z-r.w/255.0,r.w);\n}\nvec2 unpackRGBATo2Half(vec4 v){\nreturn vec2(v.x+(v.y/255.0),v.z+(v.w/255.0));\n}\nfloat viewZToOrthographicDepth(const in float viewZ,const in float near,const in float far){\nreturn (viewZ+near)/(near-far);\n}\nfloat orthographicDepthToViewZ(const in float linearClipZ,const in float near,const in float far){\nreturn linearClipZ*(near-far)-near;\n}\nfloat viewZToPerspectiveDepth(const in float viewZ,const in float near,const in float far){\nreturn ((near+viewZ)*far)/((far-near)*viewZ);\n}\nfloat perspectiveDepthToViewZ(const in float invClipZ,const in float near,const in float far){\nreturn (near*far)/((far-near)*invClipZ-far);\n}",premultiplied_alpha_fragment:"#ifdef PREMULTIPLIED_ALPHA\ngl_FragColor.rgb*=gl_FragColor.a;\n#endif",project_vertex:"vec4 mvPosition=vec4(transformed,1.0);\n#ifdef USE_INSTANCING\nmvPosition=instanceMatrix*mvPosition;\n#endif\nmvPosition=modelViewMatrix*mvPosition;\ngl_Position=projectionMatrix*mvPosition;\n#if defined(BACKGROUND_DEPTH)\ngl_Position.z=gl_Position.w;\n#endif",dithering_fragment:"#ifdef DITHERING\ngl_FragColor.rgb=dithering(gl_FragColor.rgb);\n#endif",dithering_pars_fragment:"#ifdef DITHERING\nvec3 dithering(vec3 color){\nfloat grid_position=rand(gl_FragCoord.xy);\nvec3 dither_shift_RGB=vec3(0.25/255.0,-0.25/255.0,0.25/255.0);\ndither_shift_RGB=mix(2.0*dither_shift_RGB,-2.0*dither_shift_RGB,grid_position);\nreturn color+dither_shift_RGB;\n}\n#endif",roughnessmap_fragment:"float roughnessFactor=roughness;\n#ifdef USE_ROUGHNESSMAP\nvec4 texelRoughness=texture2D(roughnessMap,vUv);\nroughnessFactor*=texelRoughness.g;\n#endif",roughnessmap_pars_fragment:"#ifdef USE_ROUGHNESSMAP\nuniform sampler2D roughnessMap;\n#endif",shadowmap_pars_fragment:"\n#define BIAS_FRUSTUM_SCALE_COEFF 30.0\n#define ESM_SPOT_SINGLE_BLUR_COEFF 0.25\n#define PCF_POISSON_SPOT_OMNI_BLUR_COEFF 4.0\n#define PCF_POISSON_POINT_BLUR_COEFF 2.5\n#define ESM_BIAS_COEFF 100.0\n#ifndef ESM_DISTANCE_SCALE\n#define ESM_DISTANCE_SCALE 1.0\n#endif\n#ifdef USE_SHADOWMAP\n#if NUM_SPOT_LIGHT_SHADOWS>0\nuniform sampler2D spotShadowMap[NUM_SPOT_LIGHT_SHADOWS];\nvarying vec4 vSpotShadowCoord[NUM_SPOT_LIGHT_SHADOWS];\nstruct SpotLightShadow {\nfloat shadowBias;\nfloat shadowNormalBias;\nfloat shadowRadius;\nvec2 shadowMapSize;\nint shadow;\nfloat shadowCameraNear;\nfloat shadowCameraFar;\nfloat expBias;\n};\nuniform SpotLightShadow spotLightShadows[NUM_SPOT_LIGHT_SHADOWS];\n#endif\n#if NUM_POINT_LIGHT_SHADOWS>0\nuniform sampler2D pointShadowMap[NUM_POINT_LIGHT_SHADOWS];\nvarying vec4 vPointShadowCoord[NUM_POINT_LIGHT_SHADOWS];\nstruct PointLightShadow {\nfloat shadowBias;\nfloat shadowNormalBias;\nfloat shadowRadius;\nvec2 shadowMapSize;\nfloat shadowCameraNear;\nfloat shadowCameraFar;\nfloat expBias;\n};\nuniform PointLightShadow pointLightShadows[NUM_POINT_LIGHT_SHADOWS];\n#endif\n#if NUM_RECT_AREA_LIGHT_SHADOWS>0\nuniform sampler2D rectAreaShadowMap[NUM_RECT_AREA_LIGHT_SHADOWS];\nvarying vec4 vRectAreaShadowCoord[NUM_RECT_AREA_LIGHT_SHADOWS];\nstruct RectAreaLightShadow {\nfloat shadowBias;\nfloat shadowNormalBias;\nfloat shadowRadius;\nvec2 shadowMapSize;\nfloat shadowCameraNear;\nfloat shadowCameraFar;\nfloat expBias;\n};\nuniform RectAreaLightShadow rectAreaLightShadows[NUM_RECT_AREA_LIGHT_SHADOWS];\n#endif\n#if NUM_DIR_LIGHT_SHADOWS_CSM>0\nuniform sampler2D directionalShadowCSMMap[NUM_DIR_LIGHT_SHADOW_CASCADES_CSM];\nvarying vec4 vDirectionalShadowCSMCoord[NUM_DIR_LIGHT_SHADOW_CASCADES_CSM];\nstruct DirectionalLightShadowCascade {\nfloat shadowBias;\nfloat shadowNormalBias;\nfloat shadowRadius;\nvec2 shadowMapSize;\nfloat shadowCameraNear;\nfloat shadowCameraFar;\nvec2 cascade;\nfloat expBias;\nvec3 position;\nint csmIdx;\n};\nstruct DirectionalLightShadowCSM {\nint cascadeIdxEnd;\nfloat cameraNear;\nfloat shadowFar;\nfloat fade;\n};\nuniform DirectionalLightShadowCSM directionalLightShadowsCSM[NUM_DIR_LIGHT_SHADOWS_CSM];\nuniform DirectionalLightShadowCascade directionalLightShadowsCSMCascade[NUM_DIR_LIGHT_SHADOW_CASCADES_CSM];\n#endif\nconst vec3 PERMUTE_DIR_X=vec3(1.0,0.0,0.0);\nconst vec3 PERMUTE_DIR_Y=vec3(0.0,1.0,0.0);\nconst vec3 PERMUTE_DIR_Z=vec3(0.0,0.0,1.0);\nconst mat4 POISSON_DISK_0=mat4(0.954845,0.242214,-0.623893,-0.235473,-0.173288,0.799228,0.605969,-0.548050,-0.560406,0.327647,-0.448307,-0.774344,0.308258,0.417332,-0.125623,-0.056098\n);\nconst mat4 POISSON_DISK_1=mat4(0.145585,-0.305634,0.264060,-0.661648,0.617942,0.652121,-0.041412,-0.893582,0.463911,0.039752,0.212664,0.810727,-0.955989,-0.014390,-0.652588,0.671204\n);\nfloat texture2DCompare(sampler2D depths,vec2 uv,float compare){\nreturn step(compare,unpackRGBAToDepth(texture2D(depths,uv)));\n}\nfloat texture2DShadowLerp(sampler2D depths,vec2 size,vec2 uv,float compare){\nconst vec2 offset=vec2(0.0,1.0);\nvec2 texelSize=vec2(1.0)/size;\nvec2 centroidUV=floor(uv*size+0.5)/size;\nfloat lb=texture2DCompare(depths,centroidUV+texelSize*offset.xx,compare);\nfloat lt=texture2DCompare(depths,centroidUV+texelSize*offset.xy,compare);\nfloat rb=texture2DCompare(depths,centroidUV+texelSize*offset.yx,compare);\nfloat rt=texture2DCompare(depths,centroidUV+texelSize*offset.yy,compare);\nvec2 f=fract(uv*size+0.5);\nfloat a=mix(lb,lt,f.y);\nfloat b=mix(rb,rt,f.y);\nfloat c=mix(a,b,f.x);\nreturn c;\n}\nvec2 cubeToUV(vec3 v,float texelSizeY){\nvec3 absV=abs(v);\nfloat scaleToCube=1.0/max(absV.x,max(absV.y,absV.z));\nabsV*=scaleToCube;\nv*=scaleToCube*(1.0-2.0*texelSizeY);\nvec2 planar=v.xy;\nfloat almostATexel=1.5*texelSizeY;\nfloat almostOne=1.0-almostATexel;\nif (absV.z>=almostOne){\nif (v.z>0.0)\nplanar.x=4.0-v.x;\n} else if (absV.x>=almostOne){\nfloat signX=sign(v.x);\nplanar.x=v.z*signX+2.0*signX;\n} else if (absV.y>=almostOne){\nfloat signY=sign(v.y);\nplanar.x=v.x+2.0*signY+2.0;\nplanar.y=v.z*signY-2.0;\n}\nreturn vec2(0.125,0.25)*planar+vec2(0.375,0.75);\n}\nfloat texture2DShadowAvgCube(sampler2D depths,vec2 size,vec3 bd3D,float compare){\nvec2 texelSize=vec2(1.0)/size;\nvec3 dirX=normalize(abs(bd3D.y)<0.99999?vec3(bd3D.z,0.0,-bd3D.x)\n: vec3(0.0,-bd3D.z,bd3D.y));\nvec3 dirY=cross(bd3D,dirX);\nfloat theta=PI_HALF*texelSize.y;\nvec3 sX=sin(theta)*dirX;\nvec3 sY=sin(theta)*dirY;\nfloat cosT=cos(theta);\nvec3 sampleVec[4];\nsampleVec[0]=bd3D;\nsampleVec[1]=bd3D*cosT+sY;\nsampleVec[2]=bd3D*cosT+sX;\nsampleVec[3]=sampleVec[2]*cosT+sY;\nfloat avg=0.0;\nfor (int i=0;i<4;i++){\navg+=texture2DCompare(depths,cubeToUV(sampleVec[i],texelSize.y),compare);\n}\navg/=4.0;\nreturn avg;\n}\nfloat getShadow(sampler2D shadowMap,vec2 shadowMapSize,float shadowBias,float shadowRadius,vec4 shadowCoord,float expBias,float distWorld){\nfloat shadow=1.0;\nshadowCoord.xyz/=shadowCoord.w;\nbool inFrustum=shadowCoord.x>=0.0&&shadowCoord.x<=1.0&&shadowCoord.y>=0.0&&shadowCoord.y<=1.0;\nbool frustumTest=inFrustum&&shadowCoord.z<=1.0&&shadowCoord.z>=0.0;\nif (frustumTest){\n#if defined(SHADOWMAP_TYPE_BILINEAR)\nshadowCoord.z+=shadowBias;\nshadow=texture2DShadowLerp(shadowMap,shadowMapSize,shadowCoord.xy,shadowCoord.z);\n#elif defined(SHADOWMAP_TYPE_PCF)\nshadowCoord.z+=shadowBias;\nvec2 texelSize=vec2(1.0)/shadowMapSize;\nfloat randAngle=rand(gl_FragCoord.xy)*PI2;\nfloat c=cos(randAngle),s=sin(randAngle);\nmat2 sampleMat=mat2(c,s,-s,c)\n* mat2(shadowRadius*texelSize.x,0.0,0.0,shadowRadius*texelSize.y);\nvec2 sampleVec[16];\nsampleVec[0]=POISSON_DISK_0[0].xy;\nsampleVec[1]=POISSON_DISK_0[0].zw;\nsampleVec[2]=POISSON_DISK_0[1].xy;\nsampleVec[3]=POISSON_DISK_0[1].zw;\nsampleVec[4]=POISSON_DISK_0[2].xy;\nsampleVec[5]=POISSON_DISK_0[2].zw;\nsampleVec[6]=POISSON_DISK_0[3].xy;\nsampleVec[7]=POISSON_DISK_0[3].zw;\nsampleVec[8]=POISSON_DISK_1[0].xy;\nsampleVec[9]=POISSON_DISK_1[0].zw;\nsampleVec[10]=POISSON_DISK_1[1].xy;\nsampleVec[11]=POISSON_DISK_1[1].zw;\nsampleVec[12]=POISSON_DISK_1[2].xy;\nsampleVec[13]=POISSON_DISK_1[2].zw;\nsampleVec[14]=POISSON_DISK_1[3].xy;\nsampleVec[15]=POISSON_DISK_1[3].zw;\nshadow=0.0;\nfor (int i=0;i<16;i++){\nshadow+=texture2DCompare(shadowMap,shadowCoord.xy\n+ sampleMat*sampleVec[i],shadowCoord.z);\n}\nshadow/=16.0;\n#elif defined(SHADOWMAP_TYPE_ESM)\nshadow=saturate(exp(expBias*(texture2D(shadowMap,shadowCoord.xy).x\n- length(distWorld)*ESM_DISTANCE_SCALE\n- ESM_BIAS_COEFF*shadowBias)));\n#else\nshadowCoord.z+=shadowBias;\nshadow=texture2DCompare(shadowMap,shadowCoord.xy,shadowCoord.z);\n#endif\n}\nreturn shadow;\n}\nfloat getOmniShadow(sampler2D shadowMap,vec2 shadowMapSize,float shadowBias,float expBias,float shadowRadius,vec4 shadowCoord,float shadowCameraNear,float shadowCameraFar){\nfloat shadow=1.0;\nvec3 lightToPosition=shadowCoord.xyz;\nfloat dp=(length(lightToPosition)-shadowCameraNear)\n/ (shadowCameraFar-shadowCameraNear);\nbool frustumTest=dp<=1.0&&dp>=0.0;\nif (frustumTest){\nfloat biasScaleCoeff=BIAS_FRUSTUM_SCALE_COEFF\n/ (shadowCameraFar-shadowCameraNear);\ndp+=shadowBias*biasScaleCoeff;\nvec3 bd3D=normalize(lightToPosition);\nvec2 texelSize=1.0/shadowMapSize;\n#if defined(SHADOWMAP_TYPE_BILINEAR)\nshadow=texture2DShadowAvgCube(shadowMap,shadowMapSize,bd3D,dp);\n#elif defined(SHADOWMAP_TYPE_ESM)\nshadow=saturate(exp(expBias*(texture2D(shadowMap,cubeVecToOctUV(bd3D,texelSize)).x\n- length(lightToPosition)*ESM_DISTANCE_SCALE\n- ESM_BIAS_COEFF*shadowBias)));\n#elif defined(SHADOWMAP_TYPE_PCF)\nfloat randAngle=rand(gl_FragCoord.xy)*PI2;\nfloat c=cos(randAngle),s=sin(randAngle);\nmat2 sampleMat=mat2(c,s,-s,c)\n* mat2(shadowRadius*texelSize.y,0.0,0.0,shadowRadius*texelSize.y);\nvec3 absBd3D=abs(bd3D);\nabsBd3D/=max(absBd3D.x,max(absBd3D.y,absBd3D.z));\nbvec2 isPointingCubeFace=greaterThan(absBd3D.xy,vec2(0.999));\nmat3 permuteMat=mat3(isPointingCubeFace.x?PERMUTE_DIR_Y:PERMUTE_DIR_X,isPointingCubeFace.x||isPointingCubeFace.y?PERMUTE_DIR_Z:PERMUTE_DIR_Y,isPointingCubeFace.x?PERMUTE_DIR_X:isPointingCubeFace.y?PERMUTE_DIR_Y:PERMUTE_DIR_Z\n);\nvec2 sampleVec[16];\nsampleVec[0]=POISSON_DISK_0[0].xy;\nsampleVec[1]=POISSON_DISK_0[0].zw;\nsampleVec[2]=POISSON_DISK_0[1].xy;\nsampleVec[3]=POISSON_DISK_0[1].zw;\nsampleVec[4]=POISSON_DISK_0[2].xy;\nsampleVec[5]=POISSON_DISK_0[2].zw;\nsampleVec[6]=POISSON_DISK_0[3].xy;\nsampleVec[7]=POISSON_DISK_0[3].zw;\nsampleVec[8]=POISSON_DISK_1[0].xy;\nsampleVec[9]=POISSON_DISK_1[0].zw;\nsampleVec[10]=POISSON_DISK_1[1].xy;\nsampleVec[11]=POISSON_DISK_1[1].zw;\nsampleVec[12]=POISSON_DISK_1[2].xy;\nsampleVec[13]=POISSON_DISK_1[2].zw;\nsampleVec[14]=POISSON_DISK_1[3].xy;\nsampleVec[15]=POISSON_DISK_1[3].zw;\nshadow=0.0;\nfor (int i=0;i<16;i++){\nshadow+=texture2DCompare(shadowMap,cubeToUV(bd3D+permuteMat*vec3(sampleMat*sampleVec[i],0.0),texelSize.y),dp);\n}\nshadow/=16.0;\n#else\nshadow=texture2DCompare(shadowMap,cubeToUV(bd3D,texelSize.y),dp);\n#endif\n}\nreturn shadow;\n}\n#if NUM_POINT_LIGHT_SHADOWS>0\nfloat getPointShadow(PointLightShadow light,sampler2D shadowMap,vec4 shadowCoord){\nfloat shadowRadius=light.shadowRadius;\nvec2 mapSize=light.shadowMapSize;\n#if defined(SHADOWMAP_TYPE_ESM)\nmapSize*=2.0;\n#else\nmapSize*=vec2(4.0,2.0);\n#if defined(SHADOWMAP_TYPE_PCF)\nshadowRadius*=PCF_POISSON_POINT_BLUR_COEFF;\n#endif\n#endif\nreturn getOmniShadow(shadowMap,mapSize,light.shadowBias,light.expBias,shadowRadius,shadowCoord,light.shadowCameraNear,light.shadowCameraFar);\n}\n#endif\n#if NUM_RECT_AREA_LIGHT_SHADOWS>0\nfloat getRectAreaShadow(RectAreaLightShadow light,sampler2D shadowMap,vec4 shadowCoord){\nfloat shadowRadius=light.shadowRadius;\nvec2 mapSize=light.shadowMapSize;\n#if defined(SHADOWMAP_TYPE_ESM)\nmapSize*=2.0;\n#else\nmapSize*=vec2(4.0,2.0);\n#if defined(SHADOWMAP_TYPE_PCF)\nshadowRadius*=PCF_POISSON_POINT_BLUR_COEFF;\n#endif\n#endif\nreturn getOmniShadow(shadowMap,mapSize,light.shadowBias,light.expBias,shadowRadius,shadowCoord,light.shadowCameraNear,light.shadowCameraFar);\n}\n#endif\n#if NUM_SPOT_LIGHT_SHADOWS>0\nfloat getSpotOmniShadow(SpotLightShadow light,sampler2D shadowMap,vec4 shadowCoord){\nfloat shadowRadius=light.shadowRadius;\nvec2 mapSize=light.shadowMapSize;\n#if defined(SHADOWMAP_TYPE_ESM)\n#else\nmapSize*=vec2(4.0,2.0);\n#if defined(SHADOWMAP_TYPE_PCF)\nshadowRadius*=PCF_POISSON_SPOT_OMNI_BLUR_COEFF;\n#endif\n#endif\nreturn getOmniShadow(shadowMap,mapSize,light.shadowBias,light.expBias,shadowRadius,shadowCoord,light.shadowCameraNear,light.shadowCameraFar);\n}\nfloat biasLinearNormalizedToNonlinear(float bias,float near,float far,float projZ,float projW){\nreturn (bias*(far+near)+2.0*projZ)/(bias*(far-near)+2.0*projW)\n- projZ/projW;\n}\nfloat getSpotShadow(SpotLightShadow light,sampler2D shadowMap,vec4 shadowCoord,float distWorld){\nfloat shadowRadius=light.shadowRadius;\nfloat shadowBias=light.shadowBias;\n#if defined(SHADOWMAP_TYPE_ESM)\nshadowRadius*=ESM_SPOT_SINGLE_BLUR_COEFF;\n#endif\nshadowBias*=BIAS_FRUSTUM_SCALE_COEFF\n/ (light.shadowCameraFar-light.shadowCameraNear);\n#if defined(SHADOWMAP_TYPE_BASIC)||defined(SHADOWMAP_TYPE_BILINEAR)||defined(SHADOWMAP_TYPE_PCF)\nshadowBias=biasLinearNormalizedToNonlinear(shadowBias,light.shadowCameraNear,light.shadowCameraFar,shadowCoord.z,shadowCoord.w);\n#endif\nreturn getShadow(shadowMap,light.shadowMapSize,shadowBias,shadowRadius,shadowCoord,light.expBias,distWorld);\n}\n#endif\n#if NUM_DIR_LIGHT_SHADOWS_CSM>0\nfloat getDirShadowCSM(DirectionalLightShadowCascade light,sampler2D shadowMap,vec4 shadowCoord,float distWorld){\nreturn getShadow(shadowMap,light.shadowMapSize,light.shadowBias,light.shadowRadius,shadowCoord,light.expBias,distWorld);\n}\n#endif\n#endif",shadowmap_pars_vertex:"#ifdef USE_SHADOWMAP\n#if NUM_SPOT_LIGHT_SHADOWS>0\nuniform mat4 spotShadowMatrix[NUM_SPOT_LIGHT_SHADOWS];\nvarying vec4 vSpotShadowCoord[NUM_SPOT_LIGHT_SHADOWS];\nstruct SpotLightShadow {\nfloat shadowBias;\nfloat shadowNormalBias;\nfloat shadowRadius;\nvec2 shadowMapSize;\nint shadow;\nfloat shadowCameraNear;\nfloat shadowCameraFar;\nfloat expBias;\n};\nuniform SpotLightShadow spotLightShadows[NUM_SPOT_LIGHT_SHADOWS];\n#endif\n#if NUM_POINT_LIGHT_SHADOWS>0\nuniform mat4 pointShadowMatrix[NUM_POINT_LIGHT_SHADOWS];\nvarying vec4 vPointShadowCoord[NUM_POINT_LIGHT_SHADOWS];\nstruct PointLightShadow {\nfloat shadowBias;\nfloat shadowNormalBias;\nfloat shadowRadius;\nvec2 shadowMapSize;\nfloat shadowCameraNear;\nfloat shadowCameraFar;\nfloat expBias;\n};\nuniform PointLightShadow pointLightShadows[NUM_POINT_LIGHT_SHADOWS];\n#endif\n#if NUM_RECT_AREA_LIGHT_SHADOWS>0\nuniform mat4 rectAreaShadowMatrix[NUM_RECT_AREA_LIGHT_SHADOWS];\nvarying vec4 vRectAreaShadowCoord[NUM_RECT_AREA_LIGHT_SHADOWS];\nstruct RectAreaLightShadow {\nfloat shadowBias;\nfloat shadowNormalBias;\nfloat shadowRadius;\nvec2 shadowMapSize;\nfloat shadowCameraNear;\nfloat shadowCameraFar;\nfloat expBias;\n};\nuniform RectAreaLightShadow rectAreaLightShadows[NUM_RECT_AREA_LIGHT_SHADOWS];\n#endif\n#if NUM_DIR_LIGHT_SHADOWS_CSM>0\nuniform mat4 directionalShadowCSMMatrix[NUM_DIR_LIGHT_SHADOW_CASCADES_CSM];\nvarying vec4 vDirectionalShadowCSMCoord[NUM_DIR_LIGHT_SHADOW_CASCADES_CSM];\nstruct DirectionalLightShadowCascade {\nfloat shadowBias;\nfloat shadowNormalBias;\nfloat shadowRadius;\nvec2 shadowMapSize;\nfloat shadowCameraNear;\nfloat shadowCameraFar;\nvec2 cascade;\nfloat expBias;\nvec3 position;\nint csmIdx;\n};\nstruct DirectionalLightShadowCSM {\nint cascadeIdxEnd;\nfloat cameraNear;\nfloat shadowFar;\nfloat fade;\n};\nuniform DirectionalLightShadowCSM directionalLightShadowsCSM[NUM_DIR_LIGHT_SHADOWS_CSM];\nuniform DirectionalLightShadowCascade directionalLightShadowsCSMCascade[NUM_DIR_LIGHT_SHADOW_CASCADES_CSM];\n#endif\n#endif",shadowmap_vertex:"#if defined(USE_SHADOWMAP)\n#if NUM_SPOT_LIGHT_SHADOWS>0||NUM_POINT_LIGHT_SHADOWS>0||NUM_RECT_AREA_LIGHT_SHADOWS>0||NUM_DIR_LIGHT_SHADOWS_CSM>0\nvec3 shadowWorldNormal=inverseTransformDirection(transformedNormal,viewMatrix);\nvec4 shadowWorldPosition;\n#endif\n#if NUM_SPOT_LIGHT_SHADOWS>0\n#pragma unroll_loop\nfor (int i=0;i<NUM_SPOT_LIGHT_SHADOWS;i++){\nshadowWorldPosition=worldPosition+vec4(shadowWorldNormal*spotLightShadows[i].shadowNormalBias,0);\nvSpotShadowCoord[i]=spotShadowMatrix[i]*shadowWorldPosition;\n}\n#endif\n#if NUM_POINT_LIGHT_SHADOWS>0\n#pragma unroll_loop\nfor (int i=0;i<NUM_POINT_LIGHT_SHADOWS;i++){\nshadowWorldPosition=worldPosition+vec4(shadowWorldNormal*pointLightShadows[i].shadowNormalBias,0);\nvPointShadowCoord[i]=pointShadowMatrix[i]*shadowWorldPosition;\n}\n#endif\n#if NUM_RECT_AREA_LIGHT_SHADOWS>0\n#pragma unroll_loop\nfor (int i=0;i<NUM_RECT_AREA_LIGHT_SHADOWS;i++){\nshadowWorldPosition=worldPosition+vec4(shadowWorldNormal*rectAreaLightShadows[i].shadowNormalBias,0);\nvRectAreaShadowCoord[i]=rectAreaShadowMatrix[i]*shadowWorldPosition;\n}\n#endif\n#if NUM_DIR_LIGHT_SHADOWS_CSM>0\n#pragma unroll_loop\nfor (int i=0;i<NUM_DIR_LIGHT_SHADOW_CASCADES_CSM;i++){\nshadowWorldPosition=worldPosition+vec4(shadowWorldNormal*directionalLightShadowsCSMCascade[i].shadowNormalBias,0);\nvDirectionalShadowCSMCoord[i]=directionalShadowCSMMatrix[i]*shadowWorldPosition;\n}\n#endif\n#endif",shadowmask_pars_fragment:"float getShadowMask(){\nfloat shadow=1.0;\n#ifdef USE_SHADOWMAP\n#if NUM_SPOT_LIGHT_SHADOWS>0\nSpotLightShadow spotLight;\n#pragma unroll_loop\nfor (int i=0;i<NUM_SPOT_LIGHT_SHADOWS;i++){\nspotLight=spotLightShadows[i];\nif (receiveShadow){\nif (spotLight.shadow==1){\nfloat distWorld=0.0;\n#if defined(SHADOWMAP_TYPE_ESM)\ndistWorld=length((invViewMatrix*vec4(spotLight.position\n+ vViewPosition,0.0)).xyz);\n#endif\nshadow*=getSpotShadow(spotLight,spotShadowMap[i],vSpotShadowCoord[i],distWorld);\n} else if (spotLight.shadow==2){\nshadow*=getSpotOmniShadow(spotLight,spotShadowMap[i],vSpotShadowCoord[i]);\n}\n}\n}\n#endif\n#if NUM_POINT_LIGHT_SHADOWS>0\nPointLightShadow pointLight;\n#pragma unroll_loop\nfor (int i=0;i<NUM_POINT_LIGHT_SHADOWS;i++){\npointLight=pointLightShadows[i];\nshadow*=receiveShadow?getPointShadow(pointLight,pointShadowMap[i],vPointShadowCoord[i]):1.0;\n}\n#endif\n#if NUM_RECT_AREA_LIGHT_SHADOWS>0\nRectAreaLightShadow rectAreaLight;\n#pragma unroll_loop\nfor (int i=0;i<NUM_RECT_AREA_LIGHT_SHADOWS;i++){\nrectAreaLight=rectAreaLightShadows[i];\nshadow*=receiveShadow?getRectAreaShadow(rectAreaLight,rectAreaShadowMap[i],vRectAreaShadowCoord[i]):1.0;\n}\n#endif\n#if NUM_DIR_LIGHT_SHADOWS_CSM>0\nDirectionalLightShadowCascade dirShadowCascade;\n#pragma unroll_loop\nfor (int i=0;i<NUM_DIR_LIGHT_SHADOW_CASCADES_CSM;i++){\ndirShadowCascade=directionalLightShadowsCSMCascade[i];\nfloat distWorld=0.0;\n#if defined(SHADOWMAP_TYPE_ESM)\ndistWorld=length((invViewMatrix*vec4(dirShadowCascade.position\n+ vViewPosition,0.0)).xyz);\n#endif\nshadow*=((vViewPosition.z<dirShadowCascade.shadowCameraFar)&&receiveShadow)?\ngetDirShadowCSM(dirShadowCascade,directionalShadowCSMMap[i],vDirectionalShadowCSMCoord[i],distWorld)\n: 1.0;\n}\n#endif\n#endif\nreturn shadow;\n}",skinbase_vertex:"#ifdef USE_SKINNING\nmat4 boneMatX=getBoneMatrix(skinIndex.x);\nmat4 boneMatY=getBoneMatrix(skinIndex.y);\nmat4 boneMatZ=getBoneMatrix(skinIndex.z);\nmat4 boneMatW=getBoneMatrix(skinIndex.w);\n#endif",skinning_pars_vertex:"#ifdef USE_SKINNING\nuniform mat4 bindMatrix;\nuniform mat4 bindMatrixInverse;\nuniform highp sampler2D boneTexture;\nuniform int boneTextureSize;\nmat4 getBoneMatrix(const in float i){\nfloat j=i*4.0;\nfloat x=mod(j,float(boneTextureSize));\nfloat y=floor(j/float(boneTextureSize));\nfloat dx=1.0/float(boneTextureSize);\nfloat dy=1.0/float(boneTextureSize);\ny=dy*(y+0.5);\nvec4 v1=texture2D(boneTexture,vec2(dx*(x+0.5),y));\nvec4 v2=texture2D(boneTexture,vec2(dx*(x+1.5),y));\nvec4 v3=texture2D(boneTexture,vec2(dx*(x+2.5),y));\nvec4 v4=texture2D(boneTexture,vec2(dx*(x+3.5),y));\nmat4 bone=mat4(v1,v2,v3,v4);\nreturn bone;\n}\n#endif",skinning_vertex:"#ifdef USE_SKINNING\nvec4 skinVertex=bindMatrix*vec4(transformed,1.0);\nvec4 skinned=vec4(0.0);\nskinned+=boneMatX*skinVertex*skinWeight.x;\nskinned+=boneMatY*skinVertex*skinWeight.y;\nskinned+=boneMatZ*skinVertex*skinWeight.z;\nskinned+=boneMatW*skinVertex*skinWeight.w;\ntransformed=(bindMatrixInverse*skinned).xyz;\n#endif",skinnormal_vertex:"#ifdef USE_SKINNING\nmat4 skinMatrix=mat4(0.0);\nskinMatrix+=skinWeight.x*boneMatX;\nskinMatrix+=skinWeight.y*boneMatY;\nskinMatrix+=skinWeight.z*boneMatZ;\nskinMatrix+=skinWeight.w*boneMatW;\nskinMatrix=bindMatrixInverse*skinMatrix*bindMatrix;\nobjectNormal=vec4(skinMatrix*vec4(objectNormal,0.0)).xyz;\n#ifdef USE_TANGENT\nobjectTangent=vec4(skinMatrix*vec4(objectTangent,0.0)).xyz;\n#endif\n#endif",tonemapping_fragment:"#if defined(TONE_MAPPING)\ngl_FragColor.rgb=toneMapping(gl_FragColor.rgb);\n#endif",tonemapping_pars_fragment:"#ifndef saturate\n#define saturate(a)clamp(a,0.0,1.0)\n#endif\nuniform float toneMappingExposure;\nuniform float toneMappingMidTones;\nuniform float toneMappingPhysicalScale;\nuniform float toneMappingBrightness;\nuniform float toneMappingContrast;\nuniform bool toneMappingChromaticAdaptation;\nuniform vec3 toneMappingWhiteColor;\nuniform bool toneMappingColorDifferentiation;\nuniform bool toneMappingExteriorDaylight;\nuniform vec3 toneMappingWhiteBalance;\nuniform float toneMappingHighlights;\nuniform float toneMappingShadows;\nuniform float toneMappingSaturation;\nuniform float toneMappingAperture;\nuniform float toneMappingShutter;\nuniform float toneMappingISO;\nuniform float toneMappingVignetting;\nuniform vec2 toneMappingResolution;\nconst mat3 LINEAR_REC2020_TO_LINEAR_SRGB=mat3(vec3( 1.6605,-0.1246,-0.0182),vec3(-0.5876,1.1329,-0.1006),vec3(-0.0728,-0.0083,1.1187)\n);\nconst mat3 LINEAR_SRGB_TO_LINEAR_REC2020=mat3(vec3(0.6274,0.0691,0.0164),vec3(0.3293,0.9195,0.0880),vec3(0.0433,0.0113,0.8956)\n);\n#define TONE_MAPPING_LOOK_NONE 0\n#define TONE_MAPPING_LOOK_AGX_PUNCHY 1\nconst float FILMIC_BLENDER_LOG_MIN=-12.473931188;\nconst float FILMIC_BLENDER_LOG_MAX=12.526068812;\nconst float FILMIC_BLENDER_EXPOSURE_LATITUDE_RATIO=0.66;\nvec3 LinearToneMapping(vec3 color){\nreturn toneMappingExposure*color;\n}\nvec3 ReinhardToneMapping(vec3 color){\ncolor*=toneMappingExposure;\nreturn saturate(color/(vec3(1.0)+color));\n}\nvec3 OptimizedCineonToneMapping(vec3 color){\ncolor*=toneMappingExposure;\ncolor=max(vec3(0.0),color-0.004);\nreturn pow((color*(6.2*color+0.5))/(color*(6.2*color+1.7)+0.06),vec3(2.2));\n}\nvec3 RRTAndODTFit(vec3 v){\nvec3 a=v*(v+0.0245786)-0.000090537;\nvec3 b=v*(0.983729*v+0.4329510)+0.238081;\nreturn a/b;\n}\nvec3 ACESFilmicToneMapping(vec3 color){\nconst mat3 ACESInputMat=mat3(vec3(0.59719,0.07600,0.02840),vec3(0.35458,0.90834,0.13383),vec3(0.04823,0.01566,0.83777)\n);\nconst mat3 ACESOutputMat=mat3(vec3( 1.60475,-0.10208,-0.00327),vec3(-0.53108,1.10813,-0.07276),vec3(-0.07367,-0.00605,1.07602)\n);\ncolor*=toneMappingExposure/0.6;\ncolor=ACESInputMat*color;\ncolor=RRTAndODTFit(color);\ncolor=ACESOutputMat*color;\nreturn saturate(color);\n}\nvec3 agxDefaultContrastApprox(vec3 x){\nvec3 x2=x*x;\nvec3 x4=x2*x2;\nreturn+15.5*x4*x2\n-40.14*x4*x\n+ 31.96*x4\n-6.868*x2*x\n+ 0.4298*x2\n+ 0.1191*x\n-0.00232;\n}\nvec3 toneMappingLook(vec3 color,int look){\nif (look==TONE_MAPPING_LOOK_NONE){\nreturn color;\n}\nconst vec3 lw=vec3(0.2126,0.7152,0.0722);\nfloat luma=dot(color,lw);\nvec3 offset=vec3(0.0);\nvec3 slope=vec3(1.0);\nvec3 power=vec3(1.0);\nfloat sat=1.0;\nif (look==TONE_MAPPING_LOOK_AGX_PUNCHY){\nslope=vec3(1.0);\npower=vec3(1.35,1.35,1.35);\nsat=1.4;\n}\ncolor=pow(color*slope+offset,power);\nreturn luma+sat*(color-luma);\n}\nvec3 AgXToneMapping(vec3 color){\ncolor=max(color,0.0);\nconst mat3 AgXInsetMatrix=mat3(vec3(0.856627153315983,0.137318972929847,0.11189821299995),vec3(0.0951212405381588,0.761241990602591,0.0767994186031903),vec3(0.0482516061458583,0.101439036467562,0.811302368396859)\n);\nconst mat3 AgXOutsetMatrix=mat3(vec3(1.1271005818144368,-0.1413297634984383,-0.14132976349843826),vec3(- 0.11060664309660323,1.157823702216272,-0.11060664309660294),vec3(- 0.016493938717834573,-0.016493938717834257,1.2519364065950405)\n);\nconst float AgxMinEv=-12.47393;\nconst float AgxMaxEv=4.026069;\ncolor*=toneMappingExposure;\ncolor=LINEAR_SRGB_TO_LINEAR_REC2020*color;\ncolor=AgXInsetMatrix*color;\ncolor=max(color,1e-10);\ncolor=log2(color);\ncolor=(color-AgxMinEv)/(AgxMaxEv-AgxMinEv);\ncolor=clamp(color,0.0,1.0);\ncolor=agxDefaultContrastApprox(color);\ncolor=toneMappingLook(color,TONE_MAPPING_LOOK);\ncolor=AgXOutsetMatrix*color;\ncolor=pow(max(vec3(0.0),color),vec3(2.2));\ncolor=LINEAR_REC2020_TO_LINEAR_SRGB*color;\ncolor=clamp(color,0.0,1.0);\nreturn color;\n}\nvec3 CustomToneMapping(vec3 color){return color;}\n#define ORDERS_OF_MAG 5.0\n#define PI_TONE 3.14159265359\nfloat toneCalcBrightness(in vec3 color)\n{\nreturn (abs(color.r)*0.263+abs(color.g)*0.655+abs(color.b)*0.082);\n}\nfloat toneApproximateScotopicLuminance(vec3 color)\n{\nreturn (0.062*color.r+0.608*color.g+0.330*color.b);\n}\nvec3 LogarithmicMaxToneMapping(vec3 color){\nfloat inputScaleFactor=toneMappingPhysicalScale/PI_TONE;\nfloat brightness=(toneMappingBrightness<0.0)?0.0:(toneMappingBrightness*0.7);\nfloat powerBot=toneMappingExteriorDaylight?4.0:2.0;\nfloat res=100.0/ORDERS_OF_MAG;\nfloat mag=floor((50.0/res));\nfloat power=((brightness/20.0-ORDERS_OF_MAG)-powerBot)+mag;\nfloat stepsize=9.0/res;\nfloat step=50.0-(mag*res);\nfloat param_c=(0.02*toneMappingContrast)*2.0;\nfloat param_b=pow(10.0,power)*(1.0+(stepsize*step));\nfloat param_a=param_b*(1.0+param_c);\nparam_c/=pow(2.0,toneMappingMidTones-1.0);\nparam_b*=PI_TONE;\nvec3 whiteConstancyFactor=toneMappingWhiteColor;\nif (toneMappingChromaticAdaptation){\nfloat luminance=toneCalcBrightness(whiteConstancyFactor);\nwhiteConstancyFactor.r=(whiteConstancyFactor.r>0.001)?luminance/whiteConstancyFactor.r:luminance/0.001;\nwhiteConstancyFactor.g=(whiteConstancyFactor.g>0.001)?luminance/whiteConstancyFactor.g:luminance/0.001;\nwhiteConstancyFactor.b=(whiteConstancyFactor.b>0.001)?luminance/whiteConstancyFactor.b:luminance/0.001;\n}\nvec3 outColor=inputScaleFactor*color;\nif (toneMappingChromaticAdaptation){\noutColor*=whiteConstancyFactor.rgb;\n}\nfloat luminance=toneCalcBrightness(outColor);\nif (toneMappingColorDifferentiation&&(luminance<5.62)){\nfloat sLuminance=toneApproximateScotopicLuminance(outColor);\nif (luminance<=5.62e-3){\noutColor=vec3(sLuminance);\n} else {\nfloat w=(luminance-5.62e-3)/5.61438;\noutColor=outColor*w+sLuminance*(1.0-w);\n}\n}\noutColor=outColor*(param_a/(param_b*outColor+param_c));\nreturn outColor;\n}\nfloat maxExposurePhotographic(in vec4 color1,in vec4 color2)\n{\nreturn ((color1.r*color2.r)+(color1.g*color2.g))+(color1.b*color2.b);\n}\nvec3 PhysicalMaxToneMapping(vec3 color){\nfloat vignettingInfluence=1.0;\nif (toneMappingVignetting>0.0){\nvec3 vignettingCoords=vec3(0.0,0.0,0.0);\nfloat aspect=toneMappingResolution.x/toneMappingResolution.y;\nvignettingCoords.x=gl_FragCoord.x/toneMappingResolution.x-0.5;\nvignettingCoords.y=(gl_FragCoord.y/toneMappingResolution.y-0.5)/aspect;\nvignettingCoords.z=1.0;\nvignettingCoords=normalize(vignettingCoords);\nvignettingInfluence=pow(vignettingCoords.z,toneMappingVignetting);\n}\nfloat inputScaleFactor=toneMappingPhysicalScale/PI_TONE;\nfloat filmISO=toneMappingISO;\nfloat camShutter=1.0/toneMappingShutter;\nfloat fNumber=toneMappingAperture;\nfloat cm2=1.0;\nfloat burnHighlights=toneMappingHighlights;\nfloat crushBlacks=toneMappingShadows;\nfloat saturation=toneMappingSaturation;\nvec3 whitePointInfluence=toneMappingWhiteBalance;\nif (whitePointInfluence.r>0.0){\nwhitePointInfluence.r=1.0/whitePointInfluence.r;\n} else {\nwhitePointInfluence.r=1.0;\n}\nif (whitePointInfluence.g>0.0){\nwhitePointInfluence.g=1.0/whitePointInfluence.g;\n} else {\nwhitePointInfluence.g=1.0;\n}\nif (whitePointInfluence.b>0.0){\nwhitePointInfluence.b=1.0/whitePointInfluence.b;\n} else {\nwhitePointInfluence.b=1.0;\n}\nvec4 lumFactor=vec4(0.212671,0.715160,0.072169,0.0);\nfloat whiteLumFactor=maxExposurePhotographic(lumFactor,vec4(whitePointInfluence,0.0));\nwhitePointInfluence.r/=whiteLumFactor;\nwhitePointInfluence.g/=whiteLumFactor;\nwhitePointInfluence.b/=whiteLumFactor;\nfloat isoInfluence=0.0;\nfloat camShutterInv=1.0/camShutter;\nif (filmISO>0.0){\nisoInfluence=((cm2*0.169811)*(filmISO*camShutterInv))/((15.4*fNumber)*fNumber);\n} else {\nisoInfluence=cm2;\n}\nvec3 outColor=inputScaleFactor*color;\noutColor.r=outColor.r*whitePointInfluence.r*isoInfluence*vignettingInfluence;\noutColor.g=outColor.g*whitePointInfluence.g*isoInfluence*vignettingInfluence;\noutColor.b=outColor.b*whitePointInfluence.b*isoInfluence*vignettingInfluence;\noutColor.r=(outColor.r*(1.0+(outColor.r*burnHighlights)))/(1.0+outColor.r);\noutColor.g=(outColor.g*(1.0+(outColor.g*burnHighlights)))/(1.0+outColor.g);\noutColor.b=(outColor.b*(1.0+(outColor.b*burnHighlights)))/(1.0+outColor.b);\nfloat lumFactor2=maxExposurePhotographic(lumFactor,vec4(outColor,0.0));\nfloat tmpFloat=1.0-saturation;\noutColor.r=outColor.r*saturation+lumFactor2*tmpFloat;\noutColor.g=outColor.g*saturation+lumFactor2*tmpFloat;\noutColor.b=outColor.b*saturation+lumFactor2*tmpFloat;\noutColor=max(vec3(0.0),outColor);\nfloat crushBlacksFac=crushBlacks*2.0+1.0;\nfloat crushBlacksFac2=pow(maxExposurePhotographic(lumFactor,vec4(outColor,0.0)),0.5);\ntmpFloat=(1.0-crushBlacksFac2);\nif (crushBlacksFac2<1.0){\noutColor.r=outColor.r*crushBlacksFac2+pow(outColor.r,crushBlacksFac)*tmpFloat;\noutColor.g=outColor.g*crushBlacksFac2+pow(outColor.g,crushBlacksFac)*tmpFloat;\noutColor.b=outColor.b*crushBlacksFac2+pow(outColor.b,crushBlacksFac)*tmpFloat;\n}\nreturn outColor;\n}\nfloat filmicBlenderDesaturationMinIntensity(vec3 color){\nfloat maxChannel=max(color.r,max(color.g,color.b));\nfloat x=max(maxChannel,0.6251);\nreturn (1.2192868*x-0.63221059)\n* ((x-0.65069831)/(abs(x-0.65069831)+0.00952982)+0.73015231);\n}\nvec3 filmicBlenderDesaturationTransform(vec3 color){\nconst float CURVE_SMOOTHNESS=0.03;\nfloat minIntensity=filmicBlenderDesaturationMinIntensity(color);\nvec4 x=vec4(color,1.0)-minIntensity;\nx=pow(x,vec4(2.0))/(abs(x)+CURVE_SMOOTHNESS);\nreturn (x.rgb-x.a+color+1.0)/2.0;\n}\nvec3 filmicBlenderDynamicRangeTransform(vec3 color){\nreturn pow((0.28882259*color-0.15880336)\n/ (pow(color-0.6229693,vec3(2.0))+0.16965022)\n+ 0.20453365*color+0.37847142,vec3(3.0)\n);\n}\nvec3 FilmicBlenderToneMapping(vec3 color){\ncolor*=toneMappingExposure;\ncolor=max(color,0.000175);\ncolor=clamp((log2(color)-FILMIC_BLENDER_LOG_MIN)\n/ (FILMIC_BLENDER_LOG_MAX-FILMIC_BLENDER_LOG_MIN),0.0,1.0);\ncolor=filmicBlenderDesaturationTransform(color);\ncolor=clamp(color/FILMIC_BLENDER_EXPOSURE_LATITUDE_RATIO,0.0,1.0);\ncolor=filmicBlenderDynamicRangeTransform(color);\nreturn color;\n}\nvec3 PbrNeutralToneMapping(vec3 color){\ncolor*=toneMappingExposure;\ncolor=max(color,0.0);\nconst float startCompression=0.8-0.04;\nconst float desaturation=0.15;\nfloat x=min(color.r,min(color.g,color.b));\nfloat offset=x<0.08?x-6.25*x*x:0.04;\ncolor-=offset;\nfloat peak=max(color.r,max(color.g,color.b));\nif (peak<startCompression)\nreturn color;\nconst float d=1.0-startCompression;\nfloat newPeak=1.0-d*d/(peak+d-startCompression);\ncolor*=newPeak/peak;\nfloat g=1.0-1.0/(desaturation*(peak-newPeak)+1.);\nreturn mix(color,newPeak*vec3(1,1,1),g);\n}",uv_pars_fragment:"#if (defined(USE_UV)&&!defined(UVS_VERTEX_ONLY))\nvarying vec2 vUv;\n#endif",uv_pars_vertex:"#ifdef USE_UV\n#ifdef UVS_VERTEX_ONLY\nvec2 vUv;\n#else\nvarying vec2 vUv;\n#endif\nuniform mat3 uvTransform;\n#endif",uv_vertex:"#ifdef USE_UV\nvUv=(uvTransform*vec3(uv,1)).xy;\n#endif",uv2_pars_fragment:"#if defined(USE_LIGHTMAP)||defined(USE_AOMAP)\nvarying vec2 vUv2;\n#endif",uv2_pars_vertex:"#if defined(USE_LIGHTMAP)||defined(USE_AOMAP)\nattribute vec2 uv2;\nvarying vec2 vUv2;\nuniform mat3 uv2Transform;\n#endif",uv2_vertex:"#if defined(USE_LIGHTMAP)||defined(USE_AOMAP)\nvUv2=(uv2Transform*vec3(uv2,1)).xy;\n#endif",webgl1_compat:"float cosh(float x){\nreturn (exp(x)+exp(-x))/2.0;\n}\nvec2 cosh(vec2 x){\nreturn (exp(x)+exp(-x))/2.0;\n}\nvec3 cosh(vec3 x){\nreturn (exp(x)+exp(-x))/2.0;\n}\nvec4 cosh(vec4 x){\nreturn (exp(x)+exp(-x))/2.0;\n}\nfloat sinh(float x){\nreturn (exp(x)-exp(-x))/2.0;\n}\nvec2 sinh(vec2 x){\nreturn (exp(x)-exp(-x))/2.0;\n}\nvec3 sinh(vec3 x){\nreturn (exp(x)-exp(-x))/2.0;\n}\nvec4 sinh(vec4 x){\nreturn (exp(x)-exp(-x))/2.0;\n}\nfloat tanh(float x){\nfloat exp2x=exp(2.0*x);\nreturn (exp2x-1.0)/(exp2x+1.0);\n}\nvec2 tanh(vec2 x){\nvec2 exp2x=exp(2.0*x);\nreturn (exp2x-1.0)/(exp2x+1.0);\n}\nvec3 tanh(vec3 x){\nvec3 exp2x=exp(2.0*x);\nreturn (exp2x-1.0)/(exp2x+1.0);\n}\nvec4 tanh(vec4 x){\nvec4 exp2x=exp(2.0*x);\nreturn (exp2x-1.0)/(exp2x+1.0);\n}\nfloat trunc(float x){\nreturn floor(abs(x))*sign(x);\n}\nvec2 trunc(vec2 x){\nreturn floor(abs(x))*sign(x);\n}\nvec3 trunc(vec3 x){\nreturn floor(abs(x))*sign(x);\n}\nvec4 trunc(vec4 x){\nreturn floor(abs(x))*sign(x);\n}",worldpos_vertex:"#if defined(USE_ENVMAP)||defined(DISTANCE)||defined (USE_SHADOWMAP)||defined(MASK)||defined(NODE)\nvec4 worldPosition=vec4(transformed,1.0);\n#ifdef USE_INSTANCING\nworldPosition=instanceMatrix*worldPosition;\n#endif\nworldPosition=modelMatrix*worldPosition;\n#endif",background_vert:"varying vec2 vUv;\nuniform mat3 uvTransform;\nvoid main(){\nvUv=(uvTransform*vec3(uv,1)).xy;\ngl_Position=vec4(position.xy,1.0,1.0);\n}",background_frag:"uniform sampler2D t2D;\nuniform float backgroundIntensity;\nvarying vec2 vUv;\nvoid main(){\nvec4 texColor=texture2D(t2D,vUv);\n#ifdef DECODE_VIDEO_TEXTURE\ntexColor=vec4(mix(pow(texColor.rgb*0.9478672986+vec3(0.0521327014),vec3(2.4)),texColor.rgb*0.0773993808,vec3(lessThanEqual(texColor.rgb,vec3(0.04045)))),texColor.w);\n#endif\ntexColor.rgb*=backgroundIntensity;\ngl_FragColor=texColor;\n#include <tonemapping_fragment>\n#include <encodings_fragment>\n}",backgroundCube_vert:"varying vec3 vWorldDirection;\n#include <common>\nvoid main(){\nvWorldDirection=transformDirection(position,modelMatrix);\n#include <begin_vertex>\n#include <project_vertex>\ngl_Position.z=gl_Position.w;\n}",backgroundCube_frag:"#ifdef ENVMAP_TYPE_CUBE\nuniform samplerCube envMap;\n#elif defined(ENVMAP_TYPE_CUBE_UV)\nuniform sampler2D envMap;\n#endif\nuniform float flipEnvMap;\nuniform float backgroundBlurriness;\nuniform float backgroundIntensity;\nvarying vec3 vWorldDirection;\n#include <cube_uv_reflection_fragment>\nvoid main(){\n#ifdef ENVMAP_TYPE_CUBE\nvec4 texColor=textureCube(envMap,vec3(flipEnvMap*vWorldDirection.x,vWorldDirection.yz));\n#elif defined(ENVMAP_TYPE_CUBE_UV)\nvec4 texColor=textureCubeUV(envMap,vWorldDirection,backgroundBlurriness);\n#else\nvec4 texColor=vec4(0.0,0.0,0.0,1.0);\n#endif\ntexColor.rgb*=backgroundIntensity;\ngl_FragColor=texColor;\n#include <tonemapping_fragment>\n#include <encodings_fragment>\n}",cube_vert:"varying vec3 vWorldDirection;\n#include <common>\nvoid main(){\nvWorldDirection=transformDirection(position,modelMatrix);\n#include <begin_vertex>\n#include <project_vertex>\ngl_Position.z=gl_Position.w;\n}",cube_frag:"uniform samplerCube tCube;\nuniform float tFlip;\nuniform float opacity;\nvarying vec3 vWorldDirection;\nvoid main(){\nvec4 texColor=textureCube(tCube,vec3(tFlip*vWorldDirection.x,vWorldDirection.yz));\ngl_FragColor=texColor;\ngl_FragColor.a*=opacity;\n#include <tonemapping_fragment>\n#include <encodings_fragment>\n}",depth_vert:"#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvarying vec3 vViewPosition;\nvarying vec2 vProjectedPosZW;\nvoid main(){\n#include <uv_vertex>\n#include <skinbase_vertex>\n#ifdef USE_DISPLACEMENTMAP\n#include <beginnormal_vertex>\n#include <morphnormal_vertex>\n#include <skinnormal_vertex>\n#endif\n#include <begin_vertex>\n#include <morphtarget_vertex>\n#include <skinning_vertex>\n#include <displacementmap_vertex>\n#include <project_vertex>\n#include <logdepthbuf_vertex>\n#include <clipping_planes_vertex>\nvViewPosition=mvPosition.xyz;\nvProjectedPosZW=mat2(projectionMatrix[2][2],projectionMatrix[2][3],projectionMatrix[3][2],projectionMatrix[3][3]\n)*mvPosition.zw;\n#ifdef PANCAKE_DEPTH\ngl_Position.z=max(gl_Position.z,-1.0);\n#endif\n}",depth_frag:"#if DEPTH_PACKING==3200\nuniform float opacity;\n#endif\n#ifdef USE_SLOPE_SCALED_BIAS\nuniform float slopeScaledBias;\nconst float ONE_MINUS_EPS=0.9999999;\n#endif\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvarying vec3 vViewPosition;\nvarying vec2 vProjectedPosZW;\nvoid main(){\n#include <clipping_planes_fragment>\nvec4 diffuseColor=vec4(1.0);\n#if DEPTH_PACKING==3200\ndiffuseColor.a=opacity;\n#endif\n#include <map_fragment>\n#include <alphamap_fragment>\n#include <alphatest_fragment>\n#include <logdepthbuf_fragment>\n#if DEPTH_PACKING != 3202\nfloat depth=vProjectedPosZW.x/vProjectedPosZW.y;\ndepth=(depth+1.0)/2.0;\n#ifdef PANCAKE_DEPTH\ndepth=max(depth,0.0);\n#endif\n#ifdef USE_SLOPE_SCALED_BIAS\nvec2 dxdy=abs(vec2(dFdx(depth),dFdy(depth)));\nfloat bias=slopeScaledBias*max(dxdy.x,dxdy.y);\ndepth=clamp(depth+max(bias,1e-6),0.0,ONE_MINUS_EPS);\n#endif\n#if DEPTH_PACKING==3200\ngl_FragColor=vec4(vec3(1.0-depth),opacity);\n#elif DEPTH_PACKING==3201\ngl_FragColor=packDepthToRGBA(depth);\n#endif\n#else\ngl_FragColor=vec4(vViewPosition.z);\n#endif\n}",distanceRGBA_vert:"#define DISTANCE\nvarying vec3 vWorldPosition;\n#ifdef PANCAKE_DEPTH\nvarying vec4 vMVPPosition;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main(){\n#include <uv_vertex>\n#include <skinbase_vertex>\n#ifdef USE_DISPLACEMENTMAP\n#include <beginnormal_vertex>\n#include <morphnormal_vertex>\n#include <skinnormal_vertex>\n#endif\n#include <begin_vertex>\n#include <morphtarget_vertex>\n#include <skinning_vertex>\n#include <displacementmap_vertex>\n#include <project_vertex>\n#include <worldpos_vertex>\n#include <clipping_planes_vertex>\nvWorldPosition=worldPosition.xyz;\n#ifdef PANCAKE_DEPTH\nvec4 mvpPosition=projectionMatrix*mvPosition;\ngl_Position.z=max(mvpPosition.z,-1.0);\nvMVPPosition=mvpPosition;\n#endif\n}",distanceRGBA_frag:"#define DISTANCE\n#ifdef USE_SLOPE_SCALED_BIAS\nuniform float slopeScaledBias;\nconst float ONE_MINUS_EPS=0.9999999;\n#endif\nuniform vec3 referencePosition;\nuniform float nearDistance;\nuniform float farDistance;\nvarying vec3 vWorldPosition;\n#ifdef PANCAKE_DEPTH\nvarying vec4 vMVPPosition;\n#endif\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <clipping_planes_pars_fragment>\n#ifndef DISTANCE_SCALE\n#define DISTANCE_SCALE 1.0\n#endif\nvoid main (){\n#include <clipping_planes_fragment>\nvec4 diffuseColor=vec4(1.0);\n#include <map_fragment>\n#include <alphamap_fragment>\n#include <alphatest_fragment>\nfloat dist=length(vWorldPosition-referencePosition);\n#if DISTANCE_PACKING==3301\ndist=(dist-nearDistance)/(farDistance-nearDistance);\ndist=saturate(dist);\n#ifdef USE_SLOPE_SCALED_BIAS\nvec2 dxdy=abs(vec2(dFdx(dist),dFdy(dist)));\nfloat bias=slopeScaledBias*max(dxdy.x,dxdy.y);\ndist=clamp(dist+bias,0.0,ONE_MINUS_EPS);\n#endif\ngl_FragColor=packDepthToRGBA(dist);\n#elif DISTANCE_PACKING==3302\n#ifdef USE_SLOPE_SCALED_BIAS\nvec2 dxdy=abs(vec2(dFdx(dist),dFdy(dist)));\ndist+=slopeScaledBias*max(dxdy.x,dxdy.y);\n#endif\n#ifdef PANCAKE_DEPTH\nif (vMVPPosition.z<-1.0){\ndist=length(vec3(vMVPPosition.x*CAM_WIDTH,vMVPPosition.y*CAM_HEIGHT,nearDistance));\n}\n#endif\ngl_FragColor=vec4(dist*DISTANCE_SCALE,0.0,0.0,1.0);\n#endif\n}",linedashed_vert:"uniform float scale;\nattribute float lineDistance;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main(){\nvLineDistance=scale*lineDistance;\n#include <color_vertex>\n#include <begin_vertex>\n#include <morphtarget_vertex>\n#include <project_vertex>\n#include <logdepthbuf_vertex>\n#include <clipping_planes_vertex>\n#include <fog_vertex>\n}",linedashed_frag:"uniform vec3 diffuse;\nuniform float opacity;\nuniform float dashSize;\nuniform float totalSize;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main(){\n#include <clipping_planes_fragment>\nif (mod(vLineDistance,totalSize)>dashSize){\ndiscard;\n}\nvec3 outgoingLight=vec3(0.0);\nvec4 diffuseColor=vec4(diffuse,opacity);\n#include <logdepthbuf_fragment>\n#include <color_fragment>\noutgoingLight=diffuseColor.rgb;\n#include <output_fragment>\n#include <tonemapping_fragment>\n#include <encodings_fragment>\n#include <fog_fragment>\n#include <premultiplied_alpha_fragment>\n}",meshbasic_vert:"#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main(){\n#include <uv_vertex>\n#include <uv2_vertex>\n#include <color_vertex>\n#if defined (USE_ENVMAP)||defined (USE_SKINNING)\n#include <beginnormal_vertex>\n#include <morphnormal_vertex>\n#include <skinbase_vertex>\n#include <skinnormal_vertex>\n#include <defaultnormal_vertex>\n#endif\n#include <begin_vertex>\n#include <morphtarget_vertex>\n#include <skinning_vertex>\n#include <project_vertex>\n#include <logdepthbuf_vertex>\n#include <clipping_planes_vertex>\n#include <worldpos_vertex>\n#include <envmap_vertex>\n#include <fog_vertex>\n}",meshbasic_frag:"uniform vec3 diffuse;\nuniform float opacity;\n#ifndef FLAT_SHADED\nvarying vec3 vNormal;\n#endif\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main(){\n#include <clipping_planes_fragment>\nvec4 diffuseColor=vec4(diffuse,opacity);\n#include <logdepthbuf_fragment>\n#include <map_fragment>\n#include <color_fragment>\n#include <alphamap_fragment>\n#include <alphatest_fragment>\nReflectedLight reflectedLight=ReflectedLight(vec3(0.0),vec3(0.0),vec3(0.0),vec3(0.0));\n#ifdef USE_LIGHTMAP\nvec4 lightMapTexel=texture2D(lightMap,vUv2);\nreflectedLight.indirectDiffuse+=lightMapTexel.rgb*lightMapIntensity*RECIPROCAL_PI;\n#else\nreflectedLight.indirectDiffuse+=vec3(1.0);\n#endif\n#include <aomap_fragment>\nreflectedLight.indirectDiffuse*=diffuseColor.rgb;\nvec3 outgoingLight=reflectedLight.indirectDiffuse;\n#include <envmap_fragment>\n#include <output_fragment>\n#include <tonemapping_fragment>\n#include <encodings_fragment>\n#include <fog_fragment>\n#include <premultiplied_alpha_fragment>\n#include <dithering_fragment>\n}",meshlambert_vert:"#define LAMBERT\nvarying vec3 vViewPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main(){\n#include <uv_vertex>\n#include <uv2_vertex>\n#include <color_vertex>\n#include <beginnormal_vertex>\n#include <morphnormal_vertex>\n#include <skinbase_vertex>\n#include <skinnormal_vertex>\n#include <defaultnormal_vertex>\n#include <normal_vertex>\n#include <begin_vertex>\n#include <morphtarget_vertex>\n#include <skinning_vertex>\n#include <displacementmap_vertex>\n#include <project_vertex>\n#include <logdepthbuf_vertex>\n#include <clipping_planes_vertex>\nvViewPosition=-mvPosition.xyz;\n#include <worldpos_vertex>\n#include <envmap_vertex>\n#include <shadowmap_vertex>\n#include <fog_vertex>\n}",meshlambert_frag:"#define LAMBERT\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\n#if defined(SHADOWMAP_TYPE_ESM)||defined(USE_ENVMAP)\nuniform mat4 invViewMatrix;\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_lambert_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main(){\n#include <clipping_planes_fragment>\nvec4 diffuseColor=vec4(diffuse,opacity);\nReflectedLight reflectedLight=ReflectedLight(vec3(0.0),vec3(0.0),vec3(0.0),vec3(0.0));\nvec3 totalEmissiveRadiance=emissive;\n#include <logdepthbuf_fragment>\n#include <map_fragment>\n#include <color_fragment>\n#include <alphamap_fragment>\n#include <alphatest_fragment>\n#include <normal_fragment_begin>\n#include <normal_fragment_maps>\n#include <emissivemap_fragment>\n#include <lights_lambert_fragment>\n#include <lights_fragment_begin>\n#include <lights_fragment_maps>\n#include <lights_fragment_end>\n#include <aomap_fragment>\nvec3 outgoingLight=reflectedLight.directDiffuse+reflectedLight.indirectDiffuse+totalEmissiveRadiance;\n#include <envmap_fragment>\n#include <output_fragment>\n#include <tonemapping_fragment>\n#include <encodings_fragment>\n#include <fog_fragment>\n#include <premultiplied_alpha_fragment>\n#include <dithering_fragment>\n}",meshnormal_vert:"#define NORMAL\n#if defined(FLAT_SHADED)||defined(USE_BUMPMAP)||defined(TANGENTSPACE_NORMALMAP)\nvarying vec3 vViewPosition;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main(){\n#include <uv_vertex>\n#include <beginnormal_vertex>\n#include <morphnormal_vertex>\n#include <skinbase_vertex>\n#include <skinnormal_vertex>\n#include <defaultnormal_vertex>\n#include <normal_vertex>\n#include <begin_vertex>\n#include <morphtarget_vertex>\n#include <skinning_vertex>\n#include <displacementmap_vertex>\n#include <project_vertex>\n#include <logdepthbuf_vertex>\n#include <clipping_planes_vertex>\n#if defined(FLAT_SHADED)||defined(USE_BUMPMAP)||defined(TANGENTSPACE_NORMALMAP)\nvViewPosition=-mvPosition.xyz;\n#endif\n}",meshnormal_frag:"#define NORMAL\nuniform float opacity;\n#if defined(FLAT_SHADED)||defined(USE_BUMPMAP)||defined(TANGENTSPACE_NORMALMAP)\nvarying vec3 vViewPosition;\n#endif\n#include <packing>\n#include <uv_pars_fragment>\n#include <normal_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main(){\n#include <clipping_planes_fragment>\n#include <logdepthbuf_fragment>\n#include <normal_fragment_begin>\n#include <normal_fragment_maps>\ngl_FragColor=vec4(packNormalToRGB(normal),opacity);\n#ifdef OPAQUE\ngl_FragColor.a=1.0;\n#endif\n}",meshphysical_vert:"#define STANDARD\nvarying vec3 vViewPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\n#include <plane_reflection_pars_vertex>\nvoid main(){\n#include <uv_vertex>\n#include <uv2_vertex>\n#include <color_vertex>\n#include <beginnormal_vertex>\n#include <morphnormal_vertex>\n#include <skinbase_vertex>\n#include <skinnormal_vertex>\n#include <defaultnormal_vertex>\n#include <normal_vertex>\n#include <begin_vertex>\n#include <morphtarget_vertex>\n#include <skinning_vertex>\n#include <displacementmap_vertex>\n#include <project_vertex>\n#include <plane_reflection_vertex>\n#include <logdepthbuf_vertex>\n#include <clipping_planes_vertex>\nvViewPosition=-mvPosition.xyz;\n#include <worldpos_vertex>\n#include <shadowmap_vertex>\n#include <fog_vertex>\n}",meshphysical_frag:"#define STANDARD\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n#if defined(SHADOWMAP_TYPE_ESM)||defined(USE_ENVMAP)\nuniform mat4 invViewMatrix;\n#endif\n#if defined(USE_PLANE_REFLECTION)\nuniform mat4 modelMatrix;\n#endif\nvarying vec3 vViewPosition;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <bsdfs>\n#include <cube_uv_reflection_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_physical_pars_fragment>\n#include <fog_pars_fragment>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_physical_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\n#include <plane_reflection_pars_fragment>\n#include <oit_weighted_pars_fragment>\nvoid main(){\n#include <clipping_planes_fragment>\nvec4 diffuseColor=vec4(diffuse,opacity);\nReflectedLight reflectedLight=ReflectedLight(vec3(0.0),vec3(0.0),vec3(0.0),vec3(0.0));\nvec3 totalEmissiveRadiance=emissive;\n#include <logdepthbuf_fragment>\n#include <map_fragment>\n#include <color_fragment>\n#include <alphamap_fragment>\n#include <alphatest_fragment>\n#include <roughnessmap_fragment>\n#include <metalnessmap_fragment>\n#include <normal_fragment_begin>\n#include <normal_fragment_maps>\n#include <emissivemap_fragment>\n#include <lights_physical_fragment>\n#include <lights_fragment_begin>\n#include <lights_fragment_maps>\n#include <lights_fragment_end>\n#include <aomap_fragment>\nvec3 totalDiffuse=reflectedLight.directDiffuse+reflectedLight.indirectDiffuse;\nvec3 totalSpecular=reflectedLight.directSpecular+reflectedLight.indirectSpecular;\nvec3 outgoingLight=totalDiffuse+totalSpecular+totalEmissiveRadiance;\n#include <output_fragment>\n#include <tonemapping_fragment>\n#include <encodings_fragment>\n#include <fog_fragment>\n#include <premultiplied_alpha_fragment>\n#include <dithering_fragment>\n#include <oit_weighted_fragment>\n}",points_vert:"uniform float size;\nuniform float scale;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main(){\n#include <color_vertex>\n#include <begin_vertex>\n#include <morphtarget_vertex>\n#include <project_vertex>\ngl_PointSize=size;\n#ifdef USE_SIZEATTENUATION\nbool isPerspective=isPerspectiveMatrix(projectionMatrix);\nif (isPerspective)gl_PointSize*=(scale/- mvPosition.z);\n#endif\n#include <logdepthbuf_vertex>\n#include <clipping_planes_vertex>\n#include <worldpos_vertex>\n#include <fog_vertex>\n}",points_frag:"uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <color_pars_fragment>\n#include <map_particle_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main(){\n#include <clipping_planes_fragment>\nvec3 outgoingLight=vec3(0.0);\nvec4 diffuseColor=vec4(diffuse,opacity);\n#include <logdepthbuf_fragment>\n#include <map_particle_fragment>\n#include <color_fragment>\n#include <alphatest_fragment>\noutgoingLight=diffuseColor.rgb;\n#include <output_fragment>\n#include <tonemapping_fragment>\n#include <encodings_fragment>\n#include <fog_fragment>\n#include <premultiplied_alpha_fragment>\n}",shadow_vert:"#include <common>\n#ifdef USE_SHADOWMAP\nvarying vec3 vViewPosition;\n#endif\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\nvoid main(){\n#include <beginnormal_vertex>\n#include <morphnormal_vertex>\n#include <skinbase_vertex>\n#include <skinnormal_vertex>\n#include <defaultnormal_vertex>\n#include <begin_vertex>\n#include <morphtarget_vertex>\n#include <skinning_vertex>\n#include <project_vertex>\n#include <worldpos_vertex>\n#include <shadowmap_vertex>\n#include <fog_vertex>\n#ifdef USE_SHADOWMAP\nvViewPosition=-mvPosition.xyz;\n#endif\n}",shadow_frag:"uniform vec3 color;\nuniform float opacity;\n#ifdef USE_SHADOWMAP\nvarying vec3 vViewPosition;\n#ifdef SHADOWMAP_TYPE_ESM\nuniform mat4 invViewMatrix;\n#endif\n#endif\n#include <common>\n#include <packing>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\nvoid main(){\ngl_FragColor=vec4(color,opacity*(1.0-getShadowMask()));\n#include <tonemapping_fragment>\n#include <encodings_fragment>\n#include <fog_fragment>\n}",sprite_vert:"uniform float rotation;\nuniform vec2 center;\n#include <common>\n#include <uv_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main(){\n#include <uv_vertex>\nvec4 mvPosition=modelViewMatrix*vec4(0.0,0.0,0.0,1.0);\nvec2 scale;\nscale.x=length(vec3(modelMatrix[0].x,modelMatrix[0].y,modelMatrix[0].z));\nscale.y=length(vec3(modelMatrix[1].x,modelMatrix[1].y,modelMatrix[1].z));\n#ifndef USE_SIZEATTENUATION\nbool isPerspective=isPerspectiveMatrix(projectionMatrix);\nif (isPerspective)scale*=-mvPosition.z;\n#endif\nvec2 alignedPosition=(position.xy-(center-vec2(0.5)))*scale;\nvec2 rotatedPosition;\nrotatedPosition.x=cos(rotation)*alignedPosition.x-sin(rotation)*alignedPosition.y;\nrotatedPosition.y=sin(rotation)*alignedPosition.x+cos(rotation)*alignedPosition.y;\nmvPosition.xy+=rotatedPosition;\ngl_Position=projectionMatrix*mvPosition;\n#include <logdepthbuf_vertex>\n#include <clipping_planes_vertex>\n#include <fog_vertex>\n}",sprite_frag:"uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main(){\n#include <clipping_planes_fragment>\nvec3 outgoingLight=vec3(0.0);\nvec4 diffuseColor=vec4(diffuse,opacity);\n#include <logdepthbuf_fragment>\n#include <map_fragment>\n#include <alphamap_fragment>\n#include <alphatest_fragment>\noutgoingLight=diffuseColor.rgb;\n#include <output_fragment>\n#include <tonemapping_fragment>\n#include <encodings_fragment>\n#include <fog_fragment>\n}",mask_vert:"#define MASK\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nuniform mat4 textureMatrix;\nvarying vec3 vViewPosition;\nvarying vec4 projTexCoord;\nvoid main(){\n#include <uv_vertex>\n#include <skinbase_vertex>\n#ifdef USE_DISPLACEMENTMAP\n#include <beginnormal_vertex>\n#include <morphnormal_vertex>\n#include <skinnormal_vertex>\n#endif\n#include <begin_vertex>\n#include <morphtarget_vertex>\n#include <skinning_vertex>\n#include <displacementmap_vertex>\n#include <project_vertex>\nvViewPosition=-mvPosition.xyz;\n#include <worldpos_vertex>\nprojTexCoord=textureMatrix*worldPosition;\n#include <logdepthbuf_vertex>\n#include <clipping_planes_vertex>\n}",mask_frag:"#define MASK\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nuniform float opacity;\nuniform sampler2D depthTexture;\nuniform vec2 cameraNearFar;\nvarying vec3 vViewPosition;\nvarying vec4 projTexCoord;\nvoid main(){\n#include <clipping_planes_fragment>\nvec4 diffuseColor=vec4(1.0);\ndiffuseColor.a=opacity;\n#include <map_fragment>\n#include <alphamap_fragment>\n#include <alphatest_fragment>\n#include <logdepthbuf_fragment>\nfloat depth=unpackRGBAToDepth(texture2DProj(depthTexture,projTexCoord));\nfloat viewZ;\nif (isOrthographic)\nviewZ=-orthographicDepthToViewZ(depth,cameraNearFar.x,cameraNearFar.y);\nelse\nviewZ=-perspectiveDepthToViewZ(depth,cameraNearFar.x,cameraNearFar.y);\nfloat depthTest=(vViewPosition.z>viewZ)?1.0:0.0;\ngl_FragColor=vec4(0.0,depthTest,1.0,0.0);\n}",meshnode_vert:"#define NODE\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\nvarying vec3 vNormal;\n#endif\n#include <common>\n#include <displacementmap_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\n#include <plane_reflection_pars_vertex>\n#if defined(NODE_REFLECT_REFRACT_MX)||defined(NODE_BITMAP_ENV_MX)||defined(NODE_BUMP_BL)||defined(NODE_PHY_SUN_SKY_ENV_MX)||defined(NODE_ENV_SPHERE_MY)||defined(NODE_UV_PROJECTION_AR)||defined(NODE_SUB_TRANSFORM_MX)||defined(NODE_SUB_TRANSFORM_MY)\nvarying vec3 vWorldPosition;\n#endif\n#include <node_pars_vertex>\nvoid main(){\n#include <beginnormal_vertex>\n#include <morphnormal_vertex>\n#include <skinbase_vertex>\n#include <skinnormal_vertex>\n#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\nvNormal=normalize(transformedNormal);\n#endif\n#include <begin_vertex>\n#include <morphtarget_vertex>\n#include <skinning_vertex>\n#include <displacementmap_vertex>\n#include <project_vertex>\n#include <plane_reflection_vertex>\n#include <logdepthbuf_vertex>\n#include <clipping_planes_vertex>\nvViewPosition=-mvPosition.xyz;\n#include <worldpos_vertex>\n#include <shadowmap_vertex>\n#include <fog_vertex>\n#if defined(NODE_REFLECT_REFRACT_MX)||defined(NODE_BITMAP_ENV_MX)||defined(NODE_BUMP_BL)||defined(NODE_PHY_SUN_SKY_ENV_MX)||defined(NODE_ENV_SPHERE_MY)||defined(NODE_UV_PROJECTION_AR)||defined(NODE_SUB_TRANSFORM_MX)||defined(NODE_SUB_TRANSFORM_MY)\nvWorldPosition=worldPosition.xyz;\n#endif\n#include <node_vertex>\n}",meshnode_frag:"#define NODE\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <bsdfs>\n#include <cube_uv_reflection_fragment>\n#include <envmap_common_pars_fragment>\n#if defined(NODE_NEW_GEOMETRY_BL)||defined(NODE_VECT_TRANSFORM_BL)||defined(NODE_TEX_COORD_BL)||defined(NODE_NORMAL_MAP_BL)||defined(NODE_LAYER_WEIGHT_BL)||defined(NODE_FRESNEL_BL)||defined(NODE_BUMP_BL)||defined(NODE_BSDF_GLASS_BL)||defined(NODE_BSDF_PRINCIPLED_BL)||defined(NODE_TANGENT_BL)||defined(NODE_BITMAP_MX)||defined(NODE_GRADIENT_MX)||defined(NODE_GRADIENT_RAMP_MX)||defined(NODE_NOISE_MX)||defined(NODE_SUB_TRANSFORM_MX)||defined(NODE_SUB_TRANSFORM_MY)||defined(NODE_SAMPLER_INFO_MY)||defined(NODE_INCIDENT)||defined(NODE_POSITION)||defined(NODE_NORMAL)||defined(USE_OSL)||defined(USE_ENVMAP)||defined(SHADOWMAP_TYPE_ESM)&&(defined(NODE_BSDF_DIFFUSE_BL)||defined(NODE_DIFFUSE_BSDF_BL)||defined(NODE_EEVEE_SPECULAR_BL)||defined(NODE_BSDF_GLOSSY_BL)||defined(NODE_BSDF_REFRACTION_BL)||defined(NODE_MATERIAL_MX)||defined(NODE_PHYSICAL_MX)||defined(NODE_STANDARD_SURFACE_AR)||defined(NODE_SHADOW_MATTE_AR))\nuniform mat4 invViewMatrix;\n#endif\n#include <envmap_physical_pars_fragment>\n#include <fog_pars_fragment>\n#include <lights_pars_begin>\n#include <lights_node_pars_fragment>\n#include <lights_node_gtao_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\n#if defined(USE_SSR)\nuniform mat4 projectionMatrix;\n#endif\n#if defined(NODE_VECT_TRANSFORM_BL)||defined(NODE_TEX_COORD_BL)||defined(NODE_NEW_GEOMETRY_BL)||defined(NODE_TANGENT_BL)||defined(NODE_OBJECT_INFO_BL)||defined(NODE_BITMAP_MX)||defined(NODE_GRADIENT_MX)||defined(NODE_GRADIENT_RAMP_MX)||defined(NODE_NOISE_MX)||defined(NODE_SAMPLER_INFO_MY)||defined(NODE_TRANSFORM_MY)||defined(USE_OSL)||defined(USE_PLANE_REFLECTION)||defined(NODE_UV_PROJECTION_AR)||defined(NODE_SUB_TRANSFORM_MX)||defined(NODE_SUB_TRANSFORM_MY)\nuniform mat4 modelMatrix;\nuniform mat4 invModelMatrix;\n#endif\n#if defined(NODE_VECT_TRANSFORM_BL)||defined(NODE_NORMAL_MAP_BL)||defined(NODE_NORMAL_BUMP_MX)||defined(NODE_BUMP_2D_MY)||defined(NODE_SAMPLER_INFO_MY)\nuniform mat4 modelViewMatrix;\n#endif\n#if defined(NODE_TEX_IMAGE_BL)\nuniform mat3 normalMatrix;\n#endif\n#if defined(NODE_TEX_COORD_BL)||defined(NODE_NEW_GEOMETRY_BL)||defined(NODE_TANGENT_BL)\nuniform vec3 boundingBoxMin;\nuniform vec3 boundingBoxMax;\n#endif\n#if defined(NODE_REFLECT_REFRACT_MX)||defined(NODE_BITMAP_ENV_MX)||defined(NODE_BUMP_BL)||defined(NODE_PHY_SUN_SKY_ENV_MX)||defined(NODE_ENV_SPHERE_MY)||defined(NODE_UV_PROJECTION_AR)||defined(NODE_SUB_TRANSFORM_MX)||defined(NODE_SUB_TRANSFORM_MY)\nvarying vec3 vWorldPosition;\n#endif\n#if defined(NODE_TEX_COORD_BL)\nuniform vec2 viewWidthHeight;\n#endif\n#include <ssr_pars_fragment>\n#include <plane_reflection_pars_fragment>\n#include <node_common_frag>\n#include <node_pars_fragment>\n#include <oit_weighted_pars_fragment>\nvoid main(){\n#include <clipping_planes_fragment>\n#include <logdepthbuf_fragment>\n#include <normal_fragment_begin>\nvec4 outgoingLight=vec4(0.0);\n#include <node_fragment>\n#if WORLD_NODES==1\noutgoingLight.a=1.0;\n#endif\n#ifdef USE_ALPHATEST\nif (outgoingLight.a<alphaTest)\ndiscard;\nelse\noutgoingLight.a=1.0;\n#endif\n#if defined(OPAQUE)&&!(defined(NODE_HOLDOUT_BL)||defined(NODE_MATTE_SHADOW_MX)||defined(NODE_SHADOW_MATTE_AR))\noutgoingLight.a=1.0;\n#endif\ngl_FragColor=vec4(outgoingLight);\n#include <tonemapping_fragment>\n#include <encodings_fragment>\n#include <fog_fragment>\n#include <premultiplied_alpha_fragment>\n#include <dithering_fragment>\n#include <normal_output_fragment>\n#include <oit_weighted_fragment>\n}",lights_node_pars_fragment:"\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\nvarying vec3 vNormal;\n#endif\nstruct NodeMaterial {\nvec3 diffuseColor;\nfloat roughness;\nvec3 specularColor;\nfloat specularF90;\nvec3 fresnelRefl90;\nvec3 refractionColor;\nfloat refractionRoughness;\nfloat refractionIOR;\n#ifdef USE_CLEARCOAT\nfloat clearcoat;\nfloat clearcoatRoughness;\nvec3 clearcoatF0;\nfloat clearcoatF90;\n#endif\n#ifdef USE_SHEEN\nvec3 sheenColor;\nfloat sheenRoughness;\n#endif\n};\nvec3 clearcoatSpecular=vec3(0.0);\nvec3 sheenSpecular=vec3(0.0);\nfloat IBLSheenBRDF(const in vec3 normal,const in vec3 viewDir,const in float roughness){\nfloat dotNV=saturate(dot(normal,viewDir));\nfloat r2=roughness*roughness;\nfloat a=roughness<0.25?-339.2*r2+161.4*roughness-25.9:-8.48*r2+14.3*roughness-9.95;\nfloat b=roughness<0.25?44.0*r2-23.7*roughness+3.26:1.97*r2-3.27*roughness+0.72;\nfloat DG=exp(a*dotNV+b)+(roughness<0.25?0.0:0.1*(roughness-0.25));\nreturn saturate(DG*RECIPROCAL_PI);\n}\n#if NUM_RECT_AREA_LIGHTS>0\nvoid RE_Direct_RectArea_Node(const in RectAreaLight rectAreaLight,const in GeometricContext geometry,const in NodeMaterial material,inout ReflectedLight reflectedLight){\nvec3 normal=geometry.normal;\nvec3 viewDir=geometry.viewDir;\nvec3 position=geometry.position;\nvec3 lightPos=rectAreaLight.position;\nvec3 halfWidth=rectAreaLight.halfWidth;\nvec3 halfHeight=rectAreaLight.halfHeight;\nvec3 lightColor=rectAreaLight.color;\nfloat roughness=material.roughness;\nvec3 rectCoords[4];\nrectCoords[0]=lightPos+halfWidth-halfHeight;\nrectCoords[1]=lightPos-halfWidth-halfHeight;\nrectCoords[2]=lightPos-halfWidth+halfHeight;\nrectCoords[3]=lightPos+halfWidth+halfHeight;\nvec2 uv=LTC_Uv(normal,viewDir,roughness);\nvec4 t1=texture2D(ltc_1,uv);\nvec4 t2=texture2D(ltc_2,uv);\nmat3 mInv=mat3(vec3(t1.x,0,t1.y),vec3( 0,1,0),vec3(t1.z,0,t1.w)\n);\nvec3 fresnel=(material.specularColor*t2.x+(vec3(1.0)-material.specularColor)*t2.y);\nreflectedLight.directSpecular+=lightColor*fresnel*LTC_Evaluate(normal,viewDir,position,mInv,rectCoords);\nreflectedLight.directDiffuse+=lightColor*material.diffuseColor*LTC_Evaluate(normal,viewDir,position,mat3(1.0),rectCoords);\n}\n#endif\nvoid RE_Direct_Node(const in IncidentLight directLight,const in GeometricContext geometry,const in NodeMaterial material,inout ReflectedLight reflectedLight){\nfloat dotNL=saturate(dot(geometry.normal,directLight.direction));\nvec3 irradiance=dotNL*directLight.color;\n#ifdef USE_CLEARCOAT\nfloat dotNLcc=saturate(dot(geometry.clearcoatNormal,directLight.direction));\nvec3 ccIrradiance=dotNLcc*directLight.color;\nclearcoatSpecular+=ccIrradiance*BRDF_GGX(directLight.direction,geometry.viewDir,geometry.clearcoatNormal,material.clearcoatF0,material.clearcoatF90,material.clearcoatRoughness);\n#endif\n#ifdef USE_SHEEN\nsheenSpecular+=irradiance*BRDF_Sheen(directLight.direction,geometry.viewDir,geometry.normal,material.sheenColor,material.sheenRoughness);\n#endif\nreflectedLight.directSpecular+=irradiance*BRDF_GGX(directLight.direction,geometry.viewDir,geometry.normal,material.specularColor,material.specularF90,material.roughness);\nreflectedLight.directDiffuse+=irradiance*BRDF_Lambert(material.diffuseColor);\n}\nvoid RE_IndirectDiffuse_Node(const in vec3 irradiance,const in GeometricContext geometry,const in NodeMaterial material,inout ReflectedLight reflectedLight){\nreflectedLight.indirectDiffuse+=irradiance*BRDF_Lambert(material.diffuseColor);\n}\nvoid RE_IndirectSpecular_Node(const in vec3 radiance,const in vec3 irradiance,const in vec3 clearcoatRadiance,const in GeometricContext geometry,const in NodeMaterial material,inout ReflectedLight reflectedLight){\n#ifdef USE_CLEARCOAT\nclearcoatSpecular+=clearcoatRadiance*BRDF_Specular_GGX_Environment(geometry.viewDir,geometry.clearcoatNormal,material.clearcoatF0,vec3(material.clearcoatF90),material.clearcoatRoughness);\n#endif\n#ifdef USE_SHEEN\nsheenSpecular+=irradiance*material.sheenColor*IBLSheenBRDF(geometry.normal,geometry.viewDir,material.sheenRoughness);\n#endif\n#ifdef MT_BLENDER\nvec3 specEnv=BRDF_Specular_GGX_Environment(geometry.viewDir,geometry.normal,material.specularColor,material.fresnelRefl90,material.roughness);\n#elif defined(MT_MAX)\nfloat alphaEnv=pow2(pow2(material.roughness));\nvec3 specEnv=material.specularColor/(1.0-alphaEnv+PI*alphaEnv);\n#elif defined(MT_MAYA)\nvec3 specEnv=BRDF_Specular_GGX_Environment(geometry.viewDir,geometry.normal,material.specularColor,material.fresnelRefl90,material.roughness);\n#else\nvec3 specEnv=vec3(1.0);\n#endif\nreflectedLight.indirectSpecular+=radiance*specEnv;\n}\nvoid RE_Refraction_Node(const vec3 refraction,const NodeMaterial material,inout vec3 refractedLight){\nrefractedLight+=refraction*material.refractionColor;\n}\nvoid RE_DirectDiffuseOnly_Node(const in IncidentLight directLight,const in GeometricContext geometry,const in NodeMaterial material,inout ReflectedLight reflectedLight){\nfloat dotNL=saturate(dot(geometry.normal,directLight.direction));\nvec3 irradiance=dotNL*directLight.color;\nreflectedLight.directDiffuse+=irradiance*BRDF_Lambert(material.diffuseColor);\n}\nvoid RE_IndirectDiffuse_Empty(const in vec3 irradiance,const in GeometricContext geometry,const in NodeMaterial material,inout ReflectedLight reflectedLight){}\n#define RE_Direct_RectArea RE_Direct_RectArea_Node",lights_node_gtao_pars_fragment:"#ifdef USE_GTAO\nuniform sampler2D gtaoMap;\nuniform vec2 currResolution;\nfloat calcGTAOVisibilityFix(vec3 viewDir,vec3 normal){\nfloat slopeCoeff=saturate(dot(viewDir,normal));\nreturn pow(2.0/(slopeCoeff+1.0),log2(PI)-1.0);\n}\nfloat calcSolidAngle(float radiusAngle){\nreturn PI2*(1.0-cos(radiusAngle));\n}\nfloat calcSolidAnglesIntersectionApprox(float radiusAngle0,float radiusAngle1,float distanceAngle){\nfloat rp=radiusAngle0,rl=radiusAngle1,d=distanceAngle;\nfloat rDiff=abs(rp-rl);\nreturn PI2*(1.0-cos(min(rp,rl)))*smoothstep(0.0,1.0,1.0 -\n(d-rDiff)/(rp+rl-rDiff));\n}\nfloat calcGTSOVisibility(float aoVisibility,vec3 bentNormal,vec3 viewDir,vec3 normal,float roughness){\naoVisibility=saturate(aoVisibility*calcGTAOVisibilityFix(viewDir,normal));\nfloat radiusAngleVisCone=acos(clamp(sqrt(1.0-aoVisibility),-1.0,1.0));\nfloat radiusAngleSpecCone=acos(clamp(exp2(-3.32193*pow2(roughness)),-1.0,1.0));\nradiusAngleSpecCone=max(0.001,radiusAngleSpecCone);\nvec3 specularConeAxis=-reflect(viewDir,normal);\nfloat distanceAngle=acos(clamp(dot(bentNormal,specularConeAxis),-1.0,1.0));\nfloat solidAngleIntersection=calcSolidAnglesIntersectionApprox(radiusAngleVisCone,radiusAngleSpecCone,distanceAngle);\nfloat solidAngleSpecular=calcSolidAngle(radiusAngleSpecCone);\nfloat specVisibility=solidAngleIntersection/solidAngleSpecular;\nreturn mix(specVisibility,1.0,aoVisibility);\n}\n#endif",lights_fragment_gtso:"#ifdef USE_GTAO\nreflectedLight.indirectSpecular*=calcGTSOVisibility(gtaoVisibility,gtaoBentNormal,gtaoViewDir,gtaoNormal,gtaoRoughness);\n#endif",normal_output_fragment:"#if NORMAL_OUTPUT==1\ngl_FragColor=vec4(packNormalToRGB(normal),gl_FragColor.a);\n#endif",ssr_pars_fragment:"#ifdef USE_SSR\nuniform sampler2D ssrSourceBuffer;\nuniform sampler2D ssrDepthBuffer;\nuniform sampler2D ssrBackfaceDepthBuffer;\nuniform mat4 invProjectionMatrix;\nuniform float ssrStride;\nuniform float ssrJitter;\nuniform float ssrMaxDistance;\n#ifdef USE_SSR_REFRACT\n#define STEPS_FADE_AMOUNT 0.1\n#define SCREEN_FADE_THRESHOLD 0.6\n#else\n#define STEPS_FADE_AMOUNT 1.0\n#define SCREEN_FADE_THRESHOLD 0.6\n#endif\nvec3 deproject(vec3 p){\nvec4 res=invProjectionMatrix*vec4(p,1);\nreturn res.xyz/res.w;\n}\nbool doesIntersect(float rayzmax,float rayzmin,ivec2 uv){\nfloat sceneZMin=texelFetch(ssrDepthBuffer,uv,0).r;\nif (sceneZMin==0.0)\nreturn false;\n#ifdef USE_SSR_REFRACT\nreturn rayzmax<=sceneZMin;\n#else\nfloat sceneZMax=texelFetch(ssrBackfaceDepthBuffer,uv,0).r;\nif (sceneZMax==0.0)\nsceneZMax=-1e6;\nreturn rayzmin>=sceneZMax&&rayzmax<=sceneZMin;\n#endif\n}\nfloat distanceSquared(vec2 a,vec2 b){\na-=b;\nreturn dot(a,a);\n}\nvoid swapIfBigger(inout float a,inout float b){\nif (a>b){\nfloat t=a;\na=b;\nb=t;\n}\n}\nvec3 computeSSR(vec3 color,vec3 normal,float ior){\nvec3 vpos=-vViewPosition;\n#ifdef USE_SSR_REFRACT\nvec3 dir=normalize(refract(normalize(vpos),normalize(normal),1.0/ior));\n#else\nvec3 dir=normalize(reflect(normalize(vpos),normalize(normal)));\n#endif\nfloat maxDist=ssrMaxDistance;\nfloat nearClip=deproject(vec3(0,0,-1)).z;\nfloat rayLength=(vpos.z+dir.z*maxDist)>nearClip?(nearClip-vpos.z)/dir.z:maxDist;\nvec3 csOrig=vpos;\nvec3 csEndPoint=csOrig+dir*rayLength;\nvec4 H0=projectionMatrix*vec4(csOrig,1.0);\nvec4 H1=projectionMatrix*vec4(csEndPoint,1.0);\nfloat k0=1.0/H0.w,k1=1.0/H1.w;\nvec3 Q0=csOrig.xyz*k0,Q1=csEndPoint.xyz*k1;\nvec2 P0=H0.xy*k0,P1=H1.xy*k1;\nP0=P0*0.5+vec2(0.5),P1=P1*0.5+vec2(0.5);\n#ifndef SSR_SIMPLE_REFRACT\nvec2 ssrResolution=vec2(textureSize(ssrDepthBuffer,0));\nP0*=ssrResolution,P1*=ssrResolution;\nP1+=vec2((distanceSquared(P0,P1)<0.0001)?0.01:0.0);\nvec2 delta=P1-P0;\nbool permute=false;\nif (abs(delta.x)<abs(delta.y)){\npermute=true;\ndelta=delta.yx;\nP0=P0.yx;\nP1=P1.yx;\n}\nfloat stepDir=sign(delta.x);\nfloat invdx=stepDir/delta.x;\nvec3 dQ=(Q1-Q0)*invdx;\nfloat dk=(k1-k0)*invdx;\nvec2 dP=vec2(stepDir,delta.y*invdx);\nfloat pixelStride=ssrStride;\nfloat jitterMod=(gl_FragCoord.x+gl_FragCoord.y)*0.25;\nvec4 PQK=vec4(P0,Q0.z,k0);\nvec4 dPQK=vec4(dP,dQ.z,dk);\ndPQK*=pixelStride;\nPQK+=dPQK*mod(jitterMod,1.0)*ssrJitter;\nfloat end=P1.x*stepDir;\nfloat prevZMaxEstimate=PQK.z/PQK.w;\nfloat rayZMin=prevZMaxEstimate,rayZMax=prevZMaxEstimate;\nfloat stepped=0.0;\nvec2 hitPixel,hitUV;\nbool intersected=false;\nfor (float stepCount=1.0;stepCount<=float(MAX_STEPS);stepCount ++){\nrayZMin=prevZMaxEstimate;\nrayZMax=(dPQK.z*0.5+PQK.z)/(dPQK.w*0.5+PQK.w);\nprevZMaxEstimate=rayZMax;\nswapIfBigger(rayZMax,rayZMin);\nstepped=stepCount;\nhitPixel=(permute?PQK.yx: PQK.xy);\nhitUV=hitPixel/ssrResolution;\nintersected=doesIntersect(rayZMax,rayZMin,ivec2(hitPixel));\nif (intersected||(PQK.x*stepDir)>end)\nbreak;\nPQK+=dPQK;\n}\nif (intersected&&pixelStride>1.0){\nPQK-=dPQK;\ndPQK/=ssrStride;\nfloat ogStride=pixelStride*0.5;\nfloat currStride=pixelStride;\nprevZMaxEstimate=PQK.z/PQK.w;\nrayZMin=prevZMaxEstimate,rayZMax=prevZMaxEstimate;\nfor (int j=0;j<int(BINARY_SEARCH_ITERATIONS);j++){\nPQK+=dPQK*currStride;\nrayZMin=prevZMaxEstimate;\nrayZMax=(dPQK.z*0.5+PQK.z)/(dPQK.w*0.5+PQK.w);\nprevZMaxEstimate=rayZMax;\nswapIfBigger(rayZMax,rayZMin);\nvec2 newPixel=(permute?PQK.yx: PQK.xy);\nvec2 newUV=newPixel/ssrResolution;\nogStride*=0.5;\nif (doesIntersect(rayZMax,rayZMin,ivec2(newPixel))){\nhitUV=newUV;\ncurrStride=-ogStride;\n} else {\ncurrStride=ogStride;\n}\n}\n}\nvec3 result=color;\nif (intersected){\nvec4 col=texture(ssrSourceBuffer,hitUV);\nvec2 ndc=abs(hitUV*2.0-1.0);\nfloat maxndc=max(ndc.x,ndc.y);\nfloat fadeVal =\n(1.0-(max(0.0,maxndc-SCREEN_FADE_THRESHOLD)/(1.0-SCREEN_FADE_THRESHOLD)))*\n(1.0-STEPS_FADE_AMOUNT*(stepped/float(MAX_STEPS)));\ncol.a=fadeVal;\nresult=mix(result,col.rgb,col.a);\n}\n#else\nvec3 result=texture(ssrSourceBuffer,P1).xyz;\n#endif\nreturn result;\n}\n#endif",plane_reflection_pars_vertex:"#ifdef USE_PLANE_REFLECTION\nuniform mat4 planeReflTextureMatrix;\nvarying vec4 vPlaneReflUv;\n#endif",plane_reflection_pars_fragment:"#ifdef USE_PLANE_REFLECTION\nuniform sampler2D planeReflTexture;\nuniform mat4 planeReflTextureMatrix;\nuniform vec3 planeReflDir;\nuniform vec3 planeReflBoundingBoxMin;\nuniform vec3 planeReflBoundingBoxMax;\nuniform mat4 planeReflInvModelMatrix;\nuniform float planeReflFalloff;\nvarying vec4 vPlaneReflUv;\nvec3 computePlaneReflection(vec3 radiance,float roughness,vec3 position,vec3 normal,mat4 modelMatrix){\nvec3 posRefl=(planeReflInvModelMatrix*invViewMatrix*vec4(position,1.0)).xyz;\nif (any(lessThan(posRefl,planeReflBoundingBoxMin))||any(greaterThan(posRefl,planeReflBoundingBoxMax)))\nreturn radiance;\nvec3 norWorld=transformDirection(normal,invViewMatrix);\nvec3 uvNormalOffsetScale;\nuvNormalOffsetScale.x=length(vec3(modelMatrix[0].xyz));\nuvNormalOffsetScale.y=length(vec3(modelMatrix[1].xyz));\nuvNormalOffsetScale.z=length(vec3(modelMatrix[2].xyz));\nvec4 uvNormalOffset=planeReflTextureMatrix*vec4((norWorld-planeReflDir)*uvNormalOffsetScale,0.0);\nvec3 result=texture2DProj(planeReflTexture,vPlaneReflUv+uvNormalOffset).rgb;\nfloat falloffFactor;\nif (planeReflFalloff<EPSILON)\nfalloffFactor=0.0;\nelse if (posRefl.y>0.0)\nfalloffFactor=1.0-clamp((planeReflBoundingBoxMax.y-posRefl.y)/(planeReflBoundingBoxMax.y*(planeReflFalloff)),0.0,1.0);\nelse\nfalloffFactor=1.0-clamp((planeReflBoundingBoxMin.y-posRefl.y)/(planeReflBoundingBoxMin.y*(planeReflFalloff)),0.0,1.0);\nresult=mix(result,radiance,falloffFactor);\nresult=mix(result,radiance,(roughness<0.0526)?0.0:saturate(10.0*roughness));\nreturn result;\n}\n#endif",plane_reflection_vertex:"#ifdef USE_PLANE_REFLECTION\nvPlaneReflUv=planeReflTextureMatrix*modelMatrix*vec4(transformed,1.0);\n#endif",oit_weighted_pars_fragment:"#ifdef USE_OIT_WEIGHTED\nlayout(location=1)out float outFragR;\n#endif",oit_weighted_fragment:"#ifdef USE_OIT_WEIGHTED\nfloat weight=1.0-gl_FragCoord.z;\noutFragR=gl_FragColor.a*weight;\noutFragColor=vec4(gl_FragColor.rgb*weight,gl_FragColor.a);\n#endif",node_common_frag:"\n#define LUM_WEIGHTS vec3(0.2126,0.7152,0.0722)\n#define LUM_WEIGHTS_MAYA vec3(0.3,0.59,0.11)\n#define LUMENS_PER_WATT 683.0\n#define MAX_ENV_COORDS_DIR 0\n#define MAX_ENV_COORDS_REFLECT 1\n#define MAX_ENV_COORDS_REFRACT 2\n#if defined(NODE_COLOR_CONVERT_AR)||defined(NODE_COLOR_CORRECT_AR)||defined(NODE_COMBINE_COLOR_BL)||defined(NODE_SEPARATE_COLOR_BL)||defined(NODE_HUE_SAT_BL)||defined(NODE_COLOR_CORRECTION_MX)||defined(NODE_COMPOSITE_LAYER_MX)||defined(NODE_COLOR_CORRECT_MY)||defined(USE_OSL)\n#define HSV_NODES\n#endif\n#define OPENPBR_EMISSION_LUM_FACTOR 0.001\nfloat powCompat(const in float val,const in float power){\nif (power==0.0)\nreturn 1.0;\nelse if (val<0.0){\nif (mod(-power,2.0)==0.0)\nreturn pow(abs(val),power);\nelse\nreturn -pow(abs(val),power);\n} else if (val==0.0)\nreturn 0.0;\nreturn pow(abs(val),power);\n}\nfloat maxFromRGB(vec3 rgb){\nreturn max(max(rgb.r,rgb.g),rgb.b);\n}\nvec3 swizzleUpZ(const vec3 vec){\nreturn vec3(vec[0],-vec[2],vec[1]);\n}\nvec3 swizzleUpY(const vec3 vec){\nreturn vec3(vec[0],vec[2],-vec[1]);\n}\nfloat getSmoothFactor(float a,float b,float smoothness){\nreturn max(smoothness-abs(a-b),0.0)/smoothness;\n}\nfloat smoothMin(float a,float b,float smoothness){\nfloat smoothFac=getSmoothFactor(a,b,smoothness);\nreturn min(a,b)-smoothFac*smoothFac*smoothFac*smoothness*(1.0/6.0);\n}\nfloat smoothMax(float a,float b,float smoothness){\nfloat smoothFac=getSmoothFactor(a,b,smoothness);\nreturn max(a,b)+smoothFac*smoothFac*smoothFac*smoothness*(1.0/6.0);\n}\nfloat mat3GetDeterminant(mat3 mat){\nreturn mat[0][0]*mat[1][1]*mat[2][2]\n+ mat[0][2]*mat[1][0]*mat[2][1]\n+ mat[0][1]*mat[1][2]*mat[2][0]\n- mat[0][2]*mat[1][1]*mat[2][0]\n- mat[0][0]*mat[1][2]*mat[2][1]\n- mat[0][1]*mat[1][0]*mat[2][2];\n}\nmat3 mat3RotateX(float angle){\nfloat s=sin(angle),c=cos(angle);\nreturn mat3(1.0,0.0,0.0,0.0,c,s,0.0,-s,c);\n}\nmat3 mat3RotateY(float angle){\nfloat s=sin(angle),c=cos(angle);\nreturn mat3(c,0.0,-s,0.0,1.0,0.0,s,0.0,c);\n}\nmat3 mat3RotateZ(float angle){\nfloat s=sin(angle),c=cos(angle);\nreturn mat3(c,s,0.0,-s,c,0.0,0.0,0.0,1.0);\n}\nvec3 vec3RotateXAngle(vec3 vector,float angle){\nreturn mat3RotateX(angle)*vector;\n}\nvec3 vec3RotateYAngle(vec3 vector,float angle){\nreturn mat3RotateY(angle)*vector;\n}\nvec3 vec3RotateZAngle(vec3 vector,float angle){\nreturn mat3RotateZ(angle)*vector;\n}\nvec4 eulerToAxisAngle(vec3 euler){\nfloat c1=cos(euler.x/2.0),c2=cos(euler.y/2.0),c3=cos(euler.z/2.0);\nfloat s1=sin(euler.x/2.0),s2=sin(euler.y/2.0),s3=sin(euler.z/2.0);\nvec4 axisAngle=vec4(s1*c2*c3-c1*s2*s3,c1*s2*c3+s1*c2*s3,c1*c2*s3-s1*s2*c3,2.0*acos(c1*c2*c3+s1*s2*s3)\n);\naxisAngle.xyz=length(axisAngle.xyz)>0.0?normalize(axisAngle.xyz):vec3(1.0,0.0,0.0);\nreturn axisAngle;\n}\nmat3 axisAngleToMat3(vec3 axis,float angle){\nfloat s=sin(angle),c=cos(angle);\nfloat t=1.0-c;\nfloat x=axis.x,y=axis.y,z=axis.z;\nfloat tx=t*x,ty=t*y;\nreturn mat3(tx*x+c,tx*y-s*z,tx*z+s*y,tx*y+s*z,ty*y+c,ty*z-s*x,tx*z-s*y,ty*z+s*x,t*z*z+c);\n}\nmat3 toMat3(mat4 mat){\nreturn mat3(mat[0][0],mat[0][1],mat[0][2],mat[1][0],mat[1][1],mat[1][2],mat[2][0],mat[2][1],mat[2][2]);\n}\nmat4 toMat4(mat3 mat){\nreturn mat4(mat[0][0],mat[0][1],mat[0][2],0.0,mat[1][0],mat[1][1],mat[1][2],0.0,mat[2][0],mat[2][1],mat[2][2],0.0,0.0,0.0,0.0,1.0);\n}\nmat4 translationToMat4(vec3 v){\nreturn mat4(1.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,1.0,0.0,v.x,v.y,v.z,1.0);\n}\nmat4 scalingToMat4(vec3 v){\nreturn mat4(v.x,0.0,0.0,0.0,0.0,v.y,0.0,0.0,0.0,0.0,v.z,0.0,0.0,0.0,0.0,1.0);\n}\nvec4 nodeTexelToLinear(in vec4 color,in int sourceType){\nif (sourceType==1)\nreturn vec4(pow(color.rgb,vec3(2.2)),color.a);\nelse\nreturn color;\n}\nvec3 xyz_to_sRGB(vec3 xyz){\nmat3 convMat=mat3(3.2406,-0.9689,0.0557,-1.5372,1.8758,-0.2040,-0.4986,0.0415,1.0570\n);\nreturn convMat*xyz;\n}\nvec3 xyY_to_XYZ(float x,float y,float Y){\nfloat X=0.0;\nfloat Z=0.0;\nif (y != 0.0){\nX=(Y/y)*x;\nZ=(Y/y)*(1.0-x-y);\n}\nreturn vec3(X,Y,Z);\n}\n#if defined HSV_NODES\nvoid hsvToRGB(vec4 hsv,out vec4 outCol)\n{\nfloat i,f,p,q,t,h,s,v;\nvec3 rgb;\nh=hsv[0];\ns=hsv[1];\nv=hsv[2];\nif (s==0.0)\nrgb=vec3(v,v,v);\nelse {\nif (h==1.0)\nh=0.0;\nh*=6.0;\ni=floor(h);\nf=h-i;\nrgb=vec3(f,f,f);\np=v*(1.0-s);\nq=v*(1.0-(s*f));\nt=v*(1.0-(s*(1.0-f)));\nif (i==0.0)\nrgb=vec3(v,t,p);\nelse if (i==1.0)\nrgb=vec3(q,v,p);\nelse if (i==2.0)\nrgb=vec3(p,v,t);\nelse if (i==3.0)\nrgb=vec3(p,q,v);\nelse if (i==4.0)\nrgb=vec3(t,p,v);\nelse\nrgb=vec3(v,p,q);\n}\noutCol=vec4(rgb,hsv.w);\n}\nvoid rgbToHSV(vec4 rgb,out vec4 outCol)\n{\nfloat cmax,cmin,h,s,v,cdelta;\nvec3 c;\ncmax=max(rgb[0],max(rgb[1],rgb[2]));\ncmin=min(rgb[0],min(rgb[1],rgb[2]));\ncdelta=cmax-cmin;\nv=cmax;\nif (cmax != 0.0)\ns=cdelta/cmax;\nelse {\ns=0.0;\nh=0.0;\n}\nif (s==0.0)\nh=0.0;\nelse {\nc=(vec3(cmax,cmax,cmax)-rgb.xyz)/cdelta;\nif (rgb.x==cmax)h=c[2]-c[1];\nelse if (rgb.y==cmax)h=2.0+c[0]-c[2];\nelse h=4.0+c[1]-c[0];\nh/=6.0;\nif (h<0.0)\nh+=1.0;\n}\noutCol=vec4(h,s,v,rgb.w);\n}\n#endif\n#if defined(NODE_REFLECT_REFRACT_MX)||defined(NODE_BITMAP_ENV_MX)||defined(NODE_ENV_SPHERE_MY)\nvec4 sampleEquirectangular(sampler2D map,vec3 reflectVec,mat3 uvTransform,int encoding)\n{\nreflectVec=normalize(reflectVec);\nvec2 sampleUV;\nsampleUV.y=asin(clamp(reflectVec.y,-1.0,1.0))*RECIPROCAL_PI+0.5;\nsampleUV.x=atan(reflectVec.x,reflectVec.z)*RECIPROCAL_PI2+0.5;\nsampleUV.y*=-1.0;\nconst float seamWidth=0.15;\nconst float seamBiasFactor=-10.0;\nfloat seam=max(0.0,1.0-abs (reflectVec.x)/seamWidth)*\nclamp (1.0-reflectVec.z/seamWidth,0.0,1.0);\nsampleUV=(uvTransform*vec3(sampleUV,1.0)).xy;\nreturn texture2D(map,sampleUV,seamBiasFactor*seam);\n}\n#endif\n#if defined(NODE_FRESNEL_BL)||defined(NODE_LAYER_WEIGHT_BL)||defined(NODE_FALLOFF_MX)||defined(NODE_BSDF_GLASS_BL)||defined(NODE_BSDF_PRINCIPLED_BL)\nfloat fresnelReflection(const vec3 dir,const vec3 normal,const float ior){\nfloat cosTheta=clamp(abs(dot(dir,normal)),-1.0,1.0);\nfloat gSquared=pow2(ior)+pow2(cosTheta)-1.0;\nif (gSquared<0.0)return 1.0;\nfloat g=sqrt(gSquared);\nreturn 0.5*pow2((g-cosTheta)/(g+cosTheta))\n* (1.0+pow2(((g+cosTheta)*cosTheta-1.0)/\n((g-cosTheta)*cosTheta+1.0)\n));\n}\n#endif\n#if defined(NODE_BITMAP_MX)||defined(NODE_BITMAP_ENV_MX)||defined(NODE_GRADIENT_MX)||defined(NODE_GRADIENT_RAMP_MX)\n#define MAPPING_EXPLICIT_MAP_CHANNEL 1\n#define MAPPING_VERTEX_COLOR_CHANNEL 2\n#define MAPPING_PLANAR_OBJECT_XYZ 3\n#define MAPPING_PLANAR_WORLD_XYZ 4\n#define AXIS_XY 1\n#define AXIS_YZ 2\n#define AXIS_ZX 3\n#endif\n#if defined(NODE_BITMAP_MX)||defined(NODE_BITMAP_ENV_MX)||defined(NODE_BUMP_MX)||defined(NODE_GRADIENT_MX)||defined(NODE_GRADIENT_RAMP_MX)||defined(NODE_PLACE_2D_TEXTURE_MY)\nmat3 calcUvTransform(float uOffset,float vOffset,float uTiling,float vTiling,float wAngle)\n{\nif (abs(uOffset)<EPSILON&&abs(vOffset)<EPSILON &&\n(abs(uTiling-1.0))<EPSILON&&(abs(vTiling-1.0))<EPSILON &&\nabs(wAngle)<EPSILON)\nreturn mat3(1.0);\nfloat sx=uTiling;\nfloat sy=vTiling;\nfloat c=cos(-wAngle);\nfloat s=sin(-wAngle);\n#if defined(NODE_PLACE_2D_TEXTURE_MY)\nfloat tx=uOffset;\nfloat ty=vOffset;\nfloat cx=0.5;\nfloat cy=0.5;\nreturn mat3(c*sx,s*sx,0.0,-s*sy,c*sy,0.0,s*(ty+sy-cy)+c*(tx-cx)+cx,-c*(ty+sy-cy)+s*(tx-cx)-cy+1.0,1.0);\n#else\nfloat tx=-uOffset;\nfloat ty=-vOffset;\nfloat cx=uOffset+0.5;\nfloat cy=vOffset+0.5;\nreturn mat3(sx*c,-sy*s,0.0,sx*s,sy*c,0.0,-sx*(c*cx+s*cy)+cx+tx,-sy*(- s*cx+c*cy)+cy+ty,1.0);\n#endif\n}\n#endif\n#if defined(NODE_NOISE_MX)\nmat4 calcXYZTransform(vec3 offset,vec3 tiling,vec3 angle){\nmat4 rot=mat4(cos(angle.y)*cos(angle.z),cos(angle.x)*sin(angle.z)+sin(angle.x)*sin(angle.y)*cos(angle.z),sin(angle.x)*sin(angle.z)-cos(angle.x)*sin(angle.y)*cos(angle.z),0.0,-cos(angle.y)*sin(angle.z),cos(angle.x)*cos(angle.z)-sin(angle.x)*sin(angle.y)*sin(angle.z),cos(angle.x)*sin(angle.y)*sin(angle.z)+sin(angle.x)*cos(angle.z),0.0,sin(angle.y),-sin(angle.x)*cos(angle.y),cos(angle.x)*cos(angle.y),0.0,0.0,0.0,0.0,1.0\n);\nmat4 til=mat4(tiling.x,0.0,0.0,0.0,0.0,tiling.y,0.0,0.0,0.0,0.0,tiling.z,0.0,0.0,0.0,0.0,1.0\n);\nmat4 off=mat4(1.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,1.0,0.0,offset.x,offset.y,offset.z,1.0\n);\nreturn (til*rot*off);\n}\n#endif\n#if defined(NODE_TEX_NOISE_BL)||defined(NODE_TEX_WAVE_BL)||defined(NODE_NOISE_MX)||defined(USE_OSL)||defined(NODE_NOISE_MY)\n#define NOISE_AMP_HACK 0.75\n#define NOISE_BLENDER_MEAN 0.78\n#define NOISE_SCALE_HACK 0.5\n#define noiseModulo(x)(x-floor(x*(1.0/289.0))*289.0)\nvec4 noisePermute(vec4 x){\nreturn noiseModulo(((x*34.0)+1.0)*x);\n}\nvec4 taylorInvSqrt(vec4 r){\nreturn 1.79284291400159-0.85373472095314*r;\n}\nfloat taylorInvSqrt(float r){\nreturn 1.79284291400159-0.85373472095314*r;\n}\nfloat noisePerlin(vec3 v){\nconst vec2 C=vec2(1.0/6.0,1.0/3.0);\nconst vec4 D=vec4(0.0,0.5,1.0,2.0);\nvec3 i=floor(v+dot(v,C.yyy));\nvec3 x0=v-i+dot(i,C.xxx);\nvec3 g=step(x0.yzx,x0.xyz);\nvec3 l=1.0-g;\nvec3 i1=min(g.xyz,l.zxy);\nvec3 i2=max(g.xyz,l.zxy);\nvec3 x1=x0-i1+C.xxx;\nvec3 x2=x0-i2+C.yyy;\nvec3 x3=x0-D.yyy;\ni=noiseModulo(i);\nvec4 p=noisePermute(noisePermute(noisePermute(i.z+vec4(0.0,i1.z,i2.z,1.0))\n+ i.y+vec4(0.0,i1.y,i2.y,1.0))+i.x+vec4(0.0,i1.x,i2.x,1.0));\nfloat n_=0.142857142857;\nvec3 ns=n_*D.wyz-D.xzx;\nvec4 j=p-49.0*floor(p*ns.z*ns.z);\nvec4 x_=floor(j*ns.z);\nvec4 y_=floor(j-7.0*x_);\nvec4 x=x_*ns.x+ns.yyyy;\nvec4 y=y_*ns.x+ns.yyyy;\nvec4 h=1.0-abs(x)-abs(y);\nvec4 b0=vec4(x.xy,y.xy);\nvec4 b1=vec4(x.zw,y.zw);\nvec4 s0=floor(b0)*2.0+1.0;\nvec4 s1=floor(b1)*2.0+1.0;\nvec4 sh=-step(h,vec4(0.0));\nvec4 a0=b0.xzyw+s0.xzyw*sh.xxyy;\nvec4 a1=b1.xzyw+s1.xzyw*sh.zzww;\nvec3 p0=vec3(a0.xy,h.x);\nvec3 p1=vec3(a0.zw,h.y);\nvec3 p2=vec3(a1.xy,h.z);\nvec3 p3=vec3(a1.zw,h.w);\nvec4 norm=taylorInvSqrt(vec4(dot(p0,p0),dot(p1,p1),dot(p2,p2),dot(p3,p3)));\np0*=norm.x;\np1*=norm.y;\np2*=norm.z;\np3*=norm.w;\nvec4 m=max(0.6-vec4(dot(x0,x0),dot(x1,x1),dot(x2,x2),dot(x3,x3)),0.0);\nm=m*m;\nreturn 42.0*dot(m*m,vec4(dot(p0,x0),dot(p1,x1),dot(p2,x2),dot(p3,x3)));\n}\nvec4 permute(vec4 x){\nreturn mod(((x*34.0)+1.0)*x,289.0);\n}\nfloat permute(float x){\nreturn floor(mod(((x*34.0)+1.0)*x,289.0));\n}\nvec4 grad4(float j,vec4 ip){\nconst vec4 ones=vec4(1.0,1.0,1.0,-1.0);\nvec4 p,s;\np.xyz=floor( fract (vec3(j)*ip.xyz)*7.0)*ip.z-1.0;\np.w=1.5-dot(abs(p.xyz),ones.xyz);\ns=vec4(lessThan(p,vec4(0.0)));\np.xyz=p.xyz+(s.xyz*2.0-1.0)*s.www;\nreturn p;\n}\nfloat snoise(vec4 v){\nconst vec2 C=vec2(0.138196601125010504,0.309016994374947451);\nvec4 i=floor(v+dot(v,C.yyyy));\nvec4 x0=v-i+dot(i,C.xxxx);\nvec4 i0;\nvec3 isX=step( x0.yzw,x0.xxx );\nvec3 isYZ=step( x0.zww,x0.yyz );\ni0.x=isX.x+isX.y+isX.z;\ni0.yzw=1.0-isX;\ni0.y+=isYZ.x+isYZ.y;\ni0.zw+=1.0-isYZ.xy;\ni0.z+=isYZ.z;\ni0.w+=1.0-isYZ.z;\nvec4 i3=clamp( i0,0.0,1.0 );\nvec4 i2=clamp( i0-1.0,0.0,1.0 );\nvec4 i1=clamp( i0-2.0,0.0,1.0 );\nvec4 x1=x0-i1+1.0*C.xxxx;\nvec4 x2=x0-i2+2.0*C.xxxx;\nvec4 x3=x0-i3+3.0*C.xxxx;\nvec4 x4=x0-1.0+4.0*C.xxxx;\ni=mod(i,289.0);\nfloat j0=permute( permute( permute( permute(i.w)+i.z)+i.y)+i.x);\nvec4 j1=permute( permute( permute( permute (i.w+vec4(i1.w,i2.w,i3.w,1.0 ))\n+ i.z+vec4(i1.z,i2.z,i3.z,1.0 ))\n+ i.y+vec4(i1.y,i2.y,i3.y,1.0 ))\n+ i.x+vec4(i1.x,i2.x,i3.x,1.0 ));\nvec4 ip=vec4(1.0/294.0,1.0/49.0,1.0/7.0,0.0);\nvec4 p0=grad4(j0,ip);\nvec4 p1=grad4(j1.x,ip);\nvec4 p2=grad4(j1.y,ip);\nvec4 p3=grad4(j1.z,ip);\nvec4 p4=grad4(j1.w,ip);\nvec4 norm=taylorInvSqrt(vec4(dot(p0,p0),dot(p1,p1),dot(p2,p2),dot(p3,p3)));\np0*=norm.x;\np1*=norm.y;\np2*=norm.z;\np3*=norm.w;\np4*=taylorInvSqrt(dot(p4,p4));\nvec3 m0=max(0.6-vec3(dot(x0,x0),dot(x1,x1),dot(x2,x2)),0.0);\nvec2 m1=max(0.6-vec2(dot(x3,x3),dot(x4,x4)),0.0);\nm0=m0*m0;\nm1=m1*m1;\nreturn 49.0*( dot(m0*m0,vec3( dot( p0,x0 ),dot( p1,x1 ),dot( p2,x2 )))\n+ dot(m1*m1,vec2( dot( p3,x3 ),dot( p4,x4 ))));\n}\nfloat noiseBlender(vec3 p){\nreturn 0.5*NOISE_AMP_HACK*(noisePerlin(NOISE_SCALE_HACK*vec3(p.x,p.y,p.z)))+0.5;\n}\nfloat noiseSmooth(vec3 p,float octaveLenPerPixel,float falloffFactor,float dispersionFactor){\nfloat mixFac=mix(1.0,smoothstep(0.0,1.0,octaveLenPerPixel)*falloffFactor,dispersionFactor);\nreturn mix(noiseBlender(p),NOISE_BLENDER_MEAN,mixFac);\n}\n#define MAX_OCTAVES_NUM 16\nfloat noiseTurbulence(vec3 p,float octaves,float octaveLenPerPixel,float falloffFactor,float dispersionFactor){\nfloat fscale=1.0;\nfloat amp=1.0;\nfloat sum=0.0;\noctaves=clamp(octaves,0.0,16.0);\nint octavesInt=int(octaves);\nfor (int i=0;i<=MAX_OCTAVES_NUM;i++){\n#if __VERSION__==300\nif (i<=octavesInt){\nfloat t=noiseSmooth(fscale*p,octaveLenPerPixel,falloffFactor,dispersionFactor);\nsum+=t*amp;\namp*=0.5;\nfscale*=2.0;\noctaveLenPerPixel*=2.0;\n} else {\ni=MAX_OCTAVES_NUM;\n}\n#else\nif (i>octavesInt)break;\nfloat t=noiseSmooth(fscale*p,octaveLenPerPixel,falloffFactor,dispersionFactor);\nsum+=t*amp;\namp*=0.5;\nfscale*=2.0;\noctaveLenPerPixel*=2.0;\n#endif\n}\nfloat octavesFrac=fract(octaves);\nfloat octavesCoeff=pow(2.0,float(octavesInt));\nif (octavesFrac != 0.0){\nfloat t=noiseSmooth(fscale*p,octaveLenPerPixel,falloffFactor,dispersionFactor);\nfloat sum2=sum+t*amp;\nsum*=octavesCoeff/(2.0*octavesCoeff-1.0);\nsum2*=2.0*octavesCoeff/(4.0*octavesCoeff-1.0);\nreturn mix(sum,sum2,octavesFrac);\n} else {\nreturn sum*octavesCoeff/(2.0*octavesCoeff-1.0);\n}\n}\n#endif\n#if (defined(USE_OSL)||defined(NODE_WAVELENGTH_BL))&&__VERSION__==300\nvec3 cieColorMatch[81]=vec3[](vec3(0.0014,0.0000,0.0065),vec3(0.0022,0.0001,0.0105),vec3(0.0042,0.0001,0.0201),vec3(0.0076,0.0002,0.0362),vec3(0.0143,0.0004,0.0679),vec3(0.0232,0.0006,0.1102),vec3(0.0435,0.0012,0.2074),vec3(0.0776,0.0022,0.3713),vec3(0.1344,0.0040,0.6456),vec3(0.2148,0.0073,1.0391),vec3(0.2839,0.0116,1.3856),vec3(0.3285,0.0168,1.6230),vec3(0.3483,0.0230,1.7471),vec3(0.3481,0.0298,1.7826),vec3(0.3362,0.0380,1.7721),vec3(0.3187,0.0480,1.7441),vec3(0.2908,0.0600,1.6692),vec3(0.2511,0.0739,1.5281),vec3(0.1954,0.0910,1.2876),vec3(0.1421,0.1126,1.0419),vec3(0.0956,0.1390,0.8130),vec3(0.0580,0.1693,0.6162),vec3(0.0320,0.2080,0.4652),vec3(0.0147,0.2586,0.3533),vec3(0.0049,0.3230,0.2720),vec3(0.0024,0.4073,0.2123),vec3(0.0093,0.5030,0.1582),vec3(0.0291,0.6082,0.1117),vec3(0.0633,0.7100,0.0782),vec3(0.1096,0.7932,0.0573),vec3(0.1655,0.8620,0.0422),vec3(0.2257,0.9149,0.0298),vec3(0.2904,0.9540,0.0203),vec3(0.3597,0.9803,0.0134),vec3(0.4334,0.9950,0.0087),vec3(0.5121,1.0000,0.0057),vec3(0.5945,0.9950,0.0039),vec3(0.6784,0.9786,0.0027),vec3(0.7621,0.9520,0.0021),vec3(0.8425,0.9154,0.0018),vec3(0.9163,0.8700,0.0017),vec3(0.9786,0.8163,0.0014),vec3(1.0263,0.7570,0.0011),vec3(1.0567,0.6949,0.0010),vec3(1.0622,0.6310,0.0008),vec3(1.0456,0.5668,0.0006),vec3(1.0026,0.5030,0.0003),vec3(0.9384,0.4412,0.0002),vec3(0.8544,0.3810,0.0002),vec3(0.7514,0.3210,0.0001),vec3(0.6424,0.2650,0.0000),vec3(0.5419,0.2170,0.0000),vec3(0.4479,0.1750,0.0000),vec3(0.3608,0.1382,0.0000),vec3(0.2835,0.1070,0.0000),vec3(0.2187,0.0816,0.0000),vec3(0.1649,0.0610,0.0000),vec3(0.1212,0.0446,0.0000),vec3(0.0874,0.0320,0.0000),vec3(0.0636,0.0232,0.0000),vec3(0.0468,0.0170,0.0000),vec3(0.0329,0.0119,0.0000),vec3(0.0227,0.0082,0.0000),vec3(0.0158,0.0057,0.0000),vec3(0.0114,0.0041,0.0000),vec3(0.0081,0.0029,0.0000),vec3(0.0058,0.0021,0.0000),vec3(0.0041,0.0015,0.0000),vec3(0.0029,0.0010,0.0000),vec3(0.0020,0.0007,0.0000),vec3(0.0014,0.0005,0.0000),vec3(0.0010,0.0004,0.0000),vec3(0.0007,0.0002,0.0000),vec3(0.0005,0.0002,0.0000),vec3(0.0003,0.0001,0.0000),vec3(0.0002,0.0001,0.0000),vec3(0.0002,0.0001,0.0000),vec3(0.0001,0.0000,0.0000),vec3(0.0001,0.0000,0.0000),vec3(0.0001,0.0000,0.0000),vec3(0.0000,0.0000,0.0000)\n);\n#endif\n#if defined(USE_OSL)||defined(NODE_BLACKBODY_BL)\nvec3 colorTempToRGB(float temp)\n{\nvec3 retColor;\ntemp=clamp(temp,100.0,40000.0)/100.0;\nif (temp<=66.0){\nretColor.r=1.0;\nretColor.g=saturate(0.390081578*log(temp)-0.631841443);\n} else {\nfloat t=temp-60.0;\nretColor.r=saturate(1.292936186*pow(t,-0.133204759));\nretColor.g=saturate(1.129890860*pow(t,-0.075514849));\n}\nif (temp>=66.0)\nretColor.b=1.0;\nelse if (temp<=19.0)\nretColor.b=0.0;\nelse\nretColor.b=saturate(0.543206789*log(temp-10.0)-1.196254089);\nretColor.rgb=pow(retColor.rgb,vec3(2.2));\nreturn retColor;\n}\n#endif\n#if (defined(NODE_TEX_WHITE_NOISE_BL)||defined(NODE_TEX_GABOR_BL))&&__VERSION__==300\n#define rotUint32(x,k)(((x)<< (k))|((x)>> (32-(k))))\n#define mixUint32(a,b,c){a-=c;a ^= rotUint32(c,4);c+=b;b-=a;b ^= rotUint32(a,6);a+=c;c-=b;c ^= rotUint32(b,8);b+=a;a-=c;a ^= rotUint32(c,16);c+=b;b-=a;b ^= rotUint32(a,19);a+=c;c-=b;c ^= rotUint32(b,4);b+=a;}\n#define finalUint32(a,b,c){c ^= b;c-=rotUint32(b,14);a ^= c;a-=rotUint32(c,11);b ^= a;b-=rotUint32(a,25);c ^= b;c-=rotUint32(b,16);a ^= c;a-=rotUint32(c,4);b ^= a;b-=rotUint32(a,14);c ^= b;c-=rotUint32(b,24);}\nuint hashUint(uint x){\nuint a=0xdeadbeefu+17u+x;\nuint b=0xdeadbeefu+17u;\nuint c=0xdeadbeefu+17u;\nfinalUint32(a,b,c);\nreturn c;\n}\nuint hashUint2(uvec2 vec){\nuvec3 abc=uvec3(0xdeadbeefu+21u)+uvec3(vec,0u);\nfinalUint32(abc.x,abc.y,abc.z);\nreturn abc.z;\n}\nuint hashUint3(uvec3 vec){\nuvec3 abc=uvec3(0xdeadbeefu+25u)+vec;\nfinalUint32(abc.x,abc.y,abc.z);\nreturn abc.z;\n}\nuint hashUint4(uvec4 vec){\nuvec3 abc=uvec3(0xdeadbeefu+29u)+vec.xyz;\nmixUint32(abc.x,abc.y,abc.z);\nabc.x+=vec.w;\nfinalUint32(abc.x,abc.y,abc.z);\nreturn abc.z;\n}\n#undef rotUint32\n#undef mixUint32\n#undef finalUint32\nfloat uintToFloat(uint value){\nreturn float(value)/float(0xFFFFFFFFu);\n}\nfloat hashFloatToFloat(float value){\nreturn uintToFloat(hashUint(floatBitsToUint(value)));\n}\nfloat hashVec2ToFloat(vec2 vec){\nreturn uintToFloat(hashUint2(floatBitsToUint(vec)));\n}\nfloat hashVec3ToFloat(vec3 vec){\nreturn uintToFloat(hashUint3(floatBitsToUint(vec)));\n}\nfloat hashVec4ToFloat(vec4 vec){\nreturn uintToFloat(hashUint4(floatBitsToUint(vec)));\n}\nvec2 hashVec3ToVec2(vec3 k){\nreturn vec2(hashVec3ToFloat(k.xyz),hashVec3ToFloat(k.zxy));\n}\nvec2 hashVec4ToVec2(vec4 k){\nreturn vec2(hashVec4ToFloat(k.xyzw),hashVec4ToFloat(k.zxwy));\n}\nvec3 hashFloatToVec3(float val){\nreturn vec3(hashFloatToFloat(val),hashVec2ToFloat(vec2(val,1.0)),hashVec2ToFloat(vec2(val,2.0)));\n}\nvec3 hashVec2ToVec3(vec2 vec){\nreturn vec3(hashVec2ToFloat(vec),hashVec3ToFloat(vec3(vec,1.0)),hashVec3ToFloat(vec3(vec,2.0)));\n}\nvec3 hashVec3ToVec3(vec3 vec){\nreturn vec3(hashVec3ToFloat(vec),hashVec4ToFloat(vec4(vec,1.0)),hashVec4ToFloat(vec4(vec,2.0)));\n}\nvec3 hashVec4ToVec3(vec4 vec){\nreturn vec3(hashVec4ToFloat(vec.xyzw),hashVec4ToFloat(vec.zxwy),hashVec4ToFloat(vec.wzyx));\n}\n#endif",node_osl_frag:"#ifdef USE_OSL\n#define M_PI PI\n#define M_PI_2 PI/2.0\n#define M_PI_4 PI/4.0\n#define M_2_PI 2.0/PI\n#define M_2PI 2.0*PI\n#define M_4PI 4.0*PI\n#define M_2_SQRTPI 2.0/sqrt(PI)\n#define M_E 2.718281828459\n#define M_LN2 0.69314718056\n#define M_LN10 2.30258509299\n#define M_LOG2E 1.4426950409\n#define M_LOG10E 0.43429448190\n#define M_SQRT2 sqrt(2.0)\n#define M_SQRT1_2 sqrt(0.5)\n#define OSL_ALPHA 33633\n#define OSL_ANISOTROPIC 40205\n#define OSL_AVERAGEALPHA 57701\n#define OSL_AVERAGECOLOR 46077\n#define OSL_BANDWIDTH 37485\n#define OSL_BEZIER 27645\n#define OSL_BLACK 62409\n#define OSL_BSPLINE 16959\n#define OSL_CAMERA 8198\n#define OSL_CAMERA_CLIP 34380\n#define OSL_CAMERA_CLIP_FAR 31933\n#define OSL_CAMERA_CLIP_NEAR 21485\n#define OSL_CAMERA_FOV 60706\n#define OSL_CAMERA_PIXELASPECT 4950\n#define OSL_CAMERA_PROJECTION 29369\n#define OSL_CAMERA_RESOLUTION 39679\n#define OSL_CAMERA_SCREEN_WINDOW 47009\n#define OSL_CAMERA_SHUTTER 7107\n#define OSL_CAMERA_SHUTTER_CLOSE 34406\n#define OSL_CAMERA_SHUTTER_OPEN 40085\n#define OSL_CATMULL_ROM 31642\n#define OSL_CELL 20984\n#define OSL_CHANNELS 8726\n#define OSL_CLAMP 20052\n#define OSL_COLOR 53753\n#define OSL_COMMON 49871\n#define OSL_CONSTANT 25144\n#define OSL_DATAWINDOW 54276\n#define OSL_DEFAULT 54870\n#define OSL_DIFFUSE 40389\n#define OSL_DIRECTION 42220\n#define OSL_DISPLAYWINDOW 30728\n#define OSL_DISTANCE 51337\n#define OSL_DO_FILTER 35765\n#define OSL_EMPTY 9314\n#define OSL_ERRORMESSAGE 38305\n#define OSL_EXISTS 41510\n#define OSL_FILL 39132\n#define OSL_FIRSTCHANNEL 48155\n#define OSL_GABOR 57764\n#define OSL_GEOM_NAME 63686\n#define OSL_GLOSSY 47998\n#define OSL_HASH 49390\n#define OSL_HERMITE 63643\n#define OSL_HIT 48491\n#define OSL_HITDIST 22029\n#define OSL_HSL 49898\n#define OSL_HSV 29073\n#define OSL_IMPULSES 56191\n#define OSL_INDEX 1731\n#define OSL_INTERP 10557\n#define OSL_LINEAR 2182\n#define OSL_MIRROR 64591\n#define OSL_MISSINGALPHA 39755\n#define OSL_MISSINGCOLOR 51667\n#define OSL_NDC 48899\n#define OSL_NORMAL 16520\n#define OSL_OBJECT 59084\n#define OSL_OSL_VERSION 47920\n#define OSL_PERIODIC 8749\n#define OSL_PERLIN 730\n#define OSL_POSITION 43041\n#define OSL_RASTER 2618\n#define OSL_REFLECTION 37621\n#define OSL_REFRACTION 37287\n#define OSL_RESOLUTION 48704\n#define OSL_RGB 26673\n#define OSL_RWRAP 47801\n#define OSL_SCREEN 55875\n#define OSL_SHADER 21066\n#define OSL_SHADER_GROUPNAME 62327\n#define OSL_SHADER_LAYERNAME 51796\n#define OSL_SHADER_SHADERNAME 65123\n#define OSL_SHADOW 60708\n#define OSL_SIMPLEX 61636\n#define OSL_SUBIMAGE 33526\n#define OSL_SUBIMAGES 2366\n#define OSL_SWRAP 4328\n#define OSL_TEXTUREFORMAT 17851\n#define OSL_TIME 52235\n#define OSL_TRACE 62908\n#define OSL_TWRAP 30524\n#define OSL_TYPE 64071\n#define OSL_UPERLIN 65308\n#define OSL_USIMPLEX 11314\n#define OSL_WIDTH 48751\n#define OSL_WORLD 9059\n#define OSL_WORLDTOCAMERA 32273\n#define OSL_WORLDTOSCREEN 33876\n#define OSL_WRAP 58300\n#define OSL_XYY 2228\n#define OSL_XYZ 47351\n#define OSL_YIQ 15839\nvec3 oslGetP(vec3 viewPos){\n#if WORLD_NODES==1\nreturn swizzleUpZ((invViewMatrix*vec4(-viewPos,0.0)).xyz);\n#else\nreturn swizzleUpZ((invViewMatrix*vec4(-viewPos,1.0)).xyz);\n#endif\n}\nvec3 oslGetI(vec3 viewPos){\n#if WORLD_NODES==1\nreturn swizzleUpZ((invViewMatrix*vec4(normalize(-viewPos),0.0)).xyz);\n#else\nreturn swizzleUpZ((invViewMatrix*vec4(normalize(-viewPos),0.0)).xyz);\n#endif\n}\nvec3 oslGetN(vec3 viewNorm){\nreturn swizzleUpZ(normalize(invViewMatrix*vec4(viewNorm,0.0)).xyz);\n}\nvec3 oslBlackbody(float temperatureK){\nreturn vec4(colorTempToRGB(temperatureK),1.0).rgb;\n}\nfloat oslDistance(vec3 p0,vec3 p1){\nreturn distance(p0,p1);\n}\nfloat oslDistance(vec3 p0,vec3 p1,vec3 q){\nvec3 d=p1-p0;\nfloat dd=dot(d,d);\nif (dd==0.0)\nreturn distance(q,p0);\nfloat t=dot(q-p0,d)/dd;\nreturn distance(q,p0+clamp(t,0.0,1.0)*d);\n}\nint oslEndsWith(int name1,int name2){\nreturn int(name1==name2);\n}\nint oslFormat(int name1,int name2){\nreturn name2;\n}\nint oslGetAttribute(int name,out int value){\nvalue=0;\nreturn 0;\n}\nint oslGetAttribute(int name,out float value){\nvalue=0.0;\nreturn 0;\n}\nint oslGetAttribute(int name,out vec3 vec){\nvec=vec3(0.0,0.0,0.0);\nreturn 0;\n}\nvoid oslGetTextureInfo(int filename,int name,out int value){\nvalue=4;\n}\nvoid oslGetTextureInfo(int filename,int name,out int value[2]){\nvalue[0]=1024;\nvalue[1]=1024;\n}\nvec3 oslHSV(float h,float s,float v){\nvec4 outCol;\nhsvToRGB(vec4(h,s,v,1.0),outCol);\nreturn outCol.rgb;\n}\nfloat oslHypot(float x,float y){\nreturn sqrt(x*x+y*y);\n}\nfloat oslHypot(float x,float y,float z){\nreturn sqrt(x*x+y*y+z*z);\n}\nfloat oslLog2(float x,float y){\nreturn log(x)/log(y);\n}\nfloat oslLuminance(vec3 color){\nreturn linearToRelativeLuminance(color);\n}\nfloat oslNoise(int type,vec3 vec,float phase){\nfloat n=snoise(vec4(vec,phase));\nif (type==OSL_UPERLIN)\nn=n*0.5+0.5;\nreturn n;\n}\nfloat oslNoise(int type,float value,float phase){\nreturn oslNoise(type,vec3(value),phase);\n}\nfloat oslNoise(int type,vec3 vec){\nreturn oslNoise(type,vec,0.0);\n}\nfloat oslNoise(int type,float value){\nreturn oslNoise(type,vec3(value),0.0);\n}\nvec3 oslNoise3D(int type,vec3 vec,float phase){\nfloat x=snoise(vec4(vec,phase));\nfloat y=snoise(vec4(vec.y,vec.x,vec.z,phase));\nfloat z=snoise(vec4(vec.y,vec.z,vec.x,phase));\nvec3 n=vec3(x,y,z);\nif (type==OSL_UPERLIN)\nn=n*0.5+0.5;\nreturn n;\n}\nvec3 oslNoise3D(int type,float value,float phase){\nreturn oslNoise3D(type,vec3(value),phase);\n}\nvec3 oslNoise3D(int type,vec3 vec){\nreturn oslNoise3D(type,vec,0.0);\n}\nvec3 oslNoise3D(int type,float value){\nreturn oslNoise3D(type,vec3(value),0.0);\n}\nfloat oslPow(float a,float b){\nreturn pow(a,b);\n}\nvec3 oslPow(vec3 a,float b){\nreturn pow(a,vec3(b));\n}\nint oslRayType(int name){\nif (name==OSL_CAMERA)\n#if LIGHT_PATH_IS_CAM_RAY\nreturn 1;\n#else\nreturn 0;\n#endif\nelse\nreturn 0;\n}\nvec3 oslRotate(vec3 vec,float angle,vec3 p0,vec3 p1){\nvec3 axis=normalize(p1-p0);\nfloat c=cos(angle);\nfloat s=sin(angle);\nfloat x=axis[0];\nfloat y=axis[1];\nfloat z=axis[2];\nmat4 mat=mat4(x*x+(1.0-x*x)*c,x*y*(1.0-c)+z*s,x*z*(1.0-c)-y*s,0.0,x*y*(1.0-c)-z*s,y*y+(1.0-y*y)*c,y*z*(1.0-c)+x*s,0.0,x*z*(1.0-c)+y*s,y*z*(1.0-c)-x*s,z*z+(1.0-z*z)*c,0.0,0.0,0.0,0.0,1.0\n);\nreturn (mat*vec4((vec-p0),1.0)+vec4(p0,1.0)).xyz;\n}\nvec3 oslRotate(vec3 vec,float angle,vec3 axis){\nreturn oslRotate(vec,angle,vec3(0.0),axis);\n}\nint oslStartsWith(int name1,int name2){\nreturn int(name1==name2);\n}\nint oslStrLen(int name){\nif (name==OSL_EMPTY)\nreturn 0;\nelse\nreturn 1;\n}\nint oslSubStr(int s,int start,int len){\nreturn s;\n}\nint oslSubStr(int s,int start){\nreturn s;\n}\nvec3 oslTexture(sampler2D image,float u,float v,int wrapModeFlag,int wrapMode,int alphaFlag,out float alpha){\nif (wrapMode==OSL_DEFAULT||wrapMode==OSL_BLACK){\nif (u<0.0||u>1.0||v<0.0||v>1.0)\nreturn vec3(0.0);\n} else if (wrapMode==OSL_CLAMP){\nu=clamp(u,0.0,1.0);\nv=clamp(v,0.0,1.0);\n} else if (wrapMode==OSL_PERIODIC){\nu=mod(u,1.0);\nv=mod(v,1.0);\n} else if (wrapMode==OSL_MIRROR){\nif (mod(floor(u),2.0)==0.0)\nu=u-floor(u);\nelse\nu=1.0-(u-floor(u));\nif (mod(floor(v),2.0)==0.0)\nv=v-floor(v);\nelse\nv=1.0-(v-floor(v));\n}\nvec4 colAlpha=texture2D(image,vec2(u,v));\nalpha=colAlpha.a;\nreturn colAlpha.rgb;\n}\nvec3 oslTexture(sampler2D image,float u,float v,int alphaFlag,out float alpha,int wrapModeFlag,int wrapMode){\nreturn oslTexture(image,u,v,wrapModeFlag,wrapMode,alphaFlag,alpha);\n}\nvec3 oslTexture(sampler2D image,float u,float v,int alphaFlag,out float alpha){\nreturn oslTexture(image,u,v,OSL_WRAP,OSL_DEFAULT,alphaFlag,alpha);\n}\nvec3 oslTexture(sampler2D image,float u,float v,int wrapModeFlag,int wrapMode){\nfloat alpha;\nreturn oslTexture(image,u,v,wrapModeFlag,wrapMode,OSL_ALPHA,alpha);\n}\nvec3 oslTexture(sampler2D image,float u,float v){\nfloat alpha;\nreturn oslTexture(image,u,v,OSL_WRAP,OSL_DEFAULT,OSL_ALPHA,alpha);\n}\nvec3 oslTexture(sampler2D image,float u,float v,int wrapModeFlag,int wrapMode,int colorSpaceFlag,int colorSpace){\nfloat alpha;\nreturn oslTexture(image,u,v,wrapModeFlag,wrapMode,OSL_ALPHA,alpha);\n}\nvec3 oslTransform(int fromSpace,int toSpace,vec4 vec){\nif (toSpace==OSL_WORLD||toSpace==OSL_SHADER||toSpace==OSL_COMMON){\nreturn vec.xyz;\n} else if (toSpace==OSL_OBJECT){\nvec=vec4(swizzleUpY(vec.xyz),vec.w);\nvec=invModelMatrix*vec;\nreturn swizzleUpZ(vec.xyz);\n} else if (toSpace==OSL_CAMERA){\nvec=vec4(swizzleUpY(vec.xyz),vec.w);\nreturn (viewMatrix*vec).xyz;\n} else if (toSpace==OSL_SCREEN){\nreturn vec.xyz;\n} else if (toSpace==OSL_RASTER){\nreturn gl_FragCoord.xyz;\n} else if (toSpace==OSL_NDC){\nreturn vec.xyz;\n} else {\nreturn vec.xyz;\n}\n}\nvec3 oslTransform(int fromSpace,int toSpace,vec3 vec){\nreturn oslTransform(fromSpace,toSpace,vec4(vec,1.0));\n}\nvec3 oslTransform(int toSpace,vec3 vec){\nreturn oslTransform(OSL_COMMON,toSpace,vec4(vec,1.0));\n}\nvec3 oslTransformDir(int fromSpace,int toSpace,vec3 vec){\nreturn oslTransform(fromSpace,toSpace,vec4(vec,0.0));\n}\nvec3 oslTransformDir(int toSpace,vec3 vec){\nreturn oslTransform(OSL_COMMON,toSpace,vec4(vec,0.0));\n}\nvec3 oslTransformC(int fromSpace,int toSpace,vec3 vec){\nvec4 outVec=vec4(vec,1.0);\nif (fromSpace==OSL_HSV&&toSpace==OSL_RGB)\nhsvToRGB(vec4(vec,1.0),outVec);\nelse if (fromSpace==OSL_RGB&&toSpace==OSL_HSV)\nrgbToHSV(vec4(vec,1.0),outVec);\nreturn outVec.rgb;\n}\nvec3 oslTransformC(int toSpace,vec3 vec){\nreturn oslTransformC(OSL_RGB,toSpace,vec);\n}\nvoid oslError(){}\nvoid oslFPrintf(){}\nvoid oslPrintf(){}\nvoid oslWarning(){}\nvec3 oslWaveLengthColor(float lambdaNM){\n#if __VERSION__==300\nvec3 xyz=vec3(0.0);\nfloat ii=(lambdaNM-380.0)/5.0;\nint i=int(ii);\nif (i<0||i>=80)\nreturn xyz;\nii-=float(i);\nvec3 c1=cieColorMatch[i];\nvec3 c2=cieColorMatch[i+1];\nxyz=mix(c1,c2,ii);\nreturn xyz_to_sRGB(xyz);\n#else\nreturn vec3(0.0);\n#endif\n}\n#endif",node_incident_frag:"void node_incident(vec3 viewPos,out vec3 incident)\n{\n\nvec4 viewDir=vec4(normalize(viewPos),0.0);\nincident=-swizzleUpZ(viewDir.xyz);\n}",node_normal_frag:"void node_normal(vec3 norParam,out vec3 norOut)\n{\n#ifdef MT_BLENDER\n#if WORLD_NODES==1\nvec4 viewDir=isOrthographic?vec4(0.0,0.0,-1.0,0.0):vec4(normalize(-vViewPosition),0.0);\nviewDir=invViewMatrix*viewDir;\nnorOut=-swizzleUpZ(viewDir.xyz);\n#else\nnorOut=normalize(invViewMatrix*vec4(norParam,0.0)).xyz;\nnorOut=swizzleUpZ(norOut);\n#endif\n#else\nnorOut=norParam;\n#endif\n}",node_position_frag:"void node_position(vec3 posParam,out vec3 posOut)\n{\n#if defined(MT_BLENDER)||defined(MT_MAX)\nposOut=swizzleUpZ(-posParam);\n#else\nposOut=-posParam;\n#endif\n}",node_rgb_alpha_frag:"uniform vec4 nodeRGB[NODE_RGB_NUM];\nvoid node_rgb_alpha(vec4 color,out vec3 outColor,out float outAlpha)\n{\noutColor=color.rgb;\noutAlpha=color.a;\n}",node_value_frag:"uniform float nodeValue[NODE_VALUE_NUM];\nvoid node_value(float value,out float outValue)\n{\noutValue=value;\n}",node_u_float_frag:"void node_u_float(vec2 inUv,out float u)\n{\nu=inUv.x;\n}",node_abs_ar_frag:"void node_abs(vec3 inputVal,out vec3 outColor)\n{\noutColor=abs(inputVal);\n}",node_add_ar_frag:"void node_add(vec3 input1,vec3 input2,out vec3 outColor)\n{\noutColor=input1+input2;\n}",node_atan_ar_frag:"void node_atan(int units,vec3 x,vec3 y,out vec3 outColor)\n{\noutColor=atan(y,x);\nif (units==1)\noutColor=degrees(outColor);\n}",node_checkerboard_ar_frag:"void node_checkerboard(const vec2 inUv,vec3 color1,vec3 color2,float uFrequency,float vFrequency,float uOffset,float vOffset,float contrast,out vec3 outColor){\nvec2 uv=-1.0+2.0*inUv;\nfloat fmodResult=mod(floor(uOffset*2.0+uFrequency*uv.x)+floor(vOffset*2.0+vFrequency*uv.y),2.0);\nfloat final=max(sign(fmodResult),0.0);\nvec3 col=vec3(final);\nif (final==0.0)\ncol=color1;\nelse\ncol=color2;\noutColor=col*vec3(contrast)+vec3(1.0-contrast);\n}",node_clamp_ar_frag:"void node_clamp(const int mode,vec3 inputValue,float minValue,float maxValue,vec3 minColor,vec3 maxColor,out vec3 outColor,out vec3 outTransparency)\n{\nif (mode==0)\noutColor=clamp(inputValue,vec3(minValue),vec3(maxValue));\nelse\noutColor=clamp(inputValue,minColor,maxColor);\noutTransparency=outColor;\n}",node_color_convert_ar_frag:"void node_color_convert(const int from,const int to,vec3 inputValue,out vec3 outColor,out vec3 outTransparency)\n{\nvec4 c;\nif (from==to)\nc=vec4(inputValue,1.0);\nelse if (from==0)\nrgbToHSV(vec4(inputValue,1.0),c);\nelse if (from==1)\nhsvToRGB(vec4(inputValue,1.0),c);\noutColor=c.rgb;\noutTransparency=outColor;\n}",node_color_correct_ar_frag:"void node_color_correct(vec3 inputValue,float mask,float gamma,float hueShift,float saturation,float contrast,float contrastPivot,float exposure,vec3 multiply,vec3 add,bool invert,bool alphaIsLuminance,float alphaMultiply,float alphaAdd,bool invertAlpha,out vec3 outColor,out float outAlpha)\n{\noutColor=inputValue;\noutColor=invert?1.0-outColor:outColor;\noutColor=vec3(pow(abs(outColor.r),gamma),pow(abs(outColor.g),gamma),pow(abs(outColor.b),gamma));\nvec4 hsv;\nrgbToHSV(vec4(outColor,1.0),hsv);\nhsv[0]+=hueShift/360.0;\nif (hsv[0]>1.0)\nhsv[0]-=1.0;\nelse if (hsv[0]<0.0)\nhsv[0]+=1.0;\n\nhsv[1]*=(saturation);\nhsv[1]=saturate(hsv[1]);\nhsv[2]+=exposure*2.0;\nvec4 c=hsv;\nhsvToRGB(hsv,c);\nc=((c-contrastPivot)*contrast+contrastPivot)*vec4(multiply,1.0)+vec4(add,1.0);\noutColor=c.rgb;\noutAlpha=1.0;\n}",node_color_to_float_ar_frag:"void node_color_to_float(const int mode,vec3 inputValue,out float outValue)\n{\nif (mode==0)\noutValue=min(min(inputValue.r,inputValue.g),inputValue.b);\nelse if (mode==1)\noutValue=max(max(inputValue.r,inputValue.g),inputValue.b);\nelse if (mode==2)\noutValue=(inputValue.r+inputValue.g+inputValue.b)/3.0;\nelse if (mode==3)\noutValue=inputValue.r+inputValue.g+inputValue.b;\nelse if (mode==4){\noutValue=dot(inputValue,LUM_WEIGHTS);\n}\nelse if (mode==5)\noutValue=inputValue.r;\nelse if (mode==6)\noutValue=inputValue.g;\nelse if (mode==7)\noutValue=inputValue.b;\n}",node_compare_ar_frag:"void node_compare(int test,float input1,float input2,out bool outValue)\n{\nif (test==0)\noutValue=input1==input2;\nelse if (test==1)\noutvalue=input1 != input2;\nelse if (test==2)\noutValue=input1<input2;\nelse if (test==3)\noutValue=input1>input2;\nelse if (test==4)\noutValue=input1<=input2;\nelse if (test==5)\noutValue=input1>=input2;\n}",node_complement_ar_frag:"void node_complement(vec3 inputValue,out vec3 outColor)\n{\noutColor=1.0-inputValue;\n}",node_composite_ar_frag:"void node_composite(const int operation,const int alphaOperation,vec3 A,vec3 B,float AA,float BA,out float outAlpha,out vec3 outColor,out vec3 outTransparency)\n{\nvec4 A1=vec4(A,AA);\nvec4 B1=vec4(B,BA);\nvec4 color=vec4(0.0);\nif (operation==0)\ncolor=A1;\nelse if (operation==1)\ncolor=B1;\nelse if (operation==2)\ncolor=A1*B1.a+B1*(1.0-A1.a);\nelse if (operation==3)\ncolor=(A1+B1)/2.0;\nelse if (operation==4)\ncolor=A1.a>B1.a?A1:(A1+B1*(1.0-A1.a)/B1.a);\nelse if (operation==5)\ncolor=abs(A1-B1);\nelse if (operation==6)\ncolor=A1.a+B1.a<1.0?A1+B1:A1+B1*(1.0-A1.a)/B1.a;\nelse if (operation==7)\nfor (int i=0;i<4;i++)\ncolor[i]=B1[i]==0.0?0.0:(A1[i]/B1[i]);\nelse if (operation==8)\ncolor=A1+B1-2.0*A1*B1;\nelse if (operation==9)\ncolor=B1-A1;\nelse if (operation==10)\ncolor=2.0*A1*B1/(A1+B1);\nelse if (operation==11)\nfor (int i=0;i<4;i++)\ncolor[i]=A1[i]<0.5?(A1[i]*B1[i]):(A1[i]>=0.0&&A1[i]<=1.0&&B1[i]>=0.0&&B1[i]<=1.0)?(A1[i]+B1[i]-A1[i]*B1[i]):max(A1[i],B1[i]);\nelse if (operation==12)\ncolor=sqrt(A1*A1+B1*B1);\nelse if (operation==13)\ncolor=A1*B1.a;\nelse if (operation==14)\ncolor=B1*A1.a;\nelse if (operation==15)\ncolor=A1*A1.a+B1*(1.0-A1.a);\nelse if (operation==16)\ncolor=max(A1,B1);\nelse if (operation==17)\ncolor=min(A1,B1);\nelse if (operation==18)\ncolor=A1-B1;\nelse if (operation==19)\ncolor=A1*B1;\nelse if (operation==20)\ncolor=A1*(1.0-B1.a);\nelse if (operation==21)\ncolor=A1+B1*(1.0-A1.a);\nelse if (operation==22)\nfor (int i=0;i<4;i++)\ncolor[i]=B1[i]<0.5?(A1[i]*B1[i]):(A1[i]>=0.0&&A1[i]<=1.0&&B1[i]>=0.0&&B1[i]<=1.0)?(A1[i]+B1[i]-A1[i]*B1[i]):max(A1[i],B1[i]);\nelse if (operation==23)\ncolor=A1+B1;\nelse if (operation==24)\nfor (int i=0;i<4;i++)\ncolor[i]=(A1[i]>=0.0&&A1[i]<=1.0&&B1[i]>=0.0&&B1[i]<=1.0)?(A1[i]+B1[i]-A1[i]*B1[i]):max(A1[i],B1[i]);\n\nelse if (operation==25)\nfor (int i=0;i<4;i++)\ncolor[i]=(A1[i]<.75)?(A1[i]*B1[i]):(A1[i]>=0.0&&A1[i]<=1.0&&B1[i]>=0.0&&B1[i]<=1.0)?(A1[i]+B1[i]-A1[i]*B1[i]):max(A1[i],B1[i]);\nelse if (operation==26)\ncolor=B1*(1.0-A1.a);\nelse if (operation==27)\ncolor=A1*(1.0-B1.a)+B1;\nelse if (operation==28)\ncolor=A1*(1.0-B1.a)+B1*(1.0-A1.a);\nif (alphaOperation==1)\ncolor.a=AA;\nelse if (alphaOperation ==2)\ncolor.a=BA;\noutColor=color.rgb;\noutAlpha=color.a;\noutTransparency=outColor;\n}",node_cross_ar_frag:"void node_cross(vec3 input1,vec3 input2,out vec3 outValue)\n{\noutValue=cross(input1,input2);\n}",node_divide_ar_frag:"void node_divide(vec3 input1,vec3 input2,out vec3 outColor)\n{\noutColor=input1/input2;\n}",node_dot_ar_frag:"void node_dot(vec3 input1,vec3 input2,out vec3 outValue)\n{\noutValue=dot(input1,input2);\n}",node_exp_ar_frag:"void node_exp(vec3 inputVal,out vec3 outColor)\n{\noutColor=exp(inputVal);\n}",node_facing_ratio_ar_frag:"void node_facing_ratio(vec3 viewNorm,const float bias,const float gain,const bool invert,const bool linear,out float outValue)\n{\noutValue=dot(normalize(viewNorm),normalize(vViewPosition));\n}",node_flat_ar_frag:"void node_flat(vec3 color,out vec3 outColor)\n{\noutColor=color;\n}",node_float_to_int_ar_frag:"void node_float_to_int(const int mode,float inputValue,out int outValue)\n{\nif (mode==0)\noutValue=int(round(inputValue));\nelse if (mode==1)\noutValue=int(trunc(inputValue));\nelse if (mode==2)\noutValue=int(floor(inputValue));\nelse if (mode==3)\noutValue=int(ceil(inputValue));\n}",node_float_to_matrix_ar_frag:"void node_float_to_matrix(float input00,float input01,float input02,float input03,float input10,float input11,float input12,float input13,float input20,float input21,float input22,float input23,float input30,float input31,float input32,float input33,out mat4 outValue)\n{\noutValue=mat4(input00,input01,input02,input03,input10,input11,input12,input13,input20,input21,input22,input23,input30,input31,input32,input33);\n}",node_float_to_rgba_ar_frag:"void node_float_to_rgba(float r,float g,float b,float a,out vec4 outColor,out float outAlpha,out vec3 outTransparency)\n{\noutAlpha=a;\noutColor=vec4(r,g,b,a);\noutTransparency=vec3(1.0-a);\n}",node_float_to_rgb_ar_frag:"void node_float_to_rgb(float r,float g,float b,out vec3 outValue)\n{\noutValue=vec3(r,g,b);\n}",node_fraction_ar_frag:"void node_fraction(vec3 inputValue,out vec3 outColor)\n{\noutColor=fract(inputValue);\n}",node_is_finite_ar_frag:"void node_is_finite(vec3 inputValue,out bool outValue)\n{\noutValue=!any(isinf(inputValue));\n}",node_image_ar_frag:"\nvoid node_image(sampler2D ima,const int encoding,vec3 multiply,vec3 offset,vec2 uvcoords,float soffset,float toffset,float sscale,float tscale,bool sflip,bool tflip,bool swapSt,out vec3 outColor,out float outAlpha,out vec3 outTransparency){\nvec2 uv=vec2(uvcoords.x,uvcoords.y);\nuv+=vec2(soffset,toffset);\nuv=mix(uv.xy,uv.yx,float(swapSt));\nvec2 stFlip=vec2(float(sflip),float(tflip));\nuv=mix(uv,1.0-uv,stFlip);\nuv*=vec2(sscale,tscale);\nuv.y=1.0-uv.y;\nvec4 tex=texture2D(ima,uv);\noutColor=nodeTexelToLinear(tex,encoding).rgb*multiply+offset;\noutAlpha=tex.a;\noutTransparency=outColor.rgb;\n}\nvoid node_image(sampler2D ima,const int encoding,vec3 multiply,vec3 offset,vec2 uvcoords,float soffset,float toffset,float sscale,float tscale,bool sflip,bool tflip,bool swapSt,vec2 dUVdx,vec2 dUVdy,out vec3 outColor,out float outAlpha,out vec3 outTransparency){\nvec2 uv=vec2(uvcoords.x,uvcoords.y);\nuv+=vec2(soffset,toffset);\nuv=mix(uv.xy,uv.yx,float(swapSt));\nvec2 stFlip=vec2(float(sflip),float(tflip));\nuv=mix(uv,1.0-uv,stFlip);\nuv*=vec2(sscale,tscale);\nuv.y=1.0-uv.y;\n#if __VERSION__==300\nvec2 dInvOp=stFlip*(-2.0)+1.0;\ndUVdx*=vec2(sscale,tscale)*dInvOp;\ndUVdy*=vec2(sscale,tscale)*dInvOp;\nvec4 tex=textureGrad(ima,uv,dUVdx,dUVdy);\n#else\nvec4 tex=texture2D(ima,uv);\n#endif\noutColor=nodeTexelToLinear(tex,encoding).rgb*multiply+offset;\noutAlpha=tex.a;\noutTransparency=outColor.rgb;\n}\nvoid node_image(sampler2D ima,const int encoding,vec4 multiply,vec4 offset,vec2 uvcoords,float soffset,float toffset,float sscale,float tscale,bool sflip,bool tflip,bool swapSt,out vec4 outColor){\nvec2 uv=vec2(uvcoords.x,uvcoords.y);\nuv+=vec2(soffset,toffset);\nuv=mix(uv.xy,uv.yx,float(swapSt));\nvec2 stFlip=vec2(float(sflip),float(tflip));\nuv=mix(uv,1.0-uv,stFlip);\nuv*=vec2(sscale,tscale);\nuv.y=1.0-uv.y;\nvec4 tex=texture2D(ima,uv);\noutColor=nodeTexelToLinear(tex,encoding).rgba*multiply+offset;\n}\nvoid node_image(sampler2D ima,const int encoding,vec4 multiply,vec4 offset,vec2 uvcoords,float soffset,float toffset,float sscale,float tscale,bool sflip,bool tflip,bool swapSt,vec2 dUVdx,vec2 dUVdy,out vec4 outColor){\nvec2 uv=vec2(uvcoords.x,uvcoords.y);\nuv+=vec2(soffset,toffset);\nuv=mix(uv.xy,uv.yx,float(swapSt));\nvec2 stFlip=vec2(float(sflip),float(tflip));\nuv=mix(uv,1.0-uv,stFlip);\nuv*=vec2(sscale,tscale);\nuv.y=1.0-uv.y;\n#if __VERSION__==300\nvec2 dInvOp=stFlip*(-2.0)+1.0;\ndUVdx*=vec2(sscale,tscale)*dInvOp;\ndUVdy*=vec2(sscale,tscale)*dInvOp;\nvec4 tex=textureGrad(ima,uv,dUVdx,dUVdy);\n#else\nvec4 tex=texture2D(ima,uv);\n#endif\noutColor=nodeTexelToLinear(tex,encoding).rgba*multiply+offset;\n}",node_lambert_ar_frag:"void node_lambert(vec3 geometryNormal,float base,vec3 baseColor,vec3 normalCamera,vec3 opacity,out vec4 outColor,out float outAlpha,out vec3 outTransparency)\n{\nNodeMaterial material;\nmaterial.diffuseColor=base*baseColor;\nReflectedLight reflectedLight=ReflectedLight(vec3(0.0),vec3(0.0),vec3(0.0),vec3(0.0));\n#ifdef USE_CLEARCOAT\n#undef USE_CLEARCOAT\n#define _CLEARCOAT_RESTORE\n#endif\nvec3 normal=normalCamera;\n#define RE_Direct RE_DirectDiffuseOnly_Node\n#define RE_IndirectDiffuse RE_IndirectDiffuse_Node\n#include <lights_fragment_begin>\n#include <lights_fragment_maps>\n#include <lights_fragment_end>\n#undef RE_Direct\n#undef RE_IndirectDiffuse\n#ifdef _CLEARCOAT_RESTORE\n#undef _CLEARCOAT_RESTORE\n#define USE_CLEARCOAT\n#endif\noutAlpha=average(opacity);\noutColor=vec4(reflectedLight.directDiffuse+reflectedLight.indirectDiffuse,outAlpha);\noutTransparency=vec3(1.0)-opacity;\n}",node_length_ar_frag:"void node_length(int mode,vec3 inputVec,out float outValue)\n{\nif (mode==0)\noutValue=length(inputVec);\nelse if (mode==1)\noutValue=dot(inputVec,inputVec);\nelse\noutValue=abs(inputVec.x)+abs(inputVec.y)+abs(inputVec.z);\n}",node_log_ar_frag:"void node_log(vec3 inputVec,vec3 base,out vec3 outColor)\n{\noutColor=log(inputVec)/log(base);\n}",node_map_to_mtl_ar_frag:"void node_map_to_mtl(bool opaqueEnabled,vec4 color,out vec4 outColor)\n{\noutColor=vec4(color.rgb,opaqueEnabled?color.a:1.0);\n}",node_matrix_transform_ar_frag:"\nvoid node_matrix_transform(const int transformOrder,const int rotationType,const int rotationUnits,const int rotationOrder,vec3 rotationEuler,vec3 rotationAxis,float rotationAngle,vec3 translation,vec3 scaling,vec3 pivot,out mat4 outMatrix)\n{\nmat4 tMat=translationToMat4(translation);\nmat4 sMat=scalingToMat4(scaling);\nmat4 rMat=mat4(1.0);\nif (rotationType==0){\nvec3 rot=float(rotationUnits)*radians(rotationEuler)+float(1-rotationUnits)*rotationEuler;\nmat3 matX=mat3RotateX(rot.x);\nmat3 matY=mat3RotateY(-rot.y);\nmat3 matZ=mat3RotateZ(rot.z);\nmat3 rotMat3;\nif (rotationOrder==0){\nrotMat3=matX*matY*matZ;\n} else if (rotationOrder==1){\nrotMat3=matX*matZ*matY;\n} else if (rotationOrder==2){\nrotMat3=matY*matX*matZ;\n} else if (rotationOrder==3){\nrotMat3=matY*matZ*matX;\n} else if (rotationOrder==4){\nrotMat3=matZ*matX*matY;\n} else if (rotationOrder==5){\nrotMat3=matZ*matY*matX;\n}\nrMat=toMat4(rotMat3);\n} else if (rotationType==1){\nfloat angleInRadians=float(rotationUnits)*radians(rotationAngle)+float(1-rotationUnits)*rotationAngle;\nrotationAxis=normalize(rotationAxis);\nrMat=toMat4(axisAngleToMat3(rotationAxis,angleInRadians));\n}\nif (transformOrder==0){\noutMatrix=sMat*rMat*tMat;\n} else if (transformOrder==1){\noutMatrix=sMat*tMat*rMat;\n} else if (transformOrder==2){\noutMatrix=rMat*sMat*tMat;\n} else if (transformOrder==3){\noutMatrix=rMat*tMat*sMat;\n} else if (transformOrder==4){\noutMatrix=tMat*sMat*rMat;\n} else if (transformOrder==5){\noutMatrix=tMat*rMat*sMat;\n}\nmat4 rotX90=toMat4(mat3RotateX(PI*0.5));\nmat4 pivotMat=translationToMat4(pivot);\nmat4 invPivotMat=inverse(pivotMat);\noutMatrix=invPivotMat*outMatrix*pivotMat*rotX90;\n}\nvoid node_matrix_transform(const int transformOrder,const int rotationType,const int rotationUnits,const int rotationOrder,vec3 rotationEuler,vec3 rotationAxis,float rotationAngle,vec3 translation,vec3 scaling,vec3 pivot,out mat4 outMatrix,out vec3 outTransparency)\n{\nmat4 tMat=translationToMat4(translation);\nmat4 sMat=scalingToMat4(scaling);\nmat4 rMat=mat4(1.0);\nif (rotationType==0){\nvec3 rot=mix(rotationEuler,radians(rotationEuler),float(rotationUnits));\nmat3 matX=mat3RotateX(rot.x);\nmat3 matY=mat3RotateY(-rot.y);\nmat3 matZ=mat3RotateZ(rot.z);\nmat3 rotMat3;\nif (rotationOrder==0){\nrotMat3=matX*matY*matZ;\n} else if (rotationOrder==1){\nrotMat3=matX*matZ*matY;\n} else if (rotationOrder==2){\nrotMat3=matY*matX*matZ;\n} else if (rotationOrder==3){\nrotMat3=matY*matZ*matX;\n} else if (rotationOrder==4){\nrotMat3=matZ*matX*matY;\n} else if (rotationOrder==5){\nrotMat3=matZ*matY*matX;\n}\nrMat=toMat4(rotMat3);\n} else if (rotationType==1){\nfloat angleInRadians=mix(rotationAngle,radians(rotationAngle),float(rotationUnits));\nrotationAxis=normalize(rotationAxis);\nrMat=toMat4(axisAngleToMat3(rotationAxis,angleInRadians));\n}\noutMatrix=rMat;\nif (transformOrder==0){\noutMatrix=sMat*rMat*tMat;\n} else if (transformOrder==1){\noutMatrix=sMat*tMat*rMat;\n} else if (transformOrder==2){\noutMatrix=rMat*sMat*tMat;\n} else if (transformOrder==3){\noutMatrix=rMat*tMat*sMat;\n} else if (transformOrder==4){\noutMatrix=tMat*sMat*rMat;\n} else if (transformOrder==5){\noutMatrix=tMat*rMat*sMat;\n}\nmat4 pivotMat=translationToMat4(pivot);\nmat4 invPivotMat=inverse(pivotMat);\noutMatrix=invPivotMat*outMatrix*pivotMat;\n}",node_max_ar_frag:"void node_max(vec3 input1,vec3 input2,out vec3 outColor)\n{\noutColor=max(input1,input2);\n}",node_min_ar_frag:"void node_min(vec3 input1,vec3 input2,out vec3 outColor)\n{\noutColor=min(input1,input2);\n}",node_mix_shader_ar_frag:"void node_mix_shader(const int mode,const float mixAmt,vec4 shader1,vec4 shader2,out vec4 color)\n{\nshader1.rgb*=shader1.a;\nshader2.rgb*=shader2.a;\nif (mode==0)\ncolor=mix(shader1,shader2,clamp(mixAmt,0.0,1.0));\nelse\ncolor=vec4(shader1.rgb+shader2.rgb,min(shader1.a,shader2.a));\ncolor.rgb/=color.a;\n}",node_modulo_ar_frag:"void node_modulo(vec3 inputVec,vec3 divisor,out vec3 outColor)\n{\noutColor=mod(inputVec,divisor);\n}",node_multiply_ar_frag:"void node_multiply(vec3 input1,vec3 input2,out vec3 outColor)\n{\noutColor=input1*input2;\n}",node_negate_ar_frag:"void node_negate(vec3 inputVec,out vec3 outColor)\n{\noutColor=-inputVec;\n}",node_normalize_ar_frag:"void node_normalize(vec3 inputVec,out vec3 outValue)\n{\noutValue=normalize(inputVec);\n}",node_normal_map_ar_frag:"void node_normal_map(vec4 tangentParam,vec3 inputVal,vec3 normal,float strength,vec3 tangent,out vec3 outValue){\n#ifdef DOUBLE_SIDED\nnormal=normal*(float(gl_FrontFacing)*2.0-1.0);\n#endif\nvec3 normalTex=inputVal.xyz*2.0-1.0;\nvec3 bitangent=tangentParam.w*cross(normal,tangent);\noutValue=normalize(normalTex.x*tangent+normalTex.y*bitangent+normalTex.z*normal);\noutValue=mix(normal,outValue,strength);\n}",node_pow_ar_frag:"void node_pow(vec3 base,vec3 exponent,out vec3 outColor)\n{\noutColor=pow(base,exponent);\n}",node_random_ar_frag:"void node_abs(vec3 inputColor,out vec3 outColor)\n{\noutColor=inputColor;\n}",node_range_ar_frag:"void node_range(vec3 inputValue,float inputMin,float inputMax,float outputMin,float outputMax,bool smoothstep1,float contrast,float contrastPivot,float bias,float gain,out vec3 outColor,out vec3 outTransparency)\n{\n\noutColor=min(max(inputValue,vec3(inputMin)),vec3(inputMax));\noutColor=(outColor-contrastPivot)*contrast+contrastPivot;\nif (smoothstep1==true){\nfor (int i=0;i<3;i++)\noutColor[i]=smoothstep(outputMin,outputMax,outColor[i]);\n} else\noutColor=min(max(outColor,vec3(outputMin)),vec3(outputMax));\noutTransparency=outColor;\n}",node_ray_switch_ar_frag:"void node_ray_switch(vec3 camera,vec3 diffuseReflection,vec3 diffuseTransmission,vec3 shadow,vec3 specularReflection,vec3 specularTransmission,out vec3 outColor,out float outAlpha)\n{\n#if LIGHT_PATH_IS_CAM_RAY\noutColor=camera;\n#else\noutColor=diffuseReflection;\n#endif\noutAlpha=1.0;\n}",node_reciprocal_ar_frag:"void node_reciprocal(vec3 inputVec,out vec3 outColor)\n{\noutColor=1.0/inputVec;\n}",node_rgba_to_float_ar_frag:"void node_rgba_to_float(const int mode,vec3 inputValue,float inputA,out float outValue,out vec3 outTransparency)\n{\noutTransparency=inputValue+vec3(inputA/4.0);\nif (mode==0)\noutValue=min(min(min(inputValue.r,inputValue.g),inputValue.b),inputA);\nelse if (mode==1)\noutValue=max(max(max(inputValue.r,inputValue.g),inputValue.b),inputA);\nelse if (mode==2)\noutValue=(inputValue.r+inputValue.g+inputValue.b+inputA)/4.0;\nelse if (mode==3)\noutValue=inputValue.r+inputValue.g+inputValue.b+inputA;\nelse if (mode==4){\noutValue=dot(inputValue,LUM_WEIGHTS);\n}\nelse if (mode==5)\noutValue=inputValue.r;\nelse if (mode==6)\noutValue=inputValue.g;\nelse if (mode==7)\noutValue=inputValue.b;\n}",node_rgb_to_float_ar_frag:"void node_rgb_to_float(const int mode,vec3 inputValue,out float outValue)\n{\nif (mode==0)\noutValue=min(min(inputValue.r,inputValue.g),inputValue.b);\nelse if (mode==1)\noutValue=max(max(inputValue.r,inputValue.g),inputValue.b);\nelse if (mode==2)\noutValue=(inputValue.r+inputValue.g+inputValue.b)/3.0;\nelse if (mode==3)\noutValue=inputValue.r+inputValue.g+inputValue.b;\nelse if (mode==4){\noutValue=dot(inputValue,LUM_WEIGHTS);\n}\nelse if (mode==5)\noutValue=inputValue.r;\nelse if (mode==6)\noutValue=inputValue.g;\nelse if (mode==7)\noutValue=inputValue.b;\n}",node_rgb_to_vector_ar_frag:"void node_rgb_to_vector(const int mode,vec3 inputValue,out vec3 outValue)\n{\n\noutValue=inputValue;\n}",node_shadow_matte_ar_frag:"#include <shadowmask_pars_fragment>\nvoid node_shadow_matte(vec3 normal,vec3 shadowColor,float backlighting,float shadowOpacity,out vec4 outColor,out float outAlpha){\nfloat shadow=getShadowMask();\noutColor=vec4(shadowColor,shadowOpacity*(1.0-shadow));\noutAlpha=outColor.a;\n}",node_shuffle_ar_frag:"\nvoid node_shuffle(const int channelR,const int channelG,const int channelB,const int channelA,vec3 color,float alpha,bool negateR,bool negateG,bool negateB,bool negateA,out vec3 outColor,out float outAlpha)\n{\noutColor=vec3(0.0);\nvec4 choose=vec4(color,alpha);\noutAlpha=1.0;\n#if __VERSION__==100\noutColor.r=choose[0];\noutColor.g=choose[1];\noutColor.b=choose[2];\noutAlpha=choose[3];\n#else\noutColor.r=choose[channelR];\noutColor.g=choose[channelG];\noutColor.b=choose[channelB];\noutAlpha=choose[channelA];\n#endif\nif (negateR)\noutColor.r=-outColor.r;\nif (negateG)\noutColor.g=-outColor.g;\nif (negateB)\noutColor.b=-outColor.b;\nif (negateA)\noutAlpha=-outAlpha;\n}\nvoid node_shuffle(const int channelR,const int channelG,const int channelB,const int channelA,vec4 color,float alpha,bool negateR,bool negateG,bool negateB,bool negateA,out vec4 outColor)\n{\noutColor=vec4(0.0);\nvec4 choose=vec4(color.rgb,alpha);\n#if __VERSION__==100\noutColor.r=choose[0];\noutColor.g=choose[1];\noutColor.b=choose[2];\noutColor.a=choose[3];\n#else\noutColor.r=choose[channelR];\noutColor.g=choose[channelG];\noutColor.b=choose[channelB];\noutColor.a=choose[channelA];\n#endif\nif (negateR)\noutColor.r=-outColor.r;\nif (negateG)\noutColor.g=-outColor.g;\nif (negateB)\noutColor.b=-outColor.b;\nif (negateA)\noutColor.a=-outColor.a;\n}",node_sign_ar_frag:"void node_sign(vec3 inputVec,out vec3 outColor)\n{\noutColor=sign(inputVec);\n}",node_skydome_light_ar_frag:"void node_skydome_light(vec3 color,float intensity,out vec4 outgoingLight)\n{\noutgoingLight=vec4(color*intensity,1.0);\n}",node_sqrt_ar_frag:"void node_sqrt(vec3 inputVec,out vec3 outColor)\n{\noutColor=sqrt(inputVec);\n}",node_standard_surface_ar_frag:"void node_standard_surface(vec3 geometryNormal,const bool thinWalled,const float base,const vec3 baseColor,const float diffuseRoughness,const float metalness,const float specular,const vec3 specularColor,const float specularRoughness,const float trans,const vec3 transColor,const float transDepth,const vec3 transScatter,const float transExtraRoughness,const float subsurface,const vec3 subsurfaceColor,const vec3 subsurfaceRadius,const float clearcoat,const vec3 clearcoatColor,const float clearcoatRoughness,const float sheen,const vec3 sheenColor,const float sheenRoughness,const float emission,const vec3 emissionColor,const vec3 opacity,const vec3 normal,const vec3 clearcoatNormal,const float specularIOR,out vec4 outColor,out vec3 outTransparency)\n{\nNodeMaterial material;\nvec3 baseColorWeighted=base*baseColor.rgb;\nmaterial.diffuseColor=baseColorWeighted*(1.0-metalness)*(1.0-trans);\n#ifdef USE_CLEARCOAT\nmaterial.clearcoat=saturate(clearcoat);\nmaterial.clearcoatRoughness=clamp(clearcoatRoughness,0.0,1.0);\nmaterial.clearcoatF0=vec3(0.04);\nmaterial.clearcoatF90=1.0;\n#endif\n#ifdef USE_SHEEN\nmaterial.sheenColor=saturate(sheen*sheenColor);\nmaterial.sheenRoughness=clamp(sheenRoughness,0.0,1.0);\n#endif\nvec3 dxy=max(abs(dFdx(geometryNormal)),abs(dFdy(geometryNormal)));\nfloat geometryRoughness=max(max(dxy.x,dxy.y),dxy.z);\nmaterial.roughness=max(specularRoughness,0.0525);\nmaterial.roughness+=geometryRoughness;\nmaterial.roughness=min(material.roughness,1.0);\nvec3 specularColorWeighted=specular*specularColor;\nvec3 dielRefl=pow2((1.0-specularIOR)/(1.0+specularIOR))*specularColorWeighted;\nmaterial.specularColor=mix(dielRefl,baseColorWeighted,metalness);\nmaterial.fresnelRefl90=mix(specularColorWeighted,vec3(1.0),metalness);\nmaterial.specularF90=average(material.fresnelRefl90);\nmaterial.refractionColor=pow(trans*(1.0-metalness)*transColor.rgb,vec3(2.0));\nmaterial.refractionIOR=specularIOR;\nmaterial.refractionRoughness=material.roughness;\nReflectedLight reflectedLight=ReflectedLight(vec3(0.0),vec3(0.0),vec3(0.0),vec3(0.0));\nvec3 refractedLight=vec3(0.0);\n#ifdef USE_GTAO\nvec4 gtaoVisibilityBentNormal=texture2D(gtaoMap,gl_FragCoord.xy/currResolution);\nvec3 bentNormal=normalize(unpackRGBToNormal(gtaoVisibilityBentNormal.gba));\n#define PROBE_NORMAL bentNormal\n#endif\n#define RE_Direct RE_Direct_Node\n#define RE_IndirectDiffuse RE_IndirectDiffuse_Node\n#define RE_IndirectSpecular RE_IndirectSpecular_Node\n#define RE_Refraction RE_Refraction_Node\n#include <lights_fragment_begin>\n#include <lights_fragment_maps>\n#include <lights_fragment_end>\n#undef RE_Direct\n#undef RE_IndirectDiffuse\n#undef RE_IndirectSpecular\n#undef RE_Refraction\n#ifdef PROBE_NORMAL\n#undef PROBE_NORMAL\n#endif\n#ifdef USE_GTAO\nreflectedLight.indirectDiffuse*=gtaoVisibilityBentNormal.r;\nfloat gtaoVisibility=gtaoVisibilityBentNormal.r;\nvec3 gtaoBentNormal=bentNormal;\nvec3 gtaoViewDir=geometry.viewDir;\nvec3 gtaoNormal=normal;\nfloat gtaoRoughness=material.roughness;\n#endif\n#include <lights_fragment_gtso>\nvec3 totalEmissiveRadiance=emission*emissionColor;\nvec3 outSpecular=reflectedLight.directSpecular+reflectedLight.indirectSpecular;\nvec3 outColor3=reflectedLight.directDiffuse+reflectedLight.indirectDiffuse +\noutSpecular+totalEmissiveRadiance;\n#ifdef USE_SHEEN\nfloat sheenEnergyComp=1.0-0.157*max3(material.sheenColor);\noutColor3=outColor3*sheenEnergyComp+sheenSpecular;\n#endif\n#ifdef USE_CLEARCOAT\nfloat dotNVcc=saturate(dot(geometry.normal,geometry.viewDir));\nvec3 Fcc=F_Schlick(material.clearcoatF0,material.clearcoatF90,dotNVcc);\noutColor3=outColor3*(1.0-material.clearcoat*Fcc)+clearcoatSpecular*material.clearcoat;\n#endif\nfloat alpha=1.0;\nif (thinWalled){\nalpha=average(opacity)*(1.0-saturate(trans)+maxFromRGB(outSpecular)*saturate(trans));\n} else {\noutColor3+=refractedLight;\n}\noutColor=vec4(outColor3,saturate(alpha));\noutTransparency=outColor3;\n}",node_subtract_ar_frag:"void node_subtract(vec3 input1,vec3 input2,out vec3 outColor)\n{\noutColor=input1-input2;\n}",node_trigo_ar_frag:"void node_trigo(const int function,const int units,vec3 inputVec,float frequency,float phase,out vec3 outColor)\n{\nif (units==1&&function>=0&&function <=2)\ninputVec=radians(inputVec);\nif (function==0)\noutColor=cos(inputVec*frequency+phase);\nelse if (function==1)\noutColor=sin(inputVec*frequency+phase);\nelse if (function==2)\noutColor=tan(inputVec*frequency+phase);\nelse if (function==3)\noutColor=acos(inputVec*frequency+phase);\nelse if (function==4)\noutColor=asin(inputVec*frequency+phase);\nelse if (function==5)\noutColor=atan(inputVec*frequency+phase);\nelse if (function==6)\noutColor=cosh(inputVec*frequency+phase);\nelse if (function==7)\noutColor=sinh(inputVec*frequency+phase);\nelse\noutColor=tanh(inputVec*frequency+phase);\nif (units==1&&function>=3&&function <=5)\noutColor=degrees(outColor);\n}",node_triplanar_ar_frag:"\nvoid node_triplanar(const int coordSpace,const bool inputPerAxis,const bool flipOnOppositeDirection,const float blendFactor,vec4 inputColor,vec4 inputColorY,vec4 inputColorZ,vec3 scaling,vec3 rotation,vec3 offset,vec3 normal,out vec4 outColor)\n{\nif (inputPerAxis==true){\nvec3 barycentric=abs(normal);\nbarycentric/=barycentric.x+barycentric.y+barycentric.z;\nvec3 edgeShape=min(min(barycentric.yzx,barycentric.zxy),(blendFactor-1.0)/(blendFactor-3.0));\nvec3 edgeValue=(1.0-blendFactor)*(1.0-edgeShape)/2.0;\nvec3 weight=max((barycentric-edgeValue)/(1.0-edgeValue),EPSILON);\nweight/=(weight.x+weight.y+weight.z);\noutColor=weight.x*inputColor+weight.y*inputColorY+weight.z*inputColorZ;\n} else {\noutColor=inputColor;\n}\n}\nvoid node_triplanar(const int coordSpace,const bool inputPerAxis,const bool flipOnOppositeDirection,const float blendFactor,vec3 inputColor,vec3 inputColorY,vec3 inputColorZ,vec3 scaling,vec3 rotation,vec3 offset,vec3 normal,out vec3 outColor)\n{\nif (inputPerAxis==true){\nvec3 barycentric=abs(normal);\nbarycentric/=barycentric.x+barycentric.y+barycentric.z;\nvec3 edgeShape=min(min(barycentric.yzx,barycentric.zxy),(blendFactor-1.0)/(blendFactor-3.0));\nvec3 edgeValue=(1.0-blendFactor)*(1.0-edgeShape)/2.0;\nvec3 weight=max((barycentric-edgeValue)/(1.0-edgeValue),EPSILON);\nweight/=(weight.x+weight.y+weight.z);\noutColor=weight.x*inputColor+weight.y*inputColorY+weight.z*inputColorZ;\n} else {\noutColor=inputColor;\n}\n}",node_triplanar_uv_ar_frag:"\nfloat screenSpaceDither12(vec2 vScreenPos){\nfloat vDither=dot(vec2(171.0,231.0),vScreenPos.xy);\nreturn fract(vDither/103.0);\n}\nvec3 smoothContrast(vec3 alpha,float contrast){\nvec3 powAlpha=pow(alpha,vec3(contrast));\nreturn powAlpha/(powAlpha.x+powAlpha.y+powAlpha.z);\n}\nvoid node_triplanar_uv(const bool flipOnOppositeDirection,const float blendFactor,vec3 vector,vec3 normal,out vec2 outUV,out vec2 dUVdx,out vec2 dUVdy)\n{\nvec3 norm=normal;\nfloat fp=float(flipOnOppositeDirection);\nvec2 xFac=mix(vec2(1.0),vec2(-sign(norm.x),1.0),fp);\nvec2 uvX=vec2(vector.z,vector.y)*xFac+0.5;\nvec2 yFac=mix(vec2(1.0),vec2(1.0,-sign(norm.y)),fp);\nvec2 uvY=vec2(vector.x,vector.z)*yFac+0.5;\nvec2 zFac=vec2(mix(1.0,sign(norm.z),fp),1.0);\nvec2 uvZ=vec2(vector.x,vector.y)*zFac+0.5;\n#if __VERSION__==300\nvec3 alpha=abs(norm);\nfloat contrast=mix(20.0,1.0,blendFactor);\nalpha=smoothContrast(alpha,contrast);\nfloat dither=screenSpaceDither12(gl_FragCoord.xy);\ndither=clamp(dither,0.01,0.99);\nvec3 duvwdx=dFdx(vector);\nvec3 duvwdy=dFdy(vector);\nif (alpha.x>dither){\noutUV=uvX;\ndUVdx=duvwdx.yz*xFac;\ndUVdy=duvwdy.yz*xFac;\n} else if (1.0-alpha.z>dither){\noutUV=uvY;\ndUVdx=duvwdx.xz*yFac;\ndUVdy=duvwdy.xz*yFac;\n} else {\noutUV=uvZ;\ndUVdx=duvwdx.xy*zFac;\ndUVdy=duvwdy.xy*zFac;\n}\n#else\nvec3 absNorm=abs(norm);\nvec3 faceMask=step(absNorm.yzx,absNorm)*step(absNorm.zxy,absNorm);\noutUV=faceMask.x*uvX+faceMask.y*uvY+faceMask.z*uvZ;\n#endif\n}\nvoid node_triplanar_uv(const bool flipOnOppositeDirection,const int projectionAxis,vec3 vector,vec3 normal,out vec2 outUV)\n{\nvec3 norm=normal;\nfloat fp=float(flipOnOppositeDirection);\nif (projectionAxis==0){\nvec2 xFac=mix(vec2(1.0),vec2(-sign(norm.x),1.0),fp);\noutUV=vec2(vector.z,vector.y)*xFac+0.5;\n} else if (projectionAxis==1){\nvec2 yFac=mix(vec2(1.0),vec2(1.0,-sign(norm.y)),fp);\noutUV=vec2(vector.x,vector.z)*yFac+0.5;\n} else if (projectionAxis==2){\nvec2 zFac=vec2(mix(1.0,sign(norm.z),fp),1.0);\noutUV=vec2(vector.x,vector.y)*zFac+0.5;\n} else if (projectionAxis==3){\nvec2 xFac=mix(vec2(1.0),vec2(-sign(norm.x),1.0),fp);\nvec2 uvX=vec2(vector.z,vector.y)*xFac+0.5;\nvec2 yFac=mix(vec2(1.0),vec2(1.0,-sign(norm.y)),fp);\nvec2 uvY=vec2(vector.x,vector.z)*yFac+0.5;\nvec2 zFac=vec2(mix(1.0,sign(norm.z),fp),1.0);\nvec2 uvZ=vec2(vector.x,vector.y)*zFac+0.5;\nvec3 absNorm=abs(norm);\nvec3 faceMask=step(absNorm.yzx,absNorm)*step(absNorm.zxy,absNorm);\noutUV=faceMask.x*uvX+faceMask.y*uvY+faceMask.z*uvZ;\n}\n}",node_two_sided_ar_frag:"void node_two_sided(float frontFacing,vec3 front,vec3 back,out vec3 outColor)\n{\noutColor=(frontFacing>0.0)?front:back;\n}",node_user_data_color_ar_frag:"void node_user_data_color(vec4 color,out vec3 outColor,out float outAlpha)\n{\noutColor=color.rgb;\noutAlpha=color.a;\n}",node_uv_projection_ar_frag:"#define TEX_PROJ_PLANAR 0\n#define TEX_PROJ_SPHERICAL 1\n#define TEX_PROJ_CYLINDRICAL 2\n#define TEX_PROJ_BALL 3\n#define TEX_PROJ_CUBIC 4\n#define TEX_PROJ_SHRINK_WRAP 5\n#define COORD_WORLD_SPACE 0\n#define COORD_OBJECT_SPACE 1\nvoid node_uv_projection(const int projectionType,const int coordSpace,vec3 projectionColor,float uAngleDegrees,float vAngleDegrees,mat4 matrix,out vec2 outUV)\n{\nvec3 vector=vWorldPosition.xyz;\nif (coordSpace==COORD_OBJECT_SPACE){\nvector=(invModelMatrix*vec4(vector,1.0)).xyz;\n}\nvector=(matrix*vec4(vector,1.0)).xyz;\nif (projectionType==TEX_PROJ_PLANAR){\noutUV=vector.xy*0.5+0.5;\n} else if (projectionType==TEX_PROJ_SPHERICAL){\nvector=normalize(vector);\nfloat uAngle=radians(uAngleDegrees);\nfloat vAngle=radians(vAngleDegrees);\nfloat theta=atan(vector.x,vector.z)/(uAngle);\ntheta=theta*0.5+0.5;\nfloat vAngleNormalized=vAngle*2.0/PI;\nfloat phi=(acos(-vector.y)/PI-0.5)/vAngleNormalized+0.5;\noutUV=vec2(theta,phi);\n} else if (projectionType==TEX_PROJ_CYLINDRICAL){\nvector.xz=normalize(vector).xz;\nfloat uAngle=radians(uAngleDegrees);\nvec2 uv=vec2((atan(vector.x,vector.z))/(uAngle),(vector.y)/2.0);\noutUV=uv+0.5;\n} else if (projectionType==TEX_PROJ_BALL){\nvec3 normal=normalize(vector);\nnormal.z+=1.0;\nnormal/=(2.0*sqrt(max(0.5*normal.z,0.0)));\noutUV=clamp(0.5*normal.xy+0.5,0.0,1.0);\n} else if (projectionType==TEX_PROJ_CUBIC){\nvec2 uvX=vec2(vector.z,vector.y)/abs(vector.x);\nvec2 uvY=vec2(vector.x,vector.z)/abs(vector.y);\nvec2 uvZ=vec2(vector.x,vector.y)/abs(vector.z);\nvec3 absVec=abs(vector);\nvec3 faceMask=step(absVec.yzx,absVec)*step(absVec.zxy,absVec);\nvec2 uv=faceMask.x*uvX+faceMask.y*uvY+faceMask.z*uvZ;\nuv=uv*0.5+0.5;\noutUV=uv;\n} else if (projectionType==TEX_PROJ_SHRINK_WRAP){\nvector=normalize(vector);\noutUV=normalize(vector.xz)*acos(vector.y)/PI;\noutUV=outUV*0.5+0.5;\n}\n}",node_vector_to_rgb_ar_frag:"void node_vector_to_rgb(const int mode,vec3 inputValue,out vec3 outColor)\n{\nif (mode==0)\noutColor=inputValue;\nelse if (mode==1)\noutColor=normalize(inputValue);\nelse if (mode==2)\noutColor=inputValue;\n}",node_add_shader_bl_frag:"void node_add_shader(vec4 color1,vec4 color2,out vec4 outColor){\noutColor.rgb=color1.rgb+color2.rgb;\noutColor.a=clamp(color1.a+color2.a,0.0,1.0);\n}",node_ambient_occlusion_bl_frag:"void node_ambient_occlusion(vec4 color,float distance,vec3 normal,out vec4 outColor,out float outAO){\noutColor=color;\noutAO=1.0;\n}",node_attribute_bl_frag:"void node_attribute(vec4 paramAttr,out vec4 outColor,out vec3 outVector,out float outFac,out float outAlpha){\noutColor=vec4(paramAttr.xyz,1.0);\noutVector=paramAttr.xyz;\noutFac=average(paramAttr.xyz);\noutAlpha=paramAttr.w;\n}",node_background_bl_frag:"void node_background(vec4 color,float strength,out vec4 outColor)\n{\noutColor=strength*color;\n}",node_bevel_bl_frag:"void node_bevel(float radius,vec3 normal,out vec3 outNormal){\noutNormal=normal;\n}",node_blackbody_bl_frag:"void node_blackbody(float temp,out vec4 outColor)\n{\noutColor=vec4(colorTempToRGB(temp),1.0);\n}",node_brightcontrast_bl_frag:"void node_brightcontrast(vec4 color,float bright,float contrast,out vec4 outColor)\n{\nfloat bminc=bright-contrast*0.5;\noutColor.r=max((1.0+contrast)*color.r+bminc,0.0);\noutColor.g=max((1.0+contrast)*color.g+bminc,0.0);\noutColor.b=max((1.0+contrast)*color.b+bminc,0.0);\noutColor.a=color.a;\n}",node_bsdf_anisotropic_bl_frag:"void node_bsdf_anisotropic(vec4 color,float roughness,float anisotropy,float rotation,vec3 normal,vec3 tangent,out vec4 outColor)\n{\noutColor=color;\n}",node_bsdf_diffuse_bl_frag:"\nvoid node_bsdf_diffuse(vec4 color,float roughness,vec3 normal,out vec4 outColor){\nnormal=vec3(normal[0],normal[2],-normal[1]);\nnormal=(viewMatrix*vec4(normal.xyz,0.0)).xyz;\nNodeMaterial material;\nmaterial.diffuseColor=color.rgb;\nReflectedLight reflectedLight=ReflectedLight(vec3(0.0),vec3(0.0),vec3(0.0),vec3(0.0));\n#ifdef USE_CLEARCOAT\n#undef USE_CLEARCOAT\n#define _CLEARCOAT_RESTORE\n#endif\n#ifdef USE_GTAO\nvec4 gtaoVisibilityBentNormal=texture2D(gtaoMap,gl_FragCoord.xy/currResolution);\nvec3 bentNormal=normalize(unpackRGBToNormal(gtaoVisibilityBentNormal.gba));\n#define PROBE_NORMAL bentNormal\n#endif\n#define RE_Direct RE_DirectDiffuseOnly_Node\n#define RE_IndirectDiffuse RE_IndirectDiffuse_Node\n#include <lights_fragment_begin>\n#include <lights_fragment_maps>\n#include <lights_fragment_end>\n#undef RE_Direct\n#undef RE_IndirectDiffuse\n#ifdef PROBE_NORMAL\n#undef PROBE_NORMAL\n#endif\n#ifdef _CLEARCOAT_RESTORE\n#undef _CLEARCOAT_RESTORE\n#define USE_CLEARCOAT\n#endif\n#ifdef USE_GTAO\nreflectedLight.indirectDiffuse*=gtaoVisibilityBentNormal.r;\n#endif\noutColor=vec4(reflectedLight.directDiffuse+reflectedLight.indirectDiffuse,1.0);\n}",node_bsdf_glass_bl_frag:"void node_bsdf_glass(vec3 geometryNormal,vec4 color,float roughness,float ior,vec3 normal,float thinFilmThickness,float thinFilmIOR,out vec4 outColor){\nnormal=normalize(normal);\nnormal=swizzleUpY(normal);\nvec3 normalWorld=normal;\nnormal=(viewMatrix*vec4(normal.xyz,0.0)).xyz;\nNodeMaterial material;\nmaterial.specularColor=vec3(1.0);\nmaterial.fresnelRefl90=vec3(1.0);\nmaterial.roughness=clamp(roughness,0.0,1.0);\nmaterial.refractionColor=vec3(1.0);\nmaterial.refractionIOR=ior;\nmaterial.refractionRoughness=pow2(roughness);\n#if defined(ENVMAP_TYPE_CUBE)||defined(ENVMAP_TYPE_CUBE_UV)\nfloat geomRoughness=calcGeometryRoughness(geometryNormal);\nmaterial.roughness=calcCubeUVAdjustedRoughness(material.roughness,geomRoughness);\nmaterial.refractionRoughness=calcCubeUVAdjustedRoughness(material.refractionRoughness,geomRoughness);\n#endif\nReflectedLight reflectedLight=ReflectedLight(vec3(0.0),vec3(0.0),vec3(0.0),vec3(0.0));\nvec3 refractedLight=vec3(0.0);\n#ifdef USE_CLEARCOAT\n#undef USE_CLEARCOAT\n#define _CLEARCOAT_RESTORE\n#endif\n#ifdef USE_GTAO\nvec4 gtaoVisibilityBentNormal=texture2D(gtaoMap,gl_FragCoord.xy/currResolution);\nvec3 bentNormal=normalize(unpackRGBToNormal(gtaoVisibilityBentNormal.gba));\n#define PROBE_NORMAL bentNormal\n#endif\n#define RE_Direct RE_Direct_Node\n#define RE_IndirectDiffuse RE_IndirectDiffuse_Empty\n#define RE_IndirectSpecular RE_IndirectSpecular_Node\n#define RE_Refraction RE_Refraction_Node\n#include <lights_fragment_begin>\n#include <lights_fragment_maps>\n#include <lights_fragment_end>\n#undef RE_Direct\n#undef RE_IndirectDiffuse\n#undef RE_IndirectSpecular\n#undef RE_Refraction\n#ifdef PROBE_NORMAL\n#undef PROBE_NORMAL\n#endif\n#ifdef _CLEARCOAT_RESTORE\n#undef _CLEARCOAT_RESTORE\n#define USE_CLEARCOAT\n#endif\n#ifdef USE_GTAO\nfloat gtaoVisibility=gtaoVisibilityBentNormal.r;\nvec3 gtaoBentNormal=bentNormal;\nvec3 gtaoViewDir=geometry.viewDir;\nvec3 gtaoNormal=normal;\nfloat gtaoRoughness=material.roughness;\n#endif\n#include <lights_fragment_gtso>\nvec3 viewWorld;\nif (isOrthographic)\nviewWorld=(invViewMatrix*vec4(0.0,0.0,-1.0,0.0)).xyz;\nelse\nviewWorld=(invViewMatrix*vec4(-vViewPosition,0.0)).xyz;\nviewWorld=normalize(viewWorld);\nfloat fresnel=fresnelReflection(viewWorld,normalWorld,ior);\noutColor=vec4(color.rgb*mix(refractedLight,reflectedLight.directSpecular\n+ reflectedLight.indirectSpecular,fresnel),1.0);\n}\nvoid node_bsdf_glass(vec3 geometryNormal,vec4 color,float roughness,float ior,vec3 normal,out vec4 outColor){\nnode_bsdf_glass(geometryNormal,color,roughness,ior,normal,0.0,0.0,outColor);\n}",node_bsdf_glossy_bl_frag:"void node_bsdf_glossy(vec3 geometryNormal,vec4 color,float roughness,float anisotropy,float rotation,vec3 normal,vec3 tangent,out vec4 outColor){\nnormal=vec3(normal[0],normal[2],-normal[1]);\nnormal=normalize((viewMatrix*vec4(normal.xyz,0.0)).xyz);\nNodeMaterial material;\nmaterial.specularColor=vec3(1.0);\nmaterial.fresnelRefl90=vec3(1.0);\nmaterial.roughness=clamp(roughness,0.0,1.0);\n#if defined(ENVMAP_TYPE_CUBE)||defined(ENVMAP_TYPE_CUBE_UV)\nfloat geomRoughness=calcGeometryRoughness(geometryNormal);\nmaterial.roughness=calcCubeUVAdjustedRoughness(material.roughness,geomRoughness);\n#endif\nReflectedLight reflectedLight=ReflectedLight(vec3(0.0),vec3(0.0),vec3(0.0),vec3(0.0));\n#ifdef USE_CLEARCOAT\n#undef USE_CLEARCOAT\n#define _CLEARCOAT_RESTORE\n#endif\n#ifdef USE_GTAO\nvec4 gtaoVisibilityBentNormal=texture2D(gtaoMap,gl_FragCoord.xy/currResolution);\nvec3 bentNormal=normalize(unpackRGBToNormal(gtaoVisibilityBentNormal.gba));\n#define PROBE_NORMAL bentNormal\n#endif\n#define RE_Direct RE_Direct_Node\n#define RE_IndirectDiffuse RE_IndirectDiffuse_Empty\n#define RE_IndirectSpecular RE_IndirectSpecular_Node\n#include <lights_fragment_begin>\n#include <lights_fragment_maps>\n#include <lights_fragment_end>\n#undef RE_Direct\n#undef RE_IndirectDiffuse\n#undef RE_IndirectSpecular\n#ifdef PROBE_NORMAL\n#undef PROBE_NORMAL\n#endif\n#ifdef _CLEARCOAT_RESTORE\n#undef _CLEARCOAT_RESTORE\n#define USE_CLEARCOAT\n#endif\n#ifdef USE_GTAO\nfloat gtaoVisibility=gtaoVisibilityBentNormal.r;\nvec3 gtaoBentNormal=bentNormal;\nvec3 gtaoViewDir=geometry.viewDir;\nvec3 gtaoNormal=normal;\nfloat gtaoRoughness=material.roughness;\n#endif\n#include <lights_fragment_gtso>\noutColor=vec4(color.rgb*(reflectedLight.directSpecular\n+ reflectedLight.indirectSpecular),1.0);\n}",node_bsdf_metallic_bl_frag:"#define BSDF_METALLIC_BECKMANN 0\n#define BSDF_METALLIC_GGX 1\n#define BSDF_METALLIC_MULTI_GGX 2\nvec3 fresnelConductor(float cosi,vec3 eta,vec3 k){\nvec3 cosiSqr=vec3(cosi*cosi);\nvec3 tmpF=(eta*eta)+(k*k);\nvec3 tmp2EtaCosI=2.0*eta*vec3(cosi);\nvec3 tmp=tmpF*cosiSqr;\nvec3 rparl2=(tmp-tmp2EtaCosI+vec3(1.0))/(tmp+tmp2EtaCosI+vec3(1.0));\nvec3 rperp2=(tmpF-tmp2EtaCosI+cosiSqr)/(tmpF+tmp2EtaCosI+cosiSqr);\nreturn (rparl2+rperp2)*0.5;\n}\nvoid node_bsdf_metallic(vec3 geometryNormal,const int distribution,const bool usePhysicalConductor,vec4 baseColor,vec4 edgeTint,vec3 ior,vec3 extinction,float roughness,float anisotropy,float rotation,vec3 normal,vec3 tangent,float thinFilmThickness,float thinFilmIOR,out vec4 outColor){\nnormal=vec3(normal[0],normal[2],-normal[1]);\nnormal=normalize((viewMatrix*vec4(normal.xyz,0.0)).xyz);\nNodeMaterial material;\nif (usePhysicalConductor){\nmaterial.specularColor=saturate(fresnelConductor(1.0,ior,extinction));\nmaterial.fresnelRefl90=saturate(fresnelConductor(1.0/7.0,ior,extinction));\n} else {\nmaterial.specularColor=saturate(baseColor.rgb);\nmaterial.fresnelRefl90=saturate(edgeTint.rgb);\n}\nmaterial.specularF90=average(material.fresnelRefl90);\nmaterial.roughness=saturate(roughness);\n#if defined(ENVMAP_TYPE_CUBE)||defined(ENVMAP_TYPE_CUBE_UV)\nfloat geomRoughness=calcGeometryRoughness(geometryNormal);\nmaterial.roughness=calcCubeUVAdjustedRoughness(material.roughness,geomRoughness);\n#endif\nReflectedLight reflectedLight=ReflectedLight(vec3(0.0),vec3(0.0),vec3(0.0),vec3(0.0));\n#ifdef USE_CLEARCOAT\n#undef USE_CLEARCOAT\n#define _CLEARCOAT_RESTORE\n#endif\n#ifdef USE_GTAO\nvec4 gtaoVisibilityBentNormal=texture2D(gtaoMap,gl_FragCoord.xy/currResolution);\nvec3 bentNormal=normalize(unpackRGBToNormal(gtaoVisibilityBentNormal.gba));\n#define PROBE_NORMAL bentNormal\n#endif\n#define RE_Direct RE_Direct_Node\n#define RE_IndirectDiffuse RE_IndirectDiffuse_Empty\n#define RE_IndirectSpecular RE_IndirectSpecular_Node\n#include <lights_fragment_begin>\n#include <lights_fragment_maps>\n#include <lights_fragment_end>\n#undef RE_Direct\n#undef RE_IndirectDiffuse\n#undef RE_IndirectSpecular\n#ifdef PROBE_NORMAL\n#undef PROBE_NORMAL\n#endif\n#ifdef _CLEARCOAT_RESTORE\n#undef _CLEARCOAT_RESTORE\n#define USE_CLEARCOAT\n#endif\n#ifdef USE_GTAO\nfloat gtaoVisibility=gtaoVisibilityBentNormal.r;\nvec3 gtaoBentNormal=bentNormal;\nvec3 gtaoViewDir=geometry.viewDir;\nvec3 gtaoNormal=normal;\nfloat gtaoRoughness=material.roughness;\n#endif\n#include <lights_fragment_gtso>\noutColor=vec4(reflectedLight.directDiffuse+reflectedLight.indirectDiffuse+reflectedLight.directSpecular+reflectedLight.indirectSpecular,1.0);\n}\nvoid node_bsdf_metallic(vec3 geometryNormal,const int distribution,const bool usePhysicalConductor,vec4 baseColor,vec4 edgeTint,vec3 ior,vec3 extinction,float roughness,float anisotropy,float rotation,vec3 normal,vec3 tangent,out vec4 outColor){\nnode_bsdf_metallic(geometryNormal,distribution,usePhysicalConductor,baseColor,edgeTint,ior,extinction,roughness,anisotropy,rotation,normal,tangent,0.0,0.0,outColor);\n}",node_bsdf_hair_bl_frag:"void node_bsdf_hair(vec4 color,float offset,float roughnessU,float roughnessV,vec3 tangent,out vec4 outColor)\n{\noutColor=color;\n}",node_bsdf_principled_bl_frag:"float iorToF0(float eta){\nfloat A=(eta-1.0)/(eta+1.0);\nreturn A*A;\n}\n#ifdef USE_SHEEN_BLENDER\nfloat principledSheen(float NV,float rough){\nfloat den=35.6694*rough*rough-24.4269*rough*NV-0.1405*NV*NV+6.1211*rough+0.28105*NV-0.1405;\nfloat num=58.5299*rough*rough-85.0941*rough*NV+9.8955*NV*NV+1.9250*rough+74.2268*NV-0.2246;\nreturn saturate(den/num);\n}\n#endif\nvoid node_bsdf_principled(vec3 geometryNormal,vec4 baseColor,float metallic,float roughness,float ior,float alpha,vec3 normal,float diffuseRoughness,float subsurface,vec3 subsurfaceRadius,float subsurfaceScale,float subsurfaceIOR,float subsurfaceAnisotropy,float specularIORLevel,vec4 specularTint,float anisotropic,float anisotropicRotation,vec3 tangent,float transmission,float clearcoat,float clearcoatRoughness,float clearcoatIOR,vec4 clearcoatTint,vec3 clearcoatNormal,float sheen,float sheenRoughness,vec4 sheenTint,vec4 emission,float emissionStrength,float thinFilmThickness,float thinFilmIOR,out vec4 outColor){\nnormal=vec3(normal[0],normal[2],-normal[1]);\nvec3 normalWorld=normal;\nnormal=(viewMatrix*vec4(normal.xyz,0.0)).xyz;\nNodeMaterial material;\nmetallic=clamp(metallic,0.0,1.0);\nfloat dielectric=1.0-metallic;\ntransmission*=dielectric;\nmaterial.diffuseColor=baseColor.rgb*dielectric;\n#ifdef USE_CLEARCOAT\nmaterial.clearcoat=saturate(clearcoat);\nmaterial.clearcoatRoughness=clamp(clearcoatRoughness,0.0,1.0);\nmaterial.clearcoatF0=vec3(0.04);\nmaterial.clearcoatF90=1.0;\n#endif\n#ifdef USE_SHEEN_BLENDER\nfloat dotNVsh=dot(normal,(isOrthographic)?vec3(0,0,1):normalize(vViewPosition));\nmaterial.diffuseColor+=sheen*sheenTint.rgb*principledSheen(dotNVsh,sheenRoughness);\n#endif\nmaterial.roughness=clamp(roughness,0.0,1.0);\nvec3 viewWorld;\nif (isOrthographic)\nviewWorld=(invViewMatrix*vec4(0.0,0.0,-1.0,0.0)).xyz;\nelse\nviewWorld=(invViewMatrix*vec4(-vViewPosition,0.0)).xyz;\nviewWorld=normalize(viewWorld);\nfloat f0d=iorToF0(ior);\nif (specularIORLevel != 0.5)\nf0d*=2.0*specularIORLevel;\nvec3 F0d=vec3(f0d)*specularTint.rgb;\nF0d=clamp(F0d,vec3(0.0),vec3(1.0));\nvec3 F90d=vec3(1.0);\nmaterial.specularColor=mix(F0d,baseColor.rgb,metallic);\nmaterial.fresnelRefl90=mix(F90d,specularTint.rgb,metallic);\nmaterial.specularF90=average(material.fresnelRefl90);\nmaterial.refractionColor=baseColor.rgb;\nmaterial.refractionIOR=ior;\nmaterial.refractionRoughness=pow2(roughness);\n#if defined(ENVMAP_TYPE_CUBE)||defined(ENVMAP_TYPE_CUBE_UV)\nfloat geomRoughness=calcGeometryRoughness(geometryNormal);\nmaterial.roughness=calcCubeUVAdjustedRoughness(material.roughness,geomRoughness);\nmaterial.refractionRoughness=calcCubeUVAdjustedRoughness(material.refractionRoughness,geomRoughness);\n#ifdef USE_CLEARCOAT\nmaterial.clearcoatRoughness=calcCubeUVAdjustedRoughness(material.clearcoatRoughness,geomRoughness);\nclearcoatNormal=normalize(vec3(clearcoatNormal[0],clearcoatNormal[2],-clearcoatNormal[1]));\nclearcoatNormal=(viewMatrix*vec4(clearcoatNormal.xyz,0.0)).xyz;\n#endif\n#endif\nReflectedLight reflectedLight=ReflectedLight(vec3(0.0),vec3(0.0),vec3(0.0),vec3(0.0));\nvec3 refractedLight=vec3(0.0);\n#ifdef USE_GTAO\nvec4 gtaoVisibilityBentNormal=texture2D(gtaoMap,gl_FragCoord.xy/currResolution);\nvec3 bentNormal=normalize(unpackRGBToNormal(gtaoVisibilityBentNormal.gba));\n#define PROBE_NORMAL bentNormal\n#endif\n#define RE_Direct RE_Direct_Node\n#define RE_IndirectDiffuse RE_IndirectDiffuse_Node\n#define RE_IndirectSpecular RE_IndirectSpecular_Node\n#define RE_Refraction RE_Refraction_Node\n#include <lights_fragment_begin>\n#include <lights_fragment_maps>\n#ifdef USE_CLEARCOAT\nclearcoatSpecular+=clearcoatRadiance*BRDF_Specular_GGX_Environment(geometry.viewDir,geometry.clearcoatNormal,material.clearcoatF0,vec3(material.clearcoatF90),material.clearcoatRoughness);\n#endif\nirradiance+=iblIrradiance;\nvec3 specEnv=BRDF_Specular_GGX_Environment(geometry.viewDir,geometry.normal,material.specularColor,material.fresnelRefl90,material.roughness);\nreflectedLight.indirectSpecular+=radiance*specEnv;\nfloat weight=1.0;\nweight*=max((1.0-max3(specEnv)),0.0);\nmaterial.diffuseColor*=weight;\nRE_IndirectDiffuse(irradiance,geometry,material,reflectedLight);\nRE_Refraction(refraction,material,refractedLight);\n#undef RE_Direct\n#undef RE_IndirectDiffuse\n#undef RE_IndirectSpecular\n#undef RE_Refraction\n#ifdef PROBE_NORMAL\n#undef PROBE_NORMAL\n#endif\n#ifdef USE_GTAO\nreflectedLight.indirectDiffuse*=gtaoVisibilityBentNormal.r;\nfloat gtaoVisibility=gtaoVisibilityBentNormal.r;\nvec3 gtaoBentNormal=bentNormal;\nvec3 gtaoViewDir=geometry.viewDir;\nvec3 gtaoNormal=normal;\nfloat gtaoRoughness=material.roughness;\n#endif\n#include <lights_fragment_gtso>\nfloat fresnel=fresnelReflection(viewWorld,normalWorld,ior);\nvec3 outColor3=(reflectedLight.directDiffuse+reflectedLight.indirectDiffuse)*(1.0-transmission)\n+ reflectedLight.directSpecular+reflectedLight.indirectSpecular\n+ refractedLight*transmission*(1.0-fresnel)\n+ emission.rgb*emissionStrength;\n#ifdef USE_CLEARCOAT\nfloat dotNVcc=saturate(dot(geometry.normal,geometry.viewDir));\nvec3 Fcc=F_Schlick(material.clearcoatF0,material.clearcoatF90,dotNVcc);\noutColor3=outColor3*(1.0-material.clearcoat*Fcc)+clearcoatSpecular*material.clearcoat;\n#endif\noutColor=vec4(outColor3,alpha);\n}\nvoid node_bsdf_principled(vec3 geometryNormal,vec4 baseColor,float metallic,float roughness,float ior,float alpha,vec3 normal,float subsurface,vec3 subsurfaceRadius,float subsurfaceScale,float subsurfaceIOR,float subsurfaceAnisotropy,float specularIORLevel,vec4 specularTint,float anisotropic,float anisotropicRotation,vec3 tangent,float transmission,float clearcoat,float clearcoatRoughness,float clearcoatIOR,vec4 clearcoatTint,vec3 clearcoatNormal,float sheen,float sheenRoughness,vec4 sheenTint,vec4 emission,float emissionStrength,float thinFilmThickness,float thinFilmIOR,out vec4 outColor){\nnode_bsdf_principled(geometryNormal,baseColor,metallic,roughness,ior,alpha,normal,0.0,subsurface,subsurfaceRadius,subsurfaceScale,subsurfaceIOR,subsurfaceAnisotropy,specularIORLevel,specularTint,anisotropic,anisotropicRotation,tangent,transmission,clearcoat,clearcoatRoughness,clearcoatIOR,clearcoatTint,clearcoatNormal,sheen,sheenRoughness,sheenTint,emission,emissionStrength,0.0,0.0,outColor);\n}",node_bsdf_refraction_bl_frag:"#define BSDF_REFRACTION_GGX 0\n#define BSDF_REFRACTION_BECKMANN 1\n#define BSDF_REFRACTION_SHARP 2\nvoid node_bsdf_refraction(vec3 geometryNormal,const int distribution,vec4 color,float roughness,float ior,vec3 normal,out vec4 outColor){\nnormal=swizzleUpY(normal);\nnormal=(viewMatrix*vec4(normal.xyz,0.0)).xyz;\nNodeMaterial material;\nmaterial.refractionColor=color.rgb;\nmaterial.refractionIOR=ior;\nif (distribution==BSDF_REFRACTION_SHARP){\nmaterial.refractionRoughness=0.0;\n} else {\nmaterial.refractionRoughness=pow2(roughness);\n}\n#if defined(ENVMAP_TYPE_CUBE)||defined(ENVMAP_TYPE_CUBE_UV)\nfloat geomRoughness=calcGeometryRoughness(geometryNormal);\nmaterial.refractionRoughness=calcCubeUVAdjustedRoughness(material.refractionRoughness,geomRoughness);\n#endif\nReflectedLight reflectedLight=ReflectedLight(vec3(0.0),vec3(0.0),vec3(0.0),vec3(0.0));\nvec3 refractedLight=vec3(0.0);\n#ifdef USE_CLEARCOAT\n#undef USE_CLEARCOAT\n#define _CLEARCOAT_RESTORE\n#endif\n#define RE_Refraction RE_Refraction_Node\n#include <lights_fragment_begin>\n#include <lights_fragment_maps>\n#include <lights_fragment_end>\n#undef RE_Refraction\n#ifdef _CLEARCOAT_RESTORE\n#undef _CLEARCOAT_RESTORE\n#define USE_CLEARCOAT\n#endif\noutColor=vec4(refractedLight,1.0);\n}",node_bsdf_sheen_bl_frag:"\nvoid node_bsdf_sheen(vec4 color,float roughness,vec3 normal,out vec4 outColor)\n{\nnormal=vec3(normal[0],normal[2],-normal[1]);\nnormal=(viewMatrix*vec4(normal.xyz,0.0)).xyz;\nNodeMaterial material;\nmaterial.diffuseColor=color.rgb;\nReflectedLight reflectedLight=ReflectedLight(vec3(0.0),vec3(0.0),vec3(0.0),vec3(0.0));\n#ifdef USE_CLEARCOAT\n#undef USE_CLEARCOAT\n#define _CLEARCOAT_RESTORE\n#endif\n#define RE_Direct RE_DirectDiffuseOnly_Node\n#define RE_IndirectDiffuse RE_IndirectDiffuse_Node\n#include <lights_fragment_begin>\n#include <lights_fragment_maps>\n#include <lights_fragment_end>\n#undef RE_Direct\n#undef RE_IndirectDiffuse\n#ifdef _CLEARCOAT_RESTORE\n#undef _CLEARCOAT_RESTORE\n#define USE_CLEARCOAT\n#endif\noutColor=vec4(reflectedLight.directDiffuse+reflectedLight.indirectDiffuse,1.0);\n}",node_bsdf_toon_bl_frag:"void node_bsdf_toon(vec4 color,float size,float smoothFac,vec3 normal,out vec4 outColor)\n{\noutColor=color;\n}",node_bsdf_translucent_bl_frag:"void node_bsdf_translucent(vec4 color,vec3 normal,out vec4 outColor){\nnormal=-vec3(normal[0],normal[2],-normal[1]);\nnormal=(viewMatrix*vec4(normal.xyz,0.0)).xyz;\nNodeMaterial material;\nmaterial.diffuseColor=color.rgb;\nReflectedLight reflectedLight=ReflectedLight(vec3(0.0),vec3(0.0),vec3(0.0),vec3(0.0));\n#ifdef USE_CLEARCOAT\n#undef USE_CLEARCOAT\n#define _CLEARCOAT_RESTORE\n#endif\n#define RE_Direct RE_DirectDiffuseOnly_Node\n#define RE_IndirectDiffuse RE_IndirectDiffuse_Node\n#include <lights_fragment_begin>\n#include <lights_fragment_maps>\n#include <lights_fragment_end>\n#undef RE_Direct\n#undef RE_IndirectDiffuse\n#ifdef _CLEARCOAT_RESTORE\n#undef _CLEARCOAT_RESTORE\n#define USE_CLEARCOAT\n#endif\noutColor=vec4(reflectedLight.directDiffuse+reflectedLight.indirectDiffuse,1.0);\n}",node_bsdf_transparent_bl_frag:"void node_bsdf_transparent(vec4 color,out vec4 outColor)\n{\nfloat alpha=saturate(1.0-dot(color.rgb,vec3(0.333333)));\noutColor=vec4(0.0,0.0,0.0,alpha);\n}",node_bump_bl_frag:"void node_bump(const bool invert,float strength,float bumpDist,float filterWidth,float height,vec3 normal,out vec3 outNormal){\nvec3 position=swizzleUpZ(vWorldPosition);\nif (invert)\nbumpDist*=-1.0;\nvec3 dPdx=dFdx(position);\nvec3 dPdy=dFdy(position);\nfloat dHdx=dFdx(height);\nfloat dHdy=dFdy(height);\nvec3 tanX=cross(dPdy,normal);\nvec3 tanY=cross(normal,dPdx);\nvec3 surfaceGrad=dHdx*tanX+dHdy*tanY;\nfloat dotPosTanX=dot(dPdx,tanX);\noutNormal=normalize(normal*abs(dotPosTanX)-surfaceGrad*bumpDist*sign(dotPosTanX));\noutNormal=normalize(mix(normal,outNormal,max(0.0,strength)));\n}\nvoid node_bump(const bool invert,float strength,float bumpDist,float height,vec3 normal,out vec3 outNormal){\nnode_bump(invert,strength,bumpDist,1.0,height,normal,outNormal);\n}",node_camera_bl_frag:"void node_camera(vec3 viewPos,const bool invCamZ,out vec3 outViewVector,out float outViewZDepth,out float outViewDistance)\n{\nviewPos=-viewPos;\nif (invCamZ)\nviewPos.z=-viewPos.z;\noutViewVector=normalize(viewPos);\noutViewZDepth=abs(viewPos.z);\noutViewDistance=length(viewPos);\n}",node_clamp_bl_frag:"void node_clamp(bool clampRange,float value,float minVal,float maxVal,out float result){\nif (clampRange)\nresult=(maxVal>minVal)?clamp(value,minVal,maxVal):clamp(value,maxVal,minVal);\nelse\nresult=min(max(value,minVal),maxVal);\n}",node_combine_color_bl_frag:"#define NODE_COMB_COL_RGB 0\n#define NODE_COMB_COL_HSV 1\n#define NODE_COMB_COL_HSL 2\nvoid hslToRGB(vec3 hsl,out vec3 outCol)\n{\nfloat nr,ng,nb,chroma;\nfloat h,s,l;\nh=hsl[0];\ns=hsl[1];\nl=hsl[2];\nnr=abs(h*6.0-3.0)-1.0;\nng=2.0-abs(h*6.0-2.0);\nnb=2.0-abs(h*6.0-4.0);\nnr=clamp(nr,0.0,1.0);\nnb=clamp(nb,0.0,1.0);\nng=clamp(ng,0.0,1.0);\nchroma=(1.0-abs(2.0*l-1.0))*s;\noutCol=vec3((nr-0.5)*chroma+l,(ng-0.5)*chroma+l,(nb-0.5)*chroma+l);\n}\nvoid node_combine_color(int mode,float r,float g,float b,out vec4 col)\n{\nif (mode==NODE_COMB_COL_RGB){\ncol=vec4(r,g,b,1.0);\n} else if (mode==NODE_COMB_COL_HSV){\nhsvToRGB(vec4(r,g,b,1.0),col);\n} else {\nvec3 col3;\nhslToRGB(vec3(r,g,b),col3);\ncol=vec4(col3,1.0);\n}\n}",node_combxyz_bl_frag:"void node_combxyz(float x,float y,float z,out vec3 outVector)\n{\noutVector=vec3(x,y,z);\n}",node_curve_float_bl_frag:"void node_curve_float(sampler2D curveData,float fac,float value,out float outValue)\n{\noutValue=texture2D(curveData,vec2((value+1.0)*0.5,0.0)).x;\noutValue=mix(value,outValue*2.0-1.0,fac);\n}",node_curve_rgb_bl_frag:"void node_curve_rgb(sampler2D curveData,float fac,vec4 col,out vec4 outCol)\n{\noutCol.r=texture2D(curveData,vec2(texture2D(curveData,vec2(col.r,0.0)).a,0.0)).r;\noutCol.g=texture2D(curveData,vec2(texture2D(curveData,vec2(col.g,0.0)).a,0.0)).g;\noutCol.b=texture2D(curveData,vec2(texture2D(curveData,vec2(col.b,0.0)).a,0.0)).b;\noutCol=mix(col,outCol,fac);\noutCol.a=col.a;\n}",node_curve_vec_bl_frag:"void node_curve_vec(sampler2D curveData,float fac,vec3 vec,out vec3 outVec)\n{\noutVec.x=texture2D(curveData,vec2((vec.x+1.0)*0.5,0.0)).x;\noutVec.y=texture2D(curveData,vec2((vec.y+1.0)*0.5,0.0)).y;\noutVec.z=texture2D(curveData,vec2((vec.z+1.0)*0.5,0.0)).z;\noutVec=mix(vec,outVec*2.0-vec3(1.0),fac);\n}",node_diffuse_bsdf_bl_frag:"void node_diffuse_bsdf(vec4 color,float roughness,vec3 normal,out vec4 outColor){\nnormal=vec3(normal[0],normal[2],-normal[1]);\nnormal=(viewMatrix*vec4(normal.xyz,0.0)).xyz;\nNodeMaterial material;\nmaterial.diffuseColor=color.rgb;\nReflectedLight reflectedLight=ReflectedLight(vec3(0.0),vec3(0.0),vec3(0.0),vec3(0.0));\n#ifdef USE_CLEARCOAT\n#undef USE_CLEARCOAT\n#define _CLEARCOAT_RESTORE\n#endif\n#ifdef USE_GTAO\nvec4 gtaoVisibilityBentNormal=texture2D(gtaoMap,gl_FragCoord.xy/currResolution);\nvec3 bentNormal=normalize(unpackRGBToNormal(gtaoVisibilityBentNormal.gba));\n#define PROBE_NORMAL bentNormal\n#endif\n#define RE_Direct RE_DirectDiffuseOnly_Node\n#define RE_IndirectDiffuse RE_IndirectDiffuse_Node\n#include <lights_fragment_begin>\n#include <lights_fragment_maps>\n#include <lights_fragment_end>\n#undef RE_Direct\n#undef RE_IndirectDiffuse\n#ifdef PROBE_NORMAL\n#undef PROBE_NORMAL\n#endif\n#ifdef _CLEARCOAT_RESTORE\n#undef _CLEARCOAT_RESTORE\n#define USE_CLEARCOAT\n#endif\n#ifdef USE_GTAO\nreflectedLight.indirectDiffuse*=gtaoVisibilityBentNormal.r;\n#endif\noutColor=vec4(reflectedLight.directDiffuse+reflectedLight.indirectDiffuse,1.0);\n}",node_displacement_bl_frag:"void node_displacement(float height,float midlevel,float scale,vec3 normal,out vec3 outDisplacement){\noutDisplacement=vec3(0.0);\n}",node_eevee_specular_bl_frag:"void node_eevee_specular(vec3 geometryNormal,vec4 baseColor,vec4 specular,float roughness,vec4 emissiveColor,float transparency,vec3 normal,float clearcoat,float clearcoatRoughness,vec3 clearcoatNormal,float ambientOcclusion,out vec4 outColor){\nnormal=vec3(normal[0],normal[2],-normal[1]);\nvec3 normalWorld=normal;\nnormal=(viewMatrix*vec4(normal.xyz,0.0)).xyz;\nNodeMaterial material;\nmaterial.diffuseColor=baseColor.rgb;\nmaterial.specularColor=specular.rgb;\nmaterial.roughness=clamp(roughness,0.0,1.0);\n#ifdef USE_CLEARCOAT\nmaterial.clearcoat=saturate(clearcoat);\nmaterial.clearcoatRoughness=clamp(clearcoatRoughness,0.0,1.0);\n#endif\n#if defined(ENVMAP_TYPE_CUBE)||defined(ENVMAP_TYPE_CUBE_UV)\nfloat geomRoughness=calcGeometryRoughness(geometryNormal);\nmaterial.roughness=calcCubeUVAdjustedRoughness(material.roughness,geomRoughness);\n#ifdef USE_CLEARCOAT\nmaterial.clearcoatRoughness=calcCubeUVAdjustedRoughness(material.clearcoatRoughness,geomRoughness);\nclearcoatNormal=normalize(vec3(clearcoatNormal[0],clearcoatNormal[2],-clearcoatNormal[1]));\nclearcoatNormal=(viewMatrix*vec4(clearcoatNormal.xyz,0.0)).xyz;\n#endif\n#endif\nReflectedLight reflectedLight=ReflectedLight(vec3(0.0),vec3(0.0),vec3(0.0),vec3(0.0));\n#ifdef USE_GTAO\nvec4 gtaoVisibilityBentNormal=texture2D(gtaoMap,gl_FragCoord.xy/currResolution);\nvec3 bentNormal=normalize(unpackRGBToNormal(gtaoVisibilityBentNormal.gba));\n#define PROBE_NORMAL bentNormal\n#endif\n#define RE_Direct RE_Direct_Node\n#define RE_IndirectDiffuse RE_IndirectDiffuse_Node\n#define RE_IndirectSpecular RE_IndirectSpecular_Node\n#include <lights_fragment_begin>\n#include <lights_fragment_maps>\n#include <lights_fragment_end>\n#undef RE_Direct\n#undef RE_IndirectDiffuse\n#undef RE_IndirectSpecular\n#ifdef PROBE_NORMAL\n#undef PROBE_NORMAL\n#endif\n#ifdef USE_GTAO\nreflectedLight.indirectDiffuse*=gtaoVisibilityBentNormal.r;\nfloat gtaoVisibility=gtaoVisibilityBentNormal.r;\nvec3 gtaoBentNormal=bentNormal;\nvec3 gtaoViewDir=geometry.viewDir;\nvec3 gtaoNormal=normal;\nfloat gtaoRoughness=material.roughness;\n#endif\n#include <lights_fragment_gtso>\nvec3 outColor3=(reflectedLight.directDiffuse+reflectedLight.indirectDiffuse\n+ reflectedLight.directSpecular+reflectedLight.indirectSpecular)*ambientOcclusion\n+ emissiveColor.rgb;\noutColor=vec4(outColor3,1.0-transparency);\n}",node_emission_bl_frag:"void node_emission(vec4 color,float strength,out vec4 outColor)\n{\noutColor=vec4(strength*color.rgb,1.0);\n}",node_fresnel_bl_frag:"void node_fresnel(vec3 viewPos,float IOR,vec3 normal,out float fac)\n{\nvec3 worldDir;\nif (isOrthographic)\nworldDir=(invViewMatrix*vec4(0.0,0.0,-1.0,0.0)).xyz;\nelse\nworldDir=(invViewMatrix*vec4(-viewPos,0.0)).xyz;\nworldDir=normalize(swizzleUpZ(worldDir));\nfloat eta=max(IOR,0.00001);\nfac=fresnelReflection(worldDir,normal,(gl_FrontFacing)?eta:1.0/eta);\n}",node_gamma_bl_frag:"void node_gamma(vec4 col,float gamma,out vec4 outCol)\n{\noutCol=col;\nif (col.r>0.0)\noutCol.r=powCompat(col.r,gamma);\nif (col.g>0.0)\noutCol.g=powCompat(col.g,gamma);\nif (col.b>0.0)\noutCol.b=powCompat(col.b,gamma);\n}",node_hair_info_bl_frag:"\nvoid node_hair_info(out float isStrand,out float intercept,out float len,out float thickness,out vec3 tangentNormal,out float random){\nisStrand=0.0;\nintercept=0.0;\nlen=0.0;\nthickness=0.0;\ntangentNormal=vec3(0.0);\nrandom=1.0;\n}",node_holdout_bl_frag:"void node_holdout(out vec4 outColor)\n{\noutColor=vec4(0.0);\n}",node_hue_sat_bl_frag:"void node_hue_sat(float hue,float sat,float value,float fac,vec4 col,out vec4 outCol)\n{\nvec4 hsv;\nrgbToHSV(col,hsv);\nhsv[0]+=(fract(hue)-0.5);\nif (hsv[0]>1.0)hsv[0]-=1.0;else if (hsv[0]<0.0)hsv[0]+=1.0;\nhsv[1]*=sat;\nif (hsv[1]>1.0)hsv[1]=1.0;else if (hsv[1]<0.0)hsv[1]=0.0;\nhsv[2]*=value;\nhsvToRGB(hsv,outCol);\noutCol=mix(col,outCol,fac);\n}",node_invert_bl_frag:"void node_invert(float fac,vec4 col,out vec4 outCol)\n{\noutCol.xyz=mix(col.xyz,vec3(1.0,1.0,1.0)-col.xyz,fac);\noutCol.w=col.w;\n}",node_layer_weight_bl_frag:"void node_layer_weight(vec3 viewPos,float blend,vec3 normal,out float fresnel,out float facing)\n{\nvec3 worldDir;\nif (isOrthographic)\nworldDir=(invViewMatrix*vec4(0.0,0.0,-1.0,0.0)).xyz;\nelse\nworldDir=(invViewMatrix*vec4(-viewPos,0.0)).xyz;\nworldDir=normalize(swizzleUpZ(worldDir));\nfloat eta=max(1.0-blend,EPSILON);\nfresnel=fresnelReflection(worldDir,normal,(gl_FrontFacing)?1.0/eta:eta);\nfacing=abs(dot(worldDir,normal));\nif (blend != 0.5){\nblend=clamp(blend,0.0,1.0-EPSILON);\nblend=(blend<0.5)?blend*2.0:0.5/(1.0-blend);\nfacing=pow(facing,blend);\n}\nfacing=1.0-facing;\n}",node_light_falloff_bl_frag:"void node_light_falloff(float strength,float inSmooth,out float quadratic,out float linear,out float constant)\n{\nquadratic=1.0;\nlinear=1.0;\nconstant=1.0;\n}",node_light_path_bl_frag:"void node_light_path(out float isCameraRay,out float isShadowRay,out float isDiffuseRay,out float isGlossyRay,out float isSingularRay,out float isReflectionRay,out float isTransmissionRay,out float isVolumeScatterRay,out float rayLength,out float rayDepth,out float diffuseDepth,out float glossyDepth,out float transparentDepth,out float transmissionDepth,out float portalDepth)\n{\n#if LIGHT_PATH_IS_CAM_RAY\nisCameraRay=1.0;\n#else\nisCameraRay=0.0;\n#endif\nisShadowRay=0.0;\nisDiffuseRay=0.0;\nisGlossyRay=0.0;\nisSingularRay=0.0;\nisReflectionRay=0.0;\nisTransmissionRay=0.0;\nisVolumeScatterRay=0.0;\nrayLength=1.0;\nrayDepth=1.0;\ndiffuseDepth=1.0;\nglossyDepth=1.0;\ntransparentDepth=1.0;\ntransmissionDepth=1.0;\nportalDepth=0.0;\n}\nvoid node_light_path(out float isCameraRay,out float isShadowRay,out float isDiffuseRay,out float isGlossyRay,out float isSingularRay,out float isReflectionRay,out float isTransmissionRay,out float isVolumeScatterRay,out float rayLength,out float rayDepth,out float diffuseDepth,out float glossyDepth,out float transparentDepth,out float transmissionDepth)\n{\n#if LIGHT_PATH_IS_CAM_RAY\nisCameraRay=1.0;\n#else\nisCameraRay=0.0;\n#endif\nisShadowRay=0.0;\nisDiffuseRay=0.0;\nisGlossyRay=0.0;\nisSingularRay=0.0;\nisReflectionRay=0.0;\nisTransmissionRay=0.0;\nisVolumeScatterRay=0.0;\nrayLength=1.0;\nrayDepth=1.0;\ndiffuseDepth=1.0;\nglossyDepth=1.0;\ntransparentDepth=1.0;\ntransmissionDepth=1.0;\n}\nvoid node_light_path(out float isCameraRay,out float isShadowRay,out float isDiffuseRay,out float isGlossyRay,out float isSingularRay,out float isReflectionRay,out float isTransmissionRay,out float rayLength,out float rayDepth,out float diffuseDepth,out float glossyDepth,out float transparentDepth,out float transmissionDepth)\n{\n#if LIGHT_PATH_IS_CAM_RAY\nisCameraRay=1.0;\n#else\nisCameraRay=0.0;\n#endif\nisShadowRay=0.0;\nisDiffuseRay=0.0;\nisGlossyRay=0.0;\nisSingularRay=0.0;\nisReflectionRay=0.0;\nisTransmissionRay=0.0;\nrayLength=1.0;\nrayDepth=1.0;\ndiffuseDepth=1.0;\nglossyDepth=1.0;\ntransparentDepth=1.0;\ntransmissionDepth=1.0;\n}",node_mapping_bl_frag:"#define NODE_MAPPING_POINT 1\n#define NODE_MAPPING_TEXTURE 2\n#define NODE_MAPPING_VECTOR 3\n#define NODE_MAPPING_NORMAL 4\nmat3 rotationMatrix(float angleX,float angleY,float angleZ){\nfloat cx=cos(angleX);\nfloat sx=sin(angleX);\nfloat cy=cos(angleY);\nfloat sy=sin(angleY);\nfloat cz=cos(angleZ);\nfloat sz=sin(angleZ);\nmat3 mat;\nmat[0][0]=cy*cz;\nmat[0][1]=cy*sz;\nmat[0][2]=-sy;\nmat[1][0]=sy*sx*cz-cx*sz;\nmat[1][1]=sy*sx*sz+cx*cz;\nmat[1][2]=cy*sx;\nmat[2][0]=sy*cx*cz+sx*sz;\nmat[2][1]=sy*cx*sz-sx*cz;\nmat[2][2]=cy*cx;\nreturn mat;\n}\nmat3 mat3GetInverseTransposed(mat3 mat){\nfloat det=mat3GetDeterminant(mat);\nfloat a00=(mat[1][1]*mat[2][2]-mat[1][2]*mat[2][1])/det;\nfloat a01=- (mat[1][0]*mat[2][2]-mat[1][2]*mat[2][0])/det;\nfloat a02=(mat[1][0]*mat[2][1]-mat[1][1]*mat[2][0])/det;\nfloat a10=- (mat[0][1]*mat[2][2]-mat[0][2]*mat[2][1])/det;\nfloat a11=(mat[0][0]*mat[2][2]-mat[0][2]*mat[2][0])/det;\nfloat a12=- (mat[0][0]*mat[2][1]-mat[0][1]*mat[2][0])/det;\nfloat a20=(mat[0][1]*mat[1][2]-mat[0][2]*mat[1][1])/det;\nfloat a21=- (mat[0][0]*mat[1][2]-mat[0][2]*mat[1][0])/det;\nfloat a22=(mat[0][0]*mat[1][1]-mat[0][1]*mat[1][0])/det;\nreturn mat3(a00,a01,a02,a10,a11,a12,a20,a21,a22\n);\n}\nvoid node_mapping(int type,vec3 vec,vec3 loc,vec3 rot,vec3 scale,out vec3 outVec)\n{\nif (type==NODE_MAPPING_POINT)\noutVec=rotationMatrix(rot.x,rot.y,rot.z)*(vec*scale)+loc;\nelse if (type==NODE_MAPPING_TEXTURE)\noutVec=transposeMat3(rotationMatrix(rot.x,rot.y,rot.z))*(vec-loc)/scale;\nelse if (type==NODE_MAPPING_VECTOR)\noutVec=rotationMatrix(rot.x,rot.y,rot.z)*(vec*scale);\nelse {\nmat3 rot=rotationMatrix(rot.x,rot.y,rot.z)*mat3(scale[0],0.0,0.0,0.0,scale[1],0.0,0.0,0.0,scale[2]\n);\noutVec=normalize(mat3GetInverseTransposed(rot)*vec);\n}\n}",node_map_range_bl_frag:"#define NODE_MAP_RANGE_INTERP_LINEAR 0\n#define NODE_MAP_RANGE_INTERP_STEPPED 1\n#define NODE_MAP_RANGE_INTERP_SMOOTHSTEP 2\n#define NODE_MAP_RANGE_INTERP_SMOOTHERSTEP 3\n#define NODE_MAP_RANGE_TYPE_FLOAT 0\n#define NODE_MAP_RANGE_TYPE_FLOAT_VECTOR 1\nfloat smootherstep(float edge0,float edge1,float x){\nfloat t=clamp((x-edge0)/(edge1-edge0),0.0,1.0);\nreturn t*t*t*(t*(t*6.0-15.0)+10.0);\n}\nvec3 smootherstep(vec3 x){\nvec3 t=clamp(x,0.0,1.0);\nreturn (t*(t*6.0-15.0)+10.0)*t*t*t;\n}\nvoid node_map_range(const int dataType,const int interpolation,bool inClamp,float value,float fromMin,float fromMax,float toMin,float toMax,float steps,vec3 valueVec,vec3 fromMinVec,vec3 fromMaxVec,vec3 toMinVec,vec3 toMaxVec,vec3 stepsVec,out float result,out vec3 resultVec){\nif (dataType==NODE_MAP_RANGE_TYPE_FLOAT){\nif (fromMax==fromMin){\nresult=0.0;\n} else if (interpolation==NODE_MAP_RANGE_INTERP_LINEAR){\nresult=(value-fromMin)/(fromMax-fromMin)*(toMax-toMin)+toMin;\n} else if (interpolation==NODE_MAP_RANGE_INTERP_STEPPED){\nfloat fac=(value-fromMin)/(fromMax-fromMin);\nfac=(steps>0.0)?floor(fac*(steps+1.0))/steps:0.0;\nresult=fac*(toMax-toMin)+toMin;\n} else if (interpolation==NODE_MAP_RANGE_INTERP_SMOOTHSTEP){\nfloat fac=(fromMin>fromMax)?\n1.0-smoothstep(fromMax,fromMin,value):\nsmoothstep(fromMin,fromMax,value);\nresult=fac*(toMax-toMin)+toMin;\n} else {\nfloat fac=(fromMin>fromMax)?\n1.0-smootherstep(fromMax,fromMin,value):\nsmootherstep(fromMin,fromMax,value);\nresult=fac*(toMax-toMin)+toMin;\n}\nif (inClamp&&interpolation<=NODE_MAP_RANGE_INTERP_STEPPED){\nresult=clamp(result,toMin,toMax);\n}\n} else if (dataType==NODE_MAP_RANGE_TYPE_FLOAT_VECTOR){\nvec3 deltaVec=fromMaxVec-fromMinVec;\nvec3 fac=vec3(deltaVec.x==0.0?0.0:(valueVec.x-fromMinVec.x)/deltaVec.x,deltaVec.y==0.0?0.0:(valueVec.y-fromMinVec.y)/deltaVec.y,deltaVec.z==0.0?0.0:(valueVec.z-fromMinVec.z)/deltaVec.z\n);\nif (interpolation==NODE_MAP_RANGE_INTERP_LINEAR){\nresultVec=fac*(toMaxVec-toMinVec)+toMinVec;\n} else if (interpolation==NODE_MAP_RANGE_INTERP_STEPPED){\nfac.x=stepsVec.x==0.0?0.0:floor(fac.x*(stepsVec.x+1.0))/stepsVec.x;\nfac.y=stepsVec.y==0.0?0.0:floor(fac.y*(stepsVec.y+1.0))/stepsVec.y;\nfac.z=stepsVec.z==0.0?0.0:floor(fac.z*(stepsVec.z+1.0))/stepsVec.z;\nresultVec=fac*(toMaxVec-toMinVec)+toMinVec;\n} else if (interpolation==NODE_MAP_RANGE_INTERP_SMOOTHSTEP){\nfac=clamp(fac,0.0,1.0);\nfac=fac*fac*(3.0-2.0*fac);\nresultVec=fac*(toMaxVec-toMinVec)+toMinVec;\n} else {\nresultVec=smootherstep(fac)*(toMaxVec-toMinVec)+toMinVec;\n}\nif (inClamp&&interpolation<=NODE_MAP_RANGE_INTERP_STEPPED){\nvec3 sumVec=toMinVec+toMaxVec;\ntoMaxVec=max(toMaxVec,toMinVec);\ntoMinVec=sumVec-toMaxVec;\nresultVec=clamp(resultVec,toMinVec,toMaxVec);\n}\n}\n}",node_math_bl_frag:"void node_math_add(float val1,float val2,float val3,out float outVal)\n{\noutVal=val1+val2;\n}\nvoid node_math_subtract(float val1,float val2,float val3,out float outVal)\n{\noutVal=val1-val2;\n}\nvoid node_math_multiply(float val1,float val2,float val3,out float outVal)\n{\noutVal=val1*val2;\n}\nvoid node_math_divide(float val1,float val2,float val3,out float outVal)\n{\nif (val2==0.0)\noutVal=0.0;\nelse\noutVal=val1/val2;\n}\nvoid node_math_sine(float val,float val2,float val3,out float outVal)\n{\noutVal=sin(val);\n}\nvoid node_math_cosine(float val,float val2,float val3,out float outVal)\n{\noutVal=cos(val);\n}\nvoid node_math_tangent(float val,float val2,float val3,out float outVal)\n{\noutVal=tan(val);\n}\nvoid node_math_arcsine(float val,float val2,float val3,out float outVal)\n{\nif (val<=1.0&&val>=-1.0)\noutVal=asin(val);\nelse\noutVal=0.0;\n}\nvoid node_math_arccosine(float val,float val2,float val3,out float outVal)\n{\nif (val<=1.0&&val>=-1.0)\noutVal=acos(val);\nelse\noutVal=0.0;\n}\nvoid node_math_arctangent(float val,float val2,float val3,out float outVal)\n{\noutVal=atan(val);\n}\nvoid node_math_arctan2(float val,float val2,float val3,out float outVal)\n{\noutVal=atan(val,val2);\n}\nvoid node_math_power(float val1,float val2,float val3,out float outVal)\n{\nif (val1>=0.0)\noutVal=powCompat(val1,val2);\nelse {\nfloat val2_mod_1=mod(abs(val2),1.0);\nif (val2_mod_1>0.999||val2_mod_1<0.001)\noutVal=powCompat(val1,floor(val2+0.5));\nelse\noutVal=0.0;\n}\n}\nvoid node_math_logarithm(float val1,float val2,float val3,out float outVal)\n{\nif (val1>0.0&&val2>0.0)\noutVal=log2(val1)/log2(val2);\nelse\noutVal=0.0;\n}\nvoid node_math_sqrt(float val1,float val2,float val3,out float outVal)\n{\noutVal=sqrt(val1);\n}\nvoid node_math_maximum(float val1,float val2,float val3,out float outVal)\n{\noutVal=max(val1,val2);\n}\nvoid node_math_minimum(float val1,float val2,float val3,out float outVal)\n{\noutVal=min(val1,val2);\n}\nvoid node_math_round(float val1,float val2,float val3,out float outVal)\n{\noutVal=floor(val1+0.5);\n}\nvoid node_math_floor(float val1,float val2,float val3,out float outVal)\n{\noutVal=floor(val1);\n}\nvoid node_math_ceil(float val1,float val2,float val3,out float outVal)\n{\noutVal=ceil(val1);\n}\nvoid node_math_fract(float val1,float val2,float val3,out float outVal)\n{\noutVal=fract(val1);\n}\nvoid node_math_less_than(float val1,float val2,float val3,out float outVal)\n{\nif (val1<val2)\noutVal=1.0;\nelse\noutVal=0.0;\n}\nvoid node_math_greater_than(float val1,float val2,float val3,out float outVal)\n{\nif (val1>val2)\noutVal=1.0;\nelse\noutVal=0.0;\n}\nvoid node_math_modulo(float val1,float val2,float val3,out float outVal)\n{\nif (val2==0.0)\noutVal=0.0;\nelse\noutVal=mod(val1,val2);\noutVal=(val1>0.0)?outVal:outVal-val2;\n}\nvoid node_math_floored_modulo(float val1,float val2,float val3,out float outVal)\n{\noutVal=(val2 != 0.0)?val1-floor(val1/val2)*val2:0.0;\n}\nvoid node_math_absolute(float val1,float val2,float val3,out float outVal)\n{\noutVal=abs(val1);\n}\nvoid node_math_compare(float val1,float val2,float val3,out float outVal){\noutVal=step(abs(val1-val2),val3);\n}\nvoid node_math_cosh(float val1,float val2,float val3,out float outVal){\noutVal=cosh(val1);\n}\nvoid node_math_degrees(float val1,float val2,float val3,out float outVal){\noutVal=val1/PI*180.0;\n}\nvoid node_math_exponent(float val1,float val2,float val3,out float outVal){\noutVal=exp(val1);\n}\nvoid node_math_inverse_sqrt(float val1,float val2,float val3,out float outVal){\nif (val1>=0.0){\noutVal=1.0/sqrt(val1);\n} else {\noutVal=0.0;\n}\n}\nvoid node_math_multiply_add(float val1,float val2,float val3,out float outVal){\noutVal=val1*val2+val3;\n}\nvoid node_math_pingpong(float val1,float val2,float val3,out float outVal){\nif (val2==0.0){\noutVal=0.0;\n} else {\nfloat absVal2=abs(val2);\nfloat rem=mod(val1,absVal2);\noutVal=mix(rem,absVal2-rem,mod(floor(val1/absVal2),2.0));\n}\n}\nvoid node_math_radians(float val1,float val2,float val3,out float outVal){\noutVal=val1/180.0*PI;\n}\nvoid node_math_sign(float val1,float val2,float val3,out float outVal){\noutVal=sign(val1);\n}\nvoid node_math_sinh(float val1,float val2,float val3,out float outVal){\noutVal=sinh(val1);\n}\nvoid node_math_smooth_max(float val1,float val2,float val3,out float outVal){\noutVal=smoothMax(val1,val2,val3);\n}\nvoid node_math_smooth_min(float val1,float val2,float val3,out float outVal){\noutVal=smoothMin(val1,val2,val3);\n}\nvoid node_math_snap(float val1,float val2,float val3,out float outVal){\nval1+=1e-5*sign(val2);\nfloat quot=val1/val2;\noutVal=floor(quot)*val2;\n}\nvoid node_math_tanh(float val1,float val2,float val3,out float outVal){\noutVal=tanh(val1);\n}\nvoid node_math_trunc(float val1,float val2,float val3,out float outVal){\nval1+=1e-5;\noutVal=trunc(val1);\n}\nvoid node_math_wrap(float val1,float val2,float val3,out float outVal){\nval1+=1e-5;\noutVal=mod(val1-val3,val2-val3)+val3;\n}",node_mix_bl_frag:"void node_mix_rgba_mix(float fac,vec4 col1,vec4 col2,out vec4 outCol)\n{\nfac=clamp(fac,0.0,1.0);\noutCol=mix(col1,col2,fac);\noutCol.a=col1.a;\n}\nvoid node_mix_rgba_add(float fac,vec4 col1,vec4 col2,out vec4 outCol)\n{\nfac=clamp(fac,0.0,1.0);\noutCol=mix(col1,col1+col2,fac);\noutCol.a=col1.a;\n}\nvoid node_mix_rgba_multiply(float fac,vec4 col1,vec4 col2,out vec4 outCol)\n{\nfac=clamp(fac,0.0,1.0);\noutCol=mix(col1,col1*col2,fac);\noutCol.a=col1.a;\n}\nvoid node_mix_rgba_screen(float fac,vec4 col1,vec4 col2,out vec4 outCol)\n{\nfac=clamp(fac,0.0,1.0);\nfloat facm=1.0-fac;\noutCol=vec4(1.0)-(vec4(facm)+fac*(vec4(1.0)-col2))*(vec4(1.0)-col1);\noutCol.a=col1.a;\n}\nvoid node_mix_rgba_overlay(float fac,vec4 col1,vec4 col2,out vec4 outCol)\n{\nfac=clamp(fac,0.0,1.0);\nfloat facm=1.0-fac;\noutCol=col1;\nif (outCol.r<0.5)\noutCol.r*=facm+2.0*fac*col2.r;\nelse\noutCol.r=1.0-(facm+2.0*fac*(1.0-col2.r))*(1.0-outCol.r);\nif (outCol.g<0.5)\noutCol.g*=facm+2.0*fac*col2.g;\nelse\noutCol.g=1.0-(facm+2.0*fac*(1.0-col2.g))*(1.0-outCol.g);\nif (outCol.b<0.5)\noutCol.b*=facm+2.0*fac*col2.b;\nelse\noutCol.b=1.0-(facm+2.0*fac*(1.0-col2.b))*(1.0-outCol.b);\n}\nvoid node_mix_rgba_exclusion(float fac,vec4 col1,vec4 col2,out vec4 outCol)\n{\nfac=clamp(fac,0.0,1.0);\noutCol=max(mix(col1,col1+col2-2.0*col1*col2,fac),0.0);\noutCol.a=col1.a;\n}\nvoid node_mix_rgba_subtract(float fac,vec4 col1,vec4 col2,out vec4 outCol)\n{\nfac=clamp(fac,0.0,1.0);\noutCol=mix(col1,col1-col2,fac);\noutCol.a=col1.a;\n}\nvoid node_mix_rgba_divide(float fac,vec4 col1,vec4 col2,out vec4 outCol)\n{\nfac=clamp(fac,0.0,1.0);\nfloat facm=1.0-fac;\noutCol=col1;\nif (col2.r != 0.0)outCol.r=facm*outCol.r+fac*outCol.r/col2.r;\nif (col2.g != 0.0)outCol.g=facm*outCol.g+fac*outCol.g/col2.g;\nif (col2.b != 0.0)outCol.b=facm*outCol.b+fac*outCol.b/col2.b;\n}\nvoid node_mix_rgba_difference(float fac,vec4 col1,vec4 col2,out vec4 outCol)\n{\nfac=clamp(fac,0.0,1.0);\noutCol=mix(col1,abs(col1-col2),fac);\noutCol.a=col1.a;\n}\nvoid node_mix_rgba_darken(float fac,vec4 col1,vec4 col2,out vec4 outCol)\n{\nfac=clamp(fac,0.0,1.0);\noutCol.rgb=mix(col1.rgb,min(col1.rgb,col2.rgb),fac);\noutCol.a=col1.a;\n}\nvoid node_mix_rgba_lighten(float fac,vec4 col1,vec4 col2,out vec4 outCol)\n{\nfac=clamp(fac,0.0,1.0);\noutCol.rgb=mix(col1.rgb,max(col1.rgb,col2.rgb),fac);\noutCol.a=col1.a;\n}\nvoid node_mix_rgba_dodge(float fac,vec4 col1,vec4 col2,out vec4 outCol)\n{\nfac=clamp(fac,0.0,1.0);\noutCol=col1;\nif (outCol.r != 0.0){\nfloat tmp=1.0-fac*col2.r;\nif (tmp<=0.0)\noutCol.r=1.0;\nelse if ((tmp=outCol.r/tmp)>1.0)\noutCol.r=1.0;\nelse\noutCol.r=tmp;\n}\nif (outCol.g != 0.0){\nfloat tmp=1.0-fac*col2.g;\nif (tmp<=0.0)\noutCol.g=1.0;\nelse if ((tmp=outCol.g/tmp)>1.0)\noutCol.g=1.0;\nelse\noutCol.g=tmp;\n}\nif (outCol.b != 0.0){\nfloat tmp=1.0-fac*col2.b;\nif (tmp<=0.0)\noutCol.b=1.0;\nelse if ((tmp=outCol.b/tmp)>1.0)\noutCol.b=1.0;\nelse\noutCol.b=tmp;\n}\n}\nvoid node_mix_rgba_burn(float fac,vec4 col1,vec4 col2,out vec4 outCol)\n{\nfac=clamp(fac,0.0,1.0);\nfloat tmp,facm=1.0-fac;\noutCol=col1;\ntmp=facm+fac*col2.r;\nif (tmp<=0.0)\noutCol.r=0.0;\nelse if ((tmp=(1.0-(1.0-outCol.r)/tmp))<0.0)\noutCol.r=0.0;\nelse if (tmp>1.0)\noutCol.r=1.0;\nelse\noutCol.r=tmp;\ntmp=facm+fac*col2.g;\nif (tmp<=0.0)\noutCol.g=0.0;\nelse if ((tmp=(1.0-(1.0-outCol.g)/tmp))<0.0)\noutCol.g=0.0;\nelse if (tmp>1.0)\noutCol.g=1.0;\nelse\noutCol.g=tmp;\ntmp=facm+fac*col2.b;\nif (tmp<=0.0)\noutCol.b=0.0;\nelse if ((tmp=(1.0-(1.0-outCol.b)/tmp))<0.0)\noutCol.b=0.0;\nelse if (tmp>1.0)\noutCol.b=1.0;\nelse\noutCol.b=tmp;\n}\n#ifdef HSV_NODES\nvoid node_mix_rgba_hue(float fac,vec4 col1,vec4 col2,out vec4 outCol)\n{\nfac=clamp(fac,0.0,1.0);\nfloat facm=1.0-fac;\noutCol=col1;\nvec4 hsv,hsv2,tmp;\nrgbToHSV(col2,hsv2);\nif (hsv2.y != 0.0){\nrgbToHSV(outCol,hsv);\nhsv.x=hsv2.x;\nhsvToRGB(hsv,tmp);\noutCol=mix(outCol,tmp,fac);\noutCol.a=col1.a;\n}\n}\nvoid node_mix_rgba_saturation(float fac,vec4 col1,vec4 col2,out vec4 outCol)\n{\nfac=clamp(fac,0.0,1.0);\nfloat facm=1.0-fac;\noutCol=col1;\nvec4 hsv,hsv2;\nrgbToHSV(outCol,hsv);\nif (hsv.y != 0.0){\nrgbToHSV(col2,hsv2);\nhsv.y=facm*hsv.y+fac*hsv2.y;\nhsvToRGB(hsv,outCol);\n}\n}\nvoid node_mix_rgba_value(float fac,vec4 col1,vec4 col2,out vec4 outCol)\n{\nfac=clamp(fac,0.0,1.0);\nfloat facm=1.0-fac;\nvec4 hsv,hsv2;\nrgbToHSV(col1,hsv);\nrgbToHSV(col2,hsv2);\nhsv.z=facm*hsv.z+fac*hsv2.z;\nhsvToRGB(hsv,outCol);\n}\nvoid node_mix_rgba_color(float fac,vec4 col1,vec4 col2,out vec4 outCol)\n{\nfac=clamp(fac,0.0,1.0);\nfloat facm=1.0-fac;\noutCol=col1;\nvec4 hsv,hsv2,tmp;\nrgbToHSV(col2,hsv2);\nif (hsv2.y != 0.0){\nrgbToHSV(outCol,hsv);\nhsv.x=hsv2.x;\nhsv.y=hsv2.y;\nhsvToRGB(hsv,tmp);\noutCol=mix(outCol,tmp,fac);\noutCol.a=col1.a;\n}\n}\n#endif\nvoid node_mix_rgba_soft_light(float fac,vec4 col1,vec4 col2,out vec4 outCol)\n{\nfac=clamp(fac,0.0,1.0);\nfloat facm=1.0-fac;\nvec4 one=vec4(1.0);\nvec4 scr=one-(one-col2)*(one-col1);\noutCol=facm*col1+fac*((one-col1)*col2*col1+col1*scr);\n}\nvoid node_mix_rgba_linear_light(float fac,vec4 col1,vec4 col2,out vec4 outCol)\n{\nfac=clamp(fac,0.0,1.0);\noutCol=col1+fac*(2.0*(col2-vec4(0.5)));\n}\nvoid node_mix_vector_uniform(float fac,vec3 facVec,vec3 v1,vec3 v2,out vec3 outVec)\n{\nfac=clamp(fac,0.0,1.0);\noutVec=mix(v1,v2,fac);\n}\nvoid node_mix_vector_non_uniform(float fac,vec3 facVec,vec3 v1,vec3 v2,out vec3 outVec)\n{\nfacVec=clamp(facVec,0.0,1.0);\noutVec=mix(v1,v2,facVec);\n}\nvoid node_mix_float(float fac,float val1,float val2,out float outVal)\n{\nfac=clamp(fac,0.0,1.0);\noutVal=mix(val1,val2,fac);\n}",node_mix_shader_bl_frag:"void node_mix_shader(int transpShaderNum,float fac,vec4 color1,vec4 color2,out vec4 outColor)\n{\nif (transpShaderNum==0)\ncolor1.rgb=color2.rgb;\nelse if (transpShaderNum==1)\ncolor2.rgb=color1.rgb;\noutColor=mix(color1,color2,clamp(fac,0.0,1.0));\n}",node_new_geometry_bl_frag:"void node_new_geometry(float frontFacing,vec3 viewPos,vec3 viewNorm,out vec3 position,out vec3 normal,out vec3 tangent,out vec3 trueNormal,out vec3 incoming,out vec3 parametric,out float backfacing,out float pointiness,out float randomPerIsland)\n{\nvec4 posWorld=invViewMatrix*vec4(-viewPos,1.0);\nposition=swizzleUpZ(posWorld.xyz);\nvec4 viewDir=isOrthographic?vec4(0.0,0.0,-1.0,0.0):vec4(normalize(-viewPos),0.0);\nviewDir=invViewMatrix*viewDir;\nvec3 incomingVec=-swizzleUpZ(viewDir.xyz);\n#if WORLD_NODES==1\nnormal=incomingVec;\ntangent=vec3(0.0);\n#else\nvec3 norWorld=normalize(invViewMatrix*vec4(viewNorm,0.0)).xyz;\nnormal=swizzleUpZ(norWorld);\nvec4 posLocal=invModelMatrix*posWorld;\nvec3 posLocalDelta=posLocal.xyz-boundingBoxMin;\nvec3 bbDelta=boundingBoxMax-boundingBoxMin;\nvec3 posOrco=vec3(bbDelta.x<1e-5?-sign(posLocal.y):posLocalDelta.x/bbDelta.x,0.0,bbDelta.z<1e-5?sign(posLocal.y):posLocalDelta.z/bbDelta.z\n);\nposOrco-=0.5;\nvec3 tangWorld=(modelMatrix*vec4(posOrco.z,0.0,-posOrco.x,0.0)).xyz;\ntangWorld=cross(norWorld,normalize(cross(tangWorld,norWorld)));\ntangent=swizzleUpZ(tangWorld);\n#endif\ntrueNormal=normal;\nincoming=incomingVec;\nparametric=vec3(0.0);\nbackfacing=(frontFacing>0.0)?0.0:1.0;\n#if WORLD_NODES==1\npointiness=0.0;\n#else\npointiness=0.5;\n#endif\nrandomPerIsland=0.0;\n}",node_normal_bl_frag:"void node_normal(vec3 norParam,vec3 norIn,out vec3 norOut,out float dotOut)\n{\nnorOut=norParam;\ndotOut=dot(normalize(norIn),norParam);\n}",node_normal_map_bl_frag:"void node_normal_map(vec4 tangent,vec3 normal,float strength,vec4 normalColor,out vec3 normalOut)\n{\n#ifdef DOUBLE_SIDED\nnormal=normal*(float(gl_FrontFacing)*2.0-1.0);\n#endif\nif (all(lessThan(abs(tangent.xyz),vec3(EPSILON)))){\nnormalOut=normal;\n} else {\nvec3 normalTex=(normalColor.xyz*2.0-1.0);\nvec4 viewTangent=vec4(normalize((modelViewMatrix*vec4(tangent.xyz,0.0)).xyz),tangent.w);\nvec3 bitangent=viewTangent.w*cross(normal,viewTangent.xyz);\nnormalOut=normalize(normalTex.x*viewTangent.xyz+normalTex.y*bitangent\n+ normalTex.z*normal);\nnormalOut=mix(normal,normalOut,strength);\n}\nnormalOut=normalize((invViewMatrix*vec4(normalOut,0.0)).xyz);\nnormalOut=swizzleUpZ(normalOut);\n}",node_object_info_bl_frag:"uniform int objectIndex;\nuniform vec4 objectColor;\nuniform int materialIndex;\nuniform float objectRandom;\nvoid node_object_info(out vec3 location,out vec4 color,out float alpha,out float objIndex,out float matIndex,out float random){\n#if WORLD_NODES==1\nlocation=vec3(0.0);\ncolor=vec4(1.0);\nalpha=1.0;\nobjIndex=0.0;\nmatIndex=0.0;\nrandom=0.0;\n#else\nlocation=swizzleUpZ(modelMatrix[3].xyz);\ncolor=vec4(objectColor.rgb,1.0);\nalpha=objectColor.a;\nobjIndex=float(objectIndex);\nmatIndex=float(materialIndex);\nrandom=float(objectRandom);\n#endif\n}",node_output_lamp_bl_frag:"void node_output_lamp(out vec4 outColor)\n{\noutColor=vec4(0.0);\n}",node_output_material_bl_frag:"void node_output_material(vec4 surface,vec4 volume,vec3 displacement,float thickness,out vec4 outgoingLight){\noutgoingLight=surface+volume;\n}",node_output_world_bl_frag:"void node_output_world(vec4 surface,vec4 volume,out vec4 outgoingLight)\n{\noutgoingLight=surface;\n}",node_particle_info_bl_frag:"void node_particle_info(out float index,out float random,out float age,out float lifeTime,out vec3 location,out float size,out vec3 velocity,out vec3 angularVelocity){\n#if WORLD_NODES==1\nindex=0.0;\nrandom=0.0;\nage=0.0;\nlifeTime=0.0;\nlocation=vec3(0.0);\nsize=0.0;\nvelocity=vec3(0.0);\nangularVelocity=vec3(0.0);\n#else\nindex=0.0;\nrandom=0.0;\nage=0.0;\nlifeTime=0.0;\nlocation=vec3(0.0);\nsize=0.0;\nvelocity=vec3(0.0);\nangularVelocity=vec3(0.0);\n#endif\n}",node_point_info_bl_frag:"void node_point_info(out vec3 position,out float radius,out float random){\nposition=vec3(0.0);\nradius=0.0;\nrandom=0.0;\n}",node_principled_volume_bl_frag:"void node_principled_volume(vec4 color,float colorAttribute,float density,float densityAttribute,float anisotropy,vec4 absorptionColor,float emissionStrength,vec4 emissionColor,float blackbodyIntensity,vec4 blackbodyTint,float temperature,float temperatureAttribute,out vec4 volume){\nvolume=vec4(0.0);\n}",node_rgb_bl_frag:"uniform vec4 nodeRGB[NODE_RGB_NUM];\nvoid node_rgb(vec4 color,out vec4 outColor)\n{\noutColor=color;\n}",node_rgbtobw_bl_frag:"void node_rgbtobw(vec4 color,out float outVal){\noutVal=linearToRelativeLuminance(color.rgb);\n}",node_script_bl_frag:"void node_script(out vec4 outColor)\n{\noutColor=vec4(0.0);\n}",node_separate_color_bl_frag:"#define NODE_SEP_COL_RGB 0\n#define NODE_SEP_COL_HSV 1\n#define NODE_SEP_COL_HSL 2\nvoid rgbToHSL(vec3 rgb,out vec3 outCol)\n{\nfloat cMax,cMin;\nfloat h,s,l;\ncMax=max(rgb[0],max(rgb[1],rgb[2]));\ncMin=min(rgb[0],min(rgb[1],rgb[2]));\nl=min(1.0,(cMax+cMin)/2.0);\nif (cMax==cMin){\nh=s=0.0;\n} else {\nfloat cdelta=cMax-cMin;\ns=l>0.5?cdelta/(2.0-cMax-cMin):cdelta/(cMax+cMin);\nif (cMax==rgb[0]){\nh=(rgb[1]-rgb[2])/cdelta+(rgb[1]<rgb[2]?6.0:0.0);\n} else if (cMax==rgb[1]){\nh=(rgb[2]-rgb[0])/cdelta+2.0;\n} else {\nh=(rgb[0]-rgb[1])/cdelta+4.0;\n}\n}\nh/=6.0;\noutCol=vec3(h,s,l);\n}\nvoid node_separate_color(int mode,vec4 color,out float r,out float g,out float b)\n{\nif (mode==NODE_SEP_COL_RGB){\nr=color.r;\ng=color.g;\nb=color.b;\n} else if (mode==NODE_SEP_COL_HSV){\nvec4 hsv;\nrgbToHSV(color,hsv);\nr=hsv[0];\ng=hsv[1];\nb=hsv[2];\n} else {\nvec3 hsl;\nrgbToHSL(color.rgb,hsl);\nr=hsl[0];\ng=hsl[1];\nb=hsl[2];\n}\n}",node_sepxyz_bl_frag:"void node_sepxyz(vec3 vector,out float x,out float y,out float z)\n{\nx=vector.x;\ny=vector.y;\nz=vector.z;\n}",node_shadertorgb_bl_frag:"void node_shadertorgb(vec4 shader,out vec4 color,out float alpha){\ncolor=vec4(shader.rgb,1.0);\nalpha=shader.a;\n}",node_squeeze_bl_frag:"void node_squeeze(float val,float width,float center,out float outVal)\n{\noutVal=1.0/(1.0+pow(2.71828183,-((val-center)*width)));\n}",node_subsurface_scattering_bl_frag:"void node_subsurface_scattering(vec4 color,float scale,vec3 radius,float ior,float anisotropy,float roughness,vec3 normal,out vec4 outColor)\n{\noutColor=color;\n}",node_tangent_bl_frag:"#define TANGENT_AXIS_X 0\n#define TANGENT_AXIS_Y 1\n#define TANGENT_AXIS_Z 2\nvoid node_tangent(int axis,vec3 viewPos,vec3 viewNorm,out vec3 outTangent){\noutTangent=vec3(0.0);\n#if WORLD_NODES==0\nvec4 posWorld=invViewMatrix*vec4(-viewPos,1.0);\nvec3 norWorld=normalize(invViewMatrix*vec4(viewNorm,0.0)).xyz;\nvec3 posLocal=(invModelMatrix*posWorld).xyz;\nvec3 posOrco=(posLocal-boundingBoxMin)\n/ (boundingBoxMax-boundingBoxMin)-0.5;\nvec4 posOrcoPermuted;\nif (axis==TANGENT_AXIS_X){\nposOrcoPermuted=vec4(0.0,-posOrco.z,posOrco.y,0.0);\n} else if (axis==TANGENT_AXIS_Y){\nposOrcoPermuted=vec4(-posOrco.y,posOrco.x,0.0,0.0);\n} else if (axis==TANGENT_AXIS_Z){\nposOrcoPermuted=vec4(posOrco.z,0.0,-posOrco.x,0.0);\n}\nvec3 tangWorld=(modelMatrix*posOrcoPermuted).xyz;\ntangWorld=cross(norWorld,normalize(cross(tangWorld,norWorld)));\noutTangent=swizzleUpZ(tangWorld);\n#endif\n}\nvoid node_tangent(vec4 tangent,out vec3 outTangent){\n#if WORLD_NODES==0\noutTangent=normalize((modelMatrix*vec4(tangent.xyz,0.0)).xyz);\noutTangent=swizzleUpZ(outTangent);\n#endif\n}",node_tex_brick_bl_frag:"float integer_noise(int rowCount,int brickCount)\n{\n#if __VERSION__==300\nint n=(rowCount << 16)+(brickCount&0xFFFF);\nn=(n+1013)&0x7fffffff;\nn=(n >> 13)^ n;\nint nn=(n*(n*n*60493+19990303)+1376312589)&0x7fffffff;\nreturn 0.5*(float(nn)/1073741824.0);\n#else\nconst int RAND_MAX=32767;\nint next=((123456*rowCount)+brickCount)*1103515245+12345;\nreturn (mod(float(next/65536),float(RAND_MAX+1)))/float(RAND_MAX);\n#endif\n}\nvoid node_tex_brick(float offset,int offsetFrequency,float squash,int squashFrequency,vec3 vector,vec4 color1,vec4 color2,vec4 mortar,float scale,float mortarSize,float mortarSmooth,float bias,float brickWidth,float rowHeight,out vec4 outColor,out float outFac)\n{\nfloat x,y;\nvec3 p=vector*scale;\nfloat rowCount=floor(p.y/rowHeight);\nif (offsetFrequency != 0&&squashFrequency != 0){\nbrickWidth*=mod(rowCount,float(squashFrequency))>0.5?1.0:squash;\noffset=mod(rowCount,float(offsetFrequency))>0.5?0.0:(brickWidth*offset);\n} \nint brickCount=int((p.x+offset)/brickWidth);\nfloat tint=clamp((integer_noise(int(rowCount),brickCount)+bias),0.0,1.0);\n\nx=abs((p.x+offset)-brickWidth*float(brickCount));\ny=abs(p.y-rowHeight*rowCount);\nfloat min_dist=min(min(x,y),min(brickWidth-x,rowHeight-y));\n\nfloat f=step(min_dist,mortarSize);\nif (mortarSmooth>0.0){\nmin_dist=1.0-min_dist/mortarSize;\nf*=smoothstep(0.0,mortarSmooth,min_dist);\n}\noutColor=mix(mix(color1,color2,tint),mortar,f);\noutFac=f;\n}",node_tex_checker_bl_frag:"void node_tex_checker(vec3 vector,vec4 color1,vec4 color2,float scale,out vec4 outColor,out float outFac)\n{\nvec3 p=vector*scale;\np=(p+0.00001)*0.99999;\nfloat cx=floor(p.x);\nfloat cy=floor(p.y);\nfloat cz=floor(p.z);\nfloat result=sign(mod(cx+cy+cz,2.0));\noutFac=max(result,0.0);\noutColor=mix(color2,color1,outFac);\n}",node_tex_coord_bl_frag:"uniform mat4 nodeTexCoordObjectMatrices[NODE_TEX_COORD_NUM];\nvoid node_tex_coord(mat4 objectMat,vec3 viewPos,vec3 viewNorm,vec2 uv,out vec3 outGenerated,out vec3 outNormal,out vec3 outUV,out vec3 outObject,out vec3 outCamera,out vec3 outWindow,out vec3 outReflection)\n{\nvec4 view=vec4(-viewPos,1.0);\nvec4 posWorld=invViewMatrix*view;\nvec3 loc=swizzleUpZ((invModelMatrix*posWorld).xyz);\n#if WORLD_NODES==1\nloc=normalize(loc);\n#endif\n#if WORLD_NODES==1\noutGenerated=loc;\n#else\nvec3 boxMin=vec3(boundingBoxMin.x,-boundingBoxMax.z,boundingBoxMin.y);\nvec3 boxMax=vec3(boundingBoxMax.x,-boundingBoxMin.z,boundingBoxMax.y);\nvec3 boxSize=boxMax-boxMin;\nif (abs(boxSize.x)<0.001){\noutGenerated.x=0.5;\n} else {\noutGenerated.x=(loc.x-boxMin.x)/boxSize.x;\n}\nif (abs(boxSize.y)<0.001){\noutGenerated.y=0.5;\n} else {\noutGenerated.y=(loc.y-boxMin.y)/boxSize.y;\n}\nif (abs(boxSize.z)<0.001){\noutGenerated.z=0.5;\n} else {\noutGenerated.z=(loc.z-boxMin.z)/boxSize.z;\n}\n#endif\n#if WORLD_NODES==1\noutNormal=-loc;\n#else\noutNormal=normalize(invModelMatrix*invViewMatrix*vec4(viewNorm,0.0)).rgb;\noutNormal=swizzleUpZ(outNormal);\n#endif\n#if WORLD_NODES==1\noutUV=vec3(0.0);\n#else\nuv.y=1.0-uv.y;\noutUV=vec3(uv,0.0);\n#endif\n#if WORLD_NODES==1\noutObject=loc;\n#else\noutObject=swizzleUpZ((objectMat*posWorld).xyz);\n#endif\noutCamera=vec3(view.xy,-view.z);\n#if WORLD_NODES==1\noutWindow=vec3(0.0);\n#else\noutWindow=vec3(gl_FragCoord.xy/viewWidthHeight,0.0);\n#endif\n#if WORLD_NODES==1\noutReflection=-loc;\n#else\nvec4 reflection=(invViewMatrix*vec4(reflect(view.xyz,normalize(viewNorm)),0.0));\noutReflection=normalize(swizzleUpZ(reflection.xyz));\n#endif\n}",node_tex_environment_bl_frag:"#define TEX_PROJ_EQUIRECTANGULAR 0\n#define TEX_PROJ_MIRROR_BALL 1\nvoid node_tex_environment(sampler2D tex,const int encoding,const int projection,vec3 vector,out vec4 outColor){\nvec2 uv;\nfloat bias;\nif (projection==TEX_PROJ_EQUIRECTANGULAR){\nvec3 direction=swizzleUpY(vector);\nif (length(direction)==0.0){\ndirection=vec3(0.0,1.0,0.0);\n} else {\ndirection=normalize(direction);\n}\nuv=equirectUv(direction);\n#if WORLD_NODES==1\nbias=-16.0;\n#else\nconst float seamWidth=0.15;\nconst float seamBiasFactor=-10.0;\nfloat seam=max(0.0,1.0-abs (direction.z)/seamWidth)*\nclamp (1.0-direction.x/seamWidth,0.0,1.0);\nbias=seamBiasFactor*seam;\n#endif\n} else {\nvec3 normal=normalize(vector);\nnormal.y-=1.0;\nnormal/=(2.0*sqrt(max(-0.5*normal.y,0.0)));\nuv=clamp(0.5*normal.xz+0.5,0.0,1.0);\nbias=0.0;\n}\nuv.y=1.0-uv.y;\noutColor=texture2D(tex,uv,bias);\noutColor=nodeTexelToLinear(outColor,encoding);\n}",node_tex_environment_none_bl_frag:"void node_tex_environment_none(vec3 vector,out vec4 outColor){\noutColor=vec4(1.0,0.0,1.0,1.0);\n}",node_tex_gabor_bl_frag:"#define TEX_GABOR_2D 0\n#define TEX_GABOR_3D 1\n#define IMPULSES_COUNT 8\n#if __VERSION__==300\nvec2 compute2DGaborKernel(vec2 position,float frequency,float orientation){\nfloat distanceSq=dot(position,position);\nfloat hannWindow=0.5+0.5*cos(PI*distanceSq);\nfloat gaussianEnvelop=exp(-PI*distanceSq);\nfloat windowedGaussianEnvelope=gaussianEnvelop*hannWindow;\nvec2 frequencyVector=frequency*vec2(cos(orientation),sin(orientation));\nfloat angle=2.0*PI*dot(position,frequencyVector);\nvec2 phasor=vec2(cos(angle),sin(angle));\nreturn windowedGaussianEnvelope*phasor;\n}\nfloat compute2DGaborStandardDeviation(){\nfloat integralOfGaborSq=0.25;\nfloat secondMoment=0.5;\nreturn sqrt(float(IMPULSES_COUNT)*secondMoment*integralOfGaborSq);\n}\nvec2 compute2DGaborNoiseCell(vec2 cell,vec2 position,float frequency,float isotropy,float baseOrientation){\nvec2 noise=vec2(0.0);\nfor (int i=0;i<IMPULSES_COUNT;++i){\nvec3 seedForOrientation=vec3(cell,i*3);\nvec3 seedForKernelCenter=vec3(cell,i*3+1);\nvec3 seedForWeight=vec3(cell,i*3+2);\nfloat random_orientation=(hashVec3ToFloat(seedForOrientation)-0.5)*PI;\nfloat orientation=baseOrientation+random_orientation*isotropy;\nvec2 kernelCenter=hashVec3ToVec2(seedForKernelCenter);\nvec2 positionInKernelSpace=position-kernelCenter;\nif (dot(positionInKernelSpace,positionInKernelSpace)>=1.0)\ncontinue;\nfloat weight=hashVec3ToFloat(seedForWeight)<0.5?-1.0:1.0;\nnoise+=weight*compute2DGaborKernel(positionInKernelSpace,frequency,orientation);\n}\nreturn noise;\n}\nvec2 compute2DGaborNoise(vec2 coordinates,float frequency,float isotropy,float baseOrientation){\nvec2 cellPosition=floor(coordinates);\nvec2 localPosition=coordinates-cellPosition;\nvec2 sum=vec2(0.0);\nfor (int j=-1;j<=1;j++){\nfor (int i=-1;i<=1;i++){\nvec2 cellOffset=vec2(i,j);\nvec2 currCellPosition=cellPosition+cellOffset;\nvec2 positionInCellSpace=localPosition-cellOffset;\nsum+=compute2DGaborNoiseCell(currCellPosition,positionInCellSpace,frequency,isotropy,baseOrientation);\n}\n}\nreturn sum;\n}\nvec2 compute3DGaborKernel(vec3 position,float frequency,vec3 orientation){\nfloat distanceSq=dot(position,position);\nfloat hannWindow=0.5+0.5*cos(PI*distanceSq);\nfloat gaussianEnvelop=exp(-PI*distanceSq);\nfloat windowedGaussianEnvelope=gaussianEnvelop*hannWindow;\nvec3 frequencyVector=frequency*orientation;\nfloat angle=2.0*PI*dot(position,frequencyVector);\nvec2 phasor=vec2(cos(angle),sin(angle));\nreturn windowedGaussianEnvelope*phasor;\n}\nfloat compute3DGaborStandardDeviation(){\nfloat integralOfGaborSq=1.0/(4.0*sqrt(2.0));\nfloat secondMoment=0.5;\nreturn sqrt(float(IMPULSES_COUNT)*secondMoment*integralOfGaborSq);\n}\nvec3 compute3DOrientation(vec3 orientation,float isotropy,vec4 seed){\nif (isotropy==0.0)\nreturn orientation;\nfloat inclination=acos(orientation.z);\nfloat azimuth=sign(orientation.y)*acos(orientation.x/length(orientation.xy));\nvec2 randomAngles=hashVec4ToVec2(seed)*PI;\ninclination+=randomAngles.x*isotropy;\nazimuth+=randomAngles.y*isotropy;\nreturn vec3(sin(inclination)*cos(azimuth),sin(inclination)*sin(azimuth),cos(inclination));\n}\nvec2 compute3DGaborNoiseCell(vec3 cell,vec3 position,float frequency,float isotropy,vec3 baseOrientation){\nvec2 noise=vec2(0.0);\nfor (int i=0;i<IMPULSES_COUNT;++i){\nvec4 seedForOrientation=vec4(cell,i*3);\nvec4 seedForKernelCenter=vec4(cell,i*3+1);\nvec4 seedForWeight=vec4(cell,i*3+2);\nvec3 orientation=compute3DOrientation(baseOrientation,isotropy,seedForOrientation);\nvec3 kernelCenter=hashVec4ToVec3(seedForKernelCenter);\nvec3 positionInKernelSpace=position-kernelCenter;\nif (dot(positionInKernelSpace,positionInKernelSpace)>=1.0)\ncontinue;\nfloat weight=hashVec4ToFloat(seedForWeight)<0.5?-1.0:1.0;\nnoise+=weight*compute3DGaborKernel(positionInKernelSpace,frequency,orientation);\n}\nreturn noise;\n}\nvec2 compute3DGaborNoise(vec3 coordinates,float frequency,float isotropy,vec3 baseOrientation){\nvec3 cellPosition=floor(coordinates);\nvec3 localPosition=coordinates-cellPosition;\nvec2 sum=vec2(0.0);\nfor (int k=-1;k<=1;k++){\nfor (int j=-1;j<=1;j++){\nfor (int i=-1;i<=1;i++){\nvec3 cellOffset=vec3(i,j,k);\nvec3 currCellPosition=cellPosition+cellOffset;\nvec3 positionInCellSpace=localPosition-cellOffset;\nsum+=compute3DGaborNoiseCell(currCellPosition,positionInCellSpace,frequency,isotropy,baseOrientation);\n}\n}\n}\nreturn sum;\n}\nvoid node_tex_gabor(int gaborType,vec3 vector,float scale,float frequency,float anisotropy,float orientation2D,vec3 orientation3D,out float outValue,out float outPhase,out float outIntensity){\nvec3 scaledVector=vector*scale;\nfloat isotropy=1.0-clamp(anisotropy,0.0,1.0);\nfrequency=max(0.001,frequency);\nvec2 phasor=vec2(0.0);\nfloat standard_deviation=1.0;\nif (gaborType==TEX_GABOR_2D){\nphasor=compute2DGaborNoise(scaledVector.xy,frequency,isotropy,orientation2D);\nstandard_deviation=compute2DGaborStandardDeviation();\n} else {\nvec3 orientation=normalize(orientation3D);\nphasor=compute3DGaborNoise(scaledVector,frequency,isotropy,orientation);\nstandard_deviation=compute3DGaborStandardDeviation();\n}\nfloat normalizationFactor=6.0*standard_deviation;\noutValue=(phasor.y/normalizationFactor)*0.5+0.5;\noutPhase=(atan(phasor.y,phasor.x)+PI)/(2.0*PI);\noutIntensity=length(phasor)/normalizationFactor;\n}\n#else\nvoid node_tex_gabor(int gaborType,vec3 vector,float scale,float frequency,float anisotropy,float orientation2D,vec3 orientation3D,out float outValue,out float outPhase,out float outIntensity){\noutValue=0.0;\noutPhase=0.0;\noutIntensity=0.0;\n}\n#endif",node_tex_gradient_bl_frag:"#define TEX_GRAD_LINEAR 0\n#define TEX_GRAD_QUADRATIC 1\n#define TEX_GRAD_EASING 2\n#define TEX_GRAD_DIAGONAL 3\n#define TEX_GRAD_SPHERICAL 4\n#define TEX_GRAD_QUADRATIC_SPHERE 5\n#define TEX_GRAD_RADIAL 6\nvoid node_tex_gradient(const int type,vec3 vector,out vec4 outColor,out float outFac)\n{\nfloat x,y,z,r;\nx=vector.x;\ny=vector.y;\nz=vector.z;\nif (type==TEX_GRAD_LINEAR){\noutFac=x;\n} else if (type==TEX_GRAD_QUADRATIC){\nr=max(x,0.0);\noutFac=pow2(r);\n} else if (type==TEX_GRAD_EASING){\nr=min(max(x,0.0),1.0);\noutFac=(3.0*pow2(r)-2.0*pow3(r));\n} else if (type==TEX_GRAD_DIAGONAL){\noutFac=(x+y)*0.5;\n} else if (type==TEX_GRAD_RADIAL){\noutFac=atan(y,x)/PI2+0.5;\n} else {\nr=max(0.99999-sqrt(x*x+y*y+z*z),0.0);\nif (type==TEX_GRAD_QUADRATIC_SPHERE){\noutFac=pow2(r);\n} else if (type==TEX_GRAD_SPHERICAL){\noutFac=r;\n}\n}\noutFac=clamp(outFac,0.0,1.0);\noutColor=vec4(outFac,outFac,outFac,1.0);\n}",node_tex_ies_bl_frag:"void node_tex_ies(vec3 vector,float strength,out float fac){\nfac=0.0;\n}",node_tex_image_bl_frag:"#define TEX_PROJ_FLAT 0\n#define TEX_PROJ_BOX 1\n#define TEX_PROJ_SPHERE 2\n#define TEX_PROJ_TUBE 3\n#define TEX_ALPHA_CLEAR 0\n#define TEX_ALPHA_PREMUL 1\n#define TEX_ALPHA_UNPREMUL 2\n#define TEX_ALPHA_ONE 3\nvec4 applyAlphaMode(vec4 color,const int alphaMode){\nif (alphaMode==TEX_ALPHA_CLEAR){\n} else if (alphaMode==TEX_ALPHA_PREMUL){\ncolor.rgb=color.rgb*color.a;\n} else if (alphaMode==TEX_ALPHA_UNPREMUL){\nfloat alpha=color.a;\ncolor.rgb=clamp(color.rgb,0.0,alpha);\nif (alpha==0.0)\ncolor.rgb=vec3(0.0);\nelse\ncolor.rgb/=alpha;\n}\nreturn color;\n}\nvoid node_tex_image(sampler2D ima,const int encoding,const int alphaMode,vec3 viewNorm,const int projection,const float projectionBlend,const bool clampToEdgeNoExtend,vec3 vector,out vec4 outColor,out float outAlpha){\nif (projection==TEX_PROJ_FLAT){\nvec2 uv=vector.xy;\nuv.y=1.0-uv.y;\nif (clampToEdgeNoExtend&&(uv.x<0.0||uv.x>1.0||uv.y<0.0||uv.y>1.0)){\noutColor=vec4(0.0);\noutAlpha=0.0;\n} else {\noutColor=texture2D(ima,uv);\noutAlpha=outColor.a;\n}\noutColor=nodeTexelToLinear(outColor,encoding);\n} else if (projection==TEX_PROJ_BOX){\nvec3 norm=normalize(viewNorm*normalMatrix);\nvector=swizzleUpY(vector);\nvec2 uvX=vec2(-sign(norm.x)*vector.z,-vector.y);\nvec2 uvY=vec2(sign(norm.y)*vector.z,-vector.x);\nvec2 uvZ=vec2(sign(norm.z)*vector.x,-vector.y);\nvec4 colX=nodeTexelToLinear(texture2D(ima,uvX),encoding);\nvec4 colY=nodeTexelToLinear(texture2D(ima,uvY),encoding);\nvec4 colZ=nodeTexelToLinear(texture2D(ima,uvZ),encoding);\nvec3 barycentric=abs(norm);\nbarycentric/=barycentric.x+barycentric.y+barycentric.z;\nvec3 edgeShape=min(min(barycentric.yzx,barycentric.zxy),(projectionBlend-1.0)/(projectionBlend-3.0));\nvec3 edgeValue=(1.0-projectionBlend)*(1.0-edgeShape)/2.0;\nvec3 weight=max((barycentric-edgeValue)/(1.0-edgeValue),EPSILON);\nweight/=(weight.x+weight.y+weight.z);\noutColor=weight.x*colX+weight.y*colY+weight.z*colZ;\noutAlpha=outColor.a;\n} else if (projection==TEX_PROJ_SPHERE){\nvector=normalize(vector*2.0-1.0);\nvector=swizzleUpY(vector);\nvec2 uv=vec2(atan(vector.x,vector.z)/PI2,acos(vector.y)/PI);\nuv.x=mod(uv.x,1.0);\noutColor=texture2D(ima,uv);\noutAlpha=outColor.a;\noutColor=nodeTexelToLinear(outColor,encoding);\n} else if (projection==TEX_PROJ_TUBE){\nvector=vector*2.0-1.0;\nvector=swizzleUpY(vector);\nvec2 uv=vec2(atan(vector.x,vector.z)/PI2,(1.0-vector.y)/2.0);\nuv.x=mod(uv.x,1.0);\noutColor=texture2D(ima,uv);\noutAlpha=outColor.a;\noutColor=nodeTexelToLinear(outColor,encoding);\n}\noutColor=applyAlphaMode(outColor,alphaMode);\nif (alphaMode==TEX_ALPHA_ONE)\noutAlpha=1.0;\n}",node_tex_image_none_bl_frag:"void node_tex_image_none(vec3 vector,out vec4 color,out float alpha)\n{\ncolor=vec4(1.0,0.0,1.0,1.0);\nalpha=1.0;\n}",node_tex_magic_bl_frag:"void node_tex_magic(const int depth,vec3 vector,float scale,float distortion,out vec4 outColor,out float outFac)\n{\nvec3 p=mod(vector*scale,2.0*PI);\nfloat x=sin((p.x+p.y+p.z)*5.0);\nfloat y=cos((-p.x+p.y-p.z)*5.0);\nfloat z=-cos((-p.x-p.y+p.z)*5.0);\nif (depth>0){\nx*=distortion;\ny*=distortion;\nz*=distortion;\ny=-cos(x-y+z);\ny*=distortion;\nif (depth>1){\nx=cos(x-y-z);\nx*=distortion;\nif (depth>2){\nz=sin(-x-y-z);\nz*=distortion;\nif (depth>3){\nx=-cos(-x+y-z);\nx*=distortion;\nif (depth>4){\ny=-sin(-x+y+z);\ny*=distortion;\nif (depth>5){\ny=-cos(-x+y+z);\ny*=distortion;\nif (depth>6){\nx=cos(x+y+z);\nx*=distortion;\nif (depth>7){\nz=sin(x+y-z);\nz*=distortion;\nif (depth>8){\nx=-cos(-x-y+z);\nx*=distortion;\nif (depth>9){\ny=-sin(x-y+z);\ny*=distortion;\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\nif (distortion != 0.0){\ndistortion*=2.0;\nx/=distortion;\ny/=distortion;\nz/=distortion;\n}\noutColor=vec4(0.5-x,0.5-y,0.5-z,1.0);\noutFac=(outColor.x+outColor.y+outColor.z)/3.0;\n}",node_tex_noise_bl_frag:"#define TEX_NOISE_MULTIFRACTAL 0\n#define TEX_NOISE_RIDGED_MULTIFRACTAL 1\n#define TEX_NOISE_HYBRID_MULTIFRACTAL 2\n#define TEX_NOISE_FBM 3\n#define TEX_NOISE_HETERO_TERRAIN 4\nvoid node_tex_noise(int noiseType,float falloffFactor,float dispersionFactor,vec3 vector,float w,float scale,float detail,float roughness,float lacunarity,float offset,float gain,float distortion,out float outFac,out vec4 outColor){\nvec3 p=vector*scale;\nvec3 dx=dFdx(p);\nvec3 dy=dFdy(p);\nfloat octaveLenPerPixel=(length(dx)+length(dy))/4.0;\nif (distortion != 0.0){\nvec3 r,offset=vec3(13.5,13.5,13.5);\nr.x=noiseSmooth(p+offset,octaveLenPerPixel,falloffFactor,dispersionFactor)*distortion;\nr.y=noiseSmooth(p,octaveLenPerPixel,falloffFactor,dispersionFactor)*distortion;\nr.z=noiseSmooth(p-offset,octaveLenPerPixel,falloffFactor,dispersionFactor)*distortion;\np+=r;\n}\noutFac=noiseTurbulence(p,detail,octaveLenPerPixel,falloffFactor,dispersionFactor);\nvec3 color=vec3(outFac,noiseTurbulence(vec3(p.y,p.x,p.z),detail,octaveLenPerPixel,falloffFactor,dispersionFactor),noiseTurbulence(vec3(p.y,p.z,p.x),detail,octaveLenPerPixel,falloffFactor,dispersionFactor)\n);\noutColor=vec4(color,1.0);\n}",node_tex_pointdensity_bl_frag:"void node_tex_pointdensity(vec3 vector,out vec4 outColor,out float outDensity)\n{\noutColor=vec4(0.0);\noutDensity=0.0;\n}",node_tex_sky_bl_frag:"\n#define TEX_SKY_PREETHAM 0\n#define TEX_SKY_HOSEK_WILKIE 1\n#define TEX_SKY_NISHITA 2\n#define Km 683.0\nvec3 sky_spherical_coordinates(vec3 dir){\nreturn vec3(PI_HALF-atan(dir.z,length(dir.xy)),atan(dir.x,dir.y),0.0);\n}\nvoid node_tex_sky(const int skyType,vec3 param0,vec3 param1,vec3 param2,vec3 param3,vec3 param4,vec3 param5,vec3 param6,vec3 param7,vec3 param8,vec3 radiance,vec3 sunDirection,vec3 vectorIn,out vec4 outColor){\nif (length(vectorIn)==0.0){\nvectorIn=vec3(0.0,1.0,0.0);\n} else {\nvectorIn=normalize(vectorIn);\n}\nvectorIn=swizzleUpY(vectorIn);\nsunDirection=swizzleUpY(sunDirection);\nfloat cosGamma=clamp(dot(vectorIn,sunDirection),-1.0,1.0);\nfloat cosTheta=clamp(vectorIn.y,0.0,1.0);\nif (skyType==TEX_SKY_PREETHAM){\nvec3 radInternal=(1.0+param0*exp(param1/cosTheta))*(1.0+param2*exp(param3*acos(cosGamma))\n+ param4*pow(cosGamma,2.0)\n);\nvec3 XYZ=xyY_to_XYZ(radInternal.y*radiance.y,radInternal.z*radiance.z,radInternal.x*radiance.x);\noutColor=vec4(max(xyz_to_sRGB(XYZ),0.0),1.0);\n} else if (skyType==TEX_SKY_HOSEK_WILKIE){\nfloat cosGammaSq=pow(cosGamma,2.0);\nvec3 chi=(1.0+cosGammaSq)/pow(1.0+pow(param8,vec3(2.0))\n- 2.0*param8*cosGamma,vec3(1.5));\nvec3 radInternal=(1.0+param0*exp(param1/(cosTheta+0.01)))*(param2+param3*exp(param4*acos(cosGamma))\n+ param5*cosGammaSq+param6*chi+param7*sqrt(cosTheta)\n);\noutColor=vec4(max(xyz_to_sRGB(radInternal*radiance),0.0)*PI2/Km,1.0);\n} else {\noutColor=vec4(0.0,0.0,0.0,1.0);\n}\n}\nvoid node_tex_sky(sampler2D ima,float sunRotation,vec3 vectorIn,out vec4 outColor){\nvec3 spherical=sky_spherical_coordinates(vectorIn);\nif (vectorIn.z<-0.4f){\noutColor=vec4(0,0,0,1);\n} else {\nconst float tau=6.28318530717958647692;\nfloat x=(spherical.y+PI+sunRotation)/tau;\nif (x>1.0){\nx-=1.0;\n}\nfloat fade;\nfloat y;\nif (vectorIn.z<0.0){\nfade=1.0f+vectorIn.z*2.5;\nfade=fade*fade*fade;\ny=0.0;\n} else {\nfade=1.0;\ny=sqrt((PI_HALF-spherical.x)/PI_HALF);\n}\nvec3 xyz=fade*texture(ima,vec2(x,y)).rgb;\noutColor=vec4(xyz_to_sRGB(xyz),1.0);\n}\n}",node_tex_voronoi_bl_frag:"#define DISTANCE_EUCLIDEAN 0\n#define DISTANCE_MANHATTAN 1\n#define DISTANCE_CHEBYCHEV 2\n#define DISTANCE_MINKOWSKI 3\n#define FEATURE_F1 0\n#define FEATURE_F2 1\n#define FEATURE_SMOOTH_F1 2\n#define FEATURE_DISTANCE_TO_EDGE 3\n#define FEATURE_N_SPHERE_RADIUS 4\nstruct VoronoiGridData {\nvec3 point;\nvec3 randVec;\nvec3 toClosest;\nfloat dist;\n};\nhighp vec3 rand3(const in vec3 v){\nconst highp float c=43758.5453;\nconst highp mat3 coeffs=mat3(165.15,253.34,323.22,241.49,329.07,147.79,376.31,143.45,281.63\n);\nhighp vec3 sn=mod(coeffs*v,PI);\nreturn fract(sin(sn)*c);\n}\nfloat worleyLength(vec3 vec,int distance,float exponent){\nif (distance==DISTANCE_EUCLIDEAN){\nreturn length(vec);\n} else if (distance==DISTANCE_MANHATTAN){\nreturn abs(vec.x)+abs(vec.y)+abs(vec.z);\n} else if (distance==DISTANCE_CHEBYCHEV){\nreturn max(max(abs(vec.x),abs(vec.y)),abs(vec.z));\n} else if (distance==DISTANCE_MINKOWSKI){\nreturn pow(pow(abs(vec.x),exponent)\n+ pow(abs(vec.y),exponent)\n+ pow(abs(vec.z),exponent),1.0/exponent);\n}\nreturn 0.0;\n}\nvoid worleyNoise(vec3 pos,int distance,float exponent,int feature,float smoothness,float randomness,out float outDist,out vec4 outColor,out vec3 outPosition,out float outW,out float outRadius){\nconst highp float RAND_FIX_ZERO=0.125;\nvec3 posI=floor(pos);\nvec3 posF=fract(pos);\nVoronoiGridData vgd[27];\n#pragma unroll_loop\nfor (int i=0;i<=2;i++){\n#pragma unroll_loop\nfor (int j=0;j<=2;j++){\n#pragma unroll_loop\nfor (int k=0;k<=2;k++){\nvec3 point=vec3((i),(j),(k))-1.0;\nvec3 randVec=rand3(posI+point+RAND_FIX_ZERO);\nvec3 toClosest=point+randomness*randVec-posF;\nconst int counter=(i)+(j)*3+(k)*9;\nvgd[counter].point=point;\nvgd[counter].randVec=randVec;\nvgd[counter].toClosest=toClosest;\nvgd[counter].dist=worleyLength(toClosest,distance,exponent);\n}\n}\n}\nfloat f1=1e10;\nfloat f2=1e10;\nvec3 edgeToClosest=vec3(0.0);\nfloat distToEdge=1e10;\nvec3 randColF1=vec3(0.0);\nvec3 randColF2=vec3(0.0);\nvec3 toClosestF1=vec3(0.0);\nvec3 toClosestF2=vec3(0.0);\nvec3 radPoint=vec3(0.0);\nvec3 radToClosest=vec3(0.0);\n#pragma unroll_loop\nfor (int i=0;i<27;i++){\nif (feature==FEATURE_F1){\nif (vgd[i].dist<f1){\nf1=vgd[i].dist;\nrandColF1=vgd[i].randVec;\ntoClosestF1=vgd[i].toClosest;\n}\n} else if (feature==FEATURE_F2){\nif (vgd[i].dist<f1){\nf2=f1;\nf1=vgd[i].dist;\nrandColF2=randColF1;\nrandColF1=vgd[i].randVec;\ntoClosestF2=toClosestF1;\ntoClosestF1=vgd[i].toClosest;\n} else if (vgd[i].dist<f2){\nf2=vgd[i].dist;\nrandColF2=vgd[i].randVec;\ntoClosestF2=vgd[i].toClosest;\n}\n} else if (feature==FEATURE_SMOOTH_F1){\nf1=smoothMin(f1,vgd[i].dist,smoothness);\n} else if (feature==FEATURE_DISTANCE_TO_EDGE){\nfloat dist=worleyLength(vgd[i].toClosest,DISTANCE_EUCLIDEAN,exponent);\nif (dist<f1){\nf1=dist;\nedgeToClosest=vgd[i].toClosest;\n}\n} else if (feature==FEATURE_N_SPHERE_RADIUS){\nfloat dist=worleyLength(vgd[i].toClosest,DISTANCE_EUCLIDEAN,exponent);\nif (dist<f1){\nf1=dist;\nradPoint=vgd[i].point;\nradToClosest=vgd[i].toClosest;\n}\n}\n}\nif (feature==FEATURE_F1){\noutDist=f1;\noutColor=vec4(randColF1,1.0);\noutPosition=pos+toClosestF1;\n} else if (feature==FEATURE_F2){\noutDist=f2;\noutColor=vec4(randColF2,1.0);\noutPosition=pos+toClosestF2;\n} else if (feature==FEATURE_SMOOTH_F1){\noutDist=f1;\nvec3 avgCol=vec3(0.0);\nvec3 avgOff=vec3(0.0);\nfloat sumWeightsCol=0.0;\nfloat sumWeightsOff=0.0;\n#pragma unroll_loop\nfor (int i=0;i<27;i++){\nfloat smoothFac=getSmoothFactor(f1,vgd[i].dist,smoothness);\nfloat weightOff=smoothFac*smoothFac*smoothFac;\nfloat weightCol=weightOff*smoothFac;\navgCol+=vgd[i].randVec*weightCol;\navgOff+=vgd[i].toClosest*weightOff;\nsumWeightsCol+=weightCol;\nsumWeightsOff+=weightOff;\n}\noutColor=vec4(avgCol/sumWeightsCol,1.0);\noutPosition=pos+avgOff/sumWeightsOff;\n} else if (feature==FEATURE_DISTANCE_TO_EDGE){\n#pragma unroll_loop\nfor (int i=0;i<27;i++){\nif (vgd[i].toClosest != edgeToClosest){\nfloat dist=dot(0.5*(edgeToClosest+vgd[i].toClosest),normalize(vgd[i].toClosest-edgeToClosest));\ndistToEdge=min(distToEdge,dist);\n}\n}\noutDist=distToEdge;\n} else if (feature==FEATURE_N_SPHERE_RADIUS){\nfloat diam=1e10;\n#pragma unroll_loop\nfor (int i=0;i<=2;i++){\n#pragma unroll_loop\nfor (int j=0;j<=2;j++){\n#pragma unroll_loop\nfor (int k=0;k<=2;k++){\nvec3 localPoint=vec3((i),(j),(k))-1.0;\nif (length(localPoint)>0.0){\nvec3 point=localPoint+radPoint;\nvec3 randVec=rand3(posI+point+RAND_FIX_ZERO);\nvec3 toClosest=point+randomness*randVec-posF;\ndiam=min(diam,length(toClosest-radToClosest));\n}\n}\n}\n}\noutRadius=diam/2.0;\n}\n}\n#define VORONOI_SMOOTH_COEFF 0.74\nvoid node_tex_voronoi(int distance,int feature,vec3 vector,float w,float scale,float detail,float roughness,float lacunarity,float smoothness,float exponent,float randomness,out float outDistance,out vec4 outColor,out vec3 outPosition,out float outW,out float outRadius){\nvector=scale*(vector-0.0001);\nsmoothness=clamp(smoothness,1e-3,1.0);\nsmoothness*=VORONOI_SMOOTH_COEFF;\nworleyNoise(vector,distance,exponent,feature,smoothness,randomness,outDistance,outColor,outPosition,outW,outRadius);\noutPosition/=scale;\n}\n#define FEATURE_F3 5\n#define FEATURE_F4 6\n#define FEATURE_F2F1 7\n#define COLORING_INTENSITY 0\n#define COLORING_CELLS 1\nstruct VoronoiClosest {\nvec4 closestDists;\nvec4 closestInds;\n};\nvoid updateVoronoiClosest(inout VoronoiClosest vf,vec3 newDistances,vec3 newIndices){\n#pragma unroll_loop\nfor (int i=0;i<3;i++){\nfloat currDist=newDistances[i];\nfloat currIdx=newIndices[i];\n#pragma unroll_loop\nfor (int j=0;j<4;j++){\nif (currDist<vf.closestDists[j]){\nfloat tmp=vf.closestDists[j];\nvf.closestDists[j]=currDist;\ncurrDist=tmp;\ntmp=vf.closestInds[j];\nvf.closestInds[j]=currIdx;\ncurrIdx=tmp;\n}\n}\n}\n}\nvec3 worleyPermute(vec3 x){\nreturn mod((34.0*x+1.0)*x,289.0);\n}\nvec3 worleyDist(vec3 x,vec3 y,vec3 z,int distance,float exponent){\nif (distance==DISTANCE_EUCLIDEAN){\nreturn x*x+y*y+z*z;\n} else if (distance==DISTANCE_MANHATTAN){\nreturn abs(x)+abs(y)+abs(z);\n} else if (distance==DISTANCE_CHEBYCHEV){\nreturn max(max(abs(x),abs(y)),abs(z));\n} else if (distance==DISTANCE_MINKOWSKI){\nvec3 expVec=vec3(exponent);\nreturn pow(pow(abs(x),expVec)\n+ pow(abs(y),expVec)\n+ pow(abs(z),expVec),1.0/expVec);\n}\nreturn vec3(0.0);\n}\nVoronoiClosest worleyClosest(vec3 P,float jitter,int distance,float exponent){\nfloat K=0.142857142857;\nfloat Ko=0.428571428571;\nfloat K2=0.020408163265306;\nfloat Kz=0.166666666667;\nfloat Kzo=0.416666666667;\nvec3 Pi=mod(floor(P),289.0);\nvec3 Pf=fract(P)-0.5;\nvec3 Pfx=Pf.x+vec3(1.0,0.0,-1.0);\nvec3 Pfy=Pf.y+vec3(1.0,0.0,-1.0);\nvec3 Pfz=Pf.z+vec3(1.0,0.0,-1.0);\nvec3 p=worleyPermute(Pi.x+vec3(-1.0,0.0,1.0));\nvec3 p1=worleyPermute(p+Pi.y-1.0);\nvec3 p2=worleyPermute(p+Pi.y);\nvec3 p3=worleyPermute(p+Pi.y+1.0);\nvec3 p11=worleyPermute(p1+Pi.z-1.0);\nvec3 p12=worleyPermute(p1+Pi.z);\nvec3 p13=worleyPermute(p1+Pi.z+1.0);\nvec3 p21=worleyPermute(p2+Pi.z-1.0);\nvec3 p22=worleyPermute(p2+Pi.z);\nvec3 p23=worleyPermute(p2+Pi.z+1.0);\nvec3 p31=worleyPermute(p3+Pi.z-1.0);\nvec3 p32=worleyPermute(p3+Pi.z);\nvec3 p33=worleyPermute(p3+Pi.z+1.0);\nvec3 ox11=fract(p11*K)-Ko;\nvec3 oy11=mod(floor(p11*K),7.0)*K-Ko;\nvec3 oz11=floor(p11*K2)*Kz-Kzo;\nvec3 ox12=fract(p12*K)-Ko;\nvec3 oy12=mod(floor(p12*K),7.0)*K-Ko;\nvec3 oz12=floor(p12*K2)*Kz-Kzo;\nvec3 ox13=fract(p13*K)-Ko;\nvec3 oy13=mod(floor(p13*K),7.0)*K-Ko;\nvec3 oz13=floor(p13*K2)*Kz-Kzo;\nvec3 ox21=fract(p21*K)-Ko;\nvec3 oy21=mod(floor(p21*K),7.0)*K-Ko;\nvec3 oz21=floor(p21*K2)*Kz-Kzo;\nvec3 ox22=fract(p22*K)-Ko;\nvec3 oy22=mod(floor(p22*K),7.0)*K-Ko;\nvec3 oz22=floor(p22*K2)*Kz-Kzo;\nvec3 ox23=fract(p23*K)-Ko;\nvec3 oy23=mod(floor(p23*K),7.0)*K-Ko;\nvec3 oz23=floor(p23*K2)*Kz-Kzo;\nvec3 ox31=fract(p31*K)-Ko;\nvec3 oy31=mod(floor(p31*K),7.0)*K-Ko;\nvec3 oz31=floor(p31*K2)*Kz-Kzo;\nvec3 ox32=fract(p32*K)-Ko;\nvec3 oy32=mod(floor(p32*K),7.0)*K-Ko;\nvec3 oz32=floor(p32*K2)*Kz-Kzo;\nvec3 ox33=fract(p33*K)-Ko;\nvec3 oy33=mod(floor(p33*K),7.0)*K-Ko;\nvec3 oz33=floor(p33*K2)*Kz-Kzo;\nvec3 dx11=Pfx+jitter*ox11;\nvec3 dy11=Pfy.x+jitter*oy11;\nvec3 dz11=Pfz.x+jitter*oz11;\nvec3 dx12=Pfx+jitter*ox12;\nvec3 dy12=Pfy.x+jitter*oy12;\nvec3 dz12=Pfz.y+jitter*oz12;\nvec3 dx13=Pfx+jitter*ox13;\nvec3 dy13=Pfy.x+jitter*oy13;\nvec3 dz13=Pfz.z+jitter*oz13;\nvec3 dx21=Pfx+jitter*ox21;\nvec3 dy21=Pfy.y+jitter*oy21;\nvec3 dz21=Pfz.x+jitter*oz21;\nvec3 dx22=Pfx+jitter*ox22;\nvec3 dy22=Pfy.y+jitter*oy22;\nvec3 dz22=Pfz.y+jitter*oz22;\nvec3 dx23=Pfx+jitter*ox23;\nvec3 dy23=Pfy.y+jitter*oy23;\nvec3 dz23=Pfz.z+jitter*oz23;\nvec3 dx31=Pfx+jitter*ox31;\nvec3 dy31=Pfy.z+jitter*oy31;\nvec3 dz31=Pfz.x+jitter*oz31;\nvec3 dx32=Pfx+jitter*ox32;\nvec3 dy32=Pfy.z+jitter*oy32;\nvec3 dz32=Pfz.y+jitter*oz32;\nvec3 dx33=Pfx+jitter*ox33;\nvec3 dy33=Pfy.z+jitter*oy33;\nvec3 dz33=Pfz.z+jitter*oz33;\nvec3 d11=worleyDist(dx11,dy11,dz11,distance,exponent);\nvec3 d12=worleyDist(dx12,dy12,dz12,distance,exponent);\nvec3 d13=worleyDist(dx13,dy13,dz13,distance,exponent);\nvec3 d21=worleyDist(dx21,dy21,dz21,distance,exponent);\nvec3 d22=worleyDist(dx22,dy22,dz22,distance,exponent);\nvec3 d23=worleyDist(dx23,dy23,dz23,distance,exponent);\nvec3 d31=worleyDist(dx31,dy31,dz31,distance,exponent);\nvec3 d32=worleyDist(dx32,dy32,dz32,distance,exponent);\nvec3 d33=worleyDist(dx33,dy33,dz33,distance,exponent);\nVoronoiClosest vf=VoronoiClosest(vec4(1e10),vec4(0.0));\nupdateVoronoiClosest(vf,d11,p11);\nupdateVoronoiClosest(vf,d12,p12);\nupdateVoronoiClosest(vf,d13,p13);\nupdateVoronoiClosest(vf,d21,p21);\nupdateVoronoiClosest(vf,d22,p22);\nupdateVoronoiClosest(vf,d23,p23);\nupdateVoronoiClosest(vf,d31,p31);\nupdateVoronoiClosest(vf,d32,p32);\nupdateVoronoiClosest(vf,d33,p33);\nreturn vf;\n}\nvoid node_tex_voronoi(int coloring,int distance,int feature,vec3 vector,float scale,float exponent,out vec4 outColor,out float outFac){\nvector=scale*(vector-0.0001);\nVoronoiClosest vf=worleyClosest(vector,1.0,distance,exponent);\nvec4 vorColorData;\nif (coloring==COLORING_INTENSITY){\nvorColorData=vf.closestDists;\n} else if (coloring==COLORING_CELLS){\nvorColorData=vf.closestInds;\n}\nfloat vorColorFac;\nif (feature==FEATURE_F1){\nvorColorFac=vorColorData.x;\n} else if (feature==FEATURE_F2){\nvorColorFac=vorColorData.y;\n} else if (feature==FEATURE_F3){\nvorColorFac=vorColorData.z;\n} else if (feature==FEATURE_F4){\nvorColorFac=vorColorData.w;\n} else if (feature==FEATURE_F2F1){\nvorColorFac=vorColorData.y-vorColorData.x;\n}\nif (coloring==COLORING_INTENSITY){\noutFac=vorColorFac;\noutColor=vec4(vec3(outFac),1.0);\n} else if (coloring==COLORING_CELLS){\nvorColorFac+=1e-3;\nfloat r=rand(vec2(vorColorFac/289.0));\nfloat g=rand(vec2(vorColorFac/23535.0));\nfloat b=rand(vec2(vorColorFac/4353.0));\noutFac=(r+g+b)/3.0;\noutColor=vec4(r,g,b,1.0);\n}\n}",node_tex_wave_bl_frag:"#define TEX_WAVE_TYPE_BANDS 0\n#define TEX_WAVE_TYPE_RINGS 1\n#define TEX_WAVE_PROFILE_SIN 0\n#define TEX_WAVE_PROFILE_SAW 1\n#define TEX_WAVE_PROFILE_TRI 2\n#define TEX_WAVE_BANDS_DIR_X 0\n#define TEX_WAVE_BANDS_DIR_Y 1\n#define TEX_WAVE_BANDS_DIR_Z 2\n#define TEX_WAVE_BANDS_DIR_DIAGONAL 3\n#define TEX_WAVE_RINGS_DIR_X 0\n#define TEX_WAVE_RINGS_DIR_Y 1\n#define TEX_WAVE_RINGS_DIR_Z 2\n#define TEX_WAVE_RINGS_DIR_SPHERICAL 3\nvoid node_tex_wave(int waveType,int waveProfile,int bandsDirection,int ringsDirection,vec3 vector,float scale,float distortion,float detail,float detailScale,float detailRoughness,float phaseOffset,out vec4 outColor,out float outFac){\nvec3 coScaled=vector*scale;\nfloat waveFac;\nvec3 waveVec=coScaled;\nif (waveType==TEX_WAVE_TYPE_BANDS){\nconst float BANDS_AXIS_SCALE=2.0/3.0;\nif (bandsDirection==TEX_WAVE_BANDS_DIR_X){\nwaveVec=waveVec.xxx*BANDS_AXIS_SCALE;\n} else if (bandsDirection==TEX_WAVE_BANDS_DIR_Y){\nwaveVec=waveVec.yyy*BANDS_AXIS_SCALE;\n} else if (bandsDirection==TEX_WAVE_BANDS_DIR_Z){\nwaveVec=waveVec.zzz*BANDS_AXIS_SCALE;\n} else if (bandsDirection==TEX_WAVE_BANDS_DIR_DIAGONAL){\n}\nwaveFac=(waveVec.x+waveVec.y+waveVec.z)*10.0;\n} else {\nif (ringsDirection==TEX_WAVE_RINGS_DIR_X){\nwaveVec.x=0.0;\n} else if (ringsDirection==TEX_WAVE_RINGS_DIR_Y){\nwaveVec.y=0.0;\n} else if (ringsDirection==TEX_WAVE_RINGS_DIR_Z){\nwaveVec.z=0.0;\n} else if (ringsDirection==TEX_WAVE_RINGS_DIR_SPHERICAL){\n}\nwaveFac=length(waveVec)*20.0;\n}\nif (distortion != 0.0){\nwaveFac+=distortion*noiseTurbulence(coScaled*detailScale,detail,0.0,0.0,1.0);\n}\nif (waveProfile==TEX_WAVE_PROFILE_SIN){\nwaveFac=0.5+0.5*sin(waveFac-PI_HALF+phaseOffset);\n} else if (waveProfile==TEX_WAVE_PROFILE_SAW){\nwaveFac=fract((waveFac+phaseOffset+1e-4)/PI2);\n} else if (waveProfile==TEX_WAVE_PROFILE_TRI){\nwaveFac=abs(2.0*fract((waveFac+PI+phaseOffset)/PI2)-1.0);\n}\noutColor=vec4(waveFac,waveFac,waveFac,1.0);\noutFac=waveFac;\n}",node_tex_white_noise_bl_frag:"#if __VERSION__==300\nvoid node_tex_white_noise_1d(vec3 vector,float w,out float outValue,out vec4 outColor)\n{\noutValue=hashFloatToFloat(w);\noutColor=vec4(hashFloatToVec3(w),1.0);\n}\nvoid node_tex_white_noise_2d(vec3 vector,float w,out float outValue,out vec4 outColor)\n{\noutValue=hashVec2ToFloat(vector.xy);\noutColor=vec4(hashVec2ToVec3(vector.xy),1.0);\n}\nvoid node_tex_white_noise_3d(vec3 vector,float w,out float outValue,out vec4 outColor)\n{\noutValue=hashVec3ToFloat(vector);\noutColor=vec4(hashVec3ToVec3(vector),1.0);\n}\nvoid node_tex_white_noise_4d(vec3 vector,float w,out float outValue,out vec4 outColor)\n{\noutValue=hashVec4ToFloat(vec4(vector,w));\noutColor=vec4(hashVec4ToVec3(vec4(vector,w)),1.0);\n}\n#else\nvoid node_tex_white_noise_1d(vec3 vector,float w,out float outValue,out vec4 outColor)\n{\noutValue=0.0;\noutColor=vec4(0.0);\n}\nvoid node_tex_white_noise_2d(vec3 vector,float w,out float outValue,out vec4 outColor)\n{\noutValue=0.0;\noutColor=vec4(0.0);\n}\nvoid node_tex_white_noise_3d(vec3 vector,float w,out float outValue,out vec4 outColor)\n{\noutValue=0.0;\noutColor=vec4(0.0);\n}\nvoid node_tex_white_noise_4d(vec3 vector,float w,out float outValue,out vec4 outColor)\n{\noutValue=0.0;\noutColor=vec4(0.0);\n}\n#endif",node_uvmap_bl_frag:"void node_uvmap(vec2 uv,out vec3 outUV){\n#if WORLD_NODES==1\noutUV=vec3(0.0);\n#else\nuv.y=1.0-uv.y;\noutUV=vec3(uv,0.0);\n#endif\n}",node_valtorgb_bl_frag:"void node_valtorgb(sampler2D colormap,float fac,out vec4 colOut,out float alphaOut)\n{\ncolOut=texture2D(colormap,vec2(fac,0.0));\nalphaOut=colOut.a;\n}",node_value_bl_frag:"uniform float nodeValue[NODE_VALUE_NUM];\nvoid node_value(float value,out float outValue)\n{\noutValue=value;\n}",node_vect_math_bl_frag:"void node_vect_math_add(vec3 v1,vec3 v2,vec3 v3,float val,out vec3 outVec,out float outVal){\noutVec=v1+v2;\n}\nvoid node_vect_math_subtract(vec3 v1,vec3 v2,vec3 v3,float val,out vec3 outVec,out float outVal){\noutVec=v1-v2;\n}\nvoid node_vect_math_multiply(vec3 v1,vec3 v2,vec3 v3,float val,out vec3 outVec,out float outVal){\noutVec=v1*v2;\n}\nvoid node_vect_math_divide(vec3 v1,vec3 v2,vec3 v3,float val,out vec3 outVec,out float outVal){\noutVec.x=v2.x==0.0?0.0:v1.x/v2.x;\noutVec.y=v2.y==0.0?0.0:v1.y/v2.y;\noutVec.z=v2.z==0.0?0.0:v1.z/v2.z;\n}\nvoid node_vect_math_cross_product(vec3 v1,vec3 v2,vec3 v3,float val,out vec3 outVec,out float outVal){\noutVec=cross(v1,v2);\n}\nvoid node_vect_math_project(vec3 v1,vec3 v2,vec3 v3,float val,out vec3 outVec,out float outVal){\nfloat d=dot(v2,v2);\noutVec=(d != 0.0)?(dot(v1,v2)/d)*v2:vec3(0.0);\n}\nvoid node_vect_math_reflect(vec3 v1,vec3 v2,vec3 v3,float val,out vec3 outVec,out float outVal){\nif (v2 != vec3(0.0)){\nv2=normalize(v2);\n}\noutVec=reflect(v1,v2);\n}\nvoid node_vect_math_dot_product(vec3 v1,vec3 v2,vec3 v3,float val,out vec3 outVec,out float outVal){\noutVal=dot(v1,v2);\n}\nvoid node_vect_math_distance(vec3 v1,vec3 v2,vec3 v3,float val,out vec3 outVec,out float outVal){\noutVal=distance(v1,v2);\n}\nvoid node_vect_math_length(vec3 v1,vec3 v2,vec3 v3,float val,out vec3 outVec,out float outVal){\noutVal=length(v1);\n}\nvoid node_vect_math_scale(vec3 v1,vec3 v2,vec3 v3,float val,out vec3 outVec,out float outVal){\noutVec=v1*val;\n}\nvoid node_vect_math_normalize(vec3 v1,vec3 v2,vec3 v3,float val,out vec3 outVec,out float outVal){\nif (v1 != vec3(0.0)){\nv1=normalize(v1);\n}\noutVec=v1;\n}\nvoid node_vect_math_snap(vec3 v1,vec3 v2,vec3 v3,float val,out vec3 outVec,out float outVal){\noutVec.x=v2.x==0.0?0.0:floor(v1.x/v2.x)*v2.x;\noutVec.y=v2.y==0.0?0.0:floor(v1.y/v2.y)*v2.y;\noutVec.z=v2.z==0.0?0.0:floor(v1.z/v2.z)*v2.z;\n}\nvoid node_vect_math_floor(vec3 v1,vec3 v2,vec3 v3,float val,out vec3 outVec,out float outVal){\noutVec=floor(v1);\n}\nvoid node_vect_math_ceil(vec3 v1,vec3 v2,vec3 v3,float val,out vec3 outVec,out float outVal){\noutVec=ceil(v1);\n}\nvoid node_vect_math_modulo(vec3 v1,vec3 v2,vec3 v3,float val,out vec3 outVec,out float outVal){\nvec3 signProduct=sign(v1)*sign(v2);\nv1+=1e-5*signProduct;\noutVec.x=signProduct.x>0.0?mod(v1.x,abs(v2.x)):0.0;\noutVec.y=signProduct.y>0.0?mod(v1.y,abs(v2.y)):0.0;\noutVec.z=signProduct.z>0.0?mod(v1.z,abs(v2.z)):0.0;\n}\nvoid node_vect_math_fraction(vec3 v1,vec3 v2,vec3 v3,float val,out vec3 outVec,out float outVal){\noutVec=fract(v1);\n}\nvoid node_vect_math_absolute(vec3 v1,vec3 v2,vec3 v3,float val,out vec3 outVec,out float outVal){\noutVec=abs(v1);\n}\nvoid node_vect_math_power(vec3 v1,vec3 v2,vec3 v3,float val,out vec3 outVec,out float outVal){\noutVec=vec3(powCompat(v1.x,v2.x),powCompat(v1.y,v2.y),powCompat(v1.z,v2.z));\n}\nvoid node_vect_math_sign(vec3 v1,vec3 v2,vec3 v3,float val,out vec3 outVec,out float outVal){\noutVec=sign(v1);\n}\nvoid node_vect_math_minimum(vec3 v1,vec3 v2,vec3 v3,float val,out vec3 outVec,out float outVal){\noutVec=min(v1,v2);\n}\nvoid node_vect_math_maximum(vec3 v1,vec3 v2,vec3 v3,float val,out vec3 outVec,out float outVal){\noutVec=max(v1,v2);\n}\nvoid node_vect_math_cosine(vec3 v1,vec3 v2,vec3 v3,float val,out vec3 outVec,out float outVal){\noutVec=cos(v1);\n}\nvoid node_vect_math_sine(vec3 v1,vec3 v2,vec3 v3,float val,out vec3 outVec,out float outVal){\noutVec=sin(v1);\n}\nvoid node_vect_math_tangent(vec3 v1,vec3 v2,vec3 v3,float val,out vec3 outVec,out float outVal){\noutVec=tan(v1);\n}\nvoid node_vect_math_wrap(vec3 v1,vec3 v2,vec3 v3,float val,out vec3 outVec,out float outVal){\nv1+=1e-5;\noutVec.x=v2.x==v3.x?v2.x:mod(v1.x-v3.x,v2.x-v3.x)+v3.x;\noutVec.y=v2.y==v3.y?v2.y:mod(v1.y-v3.y,v2.y-v3.y)+v3.y;\noutVec.z=v2.z==v3.z?v2.z:mod(v1.z-v3.z,v2.z-v3.z)+v3.z;\n}\nvoid node_vect_math_faceforward(vec3 v1,vec3 v2,vec3 v3,float val,out vec3 outVec,out float outVal){\noutVec=dot(v2,v3)<0.0?v1:-v1;\n}\nvoid node_vect_math_multiply_add(vec3 v1,vec3 v2,vec3 v3,float val,out vec3 outVec,out float outVal){\noutVec=v1*v2+v3;\n}\nvoid node_vect_math_refract(vec3 v1,vec3 v2,vec3 v3,float val,out vec3 outVec,out float outVal){\nif (v2 != vec3(0.0)){\nv2=normalize(v2);\n}\noutVec=refract(v1,v2,val);\n}",node_vect_transform_bl_frag:"#define VEC_TRANS_NONE 0\n#define VEC_TRANS_W_O 1\n#define VEC_TRANS_W_C 2\n#define VEC_TRANS_O_W 3\n#define VEC_TRANS_O_C 4\n#define VEC_TRANS_C_W 5\n#define VEC_TRANS_C_O 6\n#define VEC_TRANS_W_O_DIR 7\n#define VEC_TRANS_W_C_DIR 8\n#define VEC_TRANS_O_W_DIR 9\n#define VEC_TRANS_O_C_DIR 10\n#define VEC_TRANS_C_W_DIR 11\n#define VEC_TRANS_C_O_DIR 12\nvoid node_vect_transform(const int vecTransType,const bool invCamZ,vec3 vIn,out vec3 vOut)\n{\nif (vecTransType==VEC_TRANS_NONE)\nvOut=vIn;\nelse {\nvec4 vec;\nif (vecTransType<VEC_TRANS_W_O_DIR)\nvec=vec4(vIn.xyz,1.0);\nelse\nvec=vec4(vIn.xyz,0.0);\nif (vecTransType==VEC_TRANS_W_O||vecTransType==VEC_TRANS_W_O_DIR){\nvec=vec4(vec.x,vec.z,-vec.y,vec.w);\nvec=invModelMatrix*vec;\nvec=vec4(vec.x,-vec.z,vec.y,vec.w);\n} else if (vecTransType==VEC_TRANS_W_C||vecTransType==VEC_TRANS_W_C_DIR){\nvec=vec4(vec.x,vec.z,-vec.y,vec.w);\nvec=viewMatrix*vec;\nif (invCamZ)\nvec[2]=-vec[2];\n} else if (vecTransType==VEC_TRANS_O_W||vecTransType==VEC_TRANS_O_W_DIR){\nvec=vec4(vec.x,vec.z,-vec.y,vec.w);\nvec=modelMatrix*vec;\nvec=vec4(vec.x,-vec.z,vec.y,vec.w);\n} else if (vecTransType==VEC_TRANS_O_C||vecTransType==VEC_TRANS_O_C_DIR){\nvec=vec4(vec.x,vec.z,-vec.y,vec.w);\nvec=modelViewMatrix*vec;\nif (invCamZ)\nvec[2]=-vec[2];\n} else if (vecTransType==VEC_TRANS_C_W||vecTransType==VEC_TRANS_C_W_DIR){\nif (invCamZ)\nvec[2]=-vec[2];\nvec=invViewMatrix*vec;\nvec=vec4(vec.x,-vec.z,vec.y,vec.w);\n} else if (vecTransType==VEC_TRANS_C_O||vecTransType==VEC_TRANS_C_O_DIR){\nif (invCamZ)\nvec[2]=-vec[2];\nvec=invModelMatrix*invViewMatrix*vec;\nvec=vec4(vec.x,-vec.z,vec.y,vec.w);\n}\nvOut=vec.xyz;\n}\n}",node_vector_displacement_bl_frag:"void node_vector_displacement(vec4 vector,float midLevel,float scale,out vec3 displacement){\ndisplacement=vec3(0.0);\n}",node_vector_rotate_bl_frag:"void node_vector_rotate_axis_angle(float invert,vec3 vector,vec3 center,vec3 axis,float angle,vec3 rotation,out vec3 outVector){\nif (length(axis)>0.0){\nvector-=center;\noutVector=vec3RotateAxisAngle(vector,axis,invert*angle);\noutVector+=center;\n} else {\noutVector=vector;\n}\n}\nvoid node_vector_rotate_euler_xyz(float invert,vec3 vector,vec3 center,vec3 axis,float angle,vec3 rotation,out vec3 outVector){\nvec4 axisAngle=eulerToAxisAngle(rotation);\nvector-=center;\noutVector=vec3RotateAxisAngle(vector,axisAngle.xyz,invert*axisAngle.w);\noutVector+=center;\n}\nvoid node_vector_rotate_x_axis(float invert,vec3 vector,vec3 center,vec3 axis,float angle,vec3 rotation,out vec3 outVector){\nvector-=center;\noutVector=vec3RotateXAngle(vector,invert*angle);\noutVector+=center;\n}\nvoid node_vector_rotate_y_axis(float invert,vec3 vector,vec3 center,vec3 axis,float angle,vec3 rotation,out vec3 outVector){\nvector-=center;\noutVector=vec3RotateYAngle(vector,invert*angle);\noutVector+=center;\n}\nvoid node_vector_rotate_z_axis(float invert,vec3 vector,vec3 center,vec3 axis,float angle,vec3 rotation,out vec3 outVector){\nvector-=center;\noutVector=vec3RotateZAngle(vector,invert*angle);\noutVector+=center;\n}",node_vertex_color_bl_frag:"void node_vertex_color(vec4 color,out vec4 outColor,out float outAlpha){\noutColor=color;\noutAlpha=color.a;\n}",node_volume_absorption_bl_frag:"void node_volume_absorption(vec4 color,float density,out vec4 outColor)\n{\noutColor=color;\n}",node_volume_coefficients_bl_frag:"void node_volume_coefficients(vec3 absorptionCoefficients,vec3 scatterCoefficients,float anisotropy,float IOR,float backscatter,float alpha,float Diameter,vec3 emissionCoefficients,out vec4 outColor){\noutColor=vec4(0.0,0.0,0.0,1.0);\n}",node_volume_info_bl_frag:"void node_volume_info(out vec4 color,out float density,out float flame,out float temperature){\ncolor=vec4(vec3(0.0),1.0);\ndensity=0.0;\nflame=0.0;\ntemperature=0.0;\n}",node_volume_scatter_bl_frag:"void node_volume_scatter(vec4 color,float density,float anisotropy,float ior,float backscatter,float alpha,float diameter,out vec4 outColor)\n{\noutColor=vec4(color);\n}\nvoid node_volume_scatter(vec4 color,float density,float anisotropy,out vec4 outColor)\n{\noutColor=vec4(color);\n}",node_wavelength_bl_frag:"void node_wavelength(float wavelength,out vec4 outColor)\n{\noutColor=vec4(0.0,0.0,0.0,1.0);\n#if __VERSION__==300\nvec3 xyz=vec3(0.0);\nfloat ii=(wavelength-380.0)/5.0;\nint i=int(ii);\nif (i<0||i>=80){\nreturn;\n}\nii-=float(i);\nvec3 c1=cieColorMatch[i];\nvec3 c2=cieColorMatch[i+1];\nxyz=mix(c1,c2,ii);\noutColor=vec4(xyz_to_sRGB(xyz),1.0);\n#endif\n}",node_wireframe_bl_frag:"void node_wireframe(float size,out float outFac)\n{\noutFac=0.0;\n}",node_bitmap_none_mx_frag:"void node_bitmap_none(out vec4 color)\n{\ncolor=vec4(1.0);\n}",node_bitmap_env_mx_frag:"void node_bitmap_env(sampler2D envMap,int reflectMode,float IOR,const int encoding,const bool alphaAsMono,const bool alphaAsRGB,float uOffset,float vOffset,float uTiling,float vTiling,float wAngle,vec3 normal,out vec4 color,out float value)\n{\nvec3 cameraToVertex=normalize(vWorldPosition-cameraPosition);\nvec3 worldNormal=inverseTransformDirection(normal,viewMatrix);\nvec3 reflectVec;\n#if WORLD_NODES\nreflectVec=normalize(cameraToVertex);\n#else\nif (reflectMode==MAX_ENV_COORDS_REFLECT)\nreflectVec=reflect(cameraToVertex,worldNormal);\nelse {\nfloat refrRatio=1.0/IOR;\nreflectVec=refract(cameraToVertex,worldNormal,refrRatio);\n}\n#endif\nmat3 uvTransform=calcUvTransform(uOffset,vOffset,uTiling,vTiling,wAngle);\ncolor=sampleEquirectangular(envMap,reflectVec,uvTransform,encoding);\nif (alphaAsMono)\nvalue=color.a;\nelse\nvalue=average(color.rgb);\nif (alphaAsRGB)\ncolor=vec4(color.a);\n}",node_bitmap_mx_frag:"void node_bitmap(sampler2D map,const vec2 uvIn,const int mapping,const int axis,const ivec2 clampToEdgeNoExtend,const int encoding,const bool alphaAsMono,const bool alphaAsRGB,float uOffset,float vOffset,float uTiling,float vTiling,float wAngle,out vec4 color,out float value)\n{\nvec3 coordsIn;\nif (mapping==MAPPING_EXPLICIT_MAP_CHANNEL){\ncoordsIn=vec3(uvIn.x,1.0-uvIn.y,0.0);\n} else if (mapping==MAPPING_VERTEX_COLOR_CHANNEL){\ncoordsIn=vec3(0.0);\n} else if (mapping==MAPPING_PLANAR_OBJECT_XYZ){\ncoordsIn=swizzleUpZ((invModelMatrix*invViewMatrix*vec4(-vViewPosition,1.0)).xyz);\n} else {\ncoordsIn=swizzleUpZ((invViewMatrix*vec4(-vViewPosition,1.0)).xyz);\n}\nif (axis==AXIS_XY)\ncoordsIn=vec3(coordsIn.x,coordsIn.y,1.0);\nelse if (axis==AXIS_YZ)\ncoordsIn=vec3(coordsIn.y,coordsIn.z,1.0);\nelse if (axis==AXIS_ZX)\ncoordsIn=vec3(coordsIn.z,coordsIn.x,1.0);\nvec3 coordsOut=calcUvTransform(uOffset,vOffset,uTiling,vTiling,wAngle)*coordsIn;\nvec2 uv=vec2(coordsOut.x,1.0-coordsOut.y);\nif ((clampToEdgeNoExtend[0]==1&&(uvIn.x<0.0||uvIn.x>1.0))||\n(clampToEdgeNoExtend[1]==1&&(uvIn.y<0.0||uvIn.y>1.0))){\ncolor=vec4(0.0,0.0,0.0,1.0);\n} else {\ncolor=texture2D(map,uv);\ncolor=nodeTexelToLinear(color,encoding);\n}\nif (alphaAsMono)\nvalue=color.a;\nelse\nvalue=average(color.rgb);\nif (alphaAsRGB)\ncolor=vec4(color.a);\n}",node_bump_mx_frag:"void node_bump(sampler2D bumpMap,const vec3 eyePos,const vec3 normal,const vec2 uvIn,float uOffset,float vOffset,float uTiling,float vTiling,float wAngle,out vec3 normalOut)\n{\nvec3 coordsIn;\ncoordsIn=vec3(uvIn.x,1.0-uvIn.y,1.0);\nvec3 coordsOut=calcUvTransform(uOffset,vOffset,uTiling,vTiling,wAngle)*coordsIn;\nvec2 uv=vec2(coordsOut.x,1.0-coordsOut.y);\nvec2 dSTdx=dFdx(uv);\nvec2 dSTdy=dFdy(uv);\nif (any(equal(dSTdx,vec2(0.0)))||any(equal(dSTdy,vec2(0.0)))){\nnormalOut=normal;\n} else {\nconst float bumpScale=1.0;\nvec3 vSigmaX=vec3(dFdx(eyePos.x),dFdx(eyePos.y),dFdx(eyePos.z));\nvec3 vSigmaY=vec3(dFdy(eyePos.x),dFdy(eyePos.y),dFdy(eyePos.z));\nvec3 vN=normal;\nvec3 R1=cross(vSigmaY,vN);\nvec3 R2=cross(vN,vSigmaX);\nfloat fDet=dot(vSigmaX,R1);\nfloat Hll=bumpScale*texture2D(bumpMap,uv).x;\nfloat dBx=bumpScale*texture2D(bumpMap,uv+dSTdx).x-Hll;\nfloat dBy=bumpScale*texture2D(bumpMap,uv+dSTdy).x-Hll;\nvec2 dHdxy=vec2(dBx,dBy);\nvec3 vGrad=sign(fDet)*(dHdxy.x*R1+dHdxy.y*R2);\nnormalOut=normalize(abs(fDet)*normal-vGrad);\n}\n}",node_blend_mx_frag:"void node_blend(const bool useCurve,const float curveLower,const float curveUpper,const vec4 color1,const vec4 color2,float mask,out vec4 color)\n{\nif (useCurve)\nmask=smoothstep(curveLower,curveUpper,mask);\nelse\nmask=clamp(mask,0.0,1.0);\ncolor=mix(color1,color2,mask);\n}",node_color_correction_mx_frag:"#define REWIRE_RED 0\n#define REWIRE_GREEN 1\n#define REWIRE_BLUE 2\n#define REWIRE_ALPHA 3\n#define REWIRE_RED_INV 4\n#define REWIRE_GREEN_INV 5\n#define REWIRE_BLUE_INV 6\n#define REWIRE_ALPHA_INV 7\n#define REWIRE_MONOCHROME 8\n#define REWIRE_ONE 9\n#define REWIRE_ZERO 10\nfloat rewireChannel(int type,vec4 color)\n{\nif (type==REWIRE_RED)\nreturn color.r;\nelse if (type==REWIRE_GREEN)\nreturn color.g;\nelse if (type==REWIRE_BLUE)\nreturn color.b;\nelse if (type==REWIRE_ALPHA)\nreturn color.a;\nelse if (type==REWIRE_RED_INV)\nreturn 1.0-color.r;\nelse if (type==REWIRE_GREEN_INV)\nreturn 1.0-color.g;\nelse if (type==REWIRE_BLUE_INV)\nreturn 1.0-color.b;\nelse if (type==REWIRE_ALPHA_INV)\nreturn 1.0-color.a;\nelse if (type==REWIRE_MONOCHROME)\nreturn average(color.rgb);\nelse if (type==REWIRE_ONE)\nreturn 1.0;\nelse\nreturn 0.0;\n}\nvec3 gainPivotGammaLift(vec3 color,float gain,float pivot,float gamma,float lift,int exposureMode,float printerLights)\n{\ngain=gain/100.0;\nif (exposureMode==0){\ncolor=color*gain/pivot;\n} else if (exposureMode==1){\ncolor=color*pow(2.0,gain)/pivot;\n} else {\ncolor=color*pow(printerLights,gain)/pivot;\n}\nvec3 tmp=pivot*pow(color,vec3(1.0/gamma));\nreturn step(0.00001,color)*tmp+lift;\n}\nfloat gainPivotGammaLift(float value,float gain,float pivot,float gamma,float lift,int exposureMode,float printerLights)\n{\ngain=gain/100.0;\nif (exposureMode==0){\nvalue=value*gain/pivot;\n} else if (exposureMode==1){\nvalue=value*pow(2.0,gain)/pivot;\n} else {\nvalue=value*pow(printerLights,gain)/pivot;\n}\nfloat tmp=pivot*pow(value,1.0/gamma);\nreturn step(0.00001,value)*tmp+lift;\n}\nvoid node_color_correction(const ivec4 rewire,const vec4 color,const float hueShift,const float saturation,const vec4 tint,const float tintStrength,const float brightness,const float contrast,out vec4 outColor)\n{\nif (all(equal(rewire,ivec4(REWIRE_RED,REWIRE_GREEN,REWIRE_BLUE,REWIRE_ALPHA)))){\noutColor=color;\n} else {\noutColor.r=rewireChannel(rewire.x,color);\noutColor.g=rewireChannel(rewire.y,color);\noutColor.b=rewireChannel(rewire.z,color);\noutColor.a=rewireChannel(rewire.w,color);\n}\nvec4 hsv;\nrgbToHSV(outColor,hsv);\nhsv[0]+=hueShift/360.0;\nif (hsv[0]>1.0)\nhsv[0]-=1.0;\nelse if (hsv[0]<0.0)\nhsv[0]+=1.0;\nhsv[1]*=(saturation/100.0+1.0);\nhsv[1]=saturate(hsv[1]);\nif (tintStrength>0.0){\nvec4 hsvTint;\nrgbToHSV(tint,hsvTint);\nhsv[0]=hsv[0]+(hsvTint[0]-hsv[0])*tintStrength/100.0;\n}\nhsvToRGB(hsv,outColor);\noutColor=(outColor-0.5)*(contrast/100.0+1.0)+0.5+brightness/100.0;\noutColor=max(outColor,0.0);\n}\nvoid node_color_correction(const ivec4 rewire,const mat4 params,bool enableR,bool enableG,bool enableB,int exposureMode,float printerLights,const vec4 color,const float hueShift,const float saturation,const vec4 tint,const float tintStrength,out vec4 outColor)\n{\nif (all(equal(rewire,ivec4(REWIRE_RED,REWIRE_GREEN,REWIRE_BLUE,REWIRE_ALPHA)))){\noutColor=color;\n} else {\noutColor.r=rewireChannel(rewire.x,color);\noutColor.g=rewireChannel(rewire.y,color);\noutColor.b=rewireChannel(rewire.z,color);\noutColor.a=rewireChannel(rewire.w,color);\n}\nvec4 hsv;\nrgbToHSV(outColor,hsv);\nhsv[0]+=hueShift/360.0;\nif (hsv[0]>1.0)\nhsv[0]-=1.0;\nelse if (hsv[0]<0.0)\nhsv[0]+=1.0;\nhsv[1]*=(saturation/100.0+1.0);\nhsv[1]=saturate(hsv[1]);\nif (tintStrength>0.0){\nvec4 hsvTint;\nrgbToHSV(tint,hsvTint);\nhsv[0]=hsv[0]+(hsvTint[0]-hsv[0])*tintStrength/100.0;\n}\nhsvToRGB(hsv,outColor);\noutColor.rgb=gainPivotGammaLift(outColor.rgb,params[0][0],params[0][1],params[0][2],params[0][3],exposureMode,printerLights);\nif (enableR)\noutColor.r=gainPivotGammaLift(outColor.r,params[1][0],params[1][1],params[1][2],params[1][3],exposureMode,printerLights);\nif (enableG)\noutColor.g=gainPivotGammaLift(outColor.g,params[2][0],params[2][1],params[2][2],params[2][3],exposureMode,printerLights);\nif (enableB)\noutColor.b=gainPivotGammaLift(outColor.b,params[3][0],params[3][1],params[3][2],params[3][3],exposureMode,printerLights);\noutColor=max(outColor,0.0);\n}",node_color_map_mx_frag:"void node_color_map(const bool reverseGamma,const vec4 color,const float gamma,const float gain,out vec4 outColor)\n{\nfloat p=reverseGamma?gamma:1.0/gamma;\nfloat g=reverseGamma?(gain>EPSILON?1.0/gain:1.0):gain;\noutColor=vec4(g*pow(abs(color.rgb),vec3(p)),color.a);\n}",node_composite_layer_mx_frag:"#define COMP_BLEND_NORMAL 0\n#define COMP_BLEND_AVERAGE 1\n#define COMP_BLEND_ADD 2\n#define COMP_BLEND_SUBTRACT 3\n#define COMP_BLEND_DARKEN 4\n#define COMP_BLEND_MULTIPLY 5\n#define COMP_BLEND_COLORBURN 6\n#define COMP_BLEND_LINEARBURN 7\n#define COMP_BLEND_LIGHTEN 8\n#define COMP_BLEND_SCREEN 9\n#define COMP_BLEND_COLORDODGE 10\n#define COMP_BLEND_LINEARDODGE 11\n#define COMP_BLEND_SPOT 12\n#define COMP_BLEND_SPOTBLEND 13\n#define COMP_BLEND_OVERLAY 14\n#define COMP_BLEND_SOFTLIGHT 15\n#define COMP_BLEND_HARDLIGHT 16\n#define COMP_BLEND_PINLIGHT 17\n#define COMP_BLEND_HARDMIX 18\n#define COMP_BLEND_DIFFERENCE 19\n#define COMP_BLEND_EXCLUSION 20\n#define COMP_BLEND_HUE 21\n#define COMP_BLEND_SATURATION 22\n#define COMP_BLEND_COLOR 23\n#define COMP_BLEND_VALUE 24\nvec4 calcBlending(const vec4 colorBG,const vec4 colorFG,const int blendMode){\nif (blendMode==COMP_BLEND_NORMAL)\nreturn colorFG;\nelse if (blendMode==COMP_BLEND_AVERAGE)\nreturn (colorFG+colorBG)/2.0;\nelse if (blendMode==COMP_BLEND_ADD)\nreturn colorBG+colorFG;\nelse if (blendMode==COMP_BLEND_SUBTRACT)\nreturn colorBG-colorFG;\nelse if (blendMode==COMP_BLEND_DARKEN)\nreturn min(colorFG,colorBG);\nelse if (blendMode==COMP_BLEND_MULTIPLY)\nreturn colorBG*colorFG;\nelse if (blendMode==COMP_BLEND_COLORBURN){\nif (colorFG.r==0.0&&colorFG.g==0.0&&colorFG.b==0.0)\nreturn vec4(0.0,0.0,0.0,1.0);\nelse\nreturn max(1.0-(1.0-colorBG)/colorFG,0.0);\n} else if (blendMode==COMP_BLEND_LINEARBURN)\nreturn max(colorFG+colorBG-1.0,0.0);\nelse if (blendMode==COMP_BLEND_LIGHTEN)\nreturn max(colorFG,colorBG);\nelse if (blendMode==COMP_BLEND_SCREEN)\nreturn colorFG+colorBG-colorFG*colorBG;\nelse if (blendMode==COMP_BLEND_COLORDODGE){\nif (colorFG.r==1.0&&colorFG.g==1.0&&colorFG.b==1.0)\nreturn vec4(1.0);\nelse\nreturn min(colorBG/(1.0-colorFG),1.0);\n} else if (blendMode==COMP_BLEND_LINEARDODGE)\nreturn min(colorFG+colorBG,1.0);\nelse if (blendMode==COMP_BLEND_SPOT)\nreturn min(2.0*colorFG*colorBG,1.0);\nelse if (blendMode==COMP_BLEND_SPOTBLEND)\nreturn min(colorFG*colorBG+colorBG,1.0);\nelse if (blendMode==COMP_BLEND_OVERLAY){\nif (colorBG.r<=0.5&&colorBG.g<=0.5&&colorBG.b<=0.5)\nreturn saturate(2.0*colorFG*colorBG);\nelse\nreturn saturate(1.0-2.0*(1.0-colorFG)*(1.0-colorBG));\n} else if (blendMode==COMP_BLEND_SOFTLIGHT){\nif (colorFG.r<=0.5&&colorFG.g<=0.5&&colorFG.b<=0.5)\nreturn saturate(colorBG*(colorBG+2.0*colorFG*(1.0-colorBG)));\nelse\nreturn saturate(colorBG+(2.0*colorFG-1.0)*(sqrt(colorBG)-colorBG));\n} else if (blendMode==COMP_BLEND_HARDLIGHT){\nif (colorFG.r<=0.5&&colorFG.g<=0.5&&colorFG.b<=0.5)\nreturn saturate(2.0*colorFG*colorBG);\nelse\nreturn saturate(1.0-2.0*(1.0-colorFG)*(1.0-colorBG));\n} else if (blendMode==COMP_BLEND_PINLIGHT){\nif (((colorFG.r>0.5&&colorFG.g>0.5&&colorFG.b>0.5)&&all(greaterThan(colorFG,colorBG)))||\n((colorFG.r<=0.5&&colorFG.g<=0.5&&colorFG.b<=0.5)&&all(lessThan(colorFG,colorBG))))\nreturn colorFG;\nelse\nreturn colorBG;\n} else if (blendMode==COMP_BLEND_HARDMIX){\nif (colorFG.r+colorBG.r<=1.0&&colorFG.g+colorBG.g<=1.0&&colorFG.b+colorBG.b<=1.0)\nreturn vec4(0.0,0.0,0.0,1.0);\nelse\nreturn vec4(1.0);\n} else if (blendMode==COMP_BLEND_DIFFERENCE)\nreturn abs(colorFG-colorBG);\nelse if (blendMode==COMP_BLEND_EXCLUSION)\nreturn colorFG+colorBG-2.0*colorFG*colorBG;\n}\nvec4 calcBlendingHSV(const vec4 colorBG,const vec4 colorFG,const int blendMode)\n{\nvec4 hsvBG,hsvFG;\nvec4 outColor;\nif (blendMode==COMP_BLEND_HUE){\nrgbToHSV(colorBG,hsvBG);\nrgbToHSV(colorFG,hsvFG);\nhsvToRGB(vec4(hsvFG[0],hsvBG[1],hsvBG[2],1.0),outColor);\n} else if (blendMode==COMP_BLEND_SATURATION){\nrgbToHSV(colorBG,hsvBG);\nrgbToHSV(colorFG,hsvFG);\nhsvToRGB(vec4(hsvBG[0],hsvFG[1],hsvBG[2],1.0),outColor);\n} else if (blendMode==COMP_BLEND_COLOR){\nrgbToHSV(colorBG,hsvBG);\nrgbToHSV(colorFG,hsvFG);\nhsvToRGB(vec4(hsvFG[0],hsvFG[1],hsvBG[2],1.0),outColor);\n} else if (blendMode==COMP_BLEND_VALUE){\nrgbToHSV(colorBG,hsvBG);\nrgbToHSV(colorFG,hsvFG);\nhsvToRGB(vec4(hsvBG[0],hsvBG[1],hsvFG[2],1.0),outColor);\n}\nreturn outColor;\n}\nvoid node_composite_layer(const int blendMode,const float opacity,const vec4 colorBG,const vec4 colorFG,const vec4 mask,out vec4 outColor)\n{\nfloat fac=saturate(opacity*average(mask.rgb));\nif (blendMode<COMP_BLEND_HUE)\noutColor=calcBlending(colorBG,colorFG,blendMode);\nelse\noutColor=calcBlendingHSV(colorBG,colorFG,blendMode);\noutColor=mix(colorBG,outColor,fac);\n}",node_falloff_mx_frag:"#define FALLOFF_TYPE_TOWARDS_AWAY 0\n#define FALLOFF_TYPE_PERP_PARALL 1\n#define FALLOFF_TYPE_FRESHNEL 2\n#define FALLOFF_TYPE_SHADOW_LIGHT 3\n#define FALLOFF_TYPE_DIST_BLEND 4\nvoid node_falloff(const vec3 viewPos,const float IOR,const int falloffType,const vec4 color1,const vec4 color2,const vec3 normal,out vec4 color)\n{\nvec3 dir=normalize(viewPos);\nfloat fac;\nif (falloffType==FALLOFF_TYPE_TOWARDS_AWAY){\nfac=1.0-(0.5*(abs(dot(dir,normal))+1.0));\n} else if (falloffType==FALLOFF_TYPE_PERP_PARALL){\nfac=1.0-abs(dot(dir,normal));\n} else if (falloffType==FALLOFF_TYPE_FRESHNEL){\nfloat eta=max(IOR,0.00001);\nfac=fresnelReflection(dir,normal,(gl_FrontFacing)?eta:1.0/eta);\n} else {\nfac=0.0;\n}\ncolor=mix(color1,color2,fac);\n}\nvoid node_falloff(const vec3 viewPos,bool extrapolateOn,float nearDistance,float farDistance,const vec4 color1,const vec4 color2,const vec3 normal,out vec4 color)\n{\nfloat dist=length(viewPos);\nfloat fac;\nif (!extrapolateOn&&dist<=nearDistance){\nfac=1.0;\n} else if (!extrapolateOn&&dist>farDistance){\nfac=0.0;\n} else {\nfac=((farDistance-nearDistance)!= 0.0)?((farDistance-dist)/(farDistance-nearDistance)):10000.0;\n}\ncolor=mix(color1,color2,fac);\n}",node_gradient_mx_frag:"#define GRAD_TYPE_LINEAR 0\n#define GRAD_TYPE_RADIAL 1\nvoid node_gradient(float color2Pos,int gradientType,vec2 uvIn,vec3 viewPos,int mapping,int axis,ivec2 clampToEdgeNoExtend,vec3 color1,vec3 color2,vec3 color3,float uOffset,float vOffset,float uTiling,float vTiling,float wAngle,out vec4 outCol)\n{\nvec3 coordsIn;\nif (mapping==MAPPING_EXPLICIT_MAP_CHANNEL){\ncoordsIn=vec3(uvIn.x,1.0-uvIn.y,0.0);\n} else if (mapping==MAPPING_VERTEX_COLOR_CHANNEL){\ncoordsIn=vec3(0.0);\n} else if (mapping==MAPPING_PLANAR_OBJECT_XYZ){\ncoordsIn=swizzleUpZ((invModelMatrix*invViewMatrix*vec4(-viewPos,1.0)).xyz);\n} else {\ncoordsIn=swizzleUpZ((invViewMatrix*vec4(-vViewPosition,1.0)).xyz);\n}\nif (axis==AXIS_XY)\ncoordsIn=vec3(coordsIn.x,coordsIn.y,1.0);\nelse if (axis==AXIS_YZ)\ncoordsIn=vec3(coordsIn.y,coordsIn.z,1.0);\nelse if (axis==AXIS_ZX)\ncoordsIn=vec3(coordsIn.z,coordsIn.x,1.0);\nvec3 coordsOut=calcUvTransform(uOffset,vOffset,uTiling,vTiling,wAngle)*coordsIn;\nfloat coord=uvIn.x;\nuvIn=coordsOut.xy;\nif ((clampToEdgeNoExtend[0]==1&&(uvIn.x<0.0||uvIn.x>1.0))||\n(clampToEdgeNoExtend[1]==1&&(uvIn.y<0.0||uvIn.y>1.0))){\noutCol=vec4(0.0,0.0,0.0,1.0);\nreturn;\n}\nuvIn=fract(uvIn);\nif (gradientType==GRAD_TYPE_LINEAR){\ncoord=uvIn.y;\n} else {\ncoord=length(uvIn-vec2(0.5))*2.0;\nif (coord>1.0)\ncoord=1.0;\n}\nif (coord<color2Pos){\ncoord=coord/color2Pos;\noutCol=vec4(color3*(1.0-coord)+color2*coord,1.0);\n} else if (coord>color2Pos){\ncoord=(coord-color2Pos)/(1.0-color2Pos);\noutCol=vec4(color2*(1.0-coord)+color1*coord,1.0);\n} else {\noutCol=vec4(color2,1.0);\n}\n}",node_gradient_ramp_mx_frag:"#define GRAD_TYPE_4_CORNER 0\n#define GRAD_TYPE_BOX 1\n#define GRAD_TYPE_DIAGONAL 2\n#define GRAD_TYPE_LIGHTING 3\n#define GRAD_TYPE_LINEAR 4\n#define GRAD_TYPE_MAPPED 5\n#define GRAD_TYPE_NORMAL 6\n#define GRAD_TYPE_PONG 7\n#define GRAD_TYPE_RADIAL 8\n#define GRAD_TYPE_SPIRAL 9\n#define GRAD_TYPE_SWEEP 10\n#define GRAD_TYPE_TARTAN 11\nvoid node_gradient_ramp(sampler2D gradientData,int gradientType,vec2 uvIn,vec3 geometryNormal,vec3 viewPos,int mapping,int axis,ivec2 clampToEdgeNoExtend,vec4 sourceMap,float uOffset,float vOffset,float uTiling,float vTiling,float wAngle,out vec4 outCol)\n{\nvec3 coordsIn;\nif (mapping==MAPPING_EXPLICIT_MAP_CHANNEL){\ncoordsIn=vec3(uvIn.x,1.0-uvIn.y,0.0);\n} else if (mapping==MAPPING_VERTEX_COLOR_CHANNEL){\ncoordsIn=vec3(0.0);\n} else if (mapping==MAPPING_PLANAR_OBJECT_XYZ){\ncoordsIn=swizzleUpZ((invModelMatrix*invViewMatrix*vec4(-viewPos,1.0)).xyz);\n} else {\ncoordsIn=swizzleUpZ((invViewMatrix*vec4(-vViewPosition,1.0)).xyz);\n}\nif (axis==AXIS_XY)\ncoordsIn=vec3(coordsIn.x,coordsIn.y,1.0);\nelse if (axis==AXIS_YZ)\ncoordsIn=vec3(coordsIn.y,coordsIn.z,1.0);\nelse if (axis==AXIS_ZX)\ncoordsIn=vec3(coordsIn.z,coordsIn.x,1.0);\nvec3 coordsOut=calcUvTransform(uOffset,vOffset,uTiling,vTiling,wAngle)*coordsIn;\nfloat coord=uvIn.x;\nuvIn=coordsOut.xy;\nif ((clampToEdgeNoExtend[0]==1&&(uvIn.x<0.0||uvIn.x>1.0))||\n(clampToEdgeNoExtend[1]==1&&(uvIn.y<0.0||uvIn.y>1.0))){\noutCol=vec4(0.0,0.0,0.0,1.0);\nreturn;\n}\nuvIn=fract(uvIn);\nif (gradientType==GRAD_TYPE_4_CORNER){\ncoord=pow(uvIn.x,2.0);\n} else if (gradientType==GRAD_TYPE_BOX){\nvec2 boxUv=abs(uvIn-vec2(0.5))*2.0;\ncoord=max(boxUv.x,boxUv.y);\n} else if (gradientType==GRAD_TYPE_DIAGONAL){\ncoord=abs(uvIn.x-uvIn.y)*sqrt(2.0);\n} else if (gradientType==GRAD_TYPE_LIGHTING){\nIncidentLight directLight;\nGeometricContext geometry;\ngeometry.position=-viewPos;\nvec3 irr=vec3(0.0);\n#if (NUM_POINT_LIGHTS>0)\n#pragma unroll_loop\nfor (int i=0;i<NUM_POINT_LIGHTS;i++){\ngetPointLightInfo(pointLights[i],geometry,directLight);\nfloat dotNL=saturate(dot(geometryNormal,directLight.direction));\nirr+=dotNL*directLight.color;\n}\n#endif\n#if (NUM_SPOT_LIGHTS>0)\n#pragma unroll_loop\nfor (int i=0;i<NUM_SPOT_LIGHTS;i++){\ngetSpotLightInfo(spotLights[i],geometry,directLight);\nfloat dotNL=saturate(dot(geometryNormal,directLight.direction));\nirr+=dotNL*directLight.color;\n}\n#endif\n#if (NUM_DIR_LIGHTS>0)\n#pragma unroll_loop\nfor (int i=0;i<NUM_DIR_LIGHTS;i++){\ngetDirectionalLightInfo(directionalLights[i],geometry,directLight);\nfloat dotNL=saturate(dot(geometryNormal,directLight.direction));\nirr+=dotNL*directLight.color;\n}\n#endif\nirr/=PI;\nvec3 ambIrr=getAmbientLightIrradiance(ambientLightColor);\nirr+=ambIrr;\ncoord=(irr.x+irr.y+irr.z)/3.0;\n} else if (gradientType==GRAD_TYPE_LINEAR){\ncoord=uvIn.x;\n} else if (gradientType==GRAD_TYPE_MAPPED){\ncoord=(sourceMap.x+sourceMap.y+sourceMap.z)/3.0;\n} else if (gradientType==GRAD_TYPE_NORMAL){\nfloat angle=acos(clamp(dot(geometryNormal,normalize(viewPos)),-1.0,1.0));\nfloat k=100.0;\ncoord=1.0-sin(pow2(k)-k*sqrt(pow2(k)-pow2(angle)));\n} else if (gradientType==GRAD_TYPE_PONG){\nfloat y=min(uvIn.y,uvIn.x);\nfloat x=max(uvIn.y,uvIn.x);\ncoord=y/x;\n} else if (gradientType==GRAD_TYPE_RADIAL){\ncoord=length(uvIn-vec2(0.5))*2.0;\n} else if (gradientType==GRAD_TYPE_SPIRAL){\nvec2 uvSpiral=mat2(0.0,1.0,-1.0,0.0)*(uvIn-vec2(0.5));\ncoord=atan(uvSpiral.y,uvSpiral.x)/PI2+0.5;\n} else if (gradientType==GRAD_TYPE_SWEEP){\ncoord=atan(uvIn.x,uvIn.y)/PI_HALF;\n} else if (gradientType==GRAD_TYPE_TARTAN){\nvec2 uvTartan=abs(uvIn-vec2(0.5));\ncoord=1.0-min(uvTartan.x,uvTartan.y)*2.0;\n}\noutCol=texture2D(gradientData,vec2(coord,0.0));\n}",node_map_mx_frag:"\nvoid node_map(const vec4 colorIn,out vec4 color)\n{\ncolor=colorIn;\n}",node_mask_mx_frag:"void node_mask(const bool maskInverted,const vec4 color,vec4 mask,out vec4 outColor)\n{\nmask=maskInverted?vec4(vec3(1.0)-mask.rgb,mask.a):mask;\noutColor=color*mask;\n}",node_material_mx_frag:"void node_material(float reflectionRatio,const float refractionRatio,const bool selfIllumColorOn,const vec4 ambientColor,const vec4 diffuseColor,const vec4 specularColor,const float glossiness,const float specularLevel,const vec4 selfIllum,const float opacity,const vec4 filterColor,const vec3 normal,const vec4 reflection,const vec4 refraction,const float displacement,out vec4 outColor)\n{\nvec3 diffuse,specular;\nNodeMaterial material;\nfloat ior=1.5;\nfloat facing=pow2((1.0-ior)/(1.0+ior));\nfloat edge=1.0;\nfloat slope=5.0;\nfloat cosTheta=saturate(dot(normal,normalize(vViewPosition)));\nfloat fresnelRefl=(facing+(edge-facing)*pow(1.0-cosTheta,slope))*saturate(specularLevel);\nfloat kd=1.0-fresnelRefl;\nmaterial.diffuseColor=diffuseColor.rgb*kd;\nmaterial.specularColor=mix(vec3(0.0),specularColor.rgb,fresnelRefl);\nmaterial.roughness=1.0-glossiness;\nReflectedLight reflectedLight=ReflectedLight(vec3(0.0),vec3(0.0),vec3(0.0),vec3(0.0));\n#define RE_Direct RE_Direct_Node\n#define RE_IndirectDiffuse RE_IndirectDiffuse_Node\n#define RE_IndirectSpecular RE_IndirectSpecular_Node\n#include <lights_fragment_begin>\n#include <lights_fragment_maps>\n#include <lights_fragment_end>\n#undef RE_Direct\n#undef RE_IndirectDiffuse\n#undef RE_IndirectSpecular\ndiffuse=reflectedLight.directDiffuse+reflectedLight.indirectDiffuse;\nif (selfIllumColorOn){\ndiffuse+=selfIllum.rgb;\n} else {\ndiffuse=mix(diffuse,material.diffuseColor,selfIllum[0]);\n}\nspecular=reflectedLight.directSpecular+reflectedLight.indirectSpecular;\noutColor=vec4(saturate(diffuse+specular),1.0);\nfloat alpha=opacity-saturate(maxFromRGB(specular))*(opacity-1.0);\noutColor+=reflection*specularColor*reflectionRatio;\noutColor+=refraction*refractionRatio;\nalpha+=saturate(maxFromRGB(reflection.rgb)*maxFromRGB(specularColor.rgb))*reflectionRatio;\nalpha+=saturate(maxFromRGB(refraction.rgb))*refractionRatio;\noutColor.a=alpha;\n}",node_matte_shadow_mx_frag:"#include <shadowmask_pars_fragment>\nvoid node_matte_shadow(vec3 normal,bool receiveShadow,float shadowBrightness,vec3 color,out vec4 outColor){\nfloat shadow=getShadowMask();\noutColor=vec4(color,1.0-(shadowBrightness+(1.0-shadowBrightness)*shadow));\n}",node_mix_mx_frag:"void node_mix(const vec4 color1,const vec4 color2,const float amount,out vec4 color)\n{\ncolor=mix(color1,color2,clamp(amount,0.0,1.0));\n}",node_noise_mx_frag:"#define NOISE_REGULAR 0\n#define NOISE_FRACTAL 1\n#define NOISE_TURBULENCE 2\nfloat noise(vec3 vec,const int noiseType,const float size,const float thresholdLow,const float thresholdHigh,const float levels,float phase){\nvec/=size;\nfloat n=0.0;\nif (noiseType==NOISE_REGULAR){\nn=(1.0+snoise(vec4(vec,phase)))*0.5;\n} else if (noiseType==NOISE_FRACTAL){\nfloat l,f=1.0;\n#if __VERSION__==100\nfor (float l=3.0;l>=1.0;l-=1.0){\n#else\nfor (l=levels;l>=1.0;l-=1.0){\n#endif\nn+=snoise(vec4(vec*f,phase))/f;\nf*=2.0;\n}\nif (l>0.0)\nn+=l*snoise(vec4(vec*f,phase))/f;\nn=0.5*(n+1.0);\n} else {\nfloat l,f=1.0;\nfloat ml=levels;\n#if __VERSION__==100\nfor (float l=3.0;l>=1.0;l-=1.0){\n#else\nfor (l=levels;l>=1.0;l-=1.0,ml-=1.0){\n#endif\nn+=abs(snoise(vec4(vec*f,phase)))/f;\nf*=2.0;\n}\nif (l>0.0)\nn+=l*abs(snoise(vec4(vec*f,phase)))/f;\n}\nreturn clamp(smoothstep(thresholdLow,thresholdHigh,n),0.0,1.0);\n}\nvoid node_noise(const vec2 uv,const int noiseType,const int coordType,const vec3 color1,const vec3 color2,const float size,const float thresholdLow,const float thresholdHigh,const float levels,const float phase,const vec3 offset,const vec3 tiling,const vec3 angle,out vec4 color){\nvec3 vec=(calcXYZTransform(offset,tiling,angle)*vec4(uv.x,1.0-uv.y,1.0,1.0)).xyz;\ncolor=vec4(mix(color1,color2,noise(vec,noiseType,size,thresholdLow,thresholdHigh,levels,phase)),1.0);\n}\nvoid node_noise(const vec3 viewPos,const int noiseType,const int coordType,const vec3 color1,const vec3 color2,const float size,const float thresholdLow,const float thresholdHigh,const float levels,const float phase,const vec3 offset,const vec3 tiling,const vec3 angle,out vec4 color){\nvec4 posWorld=invViewMatrix*vec4(-viewPos,1.0);\nvec3 vec;\nif (coordType==0)\nvec=(invModelMatrix*posWorld).xyz;\nelse\nvec=posWorld.xyz;\nvec=(calcXYZTransform(offset,tiling,angle)*vec4(swizzleUpZ(vec),1.0)).xyz;\ncolor=vec4(mix(color1,color2,noise(vec,noiseType,size,thresholdLow,thresholdHigh,levels,phase)),1.0);\n}",node_normal_bump_mx_frag:"void node_normal_bump(const vec4 tangent,const vec3 normal,ivec2 flip,vec4 normalColor,vec3 additionalBump,float normalMult,float addBumpMult,out vec3 normalOut)\n{\nif (flip[0]==1)\nnormalColor.x=1.0-normalColor.x;\nif (flip[1]==0)\nnormalColor.y=1.0-normalColor.y;\nvec3 normalTex=(normalColor.xyz*2.0-1.0);\nvec4 viewTangent=vec4(normalize(modelViewMatrix*vec4(tangent.xyz,0.0)).xyz,tangent.w);\nvec3 bitangent=viewTangent.w*cross(normal,viewTangent.xyz);\nnormalOut=normalize(normalTex.x*viewTangent.xyz+normalTex.y*bitangent \n+ normalTex.z*normal);\nnormalOut=mix(normal,normalOut,normalMult);\nadditionalBump=mix(normal,additionalBump,addBumpMult);\nnormalOut=normalize(normalOut+additionalBump);\n}",node_openpbr_surface_mx_frag:"void node_openpbr_surface(vec3 geometryNormal,const bool thinWalled,const float baseWeight,const vec3 baseColor,const float baseMetalness,const float baseDiffuseRoughness,const float specularWeight,const vec3 specularColor,const float specularRoughness,const float specularIOR,const float transmissionWeight,const vec3 transmissionColor,const float transmissionDepth,const float coatWeight,const vec3 coatColor,const float coatRoughness,const float fuzzWeight,const vec3 fuzzColor,const float fuzzRoughness,const float emissionWeight,const vec3 emissionColor,const float emissionLuminance,const float geometryOpacity,const vec3 normal,const vec3 clearcoatNormal,out vec4 outColor)\n{\nNodeMaterial material;\nvec3 baseColorWeighted=baseWeight*baseColor.rgb;\nmaterial.diffuseColor=baseColorWeighted*(1.0-baseMetalness)*(1.0-transmissionWeight);\n#ifdef USE_CLEARCOAT\nmaterial.clearcoat=saturate(coatWeight);\nmaterial.clearcoatRoughness=clamp(coatRoughness,0.0,1.0);\nmaterial.clearcoatF0=vec3(0.04);\nmaterial.clearcoatF90=1.0;\n#endif\n#ifdef USE_SHEEN\nmaterial.sheenColor=saturate(fuzzWeight*fuzzColor);\nmaterial.sheenRoughness=clamp(fuzzRoughness,0.0,1.0);\n#endif\nvec3 dxy=max(abs(dFdx(geometryNormal)),abs(dFdy(geometryNormal)));\nfloat geometryRoughness=max(max(dxy.x,dxy.y),dxy.z);\nmaterial.roughness=max(specularRoughness,0.0525);\nmaterial.roughness+=geometryRoughness;\nmaterial.roughness=min(material.roughness,1.0);\nvec3 specularColorWeighted=specularWeight*specularColor;\nvec3 dielRefl=pow2((1.0-specularIOR)/(1.0+specularIOR))*specularColorWeighted;\nmaterial.specularColor=mix(dielRefl,baseColorWeighted,baseMetalness);\nmaterial.fresnelRefl90=mix(specularColorWeighted,vec3(1.0),baseMetalness);\nmaterial.specularF90=average(material.fresnelRefl90);\nmaterial.refractionColor=pow(transmissionWeight*(1.0-baseMetalness)*transmissionColor.rgb,vec3(2.0));\nmaterial.refractionIOR=specularIOR;\nmaterial.refractionRoughness=material.roughness;\nReflectedLight reflectedLight=ReflectedLight(vec3(0.0),vec3(0.0),vec3(0.0),vec3(0.0));\nvec3 refractedLight=vec3(0.0);\n#ifdef USE_GTAO\nvec4 gtaoVisibilityBentNormal=texture2D(gtaoMap,gl_FragCoord.xy/currResolution);\nvec3 bentNormal=normalize(unpackRGBToNormal(gtaoVisibilityBentNormal.gba));\n#define PROBE_NORMAL bentNormal\n#endif\n#define RE_Direct RE_Direct_Node\n#define RE_IndirectDiffuse RE_IndirectDiffuse_Node\n#define RE_IndirectSpecular RE_IndirectSpecular_Node\n#define RE_Refraction RE_Refraction_Node\n#include <lights_fragment_begin>\n#include <lights_fragment_maps>\n#include <lights_fragment_end>\n#undef RE_Direct\n#undef RE_IndirectDiffuse\n#undef RE_IndirectSpecular\n#undef RE_Refraction\n#ifdef PROBE_NORMAL\n#undef PROBE_NORMAL\n#endif\n#ifdef USE_GTAO\nreflectedLight.indirectDiffuse*=gtaoVisibilityBentNormal.r;\nfloat gtaoVisibility=gtaoVisibilityBentNormal.r;\nvec3 gtaoBentNormal=bentNormal;\nvec3 gtaoViewDir=geometry.viewDir;\nvec3 gtaoNormal=normal;\nfloat gtaoRoughness=material.roughness;\n#endif\n#include <lights_fragment_gtso>\nvec3 totalEmissiveRadiance=emissionWeight*emissionColor*emissionLuminance*OPENPBR_EMISSION_LUM_FACTOR;\nvec3 outSpecular=reflectedLight.directSpecular+reflectedLight.indirectSpecular;\nvec3 outColor3=reflectedLight.directDiffuse+reflectedLight.indirectDiffuse +\noutSpecular+totalEmissiveRadiance;\n#ifdef USE_SHEEN\nfloat sheenEnergyComp=1.0-0.157*max3(material.sheenColor);\noutColor3=outColor3*sheenEnergyComp+sheenSpecular;\n#endif\n#ifdef USE_CLEARCOAT\nfloat dotNVcc=saturate(dot(geometry.normal,geometry.viewDir));\nvec3 Fcc=F_Schlick(material.clearcoatF0,material.clearcoatF90,dotNVcc);\noutColor3=outColor3*(1.0-material.clearcoat*Fcc)+clearcoatSpecular*material.clearcoat;\n#endif\nfloat alpha=1.0;\nif (thinWalled){\nalpha=geometryOpacity*(1.0-saturate(transmissionWeight)+maxFromRGB(outSpecular)*saturate(transmissionWeight));\n} else {\noutColor3+=refractedLight;\n}\noutColor=vec4(outColor3,saturate(alpha));\n}",node_output_map_mx_frag:"vec4 processOutputColor(vec4 color,const bool invert,const bool clampColor,const bool alphaFromRGB,const float rgbLevel,const float rgbOffset,const float outputAmount)\n{\nvec3 color3=color.rgb;\ncolor3=clampColor?saturate(color3):color3;\ncolor3=color3*rgbLevel+vec3(rgbOffset);\ncolor3=invert?(vec3(1.0)-color3):color3;\ncolor=outputAmount*vec4(color3,color.a);\ncolor.a=alphaFromRGB?average(color.rgb):color.a;\nreturn color;\n}\nvoid node_output_map(const bool invert,const bool clampColor,const bool alphaFromRGB,const vec4 color,const float rgbLevel,const float rgbOffset,const float outputAmount,const float bumpAmount,out vec4 outColor)\n{\noutColor=processOutputColor(color,invert,clampColor,alphaFromRGB,rgbLevel,rgbOffset,outputAmount);\n}\nvoid node_output_map(const bool invert,const bool clampColor,const bool alphaFromRGB,sampler2D colormap,vec4 color,const float rgbLevel,const float rgbOffset,const float outputAmount,const float bumpAmount,out vec4 outColor)\n{\nfloat r=texture2D(colormap,vec2(color.r,0.0)).r;\nfloat g=texture2D(colormap,vec2(color.g,0.0)).g;\nfloat b=texture2D(colormap,vec2(color.b,0.0)).b;\noutColor=processOutputColor(vec4(r,g,b,color.a),invert,clampColor,alphaFromRGB,rgbLevel,rgbOffset,outputAmount);\n}",node_output_mx_frag:"void node_output(vec4 color,out vec4 outgoingLight)\n{\noutgoingLight=color;\n}",node_physical_mx_frag:"#define DEFAULT_REFLECTION_EDGE 1.0\n#define DEFAULT_REFLECTION_SLOPE 5.0\nvoid node_physical(vec3 geometryNormal,const float emitLuminance,const bool useCustomReflCurve,const float reflFacing,const float reflEdge,const float reflSlope,const bool roughnessInv,const bool transRoughnessLock,const bool transRoughnessInv,const bool thinWalled,const float base,const vec4 baseColor,const float reflectivity,const vec4 reflColor,const float roughness,const float metalness,const float diffRoughness,const float anisotropy,const float anisoangle,const float transparency,const vec4 transColor,const float transRoughness,const float ior,const float scattering,const vec4 sssColor,const float sssScale,const float emission,const vec4 emitColor,const float clearcoat,const vec4 clearcoatColor,const float clearcoatRoughness,const vec3 normal,const vec3 clearcoatNormal,const float displacement,const float opacity,out vec4 outColor)\n{\nNodeMaterial material;\nvec3 baseColorWeighted=base*baseColor.rgb;\nmaterial.diffuseColor=baseColorWeighted*(1.0-transparency);\n#ifdef USE_CLEARCOAT\nmaterial.clearcoat=saturate(clearcoat);\nmaterial.clearcoatRoughness=clamp(clearcoatRoughness,0.0,1.0);\nmaterial.clearcoatF0=vec3(0.04);\nmaterial.clearcoatF90=1.0;\n#endif\nfloat facing,edge,slope;\nif (useCustomReflCurve){\nfacing=reflFacing;\nedge=reflEdge;\nslope=reflSlope;\n} else {\nfacing=pow2((1.0-ior)/(1.0+ior));\nedge=DEFAULT_REFLECTION_EDGE;\nslope=DEFAULT_REFLECTION_SLOPE;\n}\nfloat cosTheta=saturate(dot(normal,normalize(vViewPosition)));\nfloat fresnelRefl=(facing+(edge-facing)*pow(1.0-cosTheta,slope))\n* saturate(reflectivity+metalness);\nfloat kd=1.0-(metalness*(1.0-fresnelRefl)+fresnelRefl);\nmaterial.specularColor=mix(metalness*baseColorWeighted,reflColor.rgb,fresnelRefl);\nmaterial.diffuseColor*=kd;\nmaterial.specularF90=1.0;\nmaterial.roughness=clamp(roughnessInv?(1.0-roughness):roughness,0.0,1.0);\nmaterial.refractionColor=pow(transparency*(1.0-metalness)*transColor.rgb,vec3(2.0));\nmaterial.refractionIOR=ior;\nfloat tRough;\nif (transRoughnessLock){\ntRough=roughnessInv?1.0-roughness:roughness;\n} else {\ntRough=transRoughnessInv?1.0-transRoughness:transRoughness;\n}\nmaterial.refractionRoughness=pow2(tRough);\n#if defined(ENVMAP_TYPE_CUBE)||defined(ENVMAP_TYPE_CUBE_UV)\nfloat geomRoughness=calcGeometryRoughness(geometryNormal);\nmaterial.roughness=calcCubeUVAdjustedRoughness(material.roughness,geomRoughness);\nmaterial.refractionRoughness=calcCubeUVAdjustedRoughness(material.refractionRoughness,geomRoughness);\n#ifdef USE_CLEARCOAT\nmaterial.clearcoatRoughness=calcCubeUVAdjustedRoughness(material.clearcoatRoughness,geomRoughness);\n#endif\n#endif\nReflectedLight reflectedLight=ReflectedLight(vec3(0.0),vec3(0.0),vec3(0.0),vec3(0.0));\nvec3 refractedLight=vec3(0.0);\n#ifdef USE_GTAO\nvec4 gtaoVisibilityBentNormal=texture2D(gtaoMap,gl_FragCoord.xy/currResolution);\nvec3 bentNormal=normalize(unpackRGBToNormal(gtaoVisibilityBentNormal.gba));\n#define PROBE_NORMAL bentNormal\n#endif\n#define RE_Direct RE_Direct_Node\n#define RE_IndirectDiffuse RE_IndirectDiffuse_Node\n#define RE_IndirectSpecular RE_IndirectSpecular_Node\n#define RE_Refraction RE_Refraction_Node\n#include <lights_fragment_begin>\n#include <lights_fragment_maps>\n#include <lights_fragment_end>\n#undef RE_Direct\n#undef RE_IndirectDiffuse\n#undef RE_IndirectSpecular\n#undef RE_Refraction\n#ifdef PROBE_NORMAL\n#undef PROBE_NORMAL\n#endif\n#ifdef USE_GTAO\nreflectedLight.indirectDiffuse*=gtaoVisibilityBentNormal.r;\nfloat gtaoVisibility=gtaoVisibilityBentNormal.r;\nvec3 gtaoBentNormal=bentNormal;\nvec3 gtaoViewDir=geometry.viewDir;\nvec3 gtaoNormal=normal;\nfloat gtaoRoughness=material.roughness;\n#endif\n#include <lights_fragment_gtso>\nvec3 totalEmissiveRadiance=emitLuminance/LUMENS_PER_WATT*emission*emitColor.rgb;\nvec3 specular=reflectedLight.directSpecular+reflectedLight.indirectSpecular;\nvec3 outColor3=reflectedLight.directDiffuse+reflectedLight.indirectDiffuse +\nspecular+totalEmissiveRadiance;\n#ifdef USE_CLEARCOAT\nfloat dotNVcc=saturate(dot(geometry.normal,geometry.viewDir));\nvec3 Fcc=F_Schlick(material.clearcoatF0,material.clearcoatF90,dotNVcc);\noutColor3=outColor3*(1.0-material.clearcoat*Fcc)+clearcoatSpecular*material.clearcoat;\n#endif\nfloat alpha=1.0;\nif (thinWalled){\nalpha=1.0-saturate(transparency)+maxFromRGB(specular)*saturate(transparency);\n} else {\noutColor3+=refractedLight;\n}\noutColor=vec4(outColor3,saturate(alpha)*opacity);\n}",node_phy_sun_sky_env_mx_frag:"vec3 perezSky(vec3 paramA,vec3 paramB,vec3 paramC,vec3 paramD,vec3 paramE,vec3 radiance,vec3 sunDirection,vec3 direction)\n{\nfloat cosGamma=clamp(dot(direction,sunDirection),-1.0,1.0);\nfloat cosTheta=clamp(direction.y,0.0,1.0);\nvec3 radInternal=(1.0+paramA*exp(paramB/cosTheta))*(1.0+paramC*exp(paramD*acos(cosGamma))\n+ paramE*pow(cosGamma,2.0)\n);\nfloat ciex=radInternal.y*radiance.y;\nfloat ciey=radInternal.z*radiance.z;\nfloat cieY=clamp(radInternal.x*radiance.x,0.0,1000000.0);\nvec3 XYZ=xyY_to_XYZ(ciex,ciey,cieY);\nreturn max(xyz_to_sRGB(XYZ),0.0);\n}\n#define GROUND_SKY_SAMPLES 16\nvec3 groundSky(vec3 paramA,vec3 paramB,vec3 paramC,vec3 paramD,vec3 paramE,vec3 radiance,vec3 sunDirection,vec3 sunIlluminance)\n{\nconst int horizSamples=GROUND_SKY_SAMPLES;\nconst int vertSamples=GROUND_SKY_SAMPLES/2;\nvec3 result=vec3(0.0);\nfor (int horizSampleIdx=0;horizSampleIdx<horizSamples;horizSampleIdx++){\nfloat horizSample=float(horizSampleIdx)/float(horizSamples);\nfloat horizAngle=PI2*horizSample;\nfor (int vertSampleIdx=0;vertSampleIdx<vertSamples;vertSampleIdx++){\nfloat vertSample=float(vertSampleIdx)/float(vertSamples);\nfloat y=1.0-vertSample;\nfloat x=sqrt(1.0-y*y)*cos(horizAngle);\nfloat z=-sqrt(1.0-y*y)*sin(horizAngle);\nvec3 direction=vec3(x,y,z);\nvec3 sampleColor=perezSky(paramA,paramB,paramC,paramD,paramE,radiance,sunDirection,direction);\n\nresult+=direction.y*sampleColor;\n}\n}\nresult/=float(horizSamples*vertSamples);\nresult+=(sunIlluminance*sunDirection.y)/PI;\nreturn result;\n}\nvoid node_phy_sun_sky_env(vec3 paramA,vec3 paramB,vec3 paramC,vec3 paramD,vec3 paramE,vec3 radiance,vec3 sunDirection,vec3 sunIlluminance,vec3 sunLuminance,float globalIntensity,vec4 groundColor,out vec4 outColor)\n{\nvec3 dir=vWorldPosition;\nif (length(dir)==0.0){\ndir=vec3(0.0,0.0,-1.0);\n} else {\ndir=normalize(dir);\n}\nif (dir.y<0.0){\noutColor=groundColor*vec4(groundSky(paramA,paramB,paramC,paramD,paramE,radiance,sunDirection,sunIlluminance),1.0);\n} else {\noutColor=vec4(perezSky(paramA,paramB,paramC,paramD,paramE,radiance,sunDirection,dir),1.0);\n}\noutColor=globalIntensity*outColor;\n}",node_reflect_refract_mx_frag:"void node_reflect_refract(sampler2D envMap,int reflectMode,const float IOR,const int encoding,vec3 normal,out vec4 color)\n{\nvec3 cameraToVertex=normalize(vWorldPosition-cameraPosition);\nvec3 worldNormal=inverseTransformDirection(normal,viewMatrix);\nvec3 reflectVec;\nif (reflectMode==MAX_ENV_COORDS_REFLECT)\nreflectVec=reflect(cameraToVertex,worldNormal);\nelse {\nfloat refrRatio=1.0/IOR;\nreflectVec=refract(cameraToVertex,worldNormal,refrRatio);\n}\nreflectVec=normalize(reflectVec);\ncolor=sampleEquirectangular(envMap,reflectVec,mat3(1.0),encoding);\n}",node_reflect_refract_color_mx_frag:"void node_reflect_refract_color(const vec4 colorIn,out vec4 color)\n{\ncolor=vec4(colorIn);\n}",node_rgb_multiply_mx_frag:"void node_rgb_multiply(const vec4 color1,const vec4 color2,out vec4 color)\n{\ncolor=color1*color2;\n}",node_rgb_tint_mx_frag:"void node_rgb_tint(const vec4 color,const vec4 red,const vec4 green,const vec4 blue,out vec4 outColor)\n{\nmat3 tintMatrix=mat3(red.rgb,green.rgb,blue.rgb);\noutColor=vec4(tintMatrix*color.rgb,color.a);\n}",node_rgb_mx_frag:"uniform vec4 nodeRGB[NODE_RGB_NUM];\nvoid node_rgb(vec4 color,out vec4 outColor)\n{\noutColor=color;\n}",node_shellac_mx_frag:"void node_shellac(const vec4 color1,const vec4 color2,const float amount,out vec4 color)\n{\ncolor=mix(color1,color2,clamp(amount,0.0,1.0));\n}",node_sub_transform_mx_frag:"#define COORD_WORLD_SPACE 0\n#define COORD_OBJECT_SPACE 1\nvoid node_sub_transform(const int coordSpace,vec3 scale,vec3 rotate,vec3 offset,out vec3 outVector,out vec3 outNormal)\n{\nvec3 norm=vNormal;\nnorm=(invViewMatrix*vec4(norm,0.0)).xyz;\nvec3 vector=vWorldPosition.xyz;\nif (coordSpace==COORD_OBJECT_SPACE){\nvector=(invModelMatrix*vec4(vector,1.0)).xyz;\nnorm=(invModelMatrix*vec4(norm,0.0)).xyz;\n}\nvector-=swizzleUpY(offset.xyz);\nvector*=scale.xzy;\nmat3 rotX90=mat3RotateX(PI*0.5);\nmat3 rotX=mat3RotateX(radians(rotate.x));\nmat3 rotY=mat3RotateY(radians(-rotate.y));\nmat3 rotZ=mat3RotateZ(radians(rotate.z));\nmat3 rotMat=rotX*rotY*rotZ*rotX90;\nvector=rotMat*vector;\nnorm=rotMat*norm;\noutVector=vector;\noutNormal=normalize(norm);\n}",node_value_mx_frag:"uniform float nodeValue[NODE_VALUE_NUM];\nvoid node_value(float value,out float outValue)\n{\noutValue=value;\n}",node_vertex_color_mx_frag:"void node_vertex_color(vec3 color,out vec4 outColor)\n{\noutColor=vec4(color,1.0);\n}",node_add_double_linear_my_frag:"void node_add_double_linear(float input1,float input2,out float outValue){\noutValue=input1+input2;\n}",node_add_matrix_my_frag:"void node_add_matrix(mat4 matrixIn1,out mat4 matrixSum)\n{\nmatrixSum=matrixIn1;\n}\nvoid node_add_matrix(mat4 matrixIn1,mat4 matrixIn2,out mat4 matrixSum)\n{\nmatrixSum=matrixIn1+matrixIn2;\n}\nvoid node_add_matrix(mat4 matrixIn1,mat4 matrixIn2,mat4 matrixIn3,out mat4 matrixSum)\n{\nmatrixSum=matrixIn1+matrixIn2+matrixIn3;\n}",node_anim_curve_ta_my_frag:"#ifndef NODE_VALUE\nuniform float nodeValue[NODE_VALUE_NUM];\n#endif\nvoid node_anim_curve_ta(float val,out float outVal)\n{\noutVal=val;\n}",node_anim_curve_tu_my_frag:"#ifndef NODE_VALUE\nuniform float nodeValue[NODE_VALUE_NUM];\n#endif\nvoid node_anim_curve_tu(float val,out float outVal)\n{\noutVal=val;\n}",node_blend_colors_my_frag:"void node_blend_colors(float blender,vec3 color1,vec3 color2,out vec3 outColor)\n{\nblender=clamp(blender,0.0,1.0);\noutColor=mix(color1,color2,1.0-blender);\n}\nvoid node_blend_colors(float blender,vec4 color1,vec4 color2,out vec4 outColor)\n{\nblender=clamp(blender,0.0,1.0);\noutColor=mix(color1,color2,1.0-blender);\n}",node_bulge_my_frag:"void node_bulge(float uWidth,float vWidth,vec2 uvCoord,out float outAlpha,out vec3 outColor){\nuvCoord=2.0*fract(uvCoord);\nfloat bulge=0.0;\nif (uvCoord.x>uWidth&&uvCoord.x<2.0-uWidth &&\nuvCoord.y>vWidth&&uvCoord.y<2.0-vWidth){\nuvCoord.x=(uvCoord.x-uWidth)/(1.0-uWidth);\nuvCoord.y=(uvCoord.y-vWidth)/(1.0-vWidth);\nbulge=uvCoord.x*(2.0-uvCoord.x)*uvCoord.y*(2.0-uvCoord.y);\n}\noutAlpha=bulge;\noutColor=vec3(bulge,bulge,bulge);\n}",node_blinn_my_frag:"void node_blinn(vec3 geometryNormal,vec3 color,vec3 ambientColor,vec3 incandescence,float matteOpacity,float diffuse,vec3 normal,float reflectivity,vec3 reflectedColor,float eccentricity,vec3 specularColor,float specularRollOff,float translucence,vec3 transparency,out vec4 outColor){\nNodeMaterial material;\nmaterial.diffuseColor=diffuse*color;\n#ifdef USE_CLEARCOAT\n#undef USE_CLEARCOAT\n#define _CLEARCOAT_RESTORE\n#endif\nvec3 dxy=max(abs(dFdx(geometryNormal)),abs(dFdy(geometryNormal)));\nfloat geometryRoughness=max(max(dxy.x,dxy.y),dxy.z);\nmaterial.roughness=max(eccentricity,0.0525);\nmaterial.roughness+=geometryRoughness;\nmaterial.roughness=min(material.roughness,1.0);\nmaterial.specularColor=specularColor;\nReflectedLight reflectedLight=ReflectedLight(vec3(0.0),vec3(0.0),vec3(0.0),vec3(0.0));\n#define RE_Direct RE_Direct_Node\n#define RE_IndirectDiffuse RE_IndirectDiffuse_Node\n#define RE_IndirectSpecular RE_IndirectSpecular_Node\n#include <lights_fragment_begin>\n#include <lights_fragment_maps>\n#include <lights_fragment_end>\n#undef RE_Direct\n#undef RE_IndirectDiffuse\n#undef RE_IndirectSpecular\n#ifdef _CLEARCOAT_RESTORE\n#undef _CLEARCOAT_RESTORE\n#define USE_CLEARCOAT\n#endif\nfloat alpha=1.0-average(transparency);\noutColor=vec4(reflectedLight.directDiffuse+reflectedLight.indirectDiffuse +\nreflectedLight.directSpecular+reflectedLight.indirectSpecular+incandescence,alpha);\n}",node_bump_2d_my_frag:"void node_bump_2d(vec3 normal,float bumpDepth,float bumpValue,out vec3 outNormal){\nvec3 position=vViewPosition;\nvec3 dPdx=dFdx(position);\nvec3 dPdy=dFdy(position);\nfloat dHdx=dFdx(bumpValue);\nfloat dHdy=dFdy(bumpValue);\nvec3 tanX=cross(dPdy,normal);\nvec3 tanY=cross(normal,dPdx);\nvec3 surfaceGrad=dHdx*tanX+dHdy*tanY;\nfloat dotPosTanX=dot(dPdx,tanX);\noutNormal=normalize(normal*abs(dotPosTanX)-surfaceGrad*sign(dotPosTanX));\noutNormal=normalize(mix(normal,outNormal,max(0.0,bumpDepth)));\n}\nvoid node_bump_2d(vec3 normal,vec4 tangent,float bumpDepth,vec3 bumpValue,out vec3 outNormal){\n#ifdef DOUBLE_SIDED\nnormal=normal*(float(gl_FrontFacing)*2.0-1.0);\n#endif\nif (length(tangent.xyz)==0.0)\ntangent.x=1.0;\nvec3 normalTex=(bumpValue.xyz*2.0-1.0);\nvec4 viewTangent=vec4(normalize((modelViewMatrix*vec4(tangent.xyz,0.0)).xyz),tangent.w);\nvec3 bitangent=viewTangent.w*cross(normal,viewTangent.xyz);\noutNormal=normalize(normalTex.x*viewTangent.xyz+normalTex.y*bitangent\n+ normalTex.z*normal);\noutNormal=mix(normal,outNormal,bumpDepth);\n}",node_channels_my_frag:"void node_channels(int channelR,int channelG,int channelB,int channelA,float inAlpha,vec3 inColor,out float outAlpha,out vec3 outColor){\noutAlpha=1.0;\noutColor=vec3(1.0);\nif (channelR==0)\noutColor.r=inColor.r;\nelse if (channelR==1)\noutColor.r=inColor.g;\nelse if (channelR==2)\noutColor.r=inColor.b;\nelse\noutColor.r=inAlpha;\nif (channelG==0)\noutColor.g=inColor.r;\nelse if (channelG==1)\noutColor.g=inColor.g;\nelse if (channelG==2)\noutColor.g=inColor.b;\nelse\noutColor.g=inAlpha;\nif (channelB==0)\noutColor.b=inColor.r;\nelse if (channelB==1)\noutColor.b=inColor.g;\nelse if (channelB==2)\noutColor.b=inColor.b;\nelse\noutColor.b=inAlpha;\nif (channelA==0)\noutAlpha=inColor.r;\nelse if (channelA==1)\noutAlpha=inColor.g;\nelse if (channelA==2)\noutAlpha=inColor.b;\nelse\noutAlpha=inAlpha;\n}",node_checker_my_frag:"void node_checker(vec3 color1,vec3 color2,float contrast,vec2 uvCoord,out float outAlpha,out vec3 outColor){\nuvCoord-=floor(uvCoord);\nvec3 deltaColor=color2-color1;\ncolor1+=(1.0-contrast)*0.5*deltaColor;\ncolor2-=(1.0-contrast)*0.5*deltaColor;\nif ((uvCoord.x<0.5&&uvCoord.y>=0.5)||(uvCoord.x>=0.5&&uvCoord.y<0.5)){\noutColor=color2;\noutAlpha=1.0;\n} else {\noutColor=color1;\noutAlpha=0.0;\n}\n}",node_clamp_my_frag:"void node_clamp(vec3 inputValue,vec3 maxValue,vec3 minValue,out vec3 outputValue){\noutputValue=clamp(inputValue,minValue,maxValue);\n}",node_cloth_my_frag:"void node_cloth(float brightSpread,vec3 gapColor,float randomness,vec3 uColor,float uWave,float uWidth,vec3 vColor,float vWave,float vWidth,float widthSpread,vec2 uvCoord,out float outAlpha,out vec3 outColor){\nif (abs(uWave)>-EPSILON||abs(vWave)>-EPSILON){\nuvCoord.x+=- uWave*sin(PI2*uvCoord.y);\nuvCoord.y+=vWave*sin(PI2*uvCoord.x);\n}\nuvCoord=fract(uvCoord);\nint thread=0;\nif ((uvCoord.x>=0.5&&uvCoord.y<0.5)||(uvCoord.x<0.5&&uvCoord.y>=0.5)){\nfloat flippedCoord;\nflippedCoord=uvCoord.x;\nuvCoord.x=uvCoord.y;\nuvCoord.y=flippedCoord;\nflippedCoord=uWidth;\nuWidth=vWidth;\nvWidth=flippedCoord;\nthread=1;\n}\nuvCoord=fract(2.0*uvCoord);\nfloat cloth=1.0;\nif (uvCoord.y<=vWidth){\nfloat clothU=uvCoord.x-0.5*uWidth;\nfloat clothV=2.0*uvCoord.y/vWidth-1.0;\ncloth=0.75*(clothU*clothU+clothV*clothV);\n} else if (uvCoord.x<=uWidth){\nfloat clothU=2.0*uvCoord.x/uWidth-1.0;\nfloat clothV=uvCoord.y-0.5*vWidth-1.0;\ncloth=0.75*(clothU*clothU+clothV*clothV);\nthread=1-thread;\n}\noutColor=gapColor;\nif (cloth<1.0){\ncloth=1.0-cloth;\ncloth=min(cloth,1.0);\noutColor*=(1.0-cloth);\nvec3 threadColor=uColor;\nif (thread==0)\nthreadColor=vColor;\noutColor+=threadColor*cloth;\n}\noutAlpha=dot(outColor,LUM_WEIGHTS_MAYA);\n}",node_color_condition_my_frag:"void node_color_condition(float alphaA,float alphaB,vec3 colorA,vec3 colorB,bool condition,out float outAlpha,out vec3 outColor){\noutAlpha=condition?alphaA:alphaB;\noutColor=condition?colorA:colorB;\n}",node_color_composite_my_frag:"void node_color_composite(int operation,vec3 colorA,float alphaA,vec3 colorB,float alphaB,float factor,out vec3 outColor,out float outAlpha)\n{\nif (factor<=0.0){\noutColor=colorA;\noutAlpha=alphaA;\nreturn;\n}\nif (operation==0){\noutColor[0]=colorA[0]+(colorB[0]*factor);\noutColor[1]=colorA[1]+(colorB[1]*factor);\noutColor[2]=colorA[2]+(colorB[2]*factor);\noutAlpha=alphaA+(alphaB*factor);\n} else if (operation==1){\noutColor[0]=colorA[0]+((colorB[0]-1.0)*factor);\noutColor[1]=colorA[1]+((colorB[1]-1.0)*factor);\noutColor[2]=colorA[2]+((colorB[2]-1.0)*factor);\noutAlpha=alphaA+((alphaB-1.0)*factor);\n} else if (operation==2){\nif (factor>=1.0){\noutColor=colorB;\noutAlpha=alphaB;\nreturn;\n}\noutColor[0]=mix(colorA[0],colorB[0],factor);\noutColor[1]=mix(colorA[1],colorB[1],factor);\noutColor[2]=mix(colorA[2],colorB[2],factor);\noutAlpha=mix(alphaA,alphaB,factor);\n} else if (operation==3){\noutColor[0]=colorA[0]*(colorB[0]*factor+(1.0-factor));\noutColor[1]=colorA[1]*(colorB[1]*factor+(1.0-factor));\noutColor[2]=colorA[2]*(colorB[2]*factor+(1.0-factor));\noutAlpha=alphaA*(alphaB*factor+(1.0-factor));\n} else if (operation==4){\noutColor[0]=1.0-((1.0-colorA[0])*(1.0-colorB[0]*factor));\noutColor[1]=1.0-((1.0-colorA[1])*(1.0-colorB[1]*factor));\noutColor[2]=1.0-((1.0-colorA[2])*(1.0-colorB[2]*factor));\noutAlpha=1.0-((1.0-alphaA)*(1.0-alphaB*factor));\n} else if (operation==5){\noutColor[0]=colorB[0]>0.5?(2.0*colorA[0]*colorB[0]*factor)+colorA[0]*(1.0-factor):\n1.0-((1.0-colorA[0])*(1.0-colorB[0]*factor))*(2.0-(1.0-factor));\noutColor[1]=colorB[1]>0.5?(2.0*colorA[1]*colorB[1]*factor)+colorA[1]*(1.0-factor):\n1.0-((1.0-colorA[1])*(1.0-colorB[1]*factor))*(2.0-(1.0-factor));\noutColor[2]=colorB[2]>0.5?(2.0*colorA[2]*colorB[2]*factor)+colorA[2]*(1.0-factor):\n1.0-((1.0-colorA[2])*(1.0-colorB[2]*factor))*(2.0-(1.0-factor));\noutAlpha=alphaB>0.5?(2.0*alphaA*alphaB*factor)+alphaA*(1.0-factor):\n1.0-((1.0-alphaA)*(1.0-alphaB*factor))*(2.0-(1.0-factor));\n} else if (operation==6){\noutColor[0]=abs(colorA[0]-(colorB[0]*factor));\noutColor[1]=abs(colorA[1]-(colorB[1]*factor));\noutColor[2]=abs(colorA[2]-(colorB[2]*factor));\noutAlpha=abs(alphaA-(alphaB*factor));\n} else if (operation==7){\noutColor[0]=clamp(mix(colorA[0],colorA[0]/max(1.0-colorB[0],0.00001),factor),colorA[0],colorB[0]);\noutColor[1]=clamp(mix(colorA[1],colorA[1]/max(1.0-colorB[1],0.00001),factor),colorA[1],colorB[1]);\noutColor[2]=clamp(mix(colorA[2],colorA[2]/max(1.0-colorB[2],0.00001),factor),colorA[2],colorB[2]);\noutAlpha=clamp(mix(alphaA,alphaA/max(1.0-alphaB,0.00001),factor),alphaA,alphaB);\n} else if (operation==8){\noutColor[0]=clamp(mix(colorA[0],1.0-(colorA[0]/max(1.0-colorB[0],0.00001)),factor),colorA[0],colorB[0]);\noutColor[1]=clamp(mix(colorA[1],1.0-(colorA[1]/max(1.0-colorB[1],0.00001)),factor),colorA[1],colorB[1]);\noutColor[2]=clamp(mix(colorA[2],1.0-(colorA[2]/max(1.0-colorB[2],0.00001)),factor),colorA[2],colorB[2]);\noutAlpha=clamp(mix(alphaA,1.0-(alphaA/max(1.0-alphaB,0.00001)),factor),alphaA,alphaB);\n}\n}",node_color_constant_my_frag:"void node_color_constant(vec3 inColor,float inAlpha,out vec3 outColor,out float outAlpha)\n{\noutColor=inColor;\noutAlpha=inAlpha;\n}",node_color_correct_my_frag:"void node_color_correct(bool colClamp,vec3 colClampMin,vec3 colClampMax,bool alphaClamp,float alphaClampMin,float alphaClampMax,bool unpremultInput,bool premultResult,float alphaGain,float alphaGamma,float alphaOffset,vec3 colGain,vec3 colGamma,vec3 colOffset,float hueShift,float inAlpha,vec3 inColor,float satGain,float valGain,out float outAlpha,out vec3 outColor)\n{\noutColor=unpremultInput?inColor/inAlpha:inColor;\nif (hueShift != 0.0||satGain != 1.0||valGain != 1.0){\nvec4 color=vec4(outColor,1.0);\nrgbToHSV(vec4(inColor,1.0),color);\ncolor.r+=hueShift/360.0;\nif (color.r>1.0)\ncolor.r-=1.0;\nelse if (color.r<0.0)\ncolor.r+=1.0;\ncolor.g*=satGain;\ncolor.b*=valGain;\nhsvToRGB(color,color);\noutColor=color.rgb;\n}\noutColor*=colGain;\noutColor+=colOffset;\nif (any(notEqual(colGamma,vec3(1.0))))\noutColor=pow(outColor,1.0/colGamma);\nif (colClamp)\noutColor=clamp(outColor,colClampMin,colClampMax);\noutAlpha=inAlpha*alphaGain;\noutAlpha+=alphaOffset;\nif (alphaGamma != 1.0)\noutAlpha=pow(outAlpha,1.0/alphaGamma);\nif (alphaClamp)\noutAlpha=clamp(outAlpha,alphaClampMin,alphaClampMax);\nif (premultResult)\noutColor*=outAlpha;\n}",node_color_logic_my_frag:"void node_color_logic(int operation,vec3 colorA,vec3 colorB,out bool outBool){\nif (operation==0){\noutBool=all(equal(colorA,colorB));\n} else if (operation==1){\noutBool=any(notEqual(colorA,colorB));\n} else if (operation==2){\noutBool=((colorA.x+colorA.y+colorA.z)<(colorB.x+colorB.y+colorB.z));\n} else if (operation==3){\noutBool=((colorA.x+colorA.y+colorA.z)>(colorB.x+colorB.y+colorB.z));\n} else if (operation==4){\noutBool=((colorA.x+colorA.y+colorA.z)<=(colorB.x+colorB.y+colorB.z));\n} else {\noutBool=((colorA.x+colorA.y+colorA.z)>=(colorB.x+colorB.y+colorB.z));\n}\n}",node_color_mask_my_frag:"void node_color_mask(bool maskAlphaIsLuminance,float inAlpha,vec3 inColor,vec3 mask,float maskAlpha,out float outAlpha,out vec3 outColor){\nif (maskAlphaIsLuminance)\nmaskAlpha=1.0-dot(mask,LUM_WEIGHTS_MAYA);\noutColor=inColor*(1.0-maskAlpha);\n}",node_color_math_my_frag:"void node_color_math(int operation,float alphaA,float alphaB,vec3 colorA,vec3 colorB,out float outAlpha,out vec3 outColor){\nif (operation==0){\noutColor=colorA+colorB;\noutAlpha=alphaA+alphaB;\n} else if (operation==1){\noutColor=colorA-colorB;\noutAlpha=alphaA-alphaB;\n} else if (operation==2){\noutColor=colorA*colorB;\noutAlpha=alphaA*alphaB;\n} else if (operation==3){\noutColor=colorA/colorB;\noutAlpha=alphaA/alphaB;\n} else if (operation==4){\noutColor=min(colorA,colorB);\noutAlpha=min(alphaA,alphaB);\n} else {\noutColor=max(colorA,colorB);\noutAlpha=max(alphaA,alphaB);\n}\n}",node_compose_matrix_my_frag:"mat3 quatToMat3(vec4 quat){\nfloat x=quat.x,y=quat.y,z=quat.z,w=quat.w;\nfloat x2=x+x;\nfloat y2=y+y;\nfloat z2=z+z;\n\nfloat xx=x*x2;\nfloat yx=y*x2;\nfloat yy=y*y2;\nfloat zx=z*x2;\nfloat zy=z*y2;\nfloat zz=z*z2;\nfloat wx=w*x2;\nfloat wy=w*y2;\nfloat wz=w*z2;\n\nmat3 mat;\n\nmat[0][0]=1.0-yy-zz;\nmat[1][0]=yx-wz;\nmat[2][0]=zx+wy;\n\nmat[0][1]=yx+wz;\nmat[1][1]=1.0-xx-zz;\nmat[2][1]=zy-wx;\n\nmat[0][2]=zx-wy;\nmat[1][2]=zy+wx;\nmat[2][2]=1.0-xx-yy;\nreturn mat;\n}\nvoid node_compose_matrix(bool useEulerRotation,int inputRotateOrder,vec4 inputQuat,vec3 inputRotate,vec3 inputScale,vec3 inputShear,vec3 inputTranslate,out mat4 outputMatrix)\n{\nmat4 rotateMatrix;\ninputRotate=radians(inputRotate);\nif (useEulerRotation)\nrotateMatrix=toMat4(mat3RotateX(inputRotate.x)*mat3RotateY(inputRotate.y)*mat3RotateZ(inputRotate.z));\nelse\nrotateMatrix=toMat4(quatToMat3(normalize(inputQuat)));\nmat4 scaleMatrix=mat4(inputScale.x,0.0,0.0,0.0,0.0,inputScale.y,0.0,0.0,0.0,0.0,inputScale.z,0.0,0.0,0.0,0.0,1.0);\nmat4 shearMatrix=mat4(1.0,0.0,0.0,0.0,inputShear.x,1.0,0.0,0.0,inputShear.y,inputShear.z,1.0,0.0,0.0,0.0,0.0,1.0);\nmat4 transMatrix=mat4(1.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,1.0,0.0,inputTranslate.x,inputTranslate.y,inputTranslate.z,1.0);\noutputMatrix=scaleMatrix*shearMatrix*rotateMatrix*transMatrix;\n}",node_condition_my_frag:"void node_condition(int operation,vec3 colorIfFalse,vec3 colorIfTrue,float firstTerm,float secondTerm,out vec3 outColor){\nif (operation==0){\nif (firstTerm==secondTerm)\noutColor=colorIfTrue;\nelse\noutColor=colorIfFalse;\n} else if (operation==1){\nif (firstTerm != secondTerm)\noutColor=colorIfTrue;\nelse\noutColor=colorIfFalse;\n} else if (operation==2){\nif (firstTerm>secondTerm)\noutColor=colorIfTrue;\nelse\noutColor=colorIfFalse;\n} else if (operation==3){\nif (firstTerm>=secondTerm)\noutColor=colorIfTrue;\nelse\noutColor=colorIfFalse;\n} else if (operation==4){\nif (firstTerm<secondTerm)\noutColor=colorIfTrue;\nelse\noutColor=colorIfFalse;\n} else if (operation==5){\nif (firstTerm<=secondTerm)\noutColor=colorIfTrue;\nelse\noutColor=colorIfFalse;\n}\n}",node_decompose_matrix_my_frag:"vec4 mat3ToQuat(mat3 m){\nfloat trace=m[0][0]+m[1][1]+m[2][2];\nvec4 q=vec4(0.0,0.0,0.0,0.0);\nif (trace>0.0){\nfloat s=sqrt(trace+1.0)*2.0;\nq.w=0.25*s;\nq.x=(m[2][1]-m[1][2])/s;\nq.y=(m[0][2]-m[2][0])/s;\nq.z=(m[1][0]-m[0][1])/s;\n} else if ((m[0][0]>m[1][1])&&(m[0][0]>m[2][2])){\nfloat s=sqrt(1.0+m[0][0]-m[1][1]-m[2][2])*2.0;\nq.w=(m[2][1]-m[1][2])/s;\nq.x=0.25*s;\nq.y=(m[0][1]+m[1][0])/s;\nq.z=(m[0][2]+m[2][0])/s;\n} else if (m[1][1]>m[2][2]){\nfloat s=sqrt(1.0+m[1][1]-m[0][0]-m[2][2])*2.0;\nq.w=(m[0][2]-m[2][0])/s;\nq.x=(m[0][1]+m[1][0])/s;\nq.y=0.25*s;\nq.z=(m[1][2]+m[2][1])/s;\n} else {\nfloat s=sqrt(1.0+m[2][2]-m[0][0]-m[1][1])*2.0;\nq.w=(m[1][0]-m[0][1])/s;\nq.x=(m[0][2]+m[2][0])/s;\nq.y=(m[1][2]+m[2][1])/s;\nq.z=0.25*s;\n}\nreturn q;\n}\nvec3 mat3ToEuler(mat3 m){\nfloat m11=m[0][0],m12=m[1][0],m13=m[2][0];\nfloat m21=m[0][1],m22=m[1][1],m23=m[2][1];\nfloat m31=m[0][2],m32=m[1][2],m33=m[2][2];\nvec3 euler;\neuler.y=asin(clamp(m13,-1.0,1.0));\nif (abs(m13)<0.9999999){\neuler.x=atan(-m23,m33);\neuler.z=atan(-m12,m11);\n} else {\neuler.x=atan(m32,m22);\neuler.z=0.0;\n}\nreturn euler;\n}\nvoid decomposeMat4(mat4 m,out vec3 position,out vec4 quat,out vec3 euler,out vec3 scale){\nfloat sx=length(vec3(m[0][0],m[0][1],m[0][2]));\nfloat sy=length(vec3(m[1][0],m[1][1],m[1][2]));\nfloat sz=length(vec3(m[2][0],m[2][1],m[2][2]));\nfloat det=mat3GetDeterminant(toMat3(m));\nif (det<0.0)\nsx=-sx;\nposition.x=m[3][0];\nposition.y=m[3][1];\nposition.z=m[3][2];\nfloat invSX=1.0/sx;\nfloat invSY=1.0/sy;\nfloat invSZ=1.0/sz;\nm[0][0]*=invSX;\nm[0][1]*=invSX;\nm[0][2]*=invSX;\nm[1][0]*=invSY;\nm[1][1]*=invSY;\nm[1][2]*=invSY;\nm[2][0]*=invSZ;\nm[2][1]*=invSZ;\nm[2][2]*=invSZ;\nquat=mat3ToQuat(toMat3(m));\neuler=mat3ToEuler(toMat3(m));\nscale.x=sx;\nscale.y=sy;\nscale.z=sz;\n}\nvoid node_decompose_matrix(mat4 inputMatrix,out vec4 outputQuat,out vec3 outputRotate,out vec3 outputScale,out vec3 outputShear,out vec3 outputTranslate)\n{\ndecomposeMat4(inputMatrix,outputTranslate,outputQuat,outputRotate,outputScale);\noutputShear=vec3(0.0,0.0,0.0);\n}",node_env_sphere_my_frag:"void node_env_sphere(sampler2D envMap,int encoding,vec3 normal,mat4 placementMatrix,out float outAlpha,out vec3 outColor)\n{\nvec3 cameraToVertex=normalize(vWorldPosition-cameraPosition);\nvec3 reflectVec;\n#if WORLD_NODES\nreflectVec=normalize(cameraToVertex);\n#else\nvec3 worldNormal=inverseTransformDirection(normal,viewMatrix);\nreflectVec=reflect(cameraToVertex,worldNormal);\n#endif\nmat3 uvTransform=mat3(1.0);\nreflectVec=toMat3(placementMatrix)*reflectVec;\nvec4 tex=sampleEquirectangular(envMap,reflectVec,uvTransform,encoding);\noutAlpha=tex.a;\noutColor=tex.rgb;\n}",node_file_my_frag:"void node_file(sampler2D ima,const int encoding,const bool rgbToAlpha,vec2 uvCoord,out float outAlpha,out vec3 outColor,out vec2 outSize,out vec3 outTransparency){\nvec2 uv=vec2(uvCoord.x,1.0-uvCoord.y);\nvec4 tex=texture2D(ima,uv);\noutColor=nodeTexelToLinear(tex,encoding).rgb;\nif (rgbToAlpha)\noutAlpha=dot(tex.rgb,LUM_WEIGHTS_MAYA);\nelse\noutAlpha=tex.a;\noutSize=vec2(0.0);\noutTransparency=vec3(1.0-outAlpha,1.0-outAlpha,1.0-outAlpha);\n}",node_float_condition_my_frag:"void node_float_condition(bool condition,float floatA,float floatB,out float outFloat){\noutFloat=condition?floatA:floatB;\n}",node_float_composite_my_frag:"void node_float_composite(int operation,float floatA,float floatB,float factor,out float outFloat)\n{\nif (factor<=0.0){\noutFloat=floatA;\nreturn;\n}\nif (operation==0){\noutFloat=floatA+(floatB*factor);\n} else if (operation==1){\noutFloat=floatA+((floatB-1.0)*factor);\n} else if (operation==2){\nif (factor>=1.0){\noutFloat=floatB;\nreturn;\n}\noutFloat=mix(floatA,floatB,factor);\n} else if (operation==3){\noutFloat=floatA*(floatB*factor+(1.0-factor));\n} else if (operation==4){\noutFloat=1.0-((1.0-floatA)*(1.0-floatB*factor));\n} else if (operation==5){\noutFloat=floatB>0.5?(2.0*floatA*floatB*factor)+floatA*(1.0-factor):\n1.0-((1.0-floatA)*(1.0-floatB*factor))*(2.0-(1.0-factor));\n} else if (operation==6){\noutFloat=abs(floatA-(floatB*factor));\n} else if (operation==7){\noutFloat=clamp(mix(floatA,floatA/max(1.0-floatB,0.00001),factor),floatA,floatB);\n} else if (operation==8){\noutFloat=clamp(mix(floatA,1.0-(floatA/max(1.0-floatB,0.00001)),factor),floatA,floatB);\n}\n}",node_float_constant_my_frag:"void node_float_constant(float value,out float outValue)\n{\noutValue=value;\n}",node_float_logic_my_frag:"void node_float_logic(int operation,float floatA,float floatB,out bool outBool){\nif (operation==0){\noutBool=(floatA==floatB);\n} else if (operation==1){\noutBool=(floatA != floatB);\n} else if (operation==2){\noutBool=(floatA<floatB);\n} else if (operation==3){\noutBool=(floatA>floatB);\n} else if (operation==4){\noutBool=(floatA<=floatB);\n} else {\noutBool=(floatA>=floatB);\n}\n}",node_float_mask_my_frag:"void node_float_mask(float inFloat,float mask,out float outFloat){\noutFloat=inFloat-mask;\n}",node_float_math_my_frag:"void node_float_math(int operation,float floatA,float floatB,out float outFloat){\nif (operation==0){\noutFloat=floatA+floatB;\n} else if (operation==1){\noutFloat=floatA-floatB;\n} else if (operation==2){\noutFloat=floatA*floatB;\n} else if (operation==3){\noutFloat=floatA/floatB;\n} else if (operation==4){\noutFloat=min(floatA,floatB);\n} else if (operation==5){\noutFloat=max(floatA,floatB);\n} else {\noutFloat=pow(floatA,floatB);\n}\n}",node_four_by_four_matrix_my_frag:"void node_four_by_four_matrix(float in00,float in01,float in02,float in03,float in10,float in11,float in12,float in13,float in20,float in21,float in22,float in23,float in30,float in31,float in32,float in33,out mat4 outMatrix)\n{\noutMatrix=mat4(in00,in01,in02,in03,in10,in11,in12,in13,in20,in21,in22,in23,in30,in31,in32,in33);\n}",node_gamma_correct_my_frag:"void node_gamma_correct(vec3 gamma,vec3 value,out vec3 outValue){\noutValue=pow(value,1.0/gamma);\n}",node_grid_my_frag:"void node_grid(float contrast,vec3 fillerColor,vec3 lineColor,float uWidth,float vWidth,vec2 uvCoord,out float outAlpha,out vec3 outColor){\nuvCoord=fract(uvCoord);\nfloat v0=max(uvCoord.y,0.5*vWidth);\nfloat v1=min(uvCoord.y,1.0-0.5*vWidth);\nfloat u0=max(uvCoord.x,0.5*uWidth);\nfloat u1=min(uvCoord.x,1.0-0.5*uWidth);\nfloat gridFactor=(v0<=v1&&u0<=u1)?1.0:0.0;\ngridFactor=0.5-contrast*(gridFactor-0.5);\ngridFactor=max(gridFactor,0.0);\nvec3 gridColor=mix(fillerColor,lineColor,gridFactor);\ngridColor.r=max(gridColor.r,0.0);\ngridColor.g=max(gridColor.g,0.0);\ngridColor.b=max(gridColor.b,0.0);\noutAlpha=saturate(gridFactor);\noutColor=gridColor;\n}",node_inverse_matrix_my_frag:"\nmat4 inverseMat4(mat4 m){\nfloat a00=m[0][0],a01=m[0][1],a02=m[0][2],a03=m[0][3],a10=m[1][0],a11=m[1][1],a12=m[1][2],a13=m[1][3],a20=m[2][0],a21=m[2][1],a22=m[2][2],a23=m[2][3],a30=m[3][0],a31=m[3][1],a32=m[3][2],a33=m[3][3];\nfloat b00=a00*a11-a01*a10,b01=a00*a12-a02*a10,b02=a00*a13-a03*a10,b03=a01*a12-a02*a11,b04=a01*a13-a03*a11,b05=a02*a13-a03*a12,b06=a20*a31-a21*a30,b07=a20*a32-a22*a30,b08=a20*a33-a23*a30,b09=a21*a32-a22*a31,b10=a21*a33-a23*a31,b11=a22*a33-a23*a32;\nfloat det=b00*b11-b01*b10+b02*b09+b03*b08-b04*b07+b05*b06;\nreturn mat4(a11*b11-a12*b10+a13*b09,a02*b10-a01*b11-a03*b09,a31*b05-a32*b04+a33*b03,a22*b04-a21*b05-a23*b03,a12*b08-a10*b11-a13*b07,a00*b11-a02*b08+a03*b07,a32*b02-a30*b05-a33*b01,a20*b05-a22*b02+a23*b01,a10*b10-a11*b08+a13*b06,a01*b08-a00*b10-a03*b06,a30*b04-a31*b02+a33*b00,a21*b02-a20*b04-a23*b00,a11*b07-a10*b09-a12*b06,a00*b09-a01*b07+a02*b06,a31*b01-a30*b03-a32*b00,a20*b03-a21*b01+a22*b00)/det;\n}\nvoid node_inverse_matrix(mat4 inputMatrix,out mat4 outputMatrix)\n{\noutputMatrix=inverseMat4(inputMatrix);\n}",node_lambert_my_frag:"void node_lambert(vec3 geometryNormal,vec3 color,vec3 ambientColor,vec3 incandescence,float matteOpacity,float diffuse,vec3 normal,float translucence,vec3 transparency,out vec4 outColor){\nNodeMaterial material;\nmaterial.diffuseColor=diffuse*color.rgb;\nReflectedLight reflectedLight=ReflectedLight(vec3(0.0),vec3(0.0),vec3(0.0),vec3(0.0));\n#ifdef USE_CLEARCOAT\n#undef USE_CLEARCOAT\n#define _CLEARCOAT_RESTORE\n#endif\n#define RE_Direct RE_DirectDiffuseOnly_Node\n#define RE_IndirectDiffuse RE_IndirectDiffuse_Node\n#include <lights_fragment_begin>\n#include <lights_fragment_maps>\n#include <lights_fragment_end>\n#undef RE_Direct\n#undef RE_IndirectDiffuse\n#ifdef _CLEARCOAT_RESTORE\n#undef _CLEARCOAT_RESTORE\n#define USE_CLEARCOAT\n#endif\nfloat alpha=1.0-average(transparency);\noutColor=vec4(reflectedLight.directDiffuse+reflectedLight.indirectDiffuse+incandescence,alpha);\n}",node_layered_texture_layer_my_frag:"#define LAYER_BLEND_MODE_NONE 0.0\n#define LAYER_BLEND_MODE_OVER 1.0\n#define LAYER_BLEND_MODE_IN 2.0\n#define LAYER_BLEND_MODE_OUT 3.0\n#define LAYER_BLEND_MODE_ADD 4.0\n#define LAYER_BLEND_MODE_SUBTRACT 5.0\n#define LAYER_BLEND_MODE_MULTIPLY 6.0\n#define LAYER_BLEND_MODE_DIFFERENCE 7.0\n#define LAYER_BLEND_MODE_LIGHTEN 8.0\n#define LAYER_BLEND_MODE_DARKEN 9.0\n#define LAYER_BLEND_MODE_SATURATE 10.0\n#define LAYER_BLEND_MODE_DESATURATE 11.0\n#define LAYER_BLEND_MODE_ILLUMINATE 12.0\nvoid node_layered_texture_layer(const float alphaBG,const vec3 colorBG,const vec3 color,const float alpha,const float blendMode,const bool isVisible,out float outAlpha,out vec3 outColor)\n{\noutAlpha=alphaBG;\noutColor=colorBG;\nif (!isVisible)\nreturn;\nif (blendMode==LAYER_BLEND_MODE_NONE){\noutColor=color;\n} else if (blendMode==LAYER_BLEND_MODE_OVER){\noutColor=mix(colorBG,color,alpha);\n} else if (blendMode==LAYER_BLEND_MODE_IN){\noutColor=alpha*colorBG;\n} else if (blendMode==LAYER_BLEND_MODE_OUT){\noutColor=(1.0-alpha)*colorBG;\n} else if (blendMode==LAYER_BLEND_MODE_ADD){\noutColor=mix(colorBG,colorBG+color,alpha);\n} else if (blendMode==LAYER_BLEND_MODE_SUBTRACT){\noutColor=mix(colorBG,colorBG-color,alpha);\n} else if (blendMode==LAYER_BLEND_MODE_MULTIPLY){\noutColor=mix(colorBG,colorBG*color,alpha);\n} else {\noutColor=mix(colorBG,color,alpha);\n}\n}",node_luminance_my_frag:"void node_luminance(vec3 value,out float outValue){\noutValue=dot(value,LUM_WEIGHTS_MAYA);\n}",node_multiply_divide_my_frag:"void node_multiply_divide(int operation,vec3 input1,vec3 input2,out vec3 outValue){\nif (operation==0){\noutValue=input1;\n} else if (operation==1){\noutValue=input1*input2;\n} else if (operation==2){\n\noutValue=input1/input2;\n} else {\noutValue=pow(input1,input2);\n}\n}",node_mult_double_linear_my_frag:"void node_mult_double_linear(float input1,float input2,out float outValue){\noutValue=input1*input2;\n}",node_mult_matrix_my_frag:"\nvoid node_mult_matrix(mat4 matrixIn1,out mat4 matrixSum)\n{\nmatrixSum=matrixIn1;\n}\nvoid node_mult_matrix(mat4 matrixIn1,mat4 matrixIn2,out mat4 matrixSum)\n{\nmatrixSum=matrixIn2*matrixIn1;\n}\nvoid node_mult_matrix(mat4 matrixIn1,mat4 matrixIn2,mat4 matrixIn3,out mat4 matrixSum)\n{\nmatrixSum=matrixIn3*matrixIn2*matrixIn1;\n}",node_noise_my_frag:"vec2 calcNoiseImplode(float implode,vec2 implodeCenter,vec2 uv){\nif (abs(implode)>=EPSILON){\nuv-=implodeCenter;\nfloat len=length(uv);\nif (len>EPSILON){\nfloat factor=pow(len,1.0-implode)/len;\nuv*=factor;\n}\nuv+=implodeCenter;\n}\nreturn uv;\n}\nvoid node_noise(float amplitude,int depthMax,float frequency,float frequencyRatio,float implode,vec2 implodeCenter,bool inflection,float ratio,float threshold,float time,vec2 uvCoord,out float outAlpha,out vec3 outColor){\nuvCoord=calcNoiseImplode(implode,implodeCenter,uvCoord);\nfrequency*=0.6;\namplitude*=0.9;\nuvCoord*=frequency;\nfloat noiseAccum=0.0;\nvec2 freqOffset=vec2(0.02,0.3);\n#if __VERSION__==300\nfor (int depthId=0;depthId<depthMax;depthId++){\n#else\nfor (int depthId=0;depthId<3;depthId++){\n#endif\nint stepVal=depthId;\nfloat noise=noisePerlin(vec3(uvCoord+freqOffset,time+0.5*float(stepVal)));\nif (inflection)\nnoise=abs(noise);\nnoiseAccum+=amplitude*noise;\nuvCoord*=frequencyRatio;\ntime*=sqrt(frequencyRatio);\namplitude*=ratio;\nfreqOffset+=vec2(0.02,0.3);\n}\nif (!inflection)\nnoiseAccum=0.5*noiseAccum+0.5;\nnoiseAccum+=threshold;\noutAlpha=min(1.0,noiseAccum);\noutColor=vec3(outAlpha,outAlpha,outAlpha);\n}",node_openpbr_surface_my_frag:"void node_openpbr_surface(vec3 geometryNormal,const bool thinWalled,const float baseWeight,const vec3 baseColor,const float baseDiffuseRoughness,const float baseMetalness,const float specularWeight,const vec3 specularColor,const float specularRoughness,const float specularIOR,const float transmissionWeight,const vec3 transmissionColor,const float transmissionDepth,const vec3 transmissionScatter,const float fuzzWeight,const vec3 fuzzColor,const float fuzzRoughness,const float coatWeight,const vec3 coatColor,const float coatRoughness,const float emissionLuminance,const vec3 emissionColor,const float geometryOpacity,const vec3 normal,out vec4 outColor)\n{\nNodeMaterial material;\nvec3 baseColorWeighted=baseWeight*baseColor.rgb;\nmaterial.diffuseColor=baseColorWeighted*(1.0-baseMetalness)*(1.0-transmissionWeight);\nvec3 clearcoatNormal=normal;\n#ifdef USE_CLEARCOAT\nmaterial.clearcoat=saturate(coatWeight);\nmaterial.clearcoatRoughness=clamp(coatRoughness,0.0,1.0);\nmaterial.clearcoatF0=vec3(0.04);\nmaterial.clearcoatF90=1.0;\n#endif\n#ifdef USE_SHEEN\nmaterial.sheenColor=saturate(fuzzWeight*fuzzColor);\nmaterial.sheenRoughness=clamp(fuzzRoughness,0.0,1.0);\n#endif\nvec3 dxy=max(abs(dFdx(geometryNormal)),abs(dFdy(geometryNormal)));\nfloat geometryRoughness=max(max(dxy.x,dxy.y),dxy.z);\nmaterial.roughness=max(specularRoughness,0.0525);\nmaterial.roughness+=geometryRoughness;\nmaterial.roughness=min(material.roughness,1.0);\nvec3 specularColorWeighted=specularWeight*specularColor;\nvec3 dielRefl=pow2((1.0-specularIOR)/(1.0+specularIOR))*specularColorWeighted;\nmaterial.specularColor=mix(dielRefl,baseColorWeighted,baseMetalness);\nmaterial.fresnelRefl90=mix(specularColorWeighted,vec3(1.0),baseMetalness);\nmaterial.specularF90=average(material.fresnelRefl90);\nmaterial.refractionColor=pow(transmissionWeight*(1.0-baseMetalness)*transmissionColor.rgb,vec3(2.0));\nmaterial.refractionIOR=specularIOR;\nmaterial.refractionRoughness=material.roughness;\nReflectedLight reflectedLight=ReflectedLight(vec3(0.0),vec3(0.0),vec3(0.0),vec3(0.0));\nvec3 refractedLight=vec3(0.0);\n#ifdef USE_GTAO\nvec4 gtaoVisibilityBentNormal=texture2D(gtaoMap,gl_FragCoord.xy/currResolution);\nvec3 bentNormal=normalize(unpackRGBToNormal(gtaoVisibilityBentNormal.gba));\n#define PROBE_NORMAL bentNormal\n#endif\n#define RE_Direct RE_Direct_Node\n#define RE_IndirectDiffuse RE_IndirectDiffuse_Node\n#define RE_IndirectSpecular RE_IndirectSpecular_Node\n#define RE_Refraction RE_Refraction_Node\n#include <lights_fragment_begin>\n#include <lights_fragment_maps>\n#include <lights_fragment_end>\n#undef RE_Direct\n#undef RE_IndirectDiffuse\n#undef RE_IndirectSpecular\n#undef RE_Refraction\n#ifdef PROBE_NORMAL\n#undef PROBE_NORMAL\n#endif\n#ifdef USE_GTAO\nreflectedLight.indirectDiffuse*=gtaoVisibilityBentNormal.r;\nfloat gtaoVisibility=gtaoVisibilityBentNormal.r;\nvec3 gtaoBentNormal=bentNormal;\nvec3 gtaoViewDir=geometry.viewDir;\nvec3 gtaoNormal=normal;\nfloat gtaoRoughness=material.roughness;\n#endif\n#include <lights_fragment_gtso>\nvec3 totalEmissiveRadiance=emissionLuminance*OPENPBR_EMISSION_LUM_FACTOR*emissionColor;\nvec3 outSpecular=reflectedLight.directSpecular+reflectedLight.indirectSpecular;\nvec3 outColor3=reflectedLight.directDiffuse+reflectedLight.indirectDiffuse +\noutSpecular+totalEmissiveRadiance;\n#ifdef USE_SHEEN\nfloat sheenEnergyComp=1.0-0.157*max3(material.sheenColor);\noutColor3=outColor3*sheenEnergyComp+sheenSpecular;\n#endif\n#ifdef USE_CLEARCOAT\nfloat dotNVcc=saturate(dot(geometry.normal,geometry.viewDir));\nvec3 Fcc=F_Schlick(material.clearcoatF0,material.clearcoatF90,dotNVcc);\noutColor3=outColor3*(1.0-material.clearcoat*Fcc)+clearcoatSpecular*material.clearcoat;\n#endif\nfloat alpha=1.0;\nif (thinWalled){\nalpha=geometryOpacity*(1.0-saturate(transmissionWeight)+maxFromRGB(outSpecular)*saturate(transmissionWeight));\n} else {\noutColor3+=refractedLight;\n}\noutColor=vec4(outColor3,saturate(alpha));\n}",node_output_my_frag:"void node_output(vec4 rgb,out vec4 outgoingLight)\n{\noutgoingLight=rgb;\n}",node_place_2d_texture_my_frag:"void node_place_2d_texture(const vec2 inUv,vec2 offset,vec2 repeatUv,float rotateUv,out vec2 outUv)\n{\noutUv=(calcUvTransform(offset.x,offset.y,repeatUv.x,repeatUv.y,rotateUv)*vec3(inUv,1.0)).xy;\noutUv.y=1.0-outUv.y;\n}",node_phong_my_frag:"void node_phong(vec3 geometryNormal,vec3 color,vec3 ambientColor,vec3 incandescence,float matteOpacity,float diffuse,vec3 normal,float reflectivity,vec3 reflectedColor,float cosinePower,vec3 specularColor,float translucence,vec3 transparency,out vec4 outColor){\nNodeMaterial material;\nmaterial.diffuseColor=diffuse*color;\n#ifdef USE_CLEARCOAT\n#undef USE_CLEARCOAT\n#define _CLEARCOAT_RESTORE\n#endif\nvec3 dxy=max(abs(dFdx(geometryNormal)),abs(dFdy(geometryNormal)));\nfloat geometryRoughness=max(max(dxy.x,dxy.y),dxy.z);\nfloat roughness=sqrt(1.0/(0.454*cosinePower+3.357));\nmaterial.roughness=max(roughness,0.0525);\nmaterial.roughness+=geometryRoughness;\nmaterial.roughness=min(material.roughness,1.0);\nmaterial.specularColor=specularColor;\nReflectedLight reflectedLight=ReflectedLight(vec3(0.0),vec3(0.0),vec3(0.0),vec3(0.0));\n#define RE_Direct RE_Direct_Node\n#define RE_IndirectDiffuse RE_IndirectDiffuse_Node\n#define RE_IndirectSpecular RE_IndirectSpecular_Node\n#include <lights_fragment_begin>\n#include <lights_fragment_maps>\n#include <lights_fragment_end>\n#undef RE_Direct\n#undef RE_IndirectDiffuse\n#undef RE_IndirectSpecular\n#ifdef _CLEARCOAT_RESTORE\n#undef _CLEARCOAT_RESTORE\n#define USE_CLEARCOAT\n#endif\nfloat alpha=1.0-average(transparency);\noutColor=vec4(reflectedLight.directDiffuse+reflectedLight.indirectDiffuse +\nreflectedLight.directSpecular+reflectedLight.indirectSpecular+incandescence,alpha);\n}",node_phong_e_my_frag:"void node_phong_e(vec3 geometryNormal,vec3 color,vec3 ambientColor,vec3 incandescence,float matteOpacity,float diffuse,vec3 normal,float reflectivity,vec3 reflectedColor,float highlightSize,float roughness,vec3 specularColor,float translucence,vec3 transparency,out vec4 outColor){\nNodeMaterial material;\nmaterial.diffuseColor=diffuse*color;\n#ifdef USE_CLEARCOAT\n#undef USE_CLEARCOAT\n#define _CLEARCOAT_RESTORE\n#endif\nvec3 dxy=max(abs(dFdx(geometryNormal)),abs(dFdy(geometryNormal)));\nfloat geometryRoughness=max(max(dxy.x,dxy.y),dxy.z);\nmaterial.roughness=max(roughness,0.0525);\nmaterial.roughness+=geometryRoughness;\nmaterial.roughness=min(material.roughness,1.0);\nmaterial.specularColor=specularColor;\nReflectedLight reflectedLight=ReflectedLight(vec3(0.0),vec3(0.0),vec3(0.0),vec3(0.0));\n#define RE_Direct RE_Direct_Node\n#define RE_IndirectDiffuse RE_IndirectDiffuse_Node\n#define RE_IndirectSpecular RE_IndirectSpecular_Node\n#include <lights_fragment_begin>\n#include <lights_fragment_maps>\n#include <lights_fragment_end>\n#undef RE_Direct\n#undef RE_IndirectDiffuse\n#undef RE_IndirectSpecular\n#ifdef _CLEARCOAT_RESTORE\n#undef _CLEARCOAT_RESTORE\n#define USE_CLEARCOAT\n#endif\nfloat alpha=1.0-average(transparency);\noutColor=vec4(reflectedLight.directDiffuse+reflectedLight.indirectDiffuse +\nreflectedLight.directSpecular+reflectedLight.indirectSpecular+incandescence,alpha);\n}",node_premultiply_my_frag:"void node_premultiply(float inAlpha,vec3 inColor,out float outAlpha,out vec3 outColor){\noutColor=inColor*inAlpha;\noutAlpha=inAlpha;\n}",node_ramp_my_frag:"#define RAMP_WRAP_REPEAT 1000\n#define RAMP_WRAP_CLAMP_TO_EDGE 1001\n#define RAMP_WRAP_MIRROR 1002\nfloat applyWrap(float coord,int wrap){\nif (coord<0.0||coord>1.0){\nif (wrap==RAMP_WRAP_REPEAT)\ncoord=mod(coord,1.0);\nelse if (wrap==RAMP_WRAP_CLAMP_TO_EDGE)\ncoord=clamp(coord,0.0,1.0);\nelse if (wrap==RAMP_WRAP_MIRROR){\nif (mod(floor(coord),2.0)==0.0)\ncoord=coord-floor(coord);\nelse\ncoord=1.0-(coord-floor(coord));\n}\n}\nreturn coord;\n}\nvoid node_ramp(sampler2D rampData,int rampType,int wrapU,int wrapV,vec2 uvCoord,out float outAlpha,out vec3 outColor)\n{\nuvCoord.x=applyWrap(uvCoord.x,wrapU);\nuvCoord.y=applyWrap(uvCoord.y,wrapV);\nfloat coord;\nif (rampType==0){\ncoord=uvCoord.y;\n} else if (rampType==1){\ncoord=uvCoord.x;\n} else if (rampType==2){\ncoord=abs(uvCoord.x+uvCoord.y)/2.0;\n} else if (rampType==3){\nvec2 uvSpiral=mat2(0.0,1.0,1.0,0.0)*(uvCoord-vec2(0.5));\ncoord=atan(uvSpiral.y,uvSpiral.x)/PI2+0.5;\n} else if (rampType==4){\ncoord=length(uvCoord-vec2(0.5))*sqrt(2.0);\n} else if (rampType==5){\nvec2 boxUv=abs(uvCoord-vec2(0.5))*2.0;\ncoord=max(boxUv.x,boxUv.y);\n} else if (rampType==6){\nuvCoord=abs((uvCoord-vec2(0.5))*2.0);\ncoord=uvCoord.y;\n} else if (rampType==7){\ncoord=uvCoord.y;\n} else {\ncoord=uvCoord.y;\n}\nfloat offset=0.5/float(RAMP_TEX_SIZE);\nfloat scale=1.0-(1.0/float(RAMP_TEX_SIZE));\ncoord=coord*scale+offset;\nvec4 tex=texture2D(rampData,vec2(coord,0.0));\noutAlpha=average(tex.xyz);\noutColor=tex.xyz;\n}",node_remap_hsv_my_frag:"void node_remap_hsv(vec3 color,out vec3 outColor)\n{\noutColor=color;\n}",node_reverse_my_frag:"void node_reverse(vec3 inValue,out vec3 outValue){\noutValue=1.0-inValue;\n}",node_sampler_info_my_frag:"void node_sampler_info(float frontFacing,vec4 tangent,vec2 uv,vec3 viewNorm,out float facingRatio,out bool flippedNormal,out mat4 matrixEyeToWorld,out vec3 normalCamera,out vec2 pixelCenter,out vec3 pointCamera,out vec3 pointObj,out vec3 pointWorld,out vec3 tangentUCamera,out vec3 tangentVCamera,out vec2 uvCoord)\n{\nvec4 worldPos=invViewMatrix*vec4(-vViewPosition,1.0);\nfacingRatio=dot(normalize(viewNorm),normalize(vViewPosition));\nflippedNormal=(frontFacing>0.0);\nmatrixEyeToWorld=invViewMatrix;\nnormalCamera=viewNorm;\npixelCenter=vec2(1.0);\npointCamera=-vViewPosition*UNITS_SCALE_FACTOR;\npointObj=(invModelMatrix*worldPos).xyz*UNITS_SCALE_FACTOR;\npointWorld=worldPos.xyz*UNITS_SCALE_FACTOR;\ntangentUCamera=normalize((modelViewMatrix*vec4(tangent.xyz,0.0)).xyz);\ntangentVCamera=tangent.w*cross(viewNorm,tangentUCamera);\nuvCoord=vec2(uv.x,1.0-uv.y);\n}",node_set_range_my_frag:"void node_set_range(vec3 maxValue,vec3 minValue,vec3 oldMax,vec3 oldMin,vec3 value,out vec3 outValue){\noutValue=minValue+(((value-oldMin)/(oldMax-oldMin))*(maxValue-minValue));\n}",node_shading_engine_my_frag:"void node_shading_engine(vec4 surface,vec4 volume,vec3 displacement,out vec4 outgoingLight){\noutgoingLight=surface+volume;\n}",node_sub_transform_my_frag:"#define COORD_WORLD_SPACE 0\n#define COORD_OBJECT_SPACE 1\nvoid node_sub_transform(const int coordSpace,vec3 scale,vec3 rotate,vec3 offset,out vec3 outVector,out vec3 outNormal)\n{\nvec3 norm=vNormal;\nnorm=(invViewMatrix*vec4(norm,0.0)).xyz;\nvec3 vector=vWorldPosition.xyz;\nif (coordSpace==COORD_OBJECT_SPACE){\nvector=(invModelMatrix*vec4(vector,1.0)).xyz;\nnorm=(invModelMatrix*vec4(norm,0.0)).xyz;\n}\nvector-=offset;\nvector*=scale;\nmat3 rotX=mat3RotateX(radians(rotate.x));\nmat3 rotY=mat3RotateY(radians(-rotate.y));\nmat3 rotZ=mat3RotateZ(radians(rotate.z));\nmat3 rotMat=rotX*rotY*rotZ;\nvector=rotMat*vector;\nnorm=rotMat*norm;\noutVector=vector;\noutNormal=normalize(norm);\n}",node_surface_shader_my_frag:"void node_surface_shader(vec3 color,vec3 glowColor,vec3 matteOpacity,vec3 transparency,out vec4 outColor,out vec3 outGlowColor,out vec3 outMatteOpacity,out vec3 outTransparency)\n{\noutColor=vec4(color,saturate(1.0-average(transparency)));\noutGlowColor=glowColor;\noutMatteOpacity=matteOpacity;\noutTransparency=transparency;\n}\nvoid node_surface_shader(vec3 color,vec3 glowColor,vec3 matteOpacity,vec3 transparency,out vec3 outColor,out vec3 outGlowColor,out vec3 outMatteOpacity,out vec3 outTransparency)\n{\noutColor=color;\noutGlowColor=glowColor;\noutMatteOpacity=matteOpacity;\noutTransparency=transparency;\n}",node_transform_my_frag:"void node_transform(out vec3 center,out mat4 inverseMatrix,out mat4 matrix,out mat4 parentInverseMatrix,out mat4 parentMatrix,out mat4 worldInverseMatrix,out mat4 worldMatrix,out mat4 xformMatrix)\n{\ncenter=modelMatrix[3].xyz;\ninverseMatrix=invModelMatrix;\nmatrix=modelMatrix;\nparentInverseMatrix=mat4(1.0);\nparentMatrix=mat4(1.0);\nworldInverseMatrix=invModelMatrix;\nworldMatrix=modelMatrix;\nxformMatrix=matrix;\n}",node_transpose_matrix_my_frag:"mat4 transposeMat4(mat4 m){\nreturn mat4(vec4(m[0].x,m[1].x,m[2].x,m[3].x),vec4(m[0].y,m[1].y,m[2].y,m[3].y),vec4(m[0].z,m[1].z,m[2].z,m[3].z),vec4(m[0].w,m[1].w,m[2].w,m[3].w));\n}\nvoid node_transpose_matrix(mat4 inputMatrix,out mat4 outputMatrix)\n{\noutputMatrix=transposeMat4(inputMatrix);\n}",node_unit_conversion_my_frag:"void node_unit_conversion(float conversionFactor,float inInput,out float outOutput)\n{\noutOutput=conversionFactor*inInput;\n}\nvoid node_unit_conversion(float conversionFactor,vec3 inInput,out vec3 outOutput)\n{\noutOutput=conversionFactor*inInput;\n}",node_unpremultiply_my_frag:"void node_unpremultiply(float inAlpha,vec3 inColor,out float outAlpha,out vec3 outColor){\noutColor=inColor/inAlpha;\noutAlpha=inAlpha;\n}",node_vector_product_my_frag:"void node_vector_product(const int operation,const bool normalizeOutput,vec3 input1,vec3 input2,mat4 matrix,out vec3 outVector){\nif (operation==0){\noutVector=input1;\n} else if (operation==1){\nif (normalizeOutput){\ninput1=normalize(input1);\ninput2=normalize(input2);\n}\noutVector=vec3(dot(input1,input2));\n} else if (operation==2){\noutVector=cross(input1,input2);\n} else if (operation==3){\noutVector=(matrix*vec4(input1,0.0)).xyz;\n} else {\noutVector=(matrix*vec4(input1,1.0)).xyz;\n}\n\nif (operation>1&&normalizeOutput)\noutVector=normalize(outVector);\n}",node_wt_add_matrix_my_frag:"void node_wt_add_matrix(mat4 matrixIn1,float weightIn1,out mat4 matrixSum)\n{\nmatrixSum=weightIn1*matrixIn1;\n}\nvoid node_wt_add_matrix(mat4 matrixIn1,float weightIn1,mat4 matrixIn2,float weightIn2,out mat4 matrixSum)\n{\nmatrixSum=weightIn1*matrixIn1+weightIn2*matrixIn2;\n}\nvoid node_wt_add_matrix(mat4 matrixIn1,float weightIn1,mat4 matrixIn2,float weightIn2,mat4 matrixIn3,float weightIn3,out mat4 matrixSum)\n{\nmatrixSum=weightIn1*matrixIn1+weightIn2*matrixIn2+weightIn3*matrixIn3;\n}",pmrem_common_vert:"precision mediump float;\nprecision mediump int;\nattribute vec3 position;\nattribute vec2 uv;\nattribute float faceIndex;\nvarying vec3 vOutputDirection;\nvec3 getDirection(vec2 uv,float face){\nuv=2.0*uv-1.0;\nvec3 direction=vec3(uv,1.0);\nif (face==0.0){\ndirection=direction.zyx;\ndirection.z*=-1.0;\n} else if (face==1.0){\ndirection=direction.xzy;\ndirection.z*=-1.0;\n} else if (face==3.0){\ndirection=direction.zyx;\ndirection.x*=-1.0;\n} else if (face==4.0){\ndirection=direction.xzy;\ndirection.y*=-1.0;\n} else if (face==5.0){\ndirection.xz*=-1.0;\n}\nreturn direction;\n}\nvoid main(){\nvOutputDirection=getDirection(uv,faceIndex);\ngl_Position=vec4(position,1.0);\n}",pmrem_blur_frag:"precision highp float;\nprecision highp int;\nvarying vec3 vOutputDirection;\nuniform sampler2D envMap;\nuniform int samples;\nuniform float weights[n];\nuniform bool latitudinal;\nuniform float dTheta;\nuniform float lodIdx;\nuniform vec3 poleAxis;\n#define ENVMAP_TYPE_CUBE_UV\n#include <cube_uv_reflection_fragment>\nvec3 getSample(float theta,vec3 axis){\nfloat cosTheta=cos(theta);\nvec3 sampleDirection=vOutputDirection*cosTheta\n+ cross(axis,vOutputDirection)*sin(theta)\n+ axis*dot(axis,vOutputDirection)*(1.0-cosTheta);\nreturn bilinearCubeUV(envMap,sampleDirection,lodIdx);\n}\nvoid main(){\nvec3 axis=latitudinal?poleAxis:cross(poleAxis,vOutputDirection);\nif (all(equal(axis,vec3(0.0)))){\naxis=vec3(vOutputDirection.z,0.0,-vOutputDirection.x);\n}\naxis=normalize(axis);\ngl_FragColor=vec4(0.0);\ngl_FragColor.rgb+=weights[0]*getSample(0.0,axis);\nfor (int i=1;i<n;i++){\nif (i>=samples){\nbreak;\n}\nfloat theta=dTheta*float(i);\ngl_FragColor.rgb+=weights[i]*getSample(-1.0*theta,axis);\ngl_FragColor.rgb+=weights[i]*getSample(theta,axis);\n}\n}",pmrem_cubemap_frag:"precision mediump float;\nprecision mediump int;\nuniform bool flipCubemapX;\nuniform samplerCube envMap;\nvarying vec3 vOutputDirection;\nvoid main(){\ngl_FragColor=textureCube(envMap,vec3(vOutputDirection.x*(flipCubemapX?-1.0:1.0),vOutputDirection.yz));\n}",pmrem_equirect_frag:"precision mediump float;\nprecision mediump int;\nvarying vec3 vOutputDirection;\nuniform sampler2D envMap;\nuniform vec2 texelSize;\n#define RECIPROCAL_PI 0.31830988618\n#define RECIPROCAL_PI2 0.15915494\nvoid main(){\ngl_FragColor=vec4(0.0);\nvec3 outputDirection=normalize(vOutputDirection);\nvec2 uv;\nuv.y=asin(clamp(outputDirection.y,-1.0,1.0))*RECIPROCAL_PI+0.5;\nuv.x=atan(outputDirection.z,outputDirection.x)*RECIPROCAL_PI2+0.5;\nvec2 f=fract(uv/texelSize-0.5);\nuv-=f*texelSize;\nvec3 tl=texture2D(envMap,uv).rgb;\nuv.x+=texelSize.x;\nvec3 tr=texture2D(envMap,uv).rgb;\nuv.y+=texelSize.y;\nvec3 br=texture2D(envMap,uv).rgb;\nuv.x-=texelSize.x;\nvec3 bl=texture2D(envMap,uv).rgb;\nvec3 tm=mix(tl,tr,f.x);\nvec3 bm=mix(bl,br,f.x);\ngl_FragColor.rgb=mix(tm,bm,f.y);\n}",pp_plane_vert:"varying vec2 vUv;\nvoid main(){\nvUv=uv;\ngl_Position=projectionMatrix*modelViewMatrix*vec4(position,1.0);\n}",pp_afterimage_frag:"uniform float damp;\nuniform sampler2D tOld;\nuniform sampler2D tNew;\nvarying vec2 vUv;\nvec4 when_gt(vec4 x,float y){\nreturn max(sign(x-y),0.0);\n}\nvoid main(){\nvec4 texelOld=texture(tOld,vUv);\nvec4 texelNew=texture(tNew,vUv);\n\ntexelOld*=damp*when_gt(texelOld,0.1);\ngl_FragColor=max(texelNew,texelOld);\n}",pp_bloom_composite_frag:"varying vec2 vUv;\nuniform sampler2D blurTexture1;\nuniform sampler2D blurTexture2;\nuniform sampler2D blurTexture3;\nuniform sampler2D blurTexture4;\nuniform sampler2D blurTexture5;\nuniform sampler2D dirtTexture;\nuniform float bloomStrength;\nuniform float bloomRadius;\nuniform float bloomFactors[NUM_MIPS];\nuniform vec3 bloomTintColors[NUM_MIPS];\nfloat lerpBloomFactor(const in float factor){\nfloat mirrorFactor=1.2-factor;\nreturn mix(factor,mirrorFactor,bloomRadius);\n}\nvoid main(){\ngl_FragColor=bloomStrength*(lerpBloomFactor(bloomFactors[0])*vec4(bloomTintColors[0],1.0)*texture(blurTexture1,vUv)+\nlerpBloomFactor(bloomFactors[1])*vec4(bloomTintColors[1],1.0)*texture(blurTexture2,vUv)+\nlerpBloomFactor(bloomFactors[2])*vec4(bloomTintColors[2],1.0)*texture(blurTexture3,vUv)+\nlerpBloomFactor(bloomFactors[3])*vec4(bloomTintColors[3],1.0)*texture(blurTexture4,vUv)+\nlerpBloomFactor(bloomFactors[4])*vec4(bloomTintColors[4],1.0)*texture(blurTexture5,vUv)\n);\n}",pp_bloom_lum_high_pass_frag:"uniform sampler2D tDiffuse;\nuniform vec3 defaultColor;\nuniform float defaultOpacity;\nuniform float luminosityThreshold;\nuniform float smoothWidth;\nvarying vec2 vUv;\nvoid main(){\nvec4 texel=texture(tDiffuse,vUv);\nvec3 luma=vec3(0.299,0.587,0.114);\nfloat v=dot(texel.xyz,luma);\nvec4 outputColor=vec4(defaultColor.rgb,defaultOpacity);\nfloat alpha=smoothstep(luminosityThreshold,luminosityThreshold+smoothWidth,v);\ngl_FragColor=mix(outputColor,texel,alpha);\ngl_FragColor=clamp(gl_FragColor,0.0,10.0);\n}",pp_bloom_separable_blur_frag:"#include <common>\nvarying vec2 vUv;\nuniform sampler2D colorTexture;\nuniform vec2 texSize;\nuniform vec2 direction;\nuniform int kernelRadius;\nuniform float sigma;\nfloat gaussianPdf(const float x,const float sigma){\nreturn 0.39894*exp(-0.5*x*x/(sigma*sigma))/sigma;\n}\nvoid main(){\nvec2 invSize=1.0/texSize;\nfloat weightSum=gaussianPdf(0.0,sigma);\nvec3 diffuseSum=texture(colorTexture,vUv).rgb*weightSum;\nfor (int i=1;i<kernelRadius;i++){\nfloat x=float(i);\nfloat w=gaussianPdf(x,sigma);\nvec2 uvOffset=direction*invSize*x;\nvec3 sample1=texture(colorTexture,vUv+uvOffset).rgb;\nvec3 sample2=texture(colorTexture,vUv-uvOffset).rgb;\ndiffuseSum+=(sample1+sample2)*w;\nweightSum+=2.0*w;\n}\ngl_FragColor=vec4(diffuseSum/weightSum,1.0);\n}",pp_blur_frag:"#include <common>\nvarying vec2 vUv;\nuniform sampler2D colorTexture;\nuniform vec2 texSize;\nuniform vec2 direction;\nuniform float kernelRadius;\nfloat gaussianPdf(in float x,in float sigma){\nreturn 0.39894*exp(-0.5*x*x/(sigma*sigma))/sigma;\n}\nvoid main(){\nvec2 invSize=1.0/texSize;\nfloat weightSum=gaussianPdf(0.0,kernelRadius);\n#if LOG_SPACE==1\nfloat origDiffuse=texture2D(colorTexture,vUv).r;\nfloat diffuseSum=weightSum;\n#else\nfloat diffuseSum=texture2D(colorTexture,vUv).r*weightSum;\n#endif\nvec2 delta=direction*invSize*kernelRadius/float(MAX_SAMPLE_RADIUS);\nvec2 uvOffset=delta;\n#if OCTAHEDRAL_MAP==1\nvec3 cubeDir=normalize(octUVToCubeVec(vUv,invSize));\nvec3 dirX=normalize(abs(cubeDir.y)<0.99999?vec3(cubeDir.z,0.0,-cubeDir.x)\n: vec3(0.0,-cubeDir.z,cubeDir.y));\nvec3 dirY=cross(cubeDir,dirX);\n#endif\n#pragma unroll_loop\nfor (int i=1;i<=MAX_SAMPLE_RADIUS;i++){\nfloat w=gaussianPdf(uvOffset.x,kernelRadius);\n#if OCTAHEDRAL_MAP==1\nvec3 cubeOffset=uvOffset.x*dirX+uvOffset.y*dirY;\nvec2 uv1=cubeVecToOctUV(cubeDir+cubeOffset,invSize);\nvec2 uv2=cubeVecToOctUV(cubeDir-cubeOffset,invSize);\n#else\nvec2 uv1=vUv+uvOffset;\nvec2 uv2=vUv-uvOffset;\n#endif\nfloat sample1=texture2D(colorTexture,uv1).r;\nfloat sample2=texture2D(colorTexture,uv2).r;\n#if LOG_SPACE==1\ndiffuseSum+=(clamp(exp(sample1-origDiffuse),0.0,1e38)+\nclamp(exp(sample2-origDiffuse),0.0,1e38)\n)*w;\n#else\ndiffuseSum+=((sample1+sample2)*w);\n#endif\nweightSum+=2.0*w;\nuvOffset+=delta;\n}\n#if LOG_SPACE==1\ngl_FragColor=vec4(origDiffuse+log(diffuseSum/weightSum),0.0,0.0,1.0);\n#else\ngl_FragColor=vec4(diffuseSum/weightSum,0.0,0.0,1.0);\n#endif\n}",pp_brightness_contrast_frag:"\nuniform sampler2D tDiffuse;\nuniform float brightness;\nuniform float contrast;\nvarying vec2 vUv;\nvoid main(){\nvec4 texel=texture(tDiffuse,vUv);\ntexel.rgb+=brightness;\nif (contrast>0.0)\ntexel.rgb=(texel.rgb-0.5)/(1.0-contrast)+0.5;\nelse\ntexel.rgb=(texel.rgb-0.5)*(1.0+contrast)+0.5;\ngl_FragColor=texel;\n}",pp_bokeh_frag:"#include <common>\nvarying vec2 vUv;\nuniform sampler2D tColor;\nuniform sampler2D tDepth;\nuniform float maxblur;\nuniform float aperture;\nuniform float nearClip;\nuniform float farClip;\nuniform float focus;\nuniform float aspect;\nuniform float depthLeakThreshold;\n#include <packing>\nfloat getDepth(const in vec2 screenPosition){\n#if DEPTH_PACKING==1\nreturn unpackRGBAToDepth(texture(tDepth,screenPosition));\n#else\nreturn texture(tDepth,screenPosition).x;\n#endif\n}\nfloat getViewZ(const in float depth){\n#if PERSPECTIVE_CAMERA==1\nreturn perspectiveDepthToViewZ(depth,nearClip,farClip);\n#else\nreturn orthoDepthToViewZ(depth,nearClip,farClip);\n#endif\n}\nvec4 blurSample(vec2 uvOffset,vec4 centerCol,float viewZCenter){\nfloat viewZ=-getViewZ(getDepth(vUv+uvOffset));\nfloat blurFactor=(viewZ>=viewZCenter)?1.0:\nmin(depthLeakThreshold*abs((focus-viewZ)/aperture),1.0);\nreturn mix(centerCol,texture(tColor,vUv+uvOffset),blurFactor);\n}\nvoid main(){\nvec2 aspectcorrect=vec2(1.0,aspect);\nfloat viewZ=-getViewZ(getDepth(vUv));\nfloat factor=abs(focus-viewZ);\n\nfloat dofblur=maxblur*min(factor/aperture,1.0);\nfloat dofblur9=dofblur*0.9;\nfloat dofblur7=dofblur*0.7;\nfloat dofblur4=dofblur*0.4;\nvec4 centerCol=texture(tColor,vUv);\nvec4 col=centerCol;\ncol+=blurSample((vec2( 0.0,0.4 )*aspectcorrect)*dofblur,centerCol,viewZ);\ncol+=blurSample((vec2( 0.15,0.37)*aspectcorrect)*dofblur,centerCol,viewZ);\ncol+=blurSample((vec2( 0.29,0.29)*aspectcorrect)*dofblur,centerCol,viewZ);\ncol+=blurSample((vec2(-0.37,0.15)*aspectcorrect)*dofblur,centerCol,viewZ);\ncol+=blurSample((vec2( 0.40,0.0 )*aspectcorrect)*dofblur,centerCol,viewZ);\ncol+=blurSample((vec2( 0.37,-0.15)*aspectcorrect)*dofblur,centerCol,viewZ);\ncol+=blurSample((vec2( 0.29,-0.29)*aspectcorrect)*dofblur,centerCol,viewZ);\ncol+=blurSample((vec2(-0.15,-0.37)*aspectcorrect)*dofblur,centerCol,viewZ);\ncol+=blurSample((vec2( 0.0,-0.4 )*aspectcorrect)*dofblur,centerCol,viewZ);\ncol+=blurSample((vec2(-0.15,0.37)*aspectcorrect)*dofblur,centerCol,viewZ);\ncol+=blurSample((vec2(-0.29,0.29)*aspectcorrect)*dofblur,centerCol,viewZ);\ncol+=blurSample((vec2( 0.37,0.15)*aspectcorrect)*dofblur,centerCol,viewZ);\ncol+=blurSample((vec2(-0.4,0.0 )*aspectcorrect)*dofblur,centerCol,viewZ);\ncol+=blurSample((vec2(-0.37,-0.15)*aspectcorrect)*dofblur,centerCol,viewZ);\ncol+=blurSample((vec2(-0.29,-0.29)*aspectcorrect)*dofblur,centerCol,viewZ);\ncol+=blurSample((vec2( 0.15,-0.37)*aspectcorrect)*dofblur,centerCol,viewZ);\n\ncol+=blurSample((vec2( 0.15,0.37)*aspectcorrect)*dofblur9,centerCol,viewZ);\ncol+=blurSample((vec2(-0.37,0.15)*aspectcorrect)*dofblur9,centerCol,viewZ);\ncol+=blurSample((vec2( 0.37,-0.15)*aspectcorrect)*dofblur9,centerCol,viewZ);\ncol+=blurSample((vec2(-0.15,-0.37)*aspectcorrect)*dofblur9,centerCol,viewZ);\ncol+=blurSample((vec2(-0.15,0.37)*aspectcorrect)*dofblur9,centerCol,viewZ);\ncol+=blurSample((vec2( 0.37,0.15)*aspectcorrect)*dofblur9,centerCol,viewZ);\ncol+=blurSample((vec2(-0.37,-0.15)*aspectcorrect)*dofblur9,centerCol,viewZ);\ncol+=blurSample((vec2( 0.15,-0.37)*aspectcorrect)*dofblur9,centerCol,viewZ);\n\ncol+=blurSample((vec2( 0.29,0.29)*aspectcorrect)*dofblur7,centerCol,viewZ);\ncol+=blurSample((vec2( 0.40,0.0 )*aspectcorrect)*dofblur7,centerCol,viewZ);\ncol+=blurSample((vec2( 0.29,-0.29)*aspectcorrect)*dofblur7,centerCol,viewZ);\ncol+=blurSample((vec2( 0.0,-0.4 )*aspectcorrect)*dofblur7,centerCol,viewZ);\ncol+=blurSample((vec2(-0.29,0.29)*aspectcorrect)*dofblur7,centerCol,viewZ);\ncol+=blurSample((vec2(-0.4,0.0 )*aspectcorrect)*dofblur7,centerCol,viewZ);\ncol+=blurSample((vec2(-0.29,-0.29)*aspectcorrect)*dofblur7,centerCol,viewZ);\ncol+=blurSample((vec2( 0.0,0.4 )*aspectcorrect)*dofblur7,centerCol,viewZ);\n\ncol+=blurSample((vec2( 0.29,0.29)*aspectcorrect)*dofblur4,centerCol,viewZ);\ncol+=blurSample((vec2( 0.4,0.0 )*aspectcorrect)*dofblur4,centerCol,viewZ);\ncol+=blurSample((vec2( 0.29,-0.29)*aspectcorrect)*dofblur4,centerCol,viewZ);\ncol+=blurSample((vec2( 0.0,-0.4 )*aspectcorrect)*dofblur4,centerCol,viewZ);\ncol+=blurSample((vec2(-0.29,0.29)*aspectcorrect)*dofblur4,centerCol,viewZ);\ncol+=blurSample((vec2(-0.4,0.0 )*aspectcorrect)*dofblur4,centerCol,viewZ);\ncol+=blurSample((vec2(-0.29,-0.29)*aspectcorrect)*dofblur4,centerCol,viewZ);\ncol+=blurSample((vec2( 0.0,0.4 )*aspectcorrect)*dofblur4,centerCol,viewZ);\ngl_FragColor=col/41.0;\ngl_FragColor.a=centerCol.a;\n}",pp_copy_frag:"uniform sampler2D tDiffuse;\nuniform float opacity;\nvarying vec2 vUv;\nvoid main(){\nvec4 texel=(texture2D(tDiffuse,vUv));\ngl_FragColor=opacity*texel;\n}",pp_cube_octahedral_proj_frag:"#include <common>\nuniform samplerCube tCube;\nuniform vec2 texelSize;\nvarying vec2 vUv;\nvoid main(){\ngl_FragColor=textureCube(tCube,octUVToCubeVec(gl_FragCoord.xy*texelSize,texelSize));\n}",pp_fxaa_frag:"\nprecision highp float;\nuniform sampler2D tDiffuse;\nuniform vec2 resolution;\nin vec2 vUv;\n#define FXAA_QUALITY_PS 5\n#define FXAA_QUALITY_P0 1.0\n#define FXAA_QUALITY_P1 1.5\n#define FXAA_QUALITY_P2 2.0\n#define FXAA_QUALITY_P3 4.0\n#define FXAA_QUALITY_P4 12.0\n#define FxaaTexTop(t,p)textureLod(t,p,0.0)\n#define FxaaTexOff(t,p,o,r)textureLodOffset(t,p,0.0,o)\nfloat FxaaLuma(vec4 rgba){return rgba.y;}\nvec4 FxaaPixelShader(vec2 pos,sampler2D tex,vec2 fxaaQualityRcpFrame,float fxaaQualitySubpix,float fxaaQualityEdgeThreshold,float fxaaQualityEdgeThresholdMin\n){\nvec2 posM;\nposM.x=pos.x;\nposM.y=pos.y;\nvec4 rgbyM=FxaaTexTop(tex,posM);\n#define lumaM rgbyM.y\nfloat lumaS=FxaaLuma(FxaaTexOff(tex,posM,ivec2(0,1),fxaaQualityRcpFrame.xy));\nfloat lumaE=FxaaLuma(FxaaTexOff(tex,posM,ivec2(1,0),fxaaQualityRcpFrame.xy));\nfloat lumaN=FxaaLuma(FxaaTexOff(tex,posM,ivec2(0,-1),fxaaQualityRcpFrame.xy));\nfloat lumaW=FxaaLuma(FxaaTexOff(tex,posM,ivec2(-1,0),fxaaQualityRcpFrame.xy));\nfloat maxSM=max(lumaS,lumaM);\nfloat minSM=min(lumaS,lumaM);\nfloat maxESM=max(lumaE,maxSM);\nfloat minESM=min(lumaE,minSM);\nfloat maxWN=max(lumaN,lumaW);\nfloat minWN=min(lumaN,lumaW);\nfloat rangeMax=max(maxWN,maxESM);\nfloat rangeMin=min(minWN,minESM);\nfloat rangeMaxScaled=rangeMax*fxaaQualityEdgeThreshold;\nfloat range=rangeMax-rangeMin;\nfloat rangeMaxClamped=max(fxaaQualityEdgeThresholdMin,rangeMaxScaled);\nbool earlyExit=range<rangeMaxClamped;\nif (earlyExit)\nreturn rgbyM;\nfloat lumaNW=FxaaLuma(FxaaTexOff(tex,posM,ivec2(-1,-1),fxaaQualityRcpFrame.xy));\nfloat lumaSE=FxaaLuma(FxaaTexOff(tex,posM,ivec2(1,1),fxaaQualityRcpFrame.xy));\nfloat lumaNE=FxaaLuma(FxaaTexOff(tex,posM,ivec2(1,-1),fxaaQualityRcpFrame.xy));\nfloat lumaSW=FxaaLuma(FxaaTexOff(tex,posM,ivec2(-1,1),fxaaQualityRcpFrame.xy));\nfloat lumaNS=lumaN+lumaS;\nfloat lumaWE=lumaW+lumaE;\nfloat subpixRcpRange=1.0/range;\nfloat subpixNSWE=lumaNS+lumaWE;\nfloat edgeHorz1=(-2.0*lumaM)+lumaNS;\nfloat edgeVert1=(-2.0*lumaM)+lumaWE;\nfloat lumaNESE=lumaNE+lumaSE;\nfloat lumaNWNE=lumaNW+lumaNE;\nfloat edgeHorz2=(-2.0*lumaE)+lumaNESE;\nfloat edgeVert2=(-2.0*lumaN)+lumaNWNE;\nfloat lumaNWSW=lumaNW+lumaSW;\nfloat lumaSWSE=lumaSW+lumaSE;\nfloat edgeHorz4=(abs(edgeHorz1)*2.0)+abs(edgeHorz2);\nfloat edgeVert4=(abs(edgeVert1)*2.0)+abs(edgeVert2);\nfloat edgeHorz3=(-2.0*lumaW)+lumaNWSW;\nfloat edgeVert3=(-2.0*lumaS)+lumaSWSE;\nfloat edgeHorz=abs(edgeHorz3)+edgeHorz4;\nfloat edgeVert=abs(edgeVert3)+edgeVert4;\nfloat subpixNWSWNESE=lumaNWSW+lumaNESE;\nfloat lengthSign=fxaaQualityRcpFrame.x;\nbool horzSpan=edgeHorz>=edgeVert;\nfloat subpixA=subpixNSWE*2.0+subpixNWSWNESE;\nif (!horzSpan)lumaN=lumaW;\nif (!horzSpan)lumaS=lumaE;\nif (horzSpan)lengthSign=fxaaQualityRcpFrame.y;\nfloat subpixB=(subpixA*(1.0/12.0))-lumaM;\nfloat gradientN=lumaN-lumaM;\nfloat gradientS=lumaS-lumaM;\nfloat lumaNN=lumaN+lumaM;\nfloat lumaSS=lumaS+lumaM;\nbool pairN=abs(gradientN)>=abs(gradientS);\nfloat gradient=max(abs(gradientN),abs(gradientS));\nif (pairN)lengthSign=-lengthSign;\nfloat subpixC=clamp(abs(subpixB)*subpixRcpRange,0.0,1.0);\nvec2 posB;\nposB.x=posM.x;\nposB.y=posM.y;\nvec2 offNP;\noffNP.x=(!horzSpan)?0.0:fxaaQualityRcpFrame.x;\noffNP.y=(horzSpan)?0.0:fxaaQualityRcpFrame.y;\nif (!horzSpan)posB.x+=lengthSign*0.5;\nif (horzSpan)posB.y+=lengthSign*0.5;\nvec2 posN;\nposN.x=posB.x-offNP.x*FXAA_QUALITY_P0;\nposN.y=posB.y-offNP.y*FXAA_QUALITY_P0;\nvec2 posP;\nposP.x=posB.x+offNP.x*FXAA_QUALITY_P0;\nposP.y=posB.y+offNP.y*FXAA_QUALITY_P0;\nfloat subpixD=((-2.0)*subpixC)+3.0;\nfloat lumaEndN=FxaaLuma(FxaaTexTop(tex,posN));\nfloat subpixE=subpixC*subpixC;\nfloat lumaEndP=FxaaLuma(FxaaTexTop(tex,posP));\nif (!pairN)lumaNN=lumaSS;\nfloat gradientScaled=gradient*1.0/4.0;\nfloat lumaMM=lumaM-lumaNN*0.5;\nfloat subpixF=subpixD*subpixE;\nbool lumaMLTZero=lumaMM<0.0;\nlumaEndN-=lumaNN*0.5;\nlumaEndP-=lumaNN*0.5;\nbool doneN=abs(lumaEndN)>=gradientScaled;\nbool doneP=abs(lumaEndP)>=gradientScaled;\nif (!doneN)posN.x-=offNP.x*FXAA_QUALITY_P1;\nif (!doneN)posN.y-=offNP.y*FXAA_QUALITY_P1;\nbool doneNP=(!doneN)||(!doneP);\nif (!doneP)posP.x+=offNP.x*FXAA_QUALITY_P1;\nif (!doneP)posP.y+=offNP.y*FXAA_QUALITY_P1;\nif (doneNP){\nif (!doneN)lumaEndN=FxaaLuma(FxaaTexTop(tex,posN.xy));\nif (!doneP)lumaEndP=FxaaLuma(FxaaTexTop(tex,posP.xy));\nif (!doneN)lumaEndN=lumaEndN-lumaNN*0.5;\nif (!doneP)lumaEndP=lumaEndP-lumaNN*0.5;\ndoneN=abs(lumaEndN)>=gradientScaled;\ndoneP=abs(lumaEndP)>=gradientScaled;\nif (!doneN)posN.x-=offNP.x*FXAA_QUALITY_P2;\nif (!doneN)posN.y-=offNP.y*FXAA_QUALITY_P2;\ndoneNP=(!doneN)||(!doneP);\nif (!doneP)posP.x+=offNP.x*FXAA_QUALITY_P2;\nif (!doneP)posP.y+=offNP.y*FXAA_QUALITY_P2;\n#if (FXAA_QUALITY_PS>3)\nif (doneNP){\nif (!doneN)lumaEndN=FxaaLuma(FxaaTexTop(tex,posN.xy));\nif (!doneP)lumaEndP=FxaaLuma(FxaaTexTop(tex,posP.xy));\nif (!doneN)lumaEndN=lumaEndN-lumaNN*0.5;\nif (!doneP)lumaEndP=lumaEndP-lumaNN*0.5;\ndoneN=abs(lumaEndN)>=gradientScaled;\ndoneP=abs(lumaEndP)>=gradientScaled;\nif (!doneN)posN.x-=offNP.x*FXAA_QUALITY_P3;\nif (!doneN)posN.y-=offNP.y*FXAA_QUALITY_P3;\ndoneNP=(!doneN)||(!doneP);\nif (!doneP)posP.x+=offNP.x*FXAA_QUALITY_P3;\nif (!doneP)posP.y+=offNP.y*FXAA_QUALITY_P3;\n#if (FXAA_QUALITY_PS>4)\nif (doneNP){\nif (!doneN)lumaEndN=FxaaLuma(FxaaTexTop(tex,posN.xy));\nif (!doneP)lumaEndP=FxaaLuma(FxaaTexTop(tex,posP.xy));\nif (!doneN)lumaEndN=lumaEndN-lumaNN*0.5;\nif (!doneP)lumaEndP=lumaEndP-lumaNN*0.5;\ndoneN=abs(lumaEndN)>=gradientScaled;\ndoneP=abs(lumaEndP)>=gradientScaled;\nif (!doneN)posN.x-=offNP.x*FXAA_QUALITY_P4;\nif (!doneN)posN.y-=offNP.y*FXAA_QUALITY_P4;\ndoneNP=(!doneN)||(!doneP);\nif (!doneP)posP.x+=offNP.x*FXAA_QUALITY_P4;\nif (!doneP)posP.y+=offNP.y*FXAA_QUALITY_P4;\n#if (FXAA_QUALITY_PS>5)\nif (doneNP){\nif (!doneN)lumaEndN=FxaaLuma(FxaaTexTop(tex,posN.xy));\nif (!doneP)lumaEndP=FxaaLuma(FxaaTexTop(tex,posP.xy));\nif (!doneN)lumaEndN=lumaEndN-lumaNN*0.5;\nif (!doneP)lumaEndP=lumaEndP-lumaNN*0.5;\ndoneN=abs(lumaEndN)>=gradientScaled;\ndoneP=abs(lumaEndP)>=gradientScaled;\nif (!doneN)posN.x-=offNP.x*FXAA_QUALITY_P5;\nif (!doneN)posN.y-=offNP.y*FXAA_QUALITY_P5;\ndoneNP=(!doneN)||(!doneP);\nif (!doneP)posP.x+=offNP.x*FXAA_QUALITY_P5;\nif (!doneP)posP.y+=offNP.y*FXAA_QUALITY_P5;\n#if (FXAA_QUALITY_PS>6)\nif (doneNP){\nif (!doneN)lumaEndN=FxaaLuma(FxaaTexTop(tex,posN.xy));\nif (!doneP)lumaEndP=FxaaLuma(FxaaTexTop(tex,posP.xy));\nif (!doneN)lumaEndN=lumaEndN-lumaNN*0.5;\nif (!doneP)lumaEndP=lumaEndP-lumaNN*0.5;\ndoneN=abs(lumaEndN)>=gradientScaled;\ndoneP=abs(lumaEndP)>=gradientScaled;\nif (!doneN)posN.x-=offNP.x*FXAA_QUALITY_P6;\nif (!doneN)posN.y-=offNP.y*FXAA_QUALITY_P6;\ndoneNP=(!doneN)||(!doneP);\nif (!doneP)posP.x+=offNP.x*FXAA_QUALITY_P6;\nif (!doneP)posP.y+=offNP.y*FXAA_QUALITY_P6;\n#if (FXAA_QUALITY_PS>7)\nif (doneNP){\nif (!doneN)lumaEndN=FxaaLuma(FxaaTexTop(tex,posN.xy));\nif (!doneP)lumaEndP=FxaaLuma(FxaaTexTop(tex,posP.xy));\nif (!doneN)lumaEndN=lumaEndN-lumaNN*0.5;\nif (!doneP)lumaEndP=lumaEndP-lumaNN*0.5;\ndoneN=abs(lumaEndN)>=gradientScaled;\ndoneP=abs(lumaEndP)>=gradientScaled;\nif (!doneN)posN.x-=offNP.x*FXAA_QUALITY_P7;\nif (!doneN)posN.y-=offNP.y*FXAA_QUALITY_P7;\ndoneNP=(!doneN)||(!doneP);\nif (!doneP)posP.x+=offNP.x*FXAA_QUALITY_P7;\nif (!doneP)posP.y+=offNP.y*FXAA_QUALITY_P7;\n#if (FXAA_QUALITY_PS>8)\nif (doneNP){\nif (!doneN)lumaEndN=FxaaLuma(FxaaTexTop(tex,posN.xy));\nif (!doneP)lumaEndP=FxaaLuma(FxaaTexTop(tex,posP.xy));\nif (!doneN)lumaEndN=lumaEndN-lumaNN*0.5;\nif (!doneP)lumaEndP=lumaEndP-lumaNN*0.5;\ndoneN=abs(lumaEndN)>=gradientScaled;\ndoneP=abs(lumaEndP)>=gradientScaled;\nif (!doneN)posN.x-=offNP.x*FXAA_QUALITY_P8;\nif (!doneN)posN.y-=offNP.y*FXAA_QUALITY_P8;\ndoneNP=(!doneN)||(!doneP);\nif (!doneP)posP.x+=offNP.x*FXAA_QUALITY_P8;\nif (!doneP)posP.y+=offNP.y*FXAA_QUALITY_P8;\n#if (FXAA_QUALITY_PS>9)\nif (doneNP){\nif (!doneN)lumaEndN=FxaaLuma(FxaaTexTop(tex,posN.xy));\nif (!doneP)lumaEndP=FxaaLuma(FxaaTexTop(tex,posP.xy));\nif (!doneN)lumaEndN=lumaEndN-lumaNN*0.5;\nif (!doneP)lumaEndP=lumaEndP-lumaNN*0.5;\ndoneN=abs(lumaEndN)>=gradientScaled;\ndoneP=abs(lumaEndP)>=gradientScaled;\nif (!doneN)posN.x-=offNP.x*FXAA_QUALITY_P9;\nif (!doneN)posN.y-=offNP.y*FXAA_QUALITY_P9;\ndoneNP=(!doneN)||(!doneP);\nif (!doneP)posP.x+=offNP.x*FXAA_QUALITY_P9;\nif (!doneP)posP.y+=offNP.y*FXAA_QUALITY_P9;\n#if (FXAA_QUALITY_PS>10)\nif (doneNP){\nif (!doneN)lumaEndN=FxaaLuma(FxaaTexTop(tex,posN.xy));\nif (!doneP)lumaEndP=FxaaLuma(FxaaTexTop(tex,posP.xy));\nif (!doneN)lumaEndN=lumaEndN-lumaNN*0.5;\nif (!doneP)lumaEndP=lumaEndP-lumaNN*0.5;\ndoneN=abs(lumaEndN)>=gradientScaled;\ndoneP=abs(lumaEndP)>=gradientScaled;\nif (!doneN)posN.x-=offNP.x*FXAA_QUALITY_P10;\nif (!doneN)posN.y-=offNP.y*FXAA_QUALITY_P10;\ndoneNP=(!doneN)||(!doneP);\nif (!doneP)posP.x+=offNP.x*FXAA_QUALITY_P10;\nif (!doneP)posP.y+=offNP.y*FXAA_QUALITY_P10;\n#if (FXAA_QUALITY_PS>11)\nif (doneNP){\nif (!doneN)lumaEndN=FxaaLuma(FxaaTexTop(tex,posN.xy));\nif (!doneP)lumaEndP=FxaaLuma(FxaaTexTop(tex,posP.xy));\nif (!doneN)lumaEndN=lumaEndN-lumaNN*0.5;\nif (!doneP)lumaEndP=lumaEndP-lumaNN*0.5;\ndoneN=abs(lumaEndN)>=gradientScaled;\ndoneP=abs(lumaEndP)>=gradientScaled;\nif (!doneN)posN.x-=offNP.x*FXAA_QUALITY_P11;\nif (!doneN)posN.y-=offNP.y*FXAA_QUALITY_P11;\ndoneNP=(!doneN)||(!doneP);\nif (!doneP)posP.x+=offNP.x*FXAA_QUALITY_P11;\nif (!doneP)posP.y+=offNP.y*FXAA_QUALITY_P11;\n#if (FXAA_QUALITY_PS>12)\nif (doneNP){\nif (!doneN)lumaEndN=FxaaLuma(FxaaTexTop(tex,posN.xy));\nif (!doneP)lumaEndP=FxaaLuma(FxaaTexTop(tex,posP.xy));\nif (!doneN)lumaEndN=lumaEndN-lumaNN*0.5;\nif (!doneP)lumaEndP=lumaEndP-lumaNN*0.5;\ndoneN=abs(lumaEndN)>=gradientScaled;\ndoneP=abs(lumaEndP)>=gradientScaled;\nif (!doneN)posN.x-=offNP.x*FXAA_QUALITY_P12;\nif (!doneN)posN.y-=offNP.y*FXAA_QUALITY_P12;\ndoneNP=(!doneN)||(!doneP);\nif (!doneP)posP.x+=offNP.x*FXAA_QUALITY_P12;\nif (!doneP)posP.y+=offNP.y*FXAA_QUALITY_P12;\n}\n#endif\n}\n#endif\n}\n#endif\n}\n#endif\n}\n#endif\n}\n#endif\n}\n#endif\n}\n#endif\n}\n#endif\n}\n#endif\n}\nfloat dstN=posM.x-posN.x;\nfloat dstP=posP.x-posM.x;\nif (!horzSpan)dstN=posM.y-posN.y;\nif (!horzSpan)dstP=posP.y-posM.y;\nbool goodSpanN=(lumaEndN<0.0)!= lumaMLTZero;\nfloat spanLength=(dstP+dstN);\nbool goodSpanP=(lumaEndP<0.0)!= lumaMLTZero;\nfloat spanLengthRcp=1.0/spanLength;\nbool directionN=dstN<dstP;\nfloat dst=min(dstN,dstP);\nbool goodSpan=directionN?goodSpanN:goodSpanP;\nfloat subpixG=subpixF*subpixF;\nfloat pixelOffset=(dst*(-spanLengthRcp))+0.5;\nfloat subpixH=subpixG*fxaaQualitySubpix;\nfloat pixelOffsetGood=goodSpan?pixelOffset:0.0;\nfloat pixelOffsetSubpix=max(pixelOffsetGood,subpixH);\nif (!horzSpan)posM.x+=pixelOffsetSubpix*lengthSign;\nif (horzSpan)posM.y+=pixelOffsetSubpix*lengthSign;\nreturn FxaaTexTop(tex,posM);\n}\nvoid main(){\ngl_FragColor=FxaaPixelShader(vUv,tDiffuse,resolution,0.75,0.166,0.0);\n}",pp_grayscale_frag:"uniform sampler2D tDiffuse;\nvarying vec2 vUv;\nvoid main(){\nvec4 texel=texture(tDiffuse,vUv);\nfloat bw=texel.r*0.35+texel.g*0.45+texel.b*0.2;\ntexel=vec4(bw,bw,bw,texel.a);\ngl_FragColor=texel;\n}",pp_gtao_blur_frag:"uniform sampler2D tDiffuse;\nuniform sampler2D tNormal;\nuniform vec2 direction;\nuniform vec2 resolution;\nvarying vec2 vUv;\n#include <packing>\nconst float SIGMA_SPATIAL=1.5;\nconst float SIGMA_INTENSITY=0.01;\nfloat gaussianPdf(float x,float sigma){\nreturn 0.39894*exp(-0.5*x*x/(sigma*sigma))/sigma;\n}\nvoid main(){\nfloat weightSum=gaussianPdf(0.0,SIGMA_SPATIAL)\n* gaussianPdf(0.0,SIGMA_INTENSITY);\nvec4 diffSample=texture(tDiffuse,vUv);\nvec4 gtaoDataSum=vec4(diffSample.r,unpackRGBToNormal(diffSample.gba))*weightSum;\nvec3 normCenter=unpackRGBToNormal(texture(tNormal,vUv).xyz);\nvec2 delta=direction/resolution;\nvec2 offset=delta;\n#pragma unroll_loop\nfor (int i=1;i<=BLUR_RADIUS_PX;i++){\nvec2 uvCoords0=vUv+offset;\nvec2 uvCoords1=vUv-offset;\nvec4 diffSample0=texture(tDiffuse,uvCoords0);\nvec4 diffSample1=texture(tDiffuse,uvCoords1);\nvec4 gtaoData0=vec4(diffSample0.r,unpackRGBToNormal(diffSample0.gba));\nvec4 gtaoData1=vec4(diffSample1.r,unpackRGBToNormal(diffSample1.gba));\nvec3 normSample0=unpackRGBToNormal(texture(tNormal,uvCoords0).xyz);\nvec3 normSample1=unpackRGBToNormal(texture(tNormal,uvCoords1).xyz);\nfloat weightSpatial=gaussianPdf(float(i),SIGMA_SPATIAL);\nfloat weight0=weightSpatial*gaussianPdf(1.0-max(0.0,dot(normCenter,normSample0)),SIGMA_INTENSITY);\nfloat weight1=weightSpatial*gaussianPdf(1.0-max(0.0,dot(normCenter,normSample1)),SIGMA_INTENSITY);\nweightSum+=weight0+weight1;\ngtaoDataSum+=weight0*gtaoData0+weight1*gtaoData1;\noffset+=delta;\n}\nfloat visibility=gtaoDataSum.r/weightSum;\nvec3 bentNormal=normalize(gtaoDataSum.gba);\ngl_FragColor=vec4(visibility,packNormalToRGB(bentNormal));\n}",pp_gtao_frag:"uniform sampler2D tNormal;\nuniform sampler2D tDepth;\nuniform sampler2D tNoise;\nuniform float occlDistance;\nuniform float factor;\nuniform float occlPrecision;\nuniform mat4 mainCameraProjMat;\nuniform vec2 resolution;\nvarying vec2 vUv;\n#include <common>\n#include <packing>\nconst vec3 AXIS_Z=vec3(0.0,0.0,1.0);\nconst float NUM_SAMPLES_HALF_MIN=4.0;\nconst float NUM_SAMPLES_HALF_MAX=8.0;\nconst float NOISE_TEX_SIZE=32.0;\nconst float NEAR_FIELD_COEFF=0.5;\nconst float SELF_OCCL_BIAS=-1e-5;\nconst float NORMAL_RENDER_GEOM_MAX_DIFF_ANGLE=0.85*PI_HALF;\nfloat integrateArc(vec2 horizonAngles,float normalAngle){\nvec2 visCoeffs=(-cos(2.0*horizonAngles-normalAngle)+cos(normalAngle)\n+ 2.0*horizonAngles*sin(normalAngle))/4.0;\nreturn visCoeffs.x+visCoeffs.y;\n}\nvec3 calcViewFromUVDepth(vec2 uv,float depth,float zBias){\nvec3 ndcCo=2.0*vec3(uv,depth)-1.0;\n#if ORTHO_CAMERA==1\nfloat viewZ=(ndcCo.z-mainCameraProjMat[3][2])/mainCameraProjMat[2][2]+zBias;\nvec2 _00_11=vec2(mainCameraProjMat[0][0],mainCameraProjMat[1][1]);\nvec2 _30_31=vec2(mainCameraProjMat[3][0],mainCameraProjMat[3][1]);\nreturn vec3((ndcCo.xy-_30_31)/_00_11,viewZ);\n#else\nfloat viewZ=-mainCameraProjMat[3][2]/(mainCameraProjMat[2][2]+ndcCo.z)+zBias;\nvec2 _00_11=vec2(mainCameraProjMat[0][0],mainCameraProjMat[1][1]);\nvec2 _20_21=vec2(mainCameraProjMat[2][0],mainCameraProjMat[2][1]);\nreturn vec3(-viewZ*(ndcCo.xy+_20_21)/_00_11,viewZ);\n#endif\n}\nvec2 calcSliceRadiusUV(float viewZ){\nvec4 distView=vec4(occlDistance,occlDistance,viewZ,1.0);\nvec4 distClip=mainCameraProjMat*distView;\nvec2 xyNDC=distClip.xy/distClip.w;\nreturn clamp(0.5*xyNDC,0.0,0.5);\n}\nvec2 calcHorizonAngles(vec3 viewPos,vec3 viewVec,vec2 sliceDir,float offsetNoise){\nvec2 maxHorizonCos=vec2(-1.0);\nvec2 sliceRadius=calcSliceRadiusUV(viewPos.z);\nvec2 pxSize=1.0/resolution;\nint NUM_SAMPLES_HALF=int(occlPrecision\n* (NUM_SAMPLES_HALF_MAX-NUM_SAMPLES_HALF_MIN)+NUM_SAMPLES_HALF_MIN);\nfor (int i=0;i<NUM_SAMPLES_HALF;i++){\nvec2 offset=sliceDir*(pxSize*(1.0+float(i))\n+ sliceRadius*pow((float(i)+offsetNoise)/float(NUM_SAMPLES_HALF),2.0));\nvec2 uvs=vUv-offset;\nvec3 ps=calcViewFromUVDepth(uvs,texture(tDepth,uvs).x,SELF_OCCL_BIAS);\nvec3 ds=normalize(ps-viewPos);\nvec2 uvt=vUv+offset;\nvec3 pt=calcViewFromUVDepth(uvt,texture(tDepth,uvt).x,SELF_OCCL_BIAS);\nvec3 dt=normalize(pt-viewPos);\nvec2 sampleLen=vec2(length(ps-viewPos),length(pt-viewPos));\nvec2 blendWeight=(sampleLen/occlDistance-1.0)/(NEAR_FIELD_COEFF-1.0);\nblendWeight=clamp(blendWeight,0.0,1.0);\nvec2 maxHorizonCosNoBlending=max(maxHorizonCos,vec2(dot(ds,viewVec),dot(dt,viewVec)));\nmaxHorizonCos=mix(maxHorizonCos,maxHorizonCosNoBlending,blendWeight);\n}\nvec2 horizons=acos(maxHorizonCos);\nreturn vec2(-horizons.x,horizons.y);\n}\nvec2 calcNormalAngleAndProjLen(vec3 viewVec,vec3 normal,vec2 sliceDir){\nvec3 sliceVec=vec3(sliceDir,0.0);\nsliceVec=sliceVec-dot(sliceVec,viewVec)*viewVec;\nvec3 sliceOrthoVec=cross(sliceVec,viewVec);\nvec3 normalProj=normal-dot(normal,sliceOrthoVec)*sliceOrthoVec;\nfloat normalProjLen=length(normalProj);\nfloat normalAngle=acos(clamp(dot(normalProj/normalProjLen,viewVec),0.0,1.0));\nnormalAngle*=sign(dot(normalProj,sliceVec));\nreturn vec2(normalAngle,normalProjLen);\n}\n#if CALC_BENT_NORMALS==1\nvec3 calcSliceBentNormal(vec2 sliceDir,vec2 h,float n){\nvec2 t=vec2(6.0*sin(h[0]-n)-sin(3.0*h[0]-n)+6.0*sin(h[1]-n)\n- sin(3.0*h[1]-n)+16.0*sin(n)-3.0*(sin(h[0]+n)+sin(h[1]+n)),-cos(3.0*h[0]-n)-cos(3.0*h[1]-n)+8.0*cos(n)\n- 3.0*(cos(h[0]+n)+cos(h[1]+n))\n)/12.0;\nreturn vec3(sliceDir*t[0],t[1]);\n}\n#endif\nvec2 clampHorizonAnglesAroundNormal(vec2 horizonAngles,float normalAngle,float geomNormalAngle){\nhorizonAngles=normalAngle+clamp(horizonAngles-normalAngle,-PI_HALF,PI_HALF);\nif (abs(normalAngle-geomNormalAngle)<NORMAL_RENDER_GEOM_MAX_DIFF_ANGLE){\nhorizonAngles=geomNormalAngle+clamp(horizonAngles-geomNormalAngle,-PI_HALF,PI_HALF);\n}\nreturn horizonAngles;\n}\nvoid main(){\nfloat depth=texture(tDepth,vUv).x;\n#ifndef GTAO_DISABLE_BKG_FIX\nif (depth==1.0){\ngl_FragColor=vec4(vec3(1.0),1.0);\n} else {\n#endif\nvec3 viewPos=calcViewFromUVDepth(vUv,depth,0.0);\n#if ORTHO_CAMERA==1\nvec3 viewVec=vec3(0.0,0.0,1.0);\n#else\nvec3 viewVec=normalize(-viewPos);\n#endif\nvec3 viewNormal=unpackRGBToNormal(texture(tNormal,vUv).xyz);\nvec3 geomViewNormal=normalize(cross(dFdx(viewPos),dFdy(viewPos)));\nvec2 noiseScale=resolution/NOISE_TEX_SIZE;\nvec4 noiseData=texture(tNoise,vUv*noiseScale);\nfloat randAngle=noiseData.r*PI_HALF;\nfloat visibility=0.0;\nvec3 bentNormalAvg=viewNormal;\nfloat normalAngle,normalProjLen,geomNormalAngle;\nvec2 horizonAngles,_vec2Tmp;\nvec3 sliceBentNormal;\n#if CALC_BENT_NORMALS==1\nbentNormalAvg=vec3(0.0);\n#if ORTHO_CAMERA==0\nvec3 bentRotAxis=cross(AXIS_Z,viewVec);\nfloat bentRotAngle=acos(clamp(dot(AXIS_Z,viewVec),-1.0,1.0));\n#endif\n#endif\nvec2 sliceDir=vec2(cos(randAngle),sin(randAngle));\n#pragma unroll_loop\nfor (int i=0;i<2;i++){\n_vec2Tmp=calcNormalAngleAndProjLen(viewVec,viewNormal,sliceDir);\nnormalAngle=_vec2Tmp[0],normalProjLen=_vec2Tmp[1];\n_vec2Tmp=calcNormalAngleAndProjLen(viewVec,geomViewNormal,sliceDir);\ngeomNormalAngle=_vec2Tmp[0];\nhorizonAngles=calcHorizonAngles(viewPos,viewVec,sliceDir,noiseData.g);\nhorizonAngles=clampHorizonAnglesAroundNormal(horizonAngles,normalAngle,geomNormalAngle);\nvisibility+=normalProjLen*integrateArc(horizonAngles,normalAngle);\n#if CALC_BENT_NORMALS==1\nsliceBentNormal=calcSliceBentNormal(sliceDir,horizonAngles,normalAngle);\n#if ORTHO_CAMERA==0\nsliceBentNormal=vec3RotateAxisAngle(sliceBentNormal,bentRotAxis,bentRotAngle);\n#endif\nbentNormalAvg+=sliceBentNormal*normalProjLen;\n#endif\nsliceDir=vec2(-sliceDir.y,sliceDir.x);\n}\nvisibility/=2.0;\n#if CALC_BENT_NORMALS==1\nfloat mixFactor=clamp((1.0-2.0*visibility)/(3.0*visibility-4.0),0.0,1.0);\nbentNormalAvg=normalize(mix(bentNormalAvg,viewNormal,mixFactor));\n#endif\ngl_FragColor=vec4(pow(visibility,factor),packNormalToRGB(bentNormalAvg));\n#ifndef GTAO_DISABLE_BKG_FIX\n}\n#endif\n}",pp_outline_edge_frag:"varying vec2 vUv;\nuniform sampler2D maskTexture;\nuniform vec2 texSize;\nuniform vec4 visibleEdgeColor;\nuniform vec4 hiddenEdgeColor;\nvoid main(){\nvec2 invSize=1.0/texSize;\nvec4 uvOffset=vec4(1.0,0.0,0.0,1.0)*vec4(invSize,invSize);\nvec4 c1=texture(maskTexture,vUv+uvOffset.xy);\nvec4 c2=texture(maskTexture,vUv-uvOffset.xy);\nvec4 c3=texture(maskTexture,vUv+uvOffset.yw);\nvec4 c4=texture(maskTexture,vUv-uvOffset.yw);\nfloat diff1=(c1.r-c2.r)*0.5;\nfloat diff2=(c3.r-c4.r)*0.5;\nfloat d=length(vec2(diff1,diff2));\nfloat a1=min(c1.g,c2.g);\nfloat a2=min(c3.g,c4.g);\nfloat visibilityFactor=min(a1,a2);\nvec4 edgeColor=(1.0-visibilityFactor>0.001)?visibleEdgeColor:hiddenEdgeColor;\ngl_FragColor=edgeColor*vec4(d);\n}",pp_outline_blur_frag:"#include <common>\nvarying vec2 vUv;\nuniform sampler2D colorTexture;\nuniform vec2 texSize;\nuniform vec2 direction;\nuniform float kernelRadius;\nfloat gaussianPdf(in float x,in float sigma){\nreturn 0.39894*exp(-0.5*x*x/(sigma*sigma))/sigma;\n}\nvoid main(){\nvec2 invSize=1.0/texSize;\nfloat weightSum=gaussianPdf(0.0,kernelRadius);\nvec4 diffuseSum=texture(colorTexture,vUv);\n#if defined(LOG_SPACE)\ndiffuseSum=exp(diffuseSum);\n#endif\ndiffuseSum*=weightSum;\nvec2 delta=direction*invSize*kernelRadius/float(MAX_RADIUS);\nvec2 uvOffset=delta;\nfor (int i=1;i<=MAX_RADIUS;i++){\nfloat w=gaussianPdf(uvOffset.x,kernelRadius);\nvec4 sample1=texture(colorTexture,vUv+uvOffset);\nvec4 sample2=texture(colorTexture,vUv-uvOffset);\n#if defined(LOG_SPACE)\nsample1=exp(sample1);\nsample2=exp(sample2);\n#endif\ndiffuseSum+=((sample1+sample2)*w);\nweightSum+=(2.0*w);\nuvOffset+=delta;\n}\nvec4 finalCol=diffuseSum/weightSum;\n#if defined(LOG_SPACE)\nfinalCol=log(finalCol);\n#endif\ngl_FragColor=finalCol;\n}",pp_outline_overlay_frag:"varying vec2 vUv;\nuniform sampler2D maskTexture;\nuniform sampler2D edgeTexture1;\nuniform sampler2D edgeTexture2;\nuniform sampler2D patternTexture;\nuniform float edgeStrength;\nuniform float edgeGlow;\nuniform bool usePatternTexture;\nvoid main(){\nvec4 edgeValue1=texture(edgeTexture1,vUv);\nvec4 edgeValue2=texture(edgeTexture2,vUv);\nvec4 maskColor=texture(maskTexture,vUv);\nvec4 patternColor=texture(patternTexture,6.0*vUv);\nfloat visibilityFactor=1.0-maskColor.g>0.0?1.0:0.5;\nvec4 edgeValue=edgeValue1+edgeValue2*edgeGlow;\nvec4 finalColor=edgeStrength*maskColor.r*edgeValue;\nif (usePatternTexture)\nfinalColor+=+ visibilityFactor*(1.0-maskColor.r)*(1.0-patternColor.r);\nfloat maxChannel=max(finalColor.r,max(finalColor.g,finalColor.b));\nif (maxChannel != 0.0){\nfinalColor.rgb/=maxChannel;\n}\ngl_FragColor=finalColor;\n}",pp_tonemap_frag:"#include <common>\nuniform sampler2D tDiffuse;\nvarying vec2 vUv;\nvoid main(){\nvec4 texel=texture(tDiffuse,vUv);\nfloat alpha=clamp(texel.a,0.0,1.0);\ngl_FragColor=texel;\ngl_FragColor.rgb/=alpha;\n#include <tonemapping_fragment>\ngl_FragColor=LinearTosRGB(gl_FragColor);\ngl_FragColor.rgb*=alpha;\n}",pp_oit_weighted_frag:"varying vec2 vUv;\nuniform sampler2D tRGBABuffer;\nuniform sampler2D tFloatBuffer;\nvoid main(){\nvec4 color=texture(tRGBABuffer,vUv);\nvec3 colorSum=color.rgb;\nfloat alphaProduct=color.a;\nfloat alphaSum=texture(tFloatBuffer,vUv).r;\ngl_FragColor=vec4(colorSum.rgb/max(alphaSum,1e-5),1.0-alphaProduct);\n}",raw_meshline_vert:"precision highp float;\nattribute vec3 position;\nattribute vec3 previous;\nattribute vec3 next;\nattribute float side;\nattribute float width;\nattribute vec2 uv;\nattribute float counters;\nuniform mat4 projectionMatrix;\nuniform mat4 modelViewMatrix;\nuniform vec2 resolution;\nuniform float lineWidth;\nuniform float sizeAttenuation;\nvarying float vCounters;\nvarying vec2 vUV;\nconst float EQ_EPS=0.000001;\nvec2 fix(vec4 i,float aspect){\nvec2 res=i.xy/i.w;\nres.x*=aspect;\nreturn res;\n}\nbool posEqual(vec2 pos0,vec2 pos1){\nreturn length(pos0-pos1)<EQ_EPS;\n}\nvoid main(){\nfloat aspect=resolution.x/resolution.y;\nvCounters=counters;\nvUV=uv;\nmat4 m=projectionMatrix*modelViewMatrix;\nvec4 finalPosition=m*vec4(position,1.0);\nvec4 prevPos=m*vec4(previous,1.0);\nvec4 nextPos=m*vec4(next,1.0);\nvec2 currentP=fix(finalPosition,aspect);\nvec2 prevP=fix(prevPos,aspect);\nvec2 nextP=fix(nextPos,aspect);\nfloat w=lineWidth*width;\nif (sizeAttenuation==0.0){\nw*=finalPosition.w/resolution.x;\n}\nvec2 dir;\nif (posEqual(nextP,currentP)){\ndir=normalize(currentP-prevP);\n} else if (posEqual(prevP,currentP)){\ndir=normalize(nextP-currentP);\n} else {\nvec2 dir1=normalize(currentP-prevP);\nvec2 dir2=normalize(nextP-currentP);\ndir=normalize(dir1+dir2);\n}\nvec2 offset=vec2(-dir.y,dir.x);\noffset.y*=aspect;\noffset*=w;\nfinalPosition.xy+=offset*side;\ngl_Position=finalPosition;\n}",raw_meshline_frag:"precision mediump float;\nuniform sampler2D map;\nuniform sampler2D alphaMap;\nuniform float useMap;\nuniform float useAlphaMap;\nuniform float visibility;\nuniform float alphaTest;\nuniform vec2 repeat;\nuniform vec3 color;\nuniform float opacity;\nvarying vec2 vUV;\nvarying float vCounters;\n#include <encodings_pars_fragment>\nvoid main(){\nvec4 c=vec4(color,opacity);\nif (useMap==1.0){\nc*=texture2D(map,vUV*repeat);\n}\nif (useAlphaMap==1.0){\nc.a*=texture2D(alphaMap,vUV*repeat).a;\n}\nif (c.a<alphaTest){\ndiscard;\n}\ngl_FragColor=c;\ngl_FragColor.a*=step(vCounters,visibility);\ngl_FragColor=LinearTosRGB(gl_FragColor);\n}"},Ui={common:{diffuse:{value:new tn(16777215)},opacity:{value:1},map:{value:null},uvTransform:{value:new xe},uv2Transform:{value:new xe},alphaMap:{value:null},alphaTest:{value:0}},envmap:{envMap:{value:null},flipEnvMap:{value:-1},reflectivity:{value:1},refractionRatio:{value:.98}},aomap:{aoMap:{value:null},aoMapIntensity:{value:1}},lightmap:{lightMap:{value:null},lightMapIntensity:{value:1}},emissivemap:{emissiveMap:{value:null}},bumpmap:{bumpMap:{value:null},bumpScale:{value:1}},normalmap:{normalMap:{value:null},normalScale:{value:new we(1,1)}},displacementmap:{displacementMap:{value:null},displacementScale:{value:1},displacementBias:{value:0}},roughnessmap:{roughnessMap:{value:null}},metalnessmap:{metalnessMap:{value:null}},fog:{fogDensity:{value:25e-5},fogNear:{value:1},fogFar:{value:2e3},fogColor:{value:new tn(16777215)}},lights:{ambientLightColor:{value:[],needsUpdate:!0},lightProbe:{value:[],needsUpdate:!0},directionalLights:{value:[],needsUpdate:!0},directionalLightShadowsCSM:{value:[],needsUpdate:!0},directionalLightShadowsCSMCascade:{value:[],needsUpdate:!0},directionalShadowCSMMap:{value:[]},directionalShadowCSMMatrix:{value:[]},spotLights:{value:[],needsUpdate:!0},spotLightShadows:{value:[],needsUpdate:!0},spotShadowMap:{value:[]},spotShadowMatrix:{value:[]},pointLights:{value:[],needsUpdate:!0},pointLightShadows:{value:[],needsUpdate:!0},pointShadowMap:{value:[]},pointShadowMatrix:{value:[]},rectAreaLights:{value:[],needsUpdate:!0},rectAreaLightShadows:{value:[],needsUpdate:!0},rectAreaShadowMap:{value:[]},rectAreaShadowMatrix:{value:[]},ltc_1:{value:null},ltc_2:{value:null}},points:{diffuse:{value:new tn(16777215)},opacity:{value:1},size:{value:1},scale:{value:1},map:{value:null},alphaMap:{value:null},alphaTest:{value:0},uvTransform:{value:new xe}},sprite:{diffuse:{value:new tn(16777215)},opacity:{value:1},center:{value:new we(.5,.5)},rotation:{value:0},map:{value:null},alphaMap:{value:null},alphaTest:{value:0},uvTransform:{value:new xe}},mask:{depthTexture:{value:null},cameraNearFar:{value:new we(.5,.5)},textureMatrix:{value:new Hn}},node:{nodeRGB:{value:[]},nodeValue:{value:[]},nodeInputsFloat:{value:[]},nodeInputsInt:{value:[]},nodeInputsBool:{value:[]},nodeInputsVec2:{value:[]},nodeInputsVec3:{value:[]},nodeInputsVec4:{value:[]},nodeInputsMat3:{value:[]},nodeInputsMat4:{value:[]},flipCubeMap:{value:-1},materialIndex:{value:0}},nodeGTAO:{gtaoMap:{value:null}},ssr:{invProjectionMatrix:{value:new Hn},ssrSourceBuffer:{value:null},ssrDepthBuffer:{value:null},ssrBackfaceDepthBuffer:{value:null},ssrStride:{value:20},ssrJitter:{value:1},ssrMaxDistance:{value:100}},planeReflectionProbe:{planeReflTexture:{value:null},planeReflTextureMatrix:{value:new Hn},planeReflDir:{value:new An},planeReflBoundingBoxMin:{value:new An},planeReflBoundingBoxMax:{value:new An},planeReflInvModelMatrix:{value:new Hn},planeReflFalloff:{value:0}}},Vi={basic:{uniforms:vi([Ui.common,Ui.envmap,Ui.aomap,Ui.lightmap,Ui.fog]),vertexShader:Fi.meshbasic_vert,fragmentShader:Fi.meshbasic_frag},lambert:{uniforms:vi([Ui.common,Ui.envmap,Ui.aomap,Ui.lightmap,Ui.emissivemap,Ui.bumpmap,Ui.normalmap,Ui.displacementmap,Ui.fog,Ui.lights,{emissive:{value:new tn(0)}}]),vertexShader:Fi.meshlambert_vert,fragmentShader:Fi.meshlambert_frag},standard:{uniforms:vi([Ui.common,Ui.envmap,Ui.aomap,Ui.lightmap,Ui.emissivemap,Ui.bumpmap,Ui.normalmap,Ui.displacementmap,Ui.roughnessmap,Ui.metalnessmap,Ui.fog,Ui.lights,Ui.planeReflectionProbe,{emissive:{value:new tn(0)},roughness:{value:1},metalness:{value:0},envMapIntensity:{value:1},envMapParallaxType:{value:0},envMapParallaxMatrix:{value:new Hn},envMapParallaxMatrixInv:{value:new Hn}}]),vertexShader:Fi.meshphysical_vert,fragmentShader:Fi.meshphysical_frag},points:{uniforms:vi([Ui.points,Ui.fog]),vertexShader:Fi.points_vert,fragmentShader:Fi.points_frag},dashed:{uniforms:vi([Ui.common,Ui.fog,{scale:{value:1},dashSize:{value:1},totalSize:{value:2}}]),vertexShader:Fi.linedashed_vert,fragmentShader:Fi.linedashed_frag},depth:{uniforms:vi([Ui.common,Ui.displacementmap,{slopeScaledBias:{value:0}}]),vertexShader:Fi.depth_vert,fragmentShader:Fi.depth_frag},normal:{uniforms:vi([Ui.common,Ui.bumpmap,Ui.normalmap,Ui.displacementmap,{opacity:{value:1}}]),vertexShader:Fi.meshnormal_vert,fragmentShader:Fi.meshnormal_frag},sprite:{uniforms:vi([Ui.sprite,Ui.fog]),vertexShader:Fi.sprite_vert,fragmentShader:Fi.sprite_frag},background:{uniforms:{uvTransform:{value:new xe},t2D:{value:null},backgroundIntensity:{value:1}},vertexShader:Fi.background_vert,fragmentShader:Fi.background_frag},backgroundCube:{uniforms:{envMap:{value:null},flipEnvMap:{value:-1},backgroundBlurriness:{value:0},backgroundIntensity:{value:1}},vertexShader:Fi.backgroundCube_vert,fragmentShader:Fi.backgroundCube_frag},cube:{uniforms:{tCube:{value:null},tFlip:{value:-1},opacity:{value:1}},vertexShader:Fi.cube_vert,fragmentShader:Fi.cube_frag},distanceRGBA:{uniforms:vi([Ui.common,Ui.displacementmap,{referencePosition:{value:new An},nearDistance:{value:1},farDistance:{value:1e3},slopeScaledBias:{value:0}}]),vertexShader:Fi.distanceRGBA_vert,fragmentShader:Fi.distanceRGBA_frag},shadow:{uniforms:vi([Ui.lights,Ui.fog,{color:{value:new tn(0)},opacity:{value:1}}]),vertexShader:Fi.shadow_vert,fragmentShader:Fi.shadow_frag},mask:{uniforms:vi([Ui.common,Ui.displacementmap,Ui.mask]),vertexShader:Fi.mask_vert,fragmentShader:Fi.mask_frag},node:{uniforms:vi([Ui.common,Ui.displacementmap,Ui.envmap,Ui.fog,Ui.lights,Ui.ssr,Ui.planeReflectionProbe,Ui.node,Ui.nodeGTAO,{envMapIntensity:{value:1},envMapParallaxType:{value:0},envMapParallaxMatrix:{value:new Hn},envMapParallaxMatrixInv:{value:new Hn}}]),vertexShader:Fi.meshnode_vert,fragmentShader:Fi.meshnode_frag},cubeOctahedral:{uniforms:{tCube:{value:null},texelSize:{value:new we(.5,.5)}},vertexShader:Fi.pp_plane_vert,fragmentShader:Fi.pp_cube_octahedral_proj_frag}};Vi.copy={uniforms:{tDiffuse:{value:null},opacity:{value:1}},vertexShader:Fi.pp_plane_vert,fragmentShader:Fi.pp_copy_frag},Vi.bokeh={defines:{DEPTH_PACKING:1,PERSPECTIVE_CAMERA:1},uniforms:{tColor:{value:null},tDepth:{value:null},focus:{value:1},aspect:{value:1},aperture:{value:.025},maxblur:{value:1},nearClip:{value:1},farClip:{value:1e3},depthLeakThreshold:{value:.2}},vertexShader:Fi.pp_plane_vert,fragmentShader:Fi.pp_bokeh_frag},Vi.fxaa={uniforms:{tDiffuse:{value:null},resolution:{value:new we(1/1024,1/512)}},vertexShader:Fi.pp_plane_vert,fragmentShader:Fi.pp_fxaa_frag},Vi.grayscale={uniforms:{tDiffuse:{value:null}},vertexShader:Fi.pp_plane_vert,fragmentShader:Fi.pp_grayscale_frag},Vi.brightness_contrast={uniforms:{tDiffuse:{value:null},brightness:{value:0},contrast:{value:0}},vertexShader:Fi.pp_plane_vert,fragmentShader:Fi.pp_brightness_contrast_frag},Vi.bloomLumHighPass={uniforms:{tDiffuse:{type:"t",value:null},luminosityThreshold:{type:"f",value:1},smoothWidth:{type:"f",value:1},defaultColor:{type:"c",value:new tn(0)},defaultOpacity:{type:"f",value:0}},vertexShader:Fi.pp_plane_vert,fragmentShader:Fi.pp_bloom_lum_high_pass_frag},Vi.blur={defines:{LOG_SPACE:0,OCTAHEDRAL_MAP:0},uniforms:{colorTexture:{value:null},texSize:{value:new we(.5,.5)},direction:{value:new we(.5,.5)},kernelRadius:{value:1}},customPrepTokens:{MAX_SAMPLE_RADIUS:4},vertexShader:Fi.pp_plane_vert,fragmentShader:Fi.pp_blur_frag},Vi.tonemap={uniforms:{tDiffuse:{value:null}},vertexShader:Fi.pp_plane_vert,fragmentShader:Fi.pp_tonemap_frag},Vi.afterimage={uniforms:{damp:{value:.96},tOld:{value:null},tNew:{value:null}},vertexShader:Fi.pp_plane_vert,fragmentShader:Fi.pp_afterimage_frag},Vi.oitWeighted={uniforms:{tRGBABuffer:{value:null},tFloatBuffer:{value:null}},vertexShader:Fi.pp_plane_vert,fragmentShader:Fi.pp_oit_weighted_frag};const Gi={r:0,b:0,g:0};function Qi(t,e,n,o,i,r,s){const a=new tn(0);let l,c,u=!0===r?0:1,h=null,f=0,d=null;function A(e,n){e.getRGB(Gi,mi(t)),o.buffers.color.setClear(Gi.r,Gi.g,Gi.b,n,s)}return{getClearColor:function(){return a},setClearColor:function(t,e=1){a.set(t),u=e,A(a,u)},getClearAlpha:function(){return u},setClearAlpha:function(t){u=t,A(a,u)},dispose:function(){l&&(l.geometry.dispose(),l.material.dispose()),l=void 0,c&&(c.geometry.dispose(),c.material.dispose()),c=void 0},render:function(o,r){let s=!1,v=!0===r.isScene?r.background:null;if(v&&v.isTexture){v=(r.backgroundBlurriness>0?n:e).get(v)}const m=t.xr,p=m.getSession&&m.getSession();p&&"additive"===p.environmentBlendMode&&(v=null),null===v?A(a,u):v&&v.isColor&&(A(v,1),s=!0),(t.autoClear||s)&&t.clear(t.autoClearColor,t.autoClearDepth,t.autoClearStencil),v&&(v.isCubeTexture||v.mapping===S)?(void 0===c&&(c=new hi(new di(1,1,1),new gi({type:"BackgroundCubeMaterial",uniforms:Ai(Vi.backgroundCube.uniforms),vertexShader:Vi.backgroundCube.vertexShader,fragmentShader:Vi.backgroundCube.fragmentShader,side:1,depthTest:!1,depthWrite:!1,fog:!1})),c.geometry.deleteAttribute("normal"),c.geometry.deleteAttribute("uv"),c.onBeforeRender=function(t,e,n){const o=n.far;this.matrixWorld.makeScale(o,o,o),this.matrixWorld.copyPosition(n.matrixWorld)},Object.defineProperty(c.material,"envMap",{get:function(){return this.uniforms.envMap.value}}),i.update(c)),c.material.uniforms.envMap.value=v,c.material.uniforms.flipEnvMap.value=v.isCubeTexture&&!1===v.isRenderTargetTexture?-1:1,c.material.uniforms.backgroundBlurriness.value=r.backgroundBlurriness,c.material.uniforms.backgroundIntensity.value=r.backgroundIntensity,c.material.toneMapped=r.backgroundToneMapped,h===v&&f===v.version&&d===t.toneMapping||(c.material.needsUpdate=!0,h=v,f=v.version,d=t.toneMapping),c.layers.enableAll(),o.unshift(c,c.geometry,c.material,0,0,null)):v&&v.isTexture&&(void 0===l&&(l=new hi(new Oi(2,2),new gi({type:"BackgroundMaterial",uniforms:Ai(Vi.background.uniforms),vertexShader:Vi.background.vertexShader,fragmentShader:Vi.background.fragmentShader,side:0,depthTest:!1,depthWrite:!1,fog:!1})),l.geometry.deleteAttribute("normal"),Object.defineProperty(l.material,"map",{get:function(){return this.uniforms.t2D.value}}),i.update(l)),l.material.uniforms.t2D.value=v,l.material.uniforms.backgroundIntensity.value=r.backgroundIntensity,l.material.toneMapped=r.backgroundToneMapped,!0===v.matrixAutoUpdate&&v.updateMatrix(),l.material.uniforms.uvTransform.value.copy(v.matrix),h===v&&f===v.version&&d===t.toneMapping||(l.material.needsUpdate=!0,h=v,f=v.version,d=t.toneMapping),l.layers.enableAll(),o.unshift(l,l.geometry,l.material,0,0,null))}}}function zi(t,e,n,o){const i=t.getParameter(34921),r=o.isWebGL2?null:e.get("OES_vertex_array_object"),s=o.isWebGL2||null!==r,a={},l=d(null);let c=l,u=!1;function h(e){return o.isWebGL2?t.bindVertexArray(e):r.bindVertexArrayOES(e)}function f(e){return o.isWebGL2?t.deleteVertexArray(e):r.deleteVertexArrayOES(e)}function d(t){const e=[],n=[],o=[];for(let t=0;t<i;t++)e[t]=0,n[t]=0,o[t]=0;return{geometry:null,program:null,wireframe:!1,newAttributes:e,enabledAttributes:n,attributeDivisors:o,object:t,attributes:{},index:null}}function A(){const t=c.newAttributes;for(let e=0,n=t.length;e<n;e++)t[e]=0}function v(t){m(t,0)}function m(n,i){const r=c.newAttributes,s=c.enabledAttributes,a=c.attributeDivisors;if(r[n]=1,0===s[n]&&(t.enableVertexAttribArray(n),s[n]=1),a[n]!==i){(o.isWebGL2?t:e.get("ANGLE_instanced_arrays"))[o.isWebGL2?"vertexAttribDivisor":"vertexAttribDivisorANGLE"](n,i),a[n]=i}}function p(){const e=c.newAttributes,n=c.enabledAttributes;for(let o=0,i=n.length;o<i;o++)n[o]!==e[o]&&(t.disableVertexAttribArray(o),n[o]=0)}function g(e,n,o,i,r,s,a){!0===a?t.vertexAttribIPointer(e,n,o,r,s):t.vertexAttribPointer(e,n,o,i,r,s)}function _(){E(),u=!0,c!==l&&(c=l,h(c.object))}function E(){l.geometry=null,l.program=null,l.wireframe=!1}return{setup:function(i,l,f,_,E){let C=!1;if(s){const e=function(e,n,i){const s=!0===i.wireframe;let l=a[e.id];void 0===l&&(l={},a[e.id]=l);let c=l[n.id];void 0===c&&(c={},l[n.id]=c);let u=c[s];void 0===u&&(u=d(o.isWebGL2?t.createVertexArray():r.createVertexArrayOES()),c[s]=u);return u}(_,f,l);c!==e&&(c=e,h(c.object)),C=function(t,e,n,o){const i=c.attributes,r=e.attributes;let s=0;const a=n.getAttributes();for(const e in a){if(a[e].location>=0){const n=i[e];let o=r[e];if(void 0===o&&("instanceMatrix"===e&&t.instanceMatrix&&(o=t.instanceMatrix),"instanceColor"===e&&t.instanceColor&&(o=t.instanceColor)),void 0===n)return!0;if(n.attribute!==o)return!0;if(o&&n.data!==o.data)return!0;s++}}return c.attributesNum!==s||c.index!==o}(i,_,f,E),C&&function(t,e,n,o){const i={},r=e.attributes;let s=0;const a=n.getAttributes();for(const e in a){if(a[e].location>=0){let n=r[e];void 0===n&&("instanceMatrix"===e&&t.instanceMatrix&&(n=t.instanceMatrix),"instanceColor"===e&&t.instanceColor&&(n=t.instanceColor));const o={};o.attribute=n,n&&n.data&&(o.data=n.data),i[e]=o,s++}}c.attributes=i,c.attributesNum=s,c.index=o}(i,_,f,E)}else{const t=!0===l.wireframe;c.geometry===_.id&&c.program===f.id&&c.wireframe===t||(c.geometry=_.id,c.program=f.id,c.wireframe=t,C=!0)}null!==E&&n.update(E,34963),(C||u)&&(u=!1,function(i,r,s,a){if(!1===o.isWebGL2&&(i.isInstancedMesh||a.isInstancedBufferGeometry)&&null===e.get("ANGLE_instanced_arrays"))return;A();const l=a.attributes,c=s.getAttributes(),u=r.defaultAttributeValues;for(const e in c){const r=c[e];if(r.location>=0){let s=l[e];if(void 0===s&&("instanceMatrix"===e&&i.instanceMatrix&&(s=i.instanceMatrix),"instanceColor"===e&&i.instanceColor&&(s=i.instanceColor)),void 0!==s){const e=s.normalized,l=s.itemSize,c=n.get(s);if(void 0===c)continue;const u=c.buffer,h=c.type,f=c.bytesPerElement,d=!0===o.isWebGL2&&(5124===h||5125===h||s.gpuType===U);if(s.isInstancedBufferAttribute){for(let t=0;t<r.locationSize;t++)m(r.location+t,s.meshPerAttribute);!0!==i.isInstancedMesh&&void 0===a.st&&(a.st=s.meshPerAttribute*s.count)}else for(let t=0;t<r.locationSize;t++)v(r.location+t);t.bindBuffer(34962,u);for(let t=0;t<r.locationSize;t++)g(r.location+t,l/r.locationSize,h,e,l*f,l/r.locationSize*t*f,d)}else if(void 0!==u){const n=u[e];if(void 0!==n)switch(n.length){case 2:t.vertexAttrib2fv(r.location,n);break;case 3:t.vertexAttrib3fv(r.location,n);break;case 4:t.vertexAttrib4fv(r.location,n);break;default:t.vertexAttrib1fv(r.location,n)}}}}p()}(i,l,f,_),null!==E&&t.bindBuffer(34963,n.get(E).buffer))},reset:_,resetDefaultState:E,dispose:function(){_();for(const t in a){const e=a[t];for(const t in e){const n=e[t];for(const t in n)f(n[t].object),delete n[t];delete e[t]}delete a[t]}},releaseStatesOfGeometry:function(t){if(void 0===a[t.id])return;const e=a[t.id];for(const t in e){const n=e[t];for(const t in n)f(n[t].object),delete n[t];delete e[t]}delete a[t.id]},releaseStatesOfProgram:function(t){for(const e in a){const n=a[e];if(void 0===n[t.id])continue;const o=n[t.id];for(const t in o)f(o[t].object),delete o[t];delete n[t.id]}},initAttributes:A,enableAttribute:v,disableUnusedAttributes:p}}function ki(t,e,n,o){const i=o.isWebGL2;let r;this.setMode=function(t){r=t},this.render=function(e,o){t.drawArrays(r,e,o),n.update(o,r,1)},this.renderInstances=function(o,s,a){if(0===a)return;let l,c;if(i)l=t,c="drawArraysInstanced";else if(l=e.get("ANGLE_instanced_arrays"),c="drawArraysInstancedANGLE",null===l)return void console.error("v3d.WebGLBufferRenderer: using v3d.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");l[c](r,o,s,a),n.update(s,r,a)}}function Hi(t,e,n){let o;function i(e){if("highp"===e){if(t.getShaderPrecisionFormat(35633,36338).precision>0&&t.getShaderPrecisionFormat(35632,36338).precision>0)return"highp";e="mediump"}return"mediump"===e&&t.getShaderPrecisionFormat(35633,36337).precision>0&&t.getShaderPrecisionFormat(35632,36337).precision>0?"mediump":"lowp"}const r="undefined"!=typeof WebGL2RenderingContext&&t instanceof WebGL2RenderingContext||"undefined"!=typeof WebGL2ComputeRenderingContext&&t instanceof WebGL2ComputeRenderingContext;let s=void 0!==n.precision?n.precision:"highp";const a=i(s);a!==s&&(console.warn("v3d.WebGLRenderer:",s,"not supported, using",a,"instead."),s=a);const l=!0===n.logarithmicDepthBuffer,c=t.getParameter(34930),u=t.getParameter(35660),h=t.getParameter(3379),f=t.getParameter(34076),d=t.getParameter(34921),A=t.getParameter(36347),v=t.getParameter(36348),m=t.getParameter(36349),p=u>0,g=r||e.has("OES_texture_float");return{isWebGL2:r,getMaxAnisotropy:function(){if(void 0!==o)return o;if(!0===e.has("EXT_texture_filter_anisotropic")){const n=e.get("EXT_texture_filter_anisotropic");o=t.getParameter(n.MAX_TEXTURE_MAX_ANISOTROPY_EXT)}else o=0;return o},getMaxPrecision:i,precision:s,logarithmicDepthBuffer:l,maxTextures:c,maxVertexTextures:u,maxTextureSize:h,maxCubemapSize:f,maxAttributes:d,maxVertexUniforms:A,maxVaryings:v,maxFragmentUniforms:m,vertexTextures:p,floatFragmentTextures:g,floatVertexTextures:p&&g,maxSamples:r?t.getParameter(36183):0}}function Wi(t){const e=this;let n=null,o=0,i=!1,r=!1;const s=new Ri,a=new xe,l={value:null,needsUpdate:!1};function c(){l.value!==n&&(l.value=n,l.needsUpdate=o>0),e.numPlanes=o,e.numIntersection=0}function u(t,n,o,i){const r=null!==t?t.length:0;let c=null;if(0!==r){if(c=l.value,!0!==i||null===c){const e=o+4*r,i=n.matrixWorldInverse;a.getNormalMatrix(i),(null===c||c.length<e)&&(c=new Float32Array(e));for(let e=0,n=o;e!==r;++e,n+=4)s.copy(t[e]).applyMatrix4(i,a),s.normal.toArray(c,n),c[n+3]=s.constant}l.value=c,l.needsUpdate=!0}return e.numPlanes=r,e.numIntersection=0,c}this.uniform=l,this.numPlanes=0,this.numIntersection=0,this.init=function(t,e,r){const s=0!==t.length||e||0!==o||i;return i=e,n=u(t,r,0),o=t.length,s},this.beginShadows=function(){r=!0,u(null)},this.endShadows=function(){r=!1,c()},this.setState=function(e,s,a){const h=e.clippingPlanes,f=e.clipIntersection,d=e.clipShadows,A=t.get(e);if(!i||null===h||0===h.length||r&&!d)r?u(null):c();else{const t=r?0:o,e=4*t;let i=A.clippingState||null;l.value=i,i=u(h,s,e,a);for(let t=0;t!==e;++t)i[t]=n[t];A.clippingState=i,this.numIntersection=f?this.numPlanes:0,this.numPlanes+=t}}}function Yi(t){let e=new WeakMap;function n(t,e){return e===I?t.mapping=w:e===M&&(t.mapping=x),t}function o(t){const n=t.target;n.removeEventListener("dispose",o);const i=e.get(n);void 0!==i&&(e.delete(n),i.dispose())}return{get:function(i){if(i&&i.isTexture&&!1===i.isRenderTargetTexture){const r=i.mapping;if(r===I||r===M){if(e.has(i)){return n(e.get(i).texture,i.mapping)}{const r=i.image;if(r&&r.height>0){const s=new Ii(r.height/2);return s.fromEquirectangularTexture(t,i),e.set(i,s),i.addEventListener("dispose",o),n(s.texture,i.mapping)}return null}}}return i},dispose:function(){e=new WeakMap}}}class Xi extends _i{constructor(t=-1,e=1,n=1,o=-1,i=.1,r=2e3){super(),this.isOrthographicCamera=!0,this.type="OrthographicCamera",this.zoom=1,this.view=null,this.left=t,this.right=e,this.top=n,this.bottom=o,this.near=i,this.far=r,this.updateProjectionMatrix()}copy(t,e){return super.copy(t,e),this.left=t.left,this.right=t.right,this.top=t.top,this.bottom=t.bottom,this.near=t.near,this.far=t.far,this.zoom=t.zoom,this.view=null===t.view?null:Object.assign({},t.view),this}setViewOffset(t,e,n,o,i,r){null===this.view&&(this.view={enabled:!0,fullWidth:1,fullHeight:1,offsetX:0,offsetY:0,width:1,height:1}),this.view.enabled=!0,this.view.fullWidth=t,this.view.fullHeight=e,this.view.offsetX=n,this.view.offsetY=o,this.view.width=i,this.view.height=r,this.updateProjectionMatrix()}clearViewOffset(){null!==this.view&&(this.view.enabled=!1),this.updateProjectionMatrix()}updateProjectionMatrix(){const t=(this.right-this.left)/(2*this.zoom),e=(this.top-this.bottom)/(2*this.zoom),n=(this.right+this.left)/2,o=(this.top+this.bottom)/2;let i=n-t,r=n+t,s=o+e,a=o-e;if(null!==this.view&&this.view.enabled){const t=(this.right-this.left)/this.view.fullWidth/this.zoom,e=(this.top-this.bottom)/this.view.fullHeight/this.zoom;i+=t*this.view.offsetX,r=i+t*this.view.width,s-=e*this.view.offsetY,a=s-e*this.view.height}this.projectionMatrix.makeOrthographic(i,r,s,a,this.near,this.far),this.projectionMatrixInverse.copy(this.projectionMatrix).invert()}}class Ki extends gi{constructor(t){super(t),this.isRawShaderMaterial=!0,this.type="RawShaderMaterial"}}let ji=256;const Zi=[{relSize:1,sigma:0,origin:[0,0]},{relSize:.5,sigma:.025,origin:[0,2/3]},{relSize:1/4,sigma:.07,origin:[.5,2/3]},{relSize:1/8,sigma:.18,origin:[.75,2/3]},{relSize:1/16,sigma:.24,origin:[.875,2/3]},{relSize:1/16,sigma:.3,origin:[.875,17/24]},{relSize:1/16,sigma:.36,origin:[.875,.75]},{relSize:1/16,sigma:.42,origin:[.875,19/24]},{relSize:1/16,sigma:.48,origin:[.875,20/24]},{relSize:1/16,sigma:.54,origin:[.875,.875]},{relSize:1/16,sigma:.6,origin:[.875,22/24]}];function qi(t){return Zi[t].relSize*ji}const Ji=20,$i=new Xi,tr=Zi.map(function(t,e){const n=1/(qi(e)-1),o=-n/2,i=1+n/2,r=[o,o,i,o,i,i,o,o,i,i,o,i],s=new Float32Array(108),a=new Float32Array(72),l=new Float32Array(36);for(let t=0;t<6;t++){const e=t%3*2/3-1,n=t>2?0:-1,o=[e,n,0,e+2/3,n,0,e+2/3,n+1,0,e,n,0,e+2/3,n+1,0,e,n+1,0];s.set(o,18*t),a.set(r,12*t);const i=[t,t,t,t,t,t];l.set(i,6*t)}const c=new Xo;return c.setAttribute("position",new Oo(s,3)),c.setAttribute("uv",new Oo(a,2)),c.setAttribute("faceIndex",new Oo(l,1)),c}),er=new tn;let nr=null;const or=(1+Math.sqrt(5))/2,ir=1/or,rr=[new An(1,1,1),new An(-1,1,1),new An(1,1,-1),new An(-1,1,-1),new An(0,or,ir),new An(0,or,-ir),new An(ir,0,or),new An(-ir,0,or),new An(or,ir,0),new An(-or,ir,0)];class sr{constructor(t,e){this.lt=t,this.ct=null,this.ut=null,this.ht=null,this.flipCubemapX=!1,Object.defineProperties(this,{maxTileSize:{get:function(){return ji},set:function(t){ji=t}}}),void 0!==e&&(this.maxTileSize=e),this.ft=function(t,e){const n=new Float32Array(t),o=new An(0,1,0),i=new Ki({defines:{n:t,cubeUV_maxTileSize:Oe(e)},uniforms:{envMap:{value:null},samples:{value:1},weights:{value:n},latitudinal:{value:!1},dTheta:{value:0},lodIdx:{value:0},poleAxis:{value:o}},vertexShader:Fi.pmrem_common_vert,fragmentShader:Fi.pmrem_blur_frag,blending:0,depthTest:!1,depthWrite:!1});return i.type="SphericalGaussianBlur",i}(Ji,this.maxTileSize),this.dt(this.ft)}fromScene(t,e=0,n=.1,o=100){nr=this.lt.getRenderTarget();const i=this.At();return this.vt(t,n,o,i),e>0&&this.gt(i,0,0,e),this._t(i),this.Et(i),i}fromEquirectangular(t){return t.magFilter=N,t.minFilter=N,t.generateMipmaps=!1,this.fromCubemap(t)}fromCubemap(t){nr=this.lt.getRenderTarget();const e=this.At(t);return this.Ct(t,e,this.flipCubemapX),this._t(e),this.Et(e),e}fromCubeRenderTarget(t,e){const n=this.At(t.texture,e);return this.wt(t,n,this.flipCubemapX),this._t(n),this.Et(n),n}compileCubemapShader(){null===this.ht&&(this.ht=ur(),this.dt(this.ht))}compileEquirectangularShader(){null===this.ut&&(this.ut=cr(),this.dt(this.ut))}dispose(){this.ft.dispose(),null!==this.ct&&this.ct.dispose(),null!==this.ht&&this.ht.dispose(),null!==this.ut&&this.ut.dispose();for(let t=0;t<tr.length;t++)tr[t].dispose();this.lt=null}Et(t){this.lt.setRenderTarget(nr),t.scissorTest=!1,t.setSize(t.width,t.height)}At(t,e){const n={magFilter:N,minFilter:N,generateMipmaps:!1,type:t?t.type:Q,format:t?t.format:W,encoding:t?t.encoding:Ot,depthBuffer:!1,stencilBuffer:!1};void 0!==e&&Object.assign(n,e);const o=ar(n);return o.depthBuffer=!t,null===this.ct&&(this.ct=ar(n)),o}dt(t){const e=new Ni;e.add(new hi(tr[0],t)),this.lt.compile(e,$i)}vt(t,e,n,o){const i=new Ei(90,1,e,n),r=[1,1,1,1,-1,1],s=[1,1,-1,-1,-1,1],a=this.lt,l=a.outputEncoding,c=a.toneMapping,u=a.toneMappingExposure;a.getClearColor(er);const h=a.getClearAlpha();a.toneMapping=1,a.toneMappingExposure=1,a.outputEncoding=Ot,t.scale.z*=-1;let f=t.background;if(f&&f.isColor){f.convertSRGBToLinear();const e=Math.max(f.r,f.g,f.b),n=Math.min(Math.max(Math.ceil(Math.log2(e)),-128),127);f=f.multiplyScalar(Math.pow(2,-n));const o=(n+128)/255;a.setClearColor(f,o),t.background=null}for(let e=0;e<6;e++){const n=e%3;0===n?(i.up.set(0,r[e],0),i.lookAt(s[e],0,0)):1===n?(i.up.set(0,0,r[e]),i.lookAt(0,s[e],0)):(i.up.set(0,r[e],0),i.lookAt(0,0,s[e]));const l=qi(0);lr(o,n*l,e>2?l:0,l,l),a.setRenderTarget(o),a.render(t,i)}a.toneMapping=c,a.toneMappingExposure=u,a.outputEncoding=l,a.setClearColor(er,h),t.scale.z*=-1}Ct(t,e,n){const o=this.lt,i=new Ni;t.isCubeTexture?null===this.ht&&(this.ht=ur()):null===this.ut&&(this.ut=cr());const r=t.isCubeTexture?this.ht:this.ut;i.add(new hi(tr[0],r));const s=r.uniforms;s.envMap.value=t,t.isCubeTexture?s.flipCubemapX.value=n||!1:s.texelSize.value.set(1/t.image.width,1/t.image.height);const a=qi(0);lr(e,0,0,3*a,2*a),o.setRenderTarget(e),o.render(i,$i)}_t(t){const e=this.lt,n=e.autoClear;e.autoClear=!1;for(let e=1;e<Zi.length;e++){const n=Zi[e].sigma,o=Zi[e-1].sigma,i=Math.sqrt(n*n-o*o),r=rr[(e-1)%rr.length];this.gt(t,e-1,e,i,r)}e.autoClear=n}gt(t,e,n,o,i){const r=this.ct;this.xt(t,r,e,n,o,"latitudinal",i),this.xt(r,t,n,n,o,"longitudinal",i)}xt(t,e,n,o,i,r,s){const a=this.lt,l=this.ft;"latitudinal"!==r&&"longitudinal"!==r&&console.error("blur direction must be either latitudinal or longitudinal!");const c=new Ni;c.add(new hi(tr[o],l));const u=l.uniforms,h=qi(n)-1;let f=isFinite(i)?Math.PI/(2*h):2*Math.PI/39,d=i/f,A=isFinite(i)?1+Math.floor(3*d):Ji;A>Ji&&(A=Ji,d=19/3,f=i/d);const v=[];let m=0;for(let t=0;t<Ji;++t){const e=t/d,n=Math.exp(-e*e/2);v.push(n),0===t?m+=n:t<A&&(m+=2*n)}for(let t=0;t<v.length;t++)v[t]=v[t]/m;u.envMap.value=t.texture,u.samples.value=A,u.weights.value=v,u.latitudinal.value="latitudinal"===r,s&&(u.poleAxis.value=s),u.dTheta.value=f,u.lodIdx.value=n;l.defines.cubeUV_maxTileSize=Oe(qi(0));const[p,g]=Zi[o].origin.map(function(t){return t*ji*3});const _=qi(o);lr(e,p,g,3*_,2*_),a.setRenderTarget(e),a.render(c,$i)}wt(t,e,n){const o=this.lt,i=new Ni;null==this.ht&&(this.ht=ur());const r=this.ht;i.add(new hi(tr[0],r));const s=r.uniforms;s.envMap.value=t.texture,s.flipCubemapX.value=n||!1;const a=qi(0);lr(e,0,0,3*a,2*a),o.setRenderTarget(e),o.render(i,$i)}}function ar(t){const e=qi(0),n=new cn(3*e,3*e,t);return n.texture.mapping=S,n.texture.name="PMREM.cubeUV",n.scissorTest=!0,n}function lr(t,e,n,o,i){t.viewport.set(e,n,o,i),t.scissor.set(e,n,o,i)}function cr(){const t=new we(1,1),e=new Ki({uniforms:{envMap:{value:null},texelSize:{value:t}},vertexShader:Fi.pmrem_common_vert,fragmentShader:Fi.pmrem_equirect_frag,blending:0,depthTest:!1,depthWrite:!1});return e.type="EquirectangularToCubeUV",e}function ur(){const t=new Ki({uniforms:{envMap:{value:null},flipCubemapX:{value:!1}},vertexShader:Fi.pmrem_common_vert,fragmentShader:Fi.pmrem_cubemap_frag,blending:0,depthTest:!1,depthWrite:!1});return t.type="CubemapToCubeUV",t}function hr(t){let e=new WeakMap,n=null;function o(t){const n=t.target;n.removeEventListener("dispose",o);const i=e.get(n);void 0!==i&&(e.delete(n),i.dispose())}return{get:function(i){if(i&&i.isTexture){const r=i.mapping,s=r===I||r===M,a=r===w||r===x;if(s||a){if(i.isRenderTargetTexture&&!0===i.needsPMREMUpdate){i.needsPMREMUpdate=!1;let o=e.get(i);return null===n&&(n=new sr(t)),o=s?n.fromEquirectangular(i,o):n.fromCubemap(i,o),e.set(i,o),o.texture}if(e.has(i))return e.get(i).texture;{const r=i.image;if(s&&r&&r.height>0||a&&r&&function(t){let e=0;const n=6;for(let o=0;o<n;o++)void 0!==t[o]&&e++;return e===n}(r)){null===n&&(n=new sr(t));const r=s?n.fromEquirectangular(i):n.fromCubemap(i);return e.set(i,r),i.addEventListener("dispose",o),r.texture}return null}}}return i},dispose:function(){e=new WeakMap,null!==n&&(n.dispose(),n=null)}}}function fr(t){const e={};function n(n){if(void 0!==e[n])return e[n];let o;switch(n){case"WEBGL_depth_texture":o=t.getExtension("WEBGL_depth_texture")||t.getExtension("MOZ_WEBGL_depth_texture")||t.getExtension("WEBKIT_WEBGL_depth_texture");break;case"EXT_texture_filter_anisotropic":o=t.getExtension("EXT_texture_filter_anisotropic")||t.getExtension("MOZ_EXT_texture_filter_anisotropic")||t.getExtension("WEBKIT_EXT_texture_filter_anisotropic");break;case"WEBGL_compressed_texture_s3tc":o=t.getExtension("WEBGL_compressed_texture_s3tc")||t.getExtension("MOZ_WEBGL_compressed_texture_s3tc")||t.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");break;case"WEBGL_compressed_texture_pvrtc":o=t.getExtension("WEBGL_compressed_texture_pvrtc")||t.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");break;default:o=t.getExtension(n)}return e[n]=o,o}return{has:function(t){return null!==n(t)},init:function(t){t.isWebGL2?n("EXT_color_buffer_float"):(n("WEBGL_depth_texture"),n("OES_texture_float"),n("OES_texture_half_float"),n("OES_texture_half_float_linear"),n("OES_standard_derivatives"),n("OES_element_index_uint"),n("OES_vertex_array_object"),n("ANGLE_instanced_arrays")),n("OES_texture_float_linear"),n("EXT_color_buffer_half_float"),n("WEBGL_multisampled_render_to_texture")},get:function(t){const e=n(t);return null===e&&console.warn("v3d.WebGLRenderer: "+t+" extension not supported."),e}}}function dr(t,e,n,o){const i={},r=new WeakMap;function s(t){const a=t.target;null!==a.index&&e.remove(a.index);for(const t in a.attributes)e.remove(a.attributes[t]);a.removeEventListener("dispose",s),delete i[a.id];const l=r.get(a);l&&(e.remove(l),r.delete(a)),o.releaseStatesOfGeometry(a),!0===a.isInstancedBufferGeometry&&delete a.st,n.memory.geometries--}function a(t){const n=[],o=t.index,i=t.attributes.position;let s=0;if(null!==o){const t=o.array;s=o.version;for(let e=0,o=t.length;e<o;e+=3){const o=t[e+0],i=t[e+1],r=t[e+2];n.push(o,i,i,r,r,o)}}else{const t=i.array;s=i.version;for(let e=0,o=t.length/3-1;e<o;e+=3){const t=e+0,o=e+1,i=e+2;n.push(t,o,o,i,i,t)}}const a=new(Se(n)?Uo:Fo)(n,1);a.version=s;const l=r.get(t);l&&e.remove(l),r.set(t,a)}return{get:function(t,e){return!0===i[e.id]||(e.addEventListener("dispose",s),i[e.id]=!0,n.memory.geometries++),e},update:function(t){const n=t.attributes;for(const t in n)e.update(n[t],34962);const o=t.morphAttributes;for(const t in o){const n=o[t];for(let t=0,o=n.length;t<o;t++)e.update(n[t],34962)}},getWireframeAttribute:function(t){const e=r.get(t);if(e){const n=t.index;null!==n&&e.version<n.version&&a(t)}else a(t);return r.get(t)}}}function Ar(t,e,n,o){const i=o.isWebGL2;let r,s,a;this.setMode=function(t){r=t},this.setIndex=function(t){s=t.type,a=t.bytesPerElement},this.render=function(e,o){t.drawElements(r,o,s,e*a),n.update(o,r,1)},this.renderInstances=function(o,l,c){if(0===c)return;let u,h;if(i)u=t,h="drawElementsInstanced";else if(u=e.get("ANGLE_instanced_arrays"),h="drawElementsInstancedANGLE",null===u)return void console.error("v3d.WebGLIndexedBufferRenderer: using v3d.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");u[h](r,l,s,o*a,c),n.update(l,r,c)}}function vr(t){const e={geometries:0,textures:0,textureSpecs:new Map},n={frame:0,calls:0,triangles:0,points:0,lines:0,customCounter:0};return{memory:e,render:n,programs:null,numShaderCompiles:0,reset:function(){n.calls=0,n.triangles=0,n.points=0,n.lines=0,n.customCounter=0},update:function(t,e,o){switch(n.calls++,e){case 4:n.triangles+=o*(t/3);break;case 1:n.lines+=o*(t/2);break;case 3:n.lines+=o*(t-1);break;case 2:n.lines+=o*t;break;case 0:n.points+=o*t;break;default:console.error("v3d.WebGLInfo: Unknown draw mode:",e)}},count:function(){n.customCounter++},addTextureSpec:function(t){let n,o,i,r,s,a;t.isWebGLRenderTarget?(n=t.texture.name,o="RenderTarget",i=t.width,r=t.height,s=t.texture.format,a=!!t.texture.isCubeTexture):(n=t.name,o="Texture",i=t.image.width,r=t.image.height,s=t.format,a=!!t.isCubeTexture),e.textureSpecs.set(t,{name:n,type:o,width:i,height:r,format:s,isCube:a})},removeTextureSpec:function(t){e.textureSpecs.delete(t)}}}function mr(t,e){function n(t,n){t.opacity.value=n.opacity,n.color&&t.diffuse.value.copy(n.color),n.emissive&&t.emissive.value.copy(n.emissive).multiplyScalar(n.emissiveIntensity),n.map&&(t.map.value=n.map),n.alphaMap&&(t.alphaMap.value=n.alphaMap),n.bumpMap&&(t.bumpMap.value=n.bumpMap,t.bumpScale.value=n.bumpScale,1===n.side&&(t.bumpScale.value*=-1)),n.displacementMap&&(t.displacementMap.value=n.displacementMap,t.displacementScale.value=n.displacementScale,t.displacementBias.value=n.displacementBias),n.emissiveMap&&(t.emissiveMap.value=n.emissiveMap),n.normalMap&&(t.normalMap.value=n.normalMap,t.normalScale.value.copy(n.normalScale),1===n.side&&t.normalScale.value.negate()),n.alphaTest>0&&(t.alphaTest.value=n.alphaTest);const o=e.get(n).envMap;let i,r;o&&(t.envMap.value=o,t.flipEnvMap.value=o.isCubeTexture&&!1===o.isRenderTargetTexture?-1:1,t.reflectivity.value=n.reflectivity,t.refractionRatio.value=n.refractionRatio),n.lightMap&&(t.lightMap.value=n.lightMap,t.lightMapIntensity.value=n.lightMapIntensity),n.aoMap&&(t.aoMap.value=n.aoMap,t.aoMapIntensity.value=n.aoMapIntensity),n.map?i=n.map:n.displacementMap?i=n.displacementMap:n.normalMap?i=n.normalMap:n.bumpMap?i=n.bumpMap:n.roughnessMap?i=n.roughnessMap:n.metalnessMap?i=n.metalnessMap:n.alphaMap?i=n.alphaMap:n.emissiveMap&&(i=n.emissiveMap),void 0!==i&&(!0===i.matrixAutoUpdate&&i.updateMatrix(),t.uvTransform.value.copy(i.matrix)),n.aoMap?r=n.aoMap:n.lightMap&&(r=n.lightMap),void 0!==r&&(!0===r.matrixAutoUpdate&&r.updateMatrix(),t.uv2Transform.value.copy(r.matrix))}return{refreshFogUniforms:function(e,n){n.color.getRGB(e.fogColor.value,mi(t)),n.isFog?(e.fogNear.value=n.near,e.fogFar.value=n.far):n.isFogExp2&&(e.fogDensity.value=n.density)},refreshMaterialUniforms:function(t,o,i,r){o.ssrParams&&function(t,e){t.invProjectionMatrix.value=e.ssrParams.invProjectionMatrix,t.ssrSourceBuffer.value=e.ssrParams.sourceBuffer.texture,t.ssrDepthBuffer.value=e.ssrParams.depthBuffer.texture,t.ssrBackfaceDepthBuffer.value=e.ssrParams.backfaceDepthBuffer.texture,t.ssrStride.value=e.ssrParams.stride,t.ssrJitter.value=e.ssrParams.jitter,t.ssrMaxDistance.value=e.ssrParams.maxDistance}(t,o),o.isMeshBasicMaterial||o.isMeshLambertMaterial?n(t,o):o.isMeshStandardMaterial?(n(t,o),function(t,n){t.roughness.value=n.roughness,t.metalness.value=n.metalness,n.roughnessMap&&(t.roughnessMap.value=n.roughnessMap);n.metalnessMap&&(t.metalnessMap.value=n.metalnessMap);const o=e.get(n).envMap;o&&(t.envMapIntensity.value=n.envMapIntensity,t.envMapParallaxType.value=n.envMapParallaxType,t.envMapParallaxMatrix.value.copy(n.envMapParallaxMatrix),t.envMapParallaxMatrixInv.value.copy(n.envMapParallaxMatrixInv))}(t,o)):o.isMeshDepthMaterial?(n(t,o),function(t,e){t.slopeScaledBias.value=e.slopeScaledBias}(t,o)):o.isMeshDistanceMaterial?(n(t,o),function(t,e){t.referencePosition.value.copy(e.referencePosition),t.nearDistance.value=e.nearDistance,t.farDistance.value=e.farDistance,t.slopeScaledBias.value=e.slopeScaledBias}(t,o)):o.isMeshNormalMaterial?n(t,o):o.isLineBasicMaterial?(function(t,e){t.diffuse.value.copy(e.color),t.opacity.value=e.opacity}(t,o),o.isLineDashedMaterial&&function(t,e){t.dashSize.value=e.dashSize,t.totalSize.value=e.dashSize+e.gapSize,t.scale.value=e.scale}(t,o)):o.isPointsMaterial?function(t,e,n,o){t.diffuse.value.copy(e.color),t.opacity.value=e.opacity,t.size.value=e.size*n,t.scale.value=.5*o,e.map&&(t.map.value=e.map);e.alphaMap&&(t.alphaMap.value=e.alphaMap);e.alphaTest>0&&(t.alphaTest.value=e.alphaTest);let i;e.map?i=e.map:e.alphaMap&&(i=e.alphaMap);void 0!==i&&(!0===i.matrixAutoUpdate&&i.updateMatrix(),t.uvTransform.value.copy(i.matrix))}(t,o,i,r):o.isSpriteMaterial?function(t,e){t.diffuse.value.copy(e.color),t.opacity.value=e.opacity,t.rotation.value=e.rotation,e.map&&(t.map.value=e.map);e.alphaMap&&(t.alphaMap.value=e.alphaMap);e.alphaTest>0&&(t.alphaTest.value=e.alphaTest);let n;e.map?n=e.map:e.alphaMap&&(n=e.alphaMap);void 0!==n&&(!0===n.matrixAutoUpdate&&n.updateMatrix(),t.uvTransform.value.copy(n.matrix))}(t,o):o.isShadowMaterial?(t.color.value.copy(o.color),t.opacity.value=o.opacity):o.isMeshMaskMaterial?(n(t,o),function(t,e){e.cameraNearFar&&(t.cameraNearFar.value=e.cameraNearFar);t.depthTexture.value=e.depthTexture,e.textureMatrix&&(t.textureMatrix.value=e.textureMatrix)}(t,o)):o.isMeshNodeMaterial?function(t,n){n.alphaTest>0&&(t.alphaTest.value=n.alphaTest);for(let e=0;e<n.nodeValue.length;e++)t.nodeValue.value[e]=n.nodeValue[e];for(let e=0;e<n.nodeRGB.length;e++){n.nodeRGB[e].toArray(t.nodeRGB.value,4*e)}const o=e.get(n).envMap;o&&(t.envMap.value=o,t.flipEnvMap.value=o.isCubeTexture&&o.isRenderTargetTexture?-1:1,t.envMapIntensity.value=n.envMapIntensity,t.envMapParallaxType.value=n.envMapParallaxType,t.envMapParallaxMatrix.value.copy(n.envMapParallaxMatrix),t.envMapParallaxMatrixInv.value.copy(n.envMapParallaxMatrixInv));n.displacementMap&&(t.displacementMap.value=n.displacementMap,t.displacementScale.value=n.displacementScale,t.displacementBias.value=n.displacementBias);t.materialIndex.value=n.materialIndex}(t,o):o.isMeshLineMaterial?function(t,e){t.lineWidth.value=e.lineWidth,t.sizeAttenuation.value=e.sizeAttenuation,t.color.value=e.color,t.opacity.value=e.opacity,t.useMap.value=e.useMap,e.map&&(t.map.value=e.map);t.useAlphaMap.value=e.useAlphaMap,e.alphaMap&&(t.alphaMap.value=e.alphaMap);t.visibility.value=e.visibility,t.alphaTest.value=e.alphaTest,t.repeat.value=e.repeat}(t,o):o.isShaderMaterial&&(o.uniformsNeedUpdate=!1)},refreshGTAOUniforms:function(t,e){t.gtaoMap.value=e},refreshPlaneReflProbeUniforms:function(t,e){t.planeReflTexture.value=e.renderTarget.texture,t.planeReflTextureMatrix.value.copy(e.textureMatrix),t.planeReflDir.value.copy(e.normal),t.planeReflBoundingBoxMin.value.copy(e.boundingBox.min),t.planeReflBoundingBoxMax.value.copy(e.boundingBox.max),t.planeReflInvModelMatrix.value.copy(e.matrixWorldInverse),t.planeReflFalloff.value=e.falloff}}}function pr(t,e){return t[0]-e[0]}function gr(t,e){return Math.abs(e[1])-Math.abs(t[1])}function _r(t,e,n){const o={},i=new Float32Array(12),r=new WeakMap,s=new ln,a=[];for(let t=0;t<12;t++)a[t]=[t,0];return{update:function(l,c,u,h){const f=l.morphTargetInfluences;if(!0===e.isWebGL2){const d=c.morphAttributes.position||c.morphAttributes.normal,A=void 0!==d?d.length:0;let v=r.get(c);if(void 0===v||v.count!==A){void 0!==v&&v.texture.dispose();const g=void 0!==c.morphAttributes.position,_=void 0!==c.morphAttributes.normal,E=c.morphAttributes.position||[],C=c.morphAttributes.normal||[];let w=0;!0===g&&(w=1),!0===_&&(w=2);let x=c.attributes.position.count*w,I=1;x>e.maxTextureSize&&(I=Math.ceil(x/e.maxTextureSize),x=e.maxTextureSize);const M=new Float32Array(x*I*4*A),S=new un(M,x,I,A);S.type=G,S.needsUpdate=!0;const b=4*w;for(let R=0;R<A;R++){const T=E[R],B=C[R],L=x*I*4*R;for(let N=0;N<T.count;N++){const D=N*b;!0===g&&(s.fromBufferAttribute(T,N),M[L+D+0]=s.x,M[L+D+1]=s.y,M[L+D+2]=s.z,M[L+D+3]=0),!0===_&&(s.fromBufferAttribute(B,N),M[L+D+4]=s.x,M[L+D+5]=s.y,M[L+D+6]=s.z,M[L+D+7]=0)}}function y(){S.dispose(),r.delete(c),c.removeEventListener("dispose",y)}v={count:A,texture:S,size:new we(x,I)},r.set(c,v),c.addEventListener("dispose",y)}let m=0;for(let P=0;P<f.length;P++)m+=f[P];const p=c.morphTargetsRelative?1:1-m;h.getUniforms().setValue(t,"morphTargetBaseInfluence",p),h.getUniforms().setValue(t,"morphTargetInfluences",f),h.getUniforms().setValue(t,"morphTargetsTexture",v.texture,n),h.getUniforms().setValue(t,"morphTargetsTextureSize",v.size)}else{const O=void 0===f?0:f.length;let F=o[c.id];if(void 0===F||F.length!==O){F=[];for(let k=0;k<O;k++)F[k]=[k,0];o[c.id]=F}for(let H=0;H<O;H++){const W=F[H];W[0]=H,W[1]=f[H]}F.sort(gr);for(let Y=0;Y<12;Y++)Y<O&&F[Y][1]?(a[Y][0]=F[Y][0],a[Y][1]=F[Y][1]):(a[Y][0]=Number.MAX_SAFE_INTEGER,a[Y][1]=0);a.sort(pr);const U=c.morphAttributes.position,V=c.morphAttributes.normal;let Q=0;for(let X=0;X<12;X++){const K=a[X],j=K[0],Z=K[1];j!==Number.MAX_SAFE_INTEGER&&Z?(U&&c.getAttribute("morphTarget"+X)!==U[j]&&c.setAttribute("morphTarget"+X,U[j]),V&&c.getAttribute("morphNormal"+X)!==V[j]&&c.setAttribute("morphNormal"+X,V[j]),i[X]=Z,Q+=Z):(U&&!0===c.hasAttribute("morphTarget"+X)&&c.deleteAttribute("morphTarget"+X),V&&!0===c.hasAttribute("morphNormal"+X)&&c.deleteAttribute("morphNormal"+X),i[X]=0)}const z=c.morphTargetsRelative?1:1-Q;h.getUniforms().setValue(t,"morphTargetBaseInfluence",z),h.getUniforms().setValue(t,"morphTargetInfluences",i)}}}}class Er extends an{constructor(t,e,n,o,i,r,s,a,l,c){if((c=void 0!==c?c:Y)!==Y&&c!==X)throw new Error("DepthTexture format must be either v3d.DepthFormat or v3d.DepthStencilFormat");void 0===n&&c===Y&&(n=V),void 0===n&&c===X&&(n=H),super(null,o,i,r,s,a,c,n,l),this.isDepthTexture=!0,this.image={width:t,height:e},this.magFilter=void 0!==s?s:T,this.minFilter=void 0!==a?a:T,this.flipY=!1,this.generateMipmaps=!1}}class Cr extends Zt{constructor(){super(),this.enabled=!0,this.needsSwap=!0,this.clear=!1,this.renderToScreen=!1}setSize(){}render(){console.error("v3d.Pass: .render() must be implemented in derived pass.")}setCamera(t){}dispose(){}}const wr=new Xi(-1,1,1,-1,0,1),xr=new Xo;xr.setAttribute("position",new Oo(new Float32Array([-1,3,0,-1,-1,0,3,-1,0]),3)),xr.setAttribute("uv",new Oo(new Float32Array([0,2,0,0,2,0]),2));class Ir{constructor(t){this.It=new hi(xr,t)}dispose(){this.It.geometry.dispose()}render(t){t.render(this.It,wr)}get material(){return this.It.material}set material(t){this.It.material=t}static dispose(){xr.dispose()}}const Mr=new tn,Sr=new eo;class br{constructor(t,e){this.isWebGLOITMethod=!0,this.resolution=t,this.textureType=e,this.type="WebGLOITMethod",this.mute=!1}render(){this.mute}dispose(){}setSize(t,e){this.resolution.set(t,e)}Mt(t){t.state.buffers.depth.setTest(!0),t.state.buffers.depth.setMask(!0),t.state.buffers.color.setMask(!0)}}class yr extends br{constructor(t,e,n){super(t,e),this.isWebGLOITWeighted=!0,this.type="WebGLOITWeighted",this.shader=Vi.oitWeighted,this.uniforms=pi.clone(this.shader.uniforms),this.scene=null,this.camera=null,this.aaSamples=n||0,this.renderTargetMRT=new fn(this.resolution.x,this.resolution.y,2),this.renderTargetMRT.texture[0].name="wboit_rgba",this.renderTargetMRT.texture[0].format=W,this.renderTargetMRT.texture[0].type=e,this.renderTargetMRT.texture[1].name="wboit_r",this.renderTargetMRT.texture[1].format=K,this.renderTargetMRT.texture[1].type=e,this.aaSamples>0&&(this.renderTargetMRTMSAA=new fn(this.resolution.x,this.resolution.y,2,{samples:n}),this.renderTargetMRTMSAA.texture[0].name="wboit_rgba",this.renderTargetMRTMSAA.texture[0].format=W,this.renderTargetMRTMSAA.texture[0].type=e,this.renderTargetMRTMSAA.texture[1].name="wboit_r",this.renderTargetMRTMSAA.texture[1].format=K,this.renderTargetMRTMSAA.texture[1].type=e),this.fsQuadSolver=new Ir(new gi({defines:Object.assign({},this.shader.defines),uniforms:pi.clone(this.shader.uniforms),vertexShader:this.shader.vertexShader,fragmentShader:this.shader.fragmentShader,depthTest:!1,depthWrite:!1,blending:5,blendEquation:a,blendSrc:A,blendDst:v,blendEquationAlpha:a,blendSrcAlpha:h,blendDstAlpha:v})),this.St={},this.bt={},this.yt=new eo}dispose(){super.dispose(),this.renderTargetMRT.dispose(),this.renderTargetMRTMSAA&&this.renderTargetMRTMSAA.dispose()}setSize(t,e){super.setSize(t,e),this.renderTargetMRT.setSize(t,e),this.renderTargetMRTMSAA&&this.renderTargetMRTMSAA.setSize(t,e)}render(t,e,n,o,i){if(this.mute)return;this.Mt(t);const r=t.getRenderTarget();if(r.isWebGLCubeRenderTarget)return void e(n,o,i);const s=o.overrideMaterial;if(s&&!this.isSupportedMaterial(s))return void e(n,o,i);if(this.resolution.x!==r.width&&this.resolution.y!==r.height)return console.warn("v3d.WebGLOITRenderer: render target size mismatch in v3d.WebGLOITWeighted."),void e(n,o,i);this.scene=o,this.camera=i,this.yt.mask=this.camera.layers.mask;const a=t.getClearColor(Mr),l=t.getClearAlpha(),c=t.autoClear,u=t.useOIT,h=t.sortObjects;t.setClearColor(0),t.setClearAlpha(0),t.autoClear=!1,t.sortObjects=!1,t.useOIT=!1;const f=this.renderTargetMRTMSAA&&this.renderTargetMRTMSAA.samples==r.samples;if(s){const a=[{object:o,material:s}];this.Rt(t,e,f,n,a);const l=s.colorWrite;s.colorWrite=!1,s.needsUpdate=!0,t.setRenderTarget(r),e(n,o,i),s.colorWrite=l,s.needsUpdate=!0}else this.Tt(n),this.Bt(n),i.layers.disableAll(),i.layers.enable(2),e(n,o,i),i.layers.disableAll(),i.layers.enable(1),this.Rt(t,e,f,n),t.setRenderTarget(r),this.Lt(t,e,n,o,i),this.Nt(n);t.setRenderTarget(r),this.Dt(t,f),t.setClearColor(a),t.setClearAlpha(l),t.sortObjects=h,t.autoClear=c,t.useOIT=u}isSupportedMaterial(t){return!(!t||!t.isMeshStandardMaterial&&!t.isMeshNodeMaterial)}Rt(t,e,n,o,i){i||(i=o);const r=t.getContext(),s=t.getRenderTarget(),a=t.getClearAlpha();if(this.Pt(i),this.Ot(i),t.setClearAlpha(1),s)if(n){t.setRenderTarget(this.renderTargetMRTMSAA),t.clear();const n=t.properties.get(this.renderTargetMRTMSAA).Ft,i=t.properties.get(s).Ft;if(i&&(r.framebufferRenderbuffer(36160,36096,36161,i),36053!==r.checkFramebufferStatus(36160)))return void console.error("v3d.WebGLOITRenderer: incomplete framebuffer in v3d.WebGLOITWeighted.");e(o,this.scene,this.camera);if(t.getTextureUtils().updateMultisampleRenderTarget(this.renderTargetMRTMSAA),i&&(r.framebufferRenderbuffer(36160,36096,36161,n||null),36053!==r.checkFramebufferStatus(36160)))return void console.error("v3d.WebGLOITRenderer: incomplete framebuffer in v3d.WebGLOITWeighted.")}else if(s.samples>0){t.setRenderTarget(this.renderTargetMRT),t.clear();const n=t.properties.get(this.renderTargetMRT).Ut,i=t.properties.get(s).Vt;if(i&&(r.bindFramebuffer(36008,i),r.bindFramebuffer(36009,n),r.blitFramebuffer(0,0,this.resolution.x,this.resolution.y,0,0,this.resolution.x,this.resolution.y,256,9728),r.bindFramebuffer(36160,n),36053!==r.checkFramebufferStatus(36160)))return void console.error("v3d.WebGLOITRenderer: incomplete framebuffer in v3d.WebGLOITWeighted. Can not blit depth buffer from multisample render target.");e(o,this.scene,this.camera)}else{t.setRenderTarget(this.renderTargetMRT),t.clear();const n=t.properties.get(this.renderTargetMRT),i=n.Ft||n.Gt,a=t.properties.get(s),l=a.Ft||a.Gt;if(l){if(r.framebufferRenderbuffer(36160,36096,36161,l),36053!==r.checkFramebufferStatus(36160))return void console.error("v3d.WebGLOITRenderer: incomplete framebuffer in v3d.WebGLOITWeighted.")}else if(s.depthTexture){const e=t.properties.get(s.depthTexture).Qt;r.framebufferTexture2D(36160,36096,3553,e,0)}if(e(o,this.scene,this.camera),l){if(r.framebufferRenderbuffer(36160,36096,36161,i||null),36053!==r.checkFramebufferStatus(36160))return void console.error("v3d.WebGLOITRenderer: incomplete framebuffer in v3d.WebGLOITWeighted.")}else if(s.depthTexture&&(r.framebufferRenderbuffer(36160,36096,36161,i||null),36053!==r.checkFramebufferStatus(36160)))return void console.error("v3d.WebGLOITRenderer: incomplete framebuffer in v3d.WebGLOITWeighted.")}else console.error("v3d.WebGLOITRenderer: undefined render target in v3d.WebGLOITWeighted.");this.zt(i),t.setClearAlpha(a),t.setRenderTarget(s)}Dt(t,e){const n=e?this.renderTargetMRTMSAA:this.renderTargetMRT;this.fsQuadSolver.material.uniforms.tRGBABuffer.value=n.texture[0],this.fsQuadSolver.material.uniforms.tFloatBuffer.value=n.texture[1],this.fsQuadSolver.render(t)}kt(t){const e=this.St[t.id];return Sr.mask=void 0!==e?e:t.layers.mask,this.yt.test(Sr)}Tt(t){this.St[this.camera.id]=this.camera.layers.mask;for(let e=0,n=t.length;e<n;e++){const n=t[e].object;this.St[n.id]=n.layers.mask}}Bt(t){for(let e=0,n=t.length;e<n;e++){const n=t[e],o=n.object,i=n.material;this.kt(o)?(o.layers.disableAll(),this.isSupportedMaterial(i)?o.layers.enable(1):o.layers.enable(2)):o.layers.disableAll()}}Nt(t){for(let e=0,n=t.length;e<n;e++){const n=t[e].object;n.layers.mask=this.St[n.id],delete this.St[n.id]}this.camera.layers.mask=this.St[this.camera.id],delete this.St[this.camera.id]}Pt(t){for(let e=0,n=t.length;e<n;e++){const n=t[e],o=n.object,i=n.material;i&&i.id in this.bt||this.kt(o)&&this.isSupportedMaterial(i)&&(this.bt[i.id]={defines:{PREMULTIPLIED_ALPHA:i.defines.PREMULTIPLIED_ALPHA},properties:{blending:i.blending,blendEquation:i.blendEquation,blendSrc:i.blendSrc,blendDst:i.blendDst,blendEquationAlpha:i.blendEquationAlpha,blendSrcAlpha:i.blendSrcAlpha,blendDstAlpha:i.blendDstAlpha,depthTest:i.depthTest,depthWrite:i.depthWrite}})}}Ot(t){for(let e=0,n=t.length;e<n;e++){const n=t[e],o=n.object,i=n.material;this.kt(o)&&(this.isSupportedMaterial(i)&&(i.defines.PREMULTIPLIED_ALPHA="",i.defines.USE_OIT_WEIGHTED="",i.blending=5,i.blendEquation=a,i.blendSrc=h,i.blendDst=h,i.blendEquationAlpha=a,i.blendSrcAlpha=u,i.blendDstAlpha=v,i.depthTest=!0,i.depthWrite=!1,i.needsUpdate=!0))}}zt(t){for(let e=0,n=t.length;e<n;e++){const n=t[e],o=n.object,i=n.material;if(!i||!(i.id in this.bt))continue;if(!this.kt(o))continue;if(!this.isSupportedMaterial(i))continue;delete i.defines.USE_OIT_WEIGHTED;const r=this.bt[i.id];for(let t in r.properties)i[t]=r.properties[t];for(let t in r.defines)r.defines[t]?i.defines[t]=r.defines[t]:delete i.defines[t];i.needsUpdate=!0,delete this.bt[i.id]}}Lt(t,e,n,o,i){const r={};for(let t=0,e=n.length;t<e;t++){const e=n[t],o=e.object,i=e.material;i&&i.id in r||this.kt(o)&&this.isSupportedMaterial(i)&&(r[i.id]={properties:{colorWrite:i.colorWrite}},i.colorWrite=!1,i.needsUpdate=!0)}e(n,o,i);for(let t=0,e=n.length;t<e;t++){const e=n[t];e.object;const o=e.material;if(!o||!(o.id in r))continue;const i=r[o.id];for(let t in i.properties)o[t]=i.properties[t];o.needsUpdate=!0,delete r[o.id]}}}class Rr{constructor(t){this.isWebGLOITRenderer=!0,this.resolution=t,this.texType=O,this.mute=!1,this.method=0,this.oitRenderer=null}render(t,e,n,o,i){this.mute||this.oitRenderer&&this.oitRenderer.render(t,e,n,o,i)}setMethod(t,e){this.method!==t&&(this.oitRenderer&&this.oitRenderer.dispose(),this.oitRenderer=null,this.method=t,0!==t&&1===t&&(this.oitRenderer=new yr(this.resolution,this.texType,e)))}isMethodCompatible(t,e){return 0===t||!(1!==t||!e.isWebGL2)}dispose(){this.oitRenderer&&this.oitRenderer.dispose(),this.method=0}setSize(t,e){this.resolution.set(t,e),this.oitRenderer&&this.oitRenderer.setSize(t,e)}}function Tr(t,e,n,o){let i=new WeakMap;function r(t){const e=t.target;e.removeEventListener("dispose",r),n.remove(e.instanceMatrix),null!==e.instanceColor&&n.remove(e.instanceColor)}return{update:function(t){const s=o.render.frame,a=t.geometry,l=e.get(t,a);return i.get(l)!==s&&(e.update(l),i.set(l,s)),t.isInstancedMesh&&(!1===t.hasEventListener("dispose",r)&&t.addEventListener("dispose",r),n.update(t.instanceMatrix,34962),null!==t.instanceColor&&n.update(t.instanceColor,34962)),l},dispose:function(){i=new WeakMap}}}const Br=new an,Lr=new un,Nr=new hn,Dr=new xi,Pr=[],Or=[],Fr=new Float32Array(16),Ur=new Float32Array(9),Vr=new Float32Array(4);function Gr(t,e,n){const o=t[0];if(o<=0||o>0)return t;const i=e*n;let r=Pr[i];if(void 0===r&&(r=new Float32Array(i),Pr[i]=r),0!==e){o.toArray(r,0);for(let o=1,i=0;o!==e;++o)i+=n,t[o].toArray(r,i)}return r}function Qr(t,e){if(t.length!==e.length)return!1;for(let n=0,o=t.length;n<o;n++)if(t[n]!==e[n])return!1;return!0}function zr(t,e){for(let n=0,o=e.length;n<o;n++)t[n]=e[n]}function kr(t,e){let n=Or[e];void 0===n&&(n=new Int32Array(e),Or[e]=n);for(let o=0;o!==e;++o)n[o]=t.allocateTextureUnit();return n}function Hr(t,e){const n=this.cache;n[0]!==e&&(t.uniform1f(this.addr,e),n[0]=e)}function Wr(t,e){const n=this.cache;if(void 0!==e.x)n[0]===e.x&&n[1]===e.y||(t.uniform2f(this.addr,e.x,e.y),n[0]=e.x,n[1]=e.y);else{if(Qr(n,e))return;t.uniform2fv(this.addr,e),zr(n,e)}}function Yr(t,e){const n=this.cache;if(void 0!==e.x)n[0]===e.x&&n[1]===e.y&&n[2]===e.z||(t.uniform3f(this.addr,e.x,e.y,e.z),n[0]=e.x,n[1]=e.y,n[2]=e.z);else if(void 0!==e.r)n[0]===e.r&&n[1]===e.g&&n[2]===e.b||(t.uniform3f(this.addr,e.r,e.g,e.b),n[0]=e.r,n[1]=e.g,n[2]=e.b);else{if(Qr(n,e))return;t.uniform3fv(this.addr,e),zr(n,e)}}function Xr(t,e){const n=this.cache;if(void 0!==e.x)n[0]===e.x&&n[1]===e.y&&n[2]===e.z&&n[3]===e.w||(t.uniform4f(this.addr,e.x,e.y,e.z,e.w),n[0]=e.x,n[1]=e.y,n[2]=e.z,n[3]=e.w);else{if(Qr(n,e))return;t.uniform4fv(this.addr,e),zr(n,e)}}function Kr(t,e){const n=this.cache,o=e.elements;if(void 0===o){if(Qr(n,e))return;t.uniformMatrix2fv(this.addr,!1,e),zr(n,e)}else{if(Qr(n,o))return;Vr.set(o),t.uniformMatrix2fv(this.addr,!1,Vr),zr(n,o)}}function jr(t,e){const n=this.cache,o=e.elements;if(void 0===o){if(Qr(n,e))return;t.uniformMatrix3fv(this.addr,!1,e),zr(n,e)}else{if(Qr(n,o))return;Ur.set(o),t.uniformMatrix3fv(this.addr,!1,Ur),zr(n,o)}}function Zr(t,e){const n=this.cache,o=e.elements;if(void 0===o){if(Qr(n,e))return;t.uniformMatrix4fv(this.addr,!1,e),zr(n,e)}else{if(Qr(n,o))return;Fr.set(o),t.uniformMatrix4fv(this.addr,!1,Fr),zr(n,o)}}function qr(t,e){const n=this.cache;n[0]!==e&&(t.uniform1i(this.addr,e),n[0]=e)}function Jr(t,e){const n=this.cache;if(void 0!==e.x)n[0]===e.x&&n[1]===e.y||(t.uniform2i(this.addr,e.x,e.y),n[0]=e.x,n[1]=e.y);else{if(Qr(n,e))return;t.uniform2iv(this.addr,e),zr(n,e)}}function $r(t,e){const n=this.cache;if(void 0!==e.x)n[0]===e.x&&n[1]===e.y&&n[2]===e.z||(t.uniform3i(this.addr,e.x,e.y,e.z),n[0]=e.x,n[1]=e.y,n[2]=e.z);else{if(Qr(n,e))return;t.uniform3iv(this.addr,e),zr(n,e)}}function ts(t,e){const n=this.cache;if(void 0!==e.x)n[0]===e.x&&n[1]===e.y&&n[2]===e.z&&n[3]===e.w||(t.uniform4i(this.addr,e.x,e.y,e.z,e.w),n[0]=e.x,n[1]=e.y,n[2]=e.z,n[3]=e.w);else{if(Qr(n,e))return;t.uniform4iv(this.addr,e),zr(n,e)}}function es(t,e){const n=this.cache;n[0]!==e&&(t.uniform1ui(this.addr,e),n[0]=e)}function ns(t,e){const n=this.cache;if(void 0!==e.x)n[0]===e.x&&n[1]===e.y||(t.uniform2ui(this.addr,e.x,e.y),n[0]=e.x,n[1]=e.y);else{if(Qr(n,e))return;t.uniform2uiv(this.addr,e),zr(n,e)}}function os(t,e){const n=this.cache;if(void 0!==e.x)n[0]===e.x&&n[1]===e.y&&n[2]===e.z||(t.uniform3ui(this.addr,e.x,e.y,e.z),n[0]=e.x,n[1]=e.y,n[2]=e.z);else{if(Qr(n,e))return;t.uniform3uiv(this.addr,e),zr(n,e)}}function is(t,e){const n=this.cache;if(void 0!==e.x)n[0]===e.x&&n[1]===e.y&&n[2]===e.z&&n[3]===e.w||(t.uniform4ui(this.addr,e.x,e.y,e.z,e.w),n[0]=e.x,n[1]=e.y,n[2]=e.z,n[3]=e.w);else{if(Qr(n,e))return;t.uniform4uiv(this.addr,e),zr(n,e)}}function rs(t,e,n){const o=this.cache,i=n.allocateTextureUnit();o[0]!==i&&(t.uniform1i(this.addr,i),o[0]=i),n.setTexture2D(e||Br,i)}function ss(t,e,n){const o=this.cache,i=n.allocateTextureUnit();o[0]!==i&&(t.uniform1i(this.addr,i),o[0]=i),n.setTexture3D(e||Nr,i)}function as(t,e,n){const o=this.cache,i=n.allocateTextureUnit();o[0]!==i&&(t.uniform1i(this.addr,i),o[0]=i),n.setTextureCube(e||Dr,i)}function ls(t,e,n){const o=this.cache,i=n.allocateTextureUnit();o[0]!==i&&(t.uniform1i(this.addr,i),o[0]=i),n.setTexture2DArray(e||Lr,i)}function cs(t,e){t.uniform1fv(this.addr,e)}function us(t,e){const n=Gr(e,this.size,2);t.uniform2fv(this.addr,n)}function hs(t,e){const n=Gr(e,this.size,3);t.uniform3fv(this.addr,n)}function fs(t,e){const n=Gr(e,this.size,4);t.uniform4fv(this.addr,n)}function ds(t,e){const n=Gr(e,this.size,4);t.uniformMatrix2fv(this.addr,!1,n)}function As(t,e){const n=Gr(e,this.size,9);t.uniformMatrix3fv(this.addr,!1,n)}function vs(t,e){const n=Gr(e,this.size,16);t.uniformMatrix4fv(this.addr,!1,n)}function ms(t,e){t.uniform1iv(this.addr,e)}function ps(t,e){t.uniform2iv(this.addr,e)}function gs(t,e){t.uniform3iv(this.addr,e)}function _s(t,e){t.uniform4iv(this.addr,e)}function Es(t,e){t.uniform1uiv(this.addr,e)}function Cs(t,e){t.uniform2uiv(this.addr,e)}function ws(t,e){t.uniform3uiv(this.addr,e)}function xs(t,e){t.uniform4uiv(this.addr,e)}function Is(t,e,n){const o=this.cache,i=e.length,r=kr(n,i);Qr(o,r)||(t.uniform1iv(this.addr,r),zr(o,r));for(let t=0;t!==i;++t)n.setTexture2D(e[t]||Br,r[t])}function Ms(t,e,n){const o=this.cache,i=e.length,r=kr(n,i);Qr(o,r)||(t.uniform1iv(this.addr,r),zr(o,r));for(let t=0;t!==i;++t)n.setTexture3D(e[t]||Nr,r[t])}function Ss(t,e,n){const o=this.cache,i=e.length,r=kr(n,i);Qr(o,r)||(t.uniform1iv(this.addr,r),zr(o,r));for(let t=0;t!==i;++t)n.setTextureCube(e[t]||Dr,r[t])}function bs(t,e,n){const o=this.cache,i=e.length,r=kr(n,i);Qr(o,r)||(t.uniform1iv(this.addr,r),zr(o,r));for(let t=0;t!==i;++t)n.setTexture2DArray(e[t]||Lr,r[t])}class ys{constructor(t,e,n){this.id=t,this.addr=n,this.cache=[],this.setValue=function(t){switch(t){case 5126:return Hr;case 35664:return Wr;case 35665:return Yr;case 35666:return Xr;case 35674:return Kr;case 35675:return jr;case 35676:return Zr;case 5124:case 35670:return qr;case 35667:case 35671:return Jr;case 35668:case 35672:return $r;case 35669:case 35673:return ts;case 5125:return es;case 36294:return ns;case 36295:return os;case 36296:return is;case 35678:case 36198:case 36298:case 36306:case 35682:return rs;case 35679:case 36299:case 36307:return ss;case 35680:case 36300:case 36308:case 36293:return as;case 36289:case 36303:case 36311:case 36292:return ls}}(e.type)}}class Rs{constructor(t,e,n){this.id=t,this.addr=n,this.cache=[],this.size=e.size,this.setValue=function(t){switch(t){case 5126:return cs;case 35664:return us;case 35665:return hs;case 35666:return fs;case 35674:return ds;case 35675:return As;case 35676:return vs;case 5124:case 35670:return ms;case 35667:case 35671:return ps;case 35668:case 35672:return gs;case 35669:case 35673:return _s;case 5125:return Es;case 36294:return Cs;case 36295:return ws;case 36296:return xs;case 35678:case 36198:case 36298:case 36306:case 35682:return Is;case 35679:case 36299:case 36307:return Ms;case 35680:case 36300:case 36308:case 36293:return Ss;case 36289:case 36303:case 36311:case 36292:return bs}}(e.type)}}class Ts{constructor(t){this.id=t,this.seq=[],this.map={}}setValue(t,e,n){const o=this.seq;for(let i=0,r=o.length;i!==r;++i){const r=o[i];r.setValue(t,e[r.id],n)}}}const Bs=/(\w+)(\])?(\[|\.)?/g;function Ls(t,e){t.seq.push(e),t.map[e.id]=e}function Ns(t,e,n){const o=t.name,i=o.length;for(Bs.lastIndex=0;;){const r=Bs.exec(o),s=Bs.lastIndex;let a=r[1];const l="]"===r[2],c=r[3];if(l&&(a|=0),void 0===c||"["===c&&s+2===i){Ls(n,void 0===c?new ys(a,t,e):new Rs(a,t,e));break}{let t=n.map[a];void 0===t&&(t=new Ts(a),Ls(n,t)),n=t}}}class Ds{constructor(t,e){this.seq=[],this.map={};const n=t.getProgramParameter(e,35718);for(let o=0;o<n;++o){const n=t.getActiveUniform(e,o);Ns(n,t.getUniformLocation(e,n.name),this)}}setValue(t,e,n,o){const i=this.map[e];void 0!==i&&i.setValue(t,n,o)}setOptional(t,e,n){const o=e[n];void 0!==o&&this.setValue(t,n,o)}static upload(t,e,n,o){for(let i=0,r=e.length;i!==r;++i){const r=e[i],s=n[r.id];!1!==s.needsUpdate&&r.setValue(t,s.value,o)}}static seqWithValue(t,e){const n=[];for(let o=0,i=t.length;o!==i;++o){const i=t[o];i.id in e&&n.push(i)}return n}}function Ps(t,e,n){const o=t.createShader(e);return t.shaderSource(o,n),t.compileShader(o),o}let Os=0;function Fs(t,e,n){const o=t.getShaderParameter(e,35713),i=t.getShaderInfoLog(e).trim();if(o&&""===i)return"";const r=/ERROR: 0:(\d+)/.exec(i);if(r){const o=parseInt(r[1]);return n.toUpperCase()+"\n\n"+i+"\n\n"+function(t,e){const n=t.split("\n"),o=[],i=Math.max(e-6,0),r=Math.min(e+6,n.length);for(let t=i;t<r;t++){const i=t+1;o.push(`${i===e?">":" "} ${i}: ${n[t]}`)}return o.join("\n")}(t.getShaderSource(e),o)}return i}function Us(t,e){const n=function(t){switch(t){case Ot:return["Linear","(value)"];case Ft:return["sRGB","(value)"];default:return console.warn("v3d.WebGLProgram: Unsupported encoding:",t),["Linear","(value)"]}}(e);return"vec4 "+t+"(vec4 value) { return LinearTo"+n[0]+n[1]+"; }"}function Vs(t,e){let n;switch(e){case 1:n="Linear";break;case 2:n="Reinhard";break;case 3:n="OptimizedCineon";break;case 4:n="ACESFilmic";break;case 5:n="Custom";break;case 6:n="LogarithmicMax";break;case 7:n="PhysicalMax";break;case 8:n="FilmicBlender";break;case 9:n="AgX";break;case 10:n="PbrNeutral";break;default:console.warn("v3d.WebGLProgram: Unsupported toneMapping:",e),n="Linear"}return"vec3 "+t+"(vec3 color) { return "+n+"ToneMapping(color); }"}function Gs(t){let e="TONE_MAPPING_LOOK_NONE";return 1===t&&(e="TONE_MAPPING_LOOK_AGX_PUNCHY"),e}function Qs(t,e){const n=[];for(const o in t){const i=t[o];!1===i||e&&e.has(o)||n.push("#define "+o+" "+i)}return n.join("\n")}function zs(t){return""!==t}function ks(t,e){return t.replace(/NUM_DIR_LIGHTS/g,e.numDirLights).replace(/NUM_SPOT_LIGHTS/g,e.numSpotLights).replace(/NUM_RECT_AREA_LIGHTS/g,e.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g,e.numPointLights).replace(/NUM_SPOT_LIGHT_SHADOWS/g,e.numSpotLightShadows).replace(/NUM_POINT_LIGHT_SHADOWS/g,e.numPointLightShadows).replace(/NUM_RECT_AREA_LIGHT_SHADOWS/g,e.numRectAreaLightShadows).replace(/NUM_DIR_LIGHT_SHADOWS_CSM_WITH_FADE/g,e.numDirLightShadowsCSMWithFade).replace(/NUM_DIR_LIGHT_SHADOWS_CSM/g,e.numDirLightShadowsCSM).replace(/NUM_DIR_LIGHT_SHADOW_CASCADES_CSM/g,e.numDirLightShadowCSMCascades)}function Hs(t,e){return t.replace(/NUM_CLIPPING_PLANES/g,e.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g,e.numClippingPlanes-e.numClipIntersection)}function Ws(t,e){const n=Object.keys(e);if(n.length){const o=new RegExp(n.join("|"),"g");return t.replace(o,function(t){return e[t]})}return t}function Ys(t){switch(t){case"blender":return"#define MT_BLENDER";case"max":return"#define MT_MAX";case"maya":return"#define MT_MAYA";default:return""}}function Xs(t,e){for(const n in e){const o=ze()?`// included: "${n}"\n`:"";t=t.replace(`#include <${n}>`,o+e[n])}return t}const Ks=/^[ \t]*#include +<([\w\d./]+)>/gm;function js(t){return t.replace(Ks,Zs)}function Zs(t,e){const n=Fi[e];if(void 0===n)throw new Error("Can not resolve #include <"+e+">");return js((ze()?`// included: "${e}"\n`:"")+n)}function qs(t){const e=new RegExp("#pragma unroll_loop[\\s]+?for \\(int (\\w+) ?\\= ?(\\d+)\\; ?(\\w+) ?<(=?) ?(\\w+)\\; ?(\\w+)\\+\\+\\) ?\\{"),n=new RegExp("\\{|\\}","g");let o;for(;o=e.exec(t);){let e,i;e=i=n.lastIndex=o.index+o[0].length;let r,s=1;do{(r=n.exec(t))&&("{"==r[0]?s++:"}"==r[0]&&s--,i=r.index)}while(r&&s>0);if(0==s){const r=t.substring(o.index,n.lastIndex),s=t.substring(e,i),a=new RegExp(`\\[${o[1]}\\]`,"g"),l=new RegExp(`\\(${o[1]}\\)`,"g");let c="";const u=parseInt(o[2]),h=parseInt(o[5])+("="===o[4]?1:0);for(let t=u;t<h;t++)c+="{"+s.replace(a,`[${t}]`).replace(l,`(${t})`)+"}";t=t.replace(r,c)}}return t}function Js(t){return"precision "+t.precision+" float;\nprecision "+t.precision+" int;"}function $s(t,e,n,o){const i=t.getContext(),r=n.defines;let s=n.vertexShader,a=n.fragmentShader;const l=function(t){let e="SHADOWMAP_TYPE_BASIC";return 1===t.shadowMapType?e="SHADOWMAP_TYPE_BILINEAR":2===t.shadowMapType?e="SHADOWMAP_TYPE_PCF":3===t.shadowMapType&&(e="SHADOWMAP_TYPE_ESM"),e}(n),c=function(t){let e="ENVMAP_TYPE_CUBE";if(t.envMap)switch(t.envMapMode){case w:case x:e="ENVMAP_TYPE_CUBE";break;case S:e="ENVMAP_TYPE_CUBE_UV"}return e}(n),u=function(t){let e="ENVMAP_MODE_REFLECTION";t.envMap&&t.envMapMode===x&&(e="ENVMAP_MODE_REFRACTION");return e}(n),h=function(t){let e="ENVMAP_BLENDING_NONE";if(t.envMap)switch(t.combine){case 0:e="ENVMAP_BLENDING_MULTIPLY";break;case 1:e="ENVMAP_BLENDING_MIX";break;case 2:e="ENVMAP_BLENDING_ADD"}return e}(n),f=n.unitsScaleFactor%1?String(n.unitsScaleFactor):String(n.unitsScaleFactor)+".0",d=n.isWebGL2?"":function(t){return[t.extensionDerivatives||t.bumpMap||t.tangentSpaceNormalMap||t.flatShading||"node"===t.shaderID||t.useSlopeScaledBias?"#extension GL_OES_standard_derivatives : enable":"",(t.extensionFragDepth||t.logarithmicDepthBuffer)&&t.rendererExtensionFragDepth?"#extension GL_EXT_frag_depth : enable":""].filter(zs).join("\n")}(n),A=Qs(r),v=Qs(r,n.definesFragOnly),m=i.createProgram(),p=this;let g,_,E=n.glslVersion?"#version "+n.glslVersion+"\n":"";n.isRawShaderMaterial?(g=[v].filter(zs).join("\n"),g.length>0&&(g+="\n"),_=[d,A].filter(zs).join("\n"),_.length>0&&(_+="\n")):(g=[Js(n),"#define SHADER_NAME "+n.shaderName,v,n.instancing?"#define USE_INSTANCING":"",n.instancingColor?"#define USE_INSTANCING_COLOR":"",n.supportsVertexTextures?"#define VERTEX_TEXTURES":"",n.useFog&&n.fog?"#define USE_FOG":"",n.useFog&&n.fogExp2?"#define FOG_EXP2":"",n.map?"#define USE_MAP":"",n.envMap?"#define USE_ENVMAP":"",n.envMap?"#define "+u:"",n.lightMap?"#define USE_LIGHTMAP":"",n.aoMap?"#define USE_AOMAP":"",n.emissiveMap?"#define USE_EMISSIVEMAP":"",n.bumpMap?"#define USE_BUMPMAP":"",n.normalMap?"#define USE_NORMALMAP":"",n.normalMap&&n.objectSpaceNormalMap?"#define OBJECTSPACE_NORMALMAP":"",n.normalMap&&n.tangentSpaceNormalMap?"#define TANGENTSPACE_NORMALMAP":"",n.displacementMap&&n.supportsVertexTextures?"#define USE_DISPLACEMENTMAP":"",n.roughnessMap?"#define USE_ROUGHNESSMAP":"",n.metalnessMap?"#define USE_METALNESSMAP":"",n.alphaMap?"#define USE_ALPHAMAP":"",n.vertexTangents?"#define USE_TANGENT":"",n.vertexColors?"#define USE_COLOR":"",n.vertexAlphas?"#define USE_COLOR_ALPHA":"",n.vertexUvs?"#define USE_UV":"",n.uvsVertexOnly?"#define UVS_VERTEX_ONLY":"",n.flatShading?"#define FLAT_SHADED":"",n.skinning?"#define USE_SKINNING":"",n.morphTargets?"#define USE_MORPHTARGETS":"",n.morphNormals&&!1===n.flatShading?"#define USE_MORPHNORMALS":"",n.morphTargetsCount>0&&n.isWebGL2?"#define MORPHTARGETS_TEXTURE":"",n.morphTargetsCount>0&&n.isWebGL2?"#define MORPHTARGETS_TEXTURE_STRIDE "+n.morphTextureStride:"",n.morphTargetsCount>0?"#define MORPHTARGETS_COUNT "+n.morphTargetsCount:"",n.doubleSided?"#define DOUBLE_SIDED":"",n.flipSided?"#define FLIP_SIDED":"",n.shadowMapEnabled?"#define USE_SHADOWMAP":"",n.shadowMapEnabled?"#define "+l:"",n.sizeAttenuation?"#define USE_SIZEATTENUATION":"",n.logarithmicDepthBuffer?"#define USE_LOGDEPTHBUF":"",n.logarithmicDepthBuffer&&n.rendererExtensionFragDepth?"#define USE_LOGDEPTHBUF_EXT":"",n.planeReflProbe?"#define USE_PLANE_REFLECTION":"","\n            uniform mat4 modelMatrix;\n            uniform mat4 modelViewMatrix;\n            uniform mat4 projectionMatrix;\n            uniform mat4 viewMatrix;\n            uniform mat3 normalMatrix;\n            uniform vec3 cameraPosition;\n            uniform bool isOrthographic;\n\n            #ifdef USE_INSTANCING\n                attribute mat4 instanceMatrix;\n            #endif\n\n            #ifdef USE_INSTANCING_COLOR\n                attribute vec3 instanceColor;\n            #endif\n\n            attribute vec3 position;\n            attribute vec3 normal;\n            attribute vec2 uv;\n\n            #ifdef USE_TANGENT\n                attribute vec4 tangent;\n            #endif\n\n            #if defined(USE_COLOR_ALPHA)\n                attribute vec4 color;\n            #elif defined(USE_COLOR)\n                attribute vec3 color;\n            #endif\n\n            #if (defined(USE_MORPHTARGETS) && !defined(MORPHTARGETS_TEXTURE))\n                #if MORPHTARGETS_COUNT > 0\n                    attribute vec3 morphTarget0;\n                #endif\n                #if MORPHTARGETS_COUNT > 1\n                    attribute vec3 morphTarget1;\n                #endif\n                #if MORPHTARGETS_COUNT > 2\n                    attribute vec3 morphTarget2;\n                #endif\n                #if MORPHTARGETS_COUNT > 3\n                    attribute vec3 morphTarget3;\n                #endif\n                #if MORPHTARGETS_COUNT > 4\n                    attribute vec3 morphTarget4;\n                #endif\n                #if MORPHTARGETS_COUNT > 5\n                    attribute vec3 morphTarget5;\n                #endif\n\n                #ifdef USE_MORPHNORMALS\n                    #if MORPHTARGETS_COUNT > 0\n                        attribute vec3 morphNormal0;\n                    #endif\n                    #if MORPHTARGETS_COUNT > 1\n                        attribute vec3 morphNormal1;\n                    #endif\n                    #if MORPHTARGETS_COUNT > 2\n                        attribute vec3 morphNormal2;\n                    #endif\n                    #if MORPHTARGETS_COUNT > 3\n                        attribute vec3 morphNormal3;\n                    #endif\n                    #if MORPHTARGETS_COUNT > 4\n                        attribute vec3 morphNormal4;\n                    #endif\n                    #if MORPHTARGETS_COUNT > 5\n                        attribute vec3 morphNormal5;\n                    #endif\n                #else\n                    #if MORPHTARGETS_COUNT > 6\n                        attribute vec3 morphTarget6;\n                    #endif\n                    #if MORPHTARGETS_COUNT > 7\n                        attribute vec3 morphTarget7;\n                    #endif\n                    #if MORPHTARGETS_COUNT > 8\n                        attribute vec3 morphTarget8;\n                    #endif\n                    #if MORPHTARGETS_COUNT > 9\n                        attribute vec3 morphTarget9;\n                    #endif\n                    #if MORPHTARGETS_COUNT > 10\n                        attribute vec3 morphTarget10;\n                    #endif\n                    #if MORPHTARGETS_COUNT > 11\n                        attribute vec3 morphTarget11;\n                    #endif\n                #endif\n            #endif\n\n            #ifdef USE_SKINNING\n                attribute vec4 skinIndex;\n                attribute vec4 skinWeight;\n            #endif\n            "].filter(zs).join("\n"),_=[d,Js(n),"#define SHADER_NAME "+n.shaderName,A,Ys(n.materialProfile),n.useFog&&n.fog?"#define USE_FOG":"",n.useFog&&n.fogExp2?"#define FOG_EXP2":"",n.map?"#define USE_MAP":"",n.envMap?"#define USE_ENVMAP":"",n.envMap?"#define "+c:"",n.envMap?"#define "+u:"",n.envMap?"#define "+h:"",0!==n.envMapCubeUVTileSize?`#define cubeUV_maxTileSize ${Oe(n.envMapCubeUVTileSize)}`:"",n.lightMap?"#define USE_LIGHTMAP":"",n.aoMap?"#define USE_AOMAP":"",n.emissiveMap?"#define USE_EMISSIVEMAP":"",n.bumpMap?"#define USE_BUMPMAP":"",n.normalMap?"#define USE_NORMALMAP":"",n.normalMap&&n.objectSpaceNormalMap?"#define OBJECTSPACE_NORMALMAP":"",n.normalMap&&n.tangentSpaceNormalMap?"#define TANGENTSPACE_NORMALMAP":"",n.roughnessMap?"#define USE_ROUGHNESSMAP":"",n.metalnessMap?"#define USE_METALNESSMAP":"",n.alphaMap?"#define USE_ALPHAMAP":"",n.alphaTest?"#define USE_ALPHATEST":"",n.decodeVideoTexture?"#define DECODE_VIDEO_TEXTURE":"",n.vertexTangents?"#define USE_TANGENT":"",n.vertexColors||n.instancingColor?"#define USE_COLOR":"",n.vertexAlphas?"#define USE_COLOR_ALPHA":"",n.vertexUvs?"#define USE_UV":"",n.uvsVertexOnly?"#define UVS_VERTEX_ONLY":"",n.flatShading?"#define FLAT_SHADED":"",n.doubleSided?"#define DOUBLE_SIDED":"",n.flipSided?"#define FLIP_SIDED":"",n.shadowMapEnabled?"#define USE_SHADOWMAP":"",n.shadowMapEnabled?"#define "+l:"",n.premultipliedAlpha?"#define PREMULTIPLIED_ALPHA":"",n.logarithmicDepthBuffer?"#define USE_LOGDEPTHBUF":"",n.logarithmicDepthBuffer&&n.rendererExtensionFragDepth?"#define USE_LOGDEPTHBUF_EXT":"","#define UNITS_SCALE_FACTOR "+f,"uniform mat4 viewMatrix;","uniform vec3 cameraPosition;","uniform bool isOrthographic;",0!==n.toneMapping?"#define TONE_MAPPING":"",0!==n.toneMapping?"#define TONE_MAPPING_LOOK "+Gs(n.toneMappingLook):"",0!==n.toneMapping?Fi.tonemapping_pars_fragment:"",0!==n.toneMapping?Vs("toneMapping",n.toneMapping):"",n.dithering?"#define DITHERING":"",n.opaque&&!n.alphaToCoverage?"#define OPAQUE":"",Fi.encodings_pars_fragment,Us("linearToOutputTexel",n.outputEncoding),n.useDepthPacking?"#define DEPTH_PACKING "+n.depthPacking:"",n.distancePacking?"#define DISTANCE_PACKING "+n.distancePacking:"",n.useSlopeScaledBias?"#define USE_SLOPE_SCALED_BIAS":"",`#define ESM_DISTANCE_SCALE ${Oe(n.esmDistanceScale)}`,n.planeReflProbe?"#define USE_PLANE_REFLECTION":"",n.useGTAO?"#define USE_GTAO":"",t.compatSettings.gtaoDisableBkgFix?"#define GTAO_DISABLE_BKG_FIX":"",n.dirLightShadowsCSMLUT.length>0&&n.isWebGL2?`#define LUT_DIR_LIGHT_SHADOWS_CSM int[](${n.dirLightShadowsCSMLUT})`:"","\n"].filter(zs).join("\n")),n.isWebGL2||!0===n.isRawShaderMaterial||(s="#include <webgl1_compat>\n"+s,a="#include <webgl1_compat>\n"+a),n.isMeshNodeMaterial&&(s=Xs(s,n.nodeChunks),a=Xs(a,n.nodeChunks)),s=js(s),s=ks(s,n),s=Hs(s,n),n.customPrepTokens&&(s=Ws(s,n.customPrepTokens)),a=js(a),a=ks(a,n),a=Hs(a,n),n.customPrepTokens&&(a=Ws(a,n.customPrepTokens)),s=qs(s),a=qs(a),n.isWebGL2&&!0!==n.isRawShaderMaterial&&(E="#version 300 es\n",g=["precision mediump sampler2DArray;","#define attribute in","#define varying out","#define texture2D texture"].join("\n")+"\n"+g,_=["#define varying in",n.glslVersion===Kt?"":"layout(location = 0) out highp vec4 outFragColor;",n.glslVersion===Kt?"":"#define gl_FragColor outFragColor","#define gl_FragDepthEXT gl_FragDepth","#define texture2D texture","#define textureCube texture","#define texture2DProj textureProj"].join("\n")+"\n"+_);let C=E+g+s,I=E+_+a;if(t.debug.disableCompiledShaderCache||ze()){const e=I.lastIndexOf("}");I=I.substr(0,e)+"    // disable shader cache\n    gl_FragColor += vec4("+1e-4*t.debug.random+");\n"+I.substr(e)}const M=Ps(i,35633,C),b=Ps(i,35632,I);ke("observe",{shaderName:n.shaderName,materialName:n.materialName,vertex:C,fragment:I}),i.attachShader(m,M),i.attachShader(m,b),void 0!==n.index0AttributeName?i.bindAttribLocation(m,0,n.index0AttributeName):!0===n.morphTargets&&i.bindAttribLocation(m,0,"position"),i.linkProgram(m);let y,R,T=!0;function B(){if(T=!1,t.debug.checkShaderErrors){const t=i.getProgramInfoLog(m).trim(),e=i.getShaderInfoLog(M).trim(),n=i.getShaderInfoLog(b).trim();let o=!0,r=!0;if(!1===i.getProgramParameter(m,35714)){o=!1;const e=Fs(i,M,"vertex"),n=Fs(i,b,"fragment");console.error("v3d.WebGLProgram: shader error: ",i.getError(),"35715",i.getProgramParameter(m,35715),"gl.getProgramInfoLog",t,e,n)}else""!==t?console.warn("v3d.WebGLProgram: gl.getProgramInfoLog()",t):""!==e&&""!==n||(r=!1);r&&(p.diagnostics={runnable:o,programLog:t,vertexShader:{log:e,prefix:g},fragmentShader:{log:n,prefix:_}})}i.deleteShader(M),i.deleteShader(b)}return this.getUniforms=function(){return void 0===y&&(T&&B(),y=new Ds(i,m)),y},this.getAttributes=function(){return void 0===R&&(T&&B(),R=function(t,e){const n={},o=t.getProgramParameter(e,35721);for(let i=0;i<o;i++){const o=t.getActiveAttrib(e,i),r=o.name;let s=1;35674===o.type&&(s=2),35675===o.type&&(s=3),35676===o.type&&(s=4),n[r]={type:o.type,location:t.getAttribLocation(e,r),locationSize:s}}return n}(i,m)),R},this.destroy=function(){o.releaseStatesOfProgram(this),i.deleteProgram(m),this.program=void 0},this.name=n.shaderName,this.id=Os++,this.cacheKey=e,this.usedTimes=1,this.program=m,this.vertexShader=M,this.fragmentShader=b,this.profile={calcRenderTime:!1,renderTime:0,timerQueries:[],materials:new Set},this.getTexUniformCount=function(){return this.getUniforms().seq.reduce(function(t,e){if(e.info)switch(e.info.type){case 35678:case 35679:case 35680:case 35682:case 36289:case 36292:case 36293:case 36298:case 36299:case 36300:case 36303:case 36306:case 36307:case 36308:case 36311:t+=e.info.size}return t},0)},this.beginTimerQuery=function(t,e){if(!this.profile.calcRenderTime)return;const n=t.getExtension(e?"EXT_disjoint_timer_query_webgl2":"EXT_disjoint_timer_query");if(!n)return;let o;e?(o=t.createQuery(),t.beginQuery(n.TIME_ELAPSED_EXT,o)):(o=n.createQueryEXT(),n.beginQueryEXT(n.TIME_ELAPSED_EXT,o)),this.profile.timerQueries.push(o)},this.endTimerQuery=function(t,e){if(!this.profile.calcRenderTime)return;const n=t.getExtension(e?"EXT_disjoint_timer_query_webgl2":"EXT_disjoint_timer_query");if(!n)return;e?t.endQuery(n.TIME_ELAPSED_EXT):n.endQueryEXT(n.TIME_ELAPSED_EXT);const o=this.profile.timerQueries;for(let i=o.length-1;i>=0;i--){const r=o[i],s=e?t.getQueryParameter(r,34919):n.getQueryObjectEXT(r,n.QUERY_RESULT_AVAILABLE_EXT),a=t.getParameter(n.GPU_DISJOINT_EXT);if(s&&!a){const s=e?t.getQueryParameter(r,34918):n.getQueryObjectEXT(r,n.QUERY_RESULT_EXT);this.profile.renderTime+=s/1e6,o.splice(i,1)}}},this}function ta(t,e,n,o,i,r,s){const a=new eo,l=[],c=i.isWebGL2,u=i.logarithmicDepthBuffer,h=i.vertexTextures;let f=i.precision,d=0;const A={MeshDepthMaterial:"depth",MeshDistanceMaterial:"distanceRGBA",MeshNormalMaterial:"normal",MeshBasicMaterial:"basic",MeshLambertMaterial:"lambert",MeshStandardMaterial:"standard",LineBasicMaterial:"basic",LineDashedMaterial:"dashed",PointsMaterial:"points",ShadowMaterial:"shadow",SpriteMaterial:"sprite",MeshMaskMaterial:"mask",MeshNodeMaterial:"node"};return{getParameters:function(r,a,l,d,v,m){const p=d.fog,g=v.geometry,_=r.isMeshNodeMaterial||r.isMeshStandardMaterial?d.environment:null,E=(r.isMeshNodeMaterial||r.isMeshStandardMaterial?n:e).get(r.envMap||_),C=A[r.type];null!==r.precision&&(f=i.getMaxPrecision(r.precision),f!==r.precision&&console.warn("v3d.WebGLProgram.getParameters:",r.precision,"not supported, using",f,"instead."));const w=g.morphAttributes.position||g.morphAttributes.normal,x=void 0!==w?w.length:0;let I,M,b=0;if(void 0!==g.morphAttributes.position&&(b=1),void 0!==g.morphAttributes.normal&&(b=2),C){const t=Vi[C];I=t.vertexShader,M=t.fragmentShader}else I=r.vertexShader,M=r.fragmentShader;const y=t.getRenderTarget(),R=r.alphaTest>0;return{isWebGL2:c,shaderID:C,shaderName:r.type,vertexShader:I,fragmentShader:M,defines:r.defines,isRawShaderMaterial:!0===r.isRawShaderMaterial,glslVersion:r.glslVersion,precision:f,instancing:!0===v.isInstancedMesh,instancingColor:!0===v.isInstancedMesh&&null!==v.instanceColor,supportsVertexTextures:h,outputEncoding:null===y?t.outputEncoding:!0===y.isXRRenderTarget?y.texture.encoding:Ot,map:!!r.map,envMap:!!E,envMapMode:E&&E.mapping,lightMap:!!r.lightMap,aoMap:!!r.aoMap,emissiveMap:!!r.emissiveMap,bumpMap:!!r.bumpMap,normalMap:!!r.normalMap,objectSpaceNormalMap:1===r.normalMapType,tangentSpaceNormalMap:0===r.normalMapType,decodeVideoTexture:!!r.map&&!0===r.map.isVideoTexture&&r.map.encoding===Ft,displacementMap:!!r.displacementMap,roughnessMap:!!r.roughnessMap,metalnessMap:!!r.metalnessMap,opaque:!1===r.transparent&&1===r.blending,alphaMap:!!r.alphaMap,alphaTest:R,combine:r.combine,vertexTangents:!!r.normalMap&&!!g.attributes.tangent,vertexColors:r.vertexColors,vertexAlphas:!0===r.vertexColors&&!!g.attributes.color&&4===g.attributes.color.itemSize,vertexUvs:!!(r.map||r.bumpMap||r.normalMap||r.alphaMap||r.emissiveMap||r.roughnessMap||r.metalnessMap||r.displacementMap),uvsVertexOnly:!(r.map||r.bumpMap||r.normalMap||r.alphaMap||r.emissiveMap||r.roughnessMap||r.metalnessMap||!r.displacementMap),fog:!!p,useFog:!0===r.fog,fogExp2:p&&p.isFogExp2,flatShading:!!r.flatShading,sizeAttenuation:r.sizeAttenuation,logarithmicDepthBuffer:u,skinning:!0===v.isSkinnedMesh,morphTargets:void 0!==g.morphAttributes.position,morphNormals:void 0!==g.morphAttributes.normal,morphTargetsCount:x,morphTextureStride:b,numDirLights:a?a.directional.length:0,numPointLights:a?a.point.length:0,numSpotLights:a?a.spot.length:0,numRectAreaLights:a?a.rectArea.length:0,numPointLightShadows:a?a.pointShadowMap.length:0,numSpotLightShadows:a?a.spotShadowMap.length:0,numClippingPlanes:s.numPlanes,numClipIntersection:s.numIntersection,dithering:r.dithering,shadowMapEnabled:t.shadowMap.enabled&&l.length>0,shadowMapType:t.shadowMap.type,toneMapping:r.toneMapped?t.toneMapping:0,toneMappingLook:r.toneMapped?t.toneMappingLook:0,premultipliedAlpha:r.premultipliedAlpha,doubleSided:2===r.side,flipSided:1===r.side,useDepthPacking:!!r.depthPacking,depthPacking:r.depthPacking||0,envMapCubeUVTileSize:E&&E.mapping===S&&void 0!==E.image?E.image.width/3:0,distancePacking:void 0!==r.distancePacking&&r.distancePacking,useSlopeScaledBias:void 0!==r.useSlopeScaledBias&&r.useSlopeScaledBias,esmDistanceScale:t.shadowMap.esmDistanceScale,numRectAreaLightShadows:a?a.rectAreaShadowMap.length:0,numDirLightShadowsCSM:a?a.directionalShadowCSM.length:0,numDirLightShadowCSMCascades:a?a.directionalShadowCSMCascade.length:0,numDirLightShadowsCSMWithFade:a?a.numDirectionalShadowsCSMWithFade:0,dirLightShadowsCSMLUT:a?a.directionalShadowCSMLUT:[],planeReflProbe:!!m,materialName:r.name,materialProfile:r.profile,unitsScaleFactor:t.unitsScaleFactor,alphaToCoverage:!!r.alphaToCoverage,customPrepTokens:r.customPrepTokens,definesFragOnly:r.definesFragOnly,isMeshNodeMaterial:r.isMeshNodeMaterial,nodeChunks:r.nodeChunks,nodeChunksHash:r.nodeChunksHash,useGTAO:t.canUseGTAO()&&r.isMeshNodeMaterial&&r.canUseGTAO(),index0AttributeName:r.index0AttributeName,extensionDerivatives:r.extensions&&r.extensions.derivatives,extensionFragDepth:r.extensions&&r.extensions.fragDepth,rendererExtensionFragDepth:c||o.has("EXT_frag_depth"),customProgramCacheKey:r.customProgramCacheKey()}},getProgramCacheKey:function(e){const n=[];e.shaderID?n.push(e.shaderID):(n.push(ve(e.vertexShader)),n.push(ve(e.fragmentShader)));for(const t in e.defines)n.push(t),n.push(e.defines[t]);if(void 0!==e.customPrepTokens)for(const t in e.customPrepTokens)n.push(t),n.push(e.customPrepTokens[t]);return!1===e.isRawShaderMaterial&&(!function(t,e){t.push(e.precision),t.push(e.outputEncoding),t.push(e.envMapMode),t.push(e.combine),t.push(e.vertexUvs),t.push(e.fogExp2),t.push(e.sizeAttenuation),t.push(e.morphTargetsCount),t.push(e.morphAttributeCount),t.push(e.numDirLights),t.push(e.numPointLights),t.push(e.numSpotLights),t.push(e.numRectAreaLights),t.push(e.numPointLightShadows),t.push(e.numSpotLightShadows),t.push(e.shadowMapType),t.push(e.toneMapping),t.push(e.toneMappingLook),t.push(e.numClippingPlanes),t.push(e.numClipIntersection),t.push(e.depthPacking),t.push(e.envMapCubeUVTileSize),t.push(e.unitsScaleFactor),t.push(e.esmDistanceScale),t.push(e.numRectAreaLightShadows),t.push(e.numDirLightShadowsCSM),t.push(e.numDirLightShadowCSMCascades),t.push(e.numDirLightShadowsCSMWithFade),t.push(e.dirLightShadowsCSMLUT)}(n,e),function(t,e){a.disableAll(),e.isWebGL2&&a.enable(0);e.supportsVertexTextures&&a.enable(1);e.instancing&&a.enable(2);e.instancingColor&&a.enable(3);e.map&&a.enable(4);e.envMap&&a.enable(5);e.lightMap&&a.enable(6);e.aoMap&&a.enable(7);e.emissiveMap&&a.enable(8);e.bumpMap&&a.enable(9);e.normalMap&&a.enable(10);e.objectSpaceNormalMap&&a.enable(11);e.tangentSpaceNormalMap&&a.enable(12);e.displacementMap&&a.enable(17);e.roughnessMap&&a.enable(19);e.metalnessMap&&a.enable(20);e.alphaMap&&a.enable(21);e.alphaTest&&a.enable(22);e.vertexColors&&a.enable(23);e.vertexAlphas&&a.enable(24);e.vertexUvs&&a.enable(25);e.vertexTangents&&a.enable(26);e.uvsVertexOnly&&a.enable(27);t.push(a.mask),a.disableAll(),e.fog&&a.enable(0);e.useFog&&a.enable(1);e.flatShading&&a.enable(2);e.logarithmicDepthBuffer&&a.enable(3);e.skinning&&a.enable(4);e.morphTargets&&a.enable(5);e.morphNormals&&a.enable(6);e.premultipliedAlpha&&a.enable(7);e.shadowMapEnabled&&a.enable(8);e.doubleSided&&a.enable(9);e.flipSided&&a.enable(10);e.useDepthPacking&&a.enable(11);e.dithering&&a.enable(12);e.decodeVideoTexture&&a.enable(18);e.opaque&&a.enable(19);e.distancePacking&&a.enable(20);e.useSlopeScaledBias&&a.enable(21);e.useGTAO&&a.enable(22);e.planeReflProbe&&a.enable(23);e.alphaToCoverage&&a.enable(24);t.push(a.mask)}(n,e),n.push(t.outputEncoding)),n.push(e.customProgramCacheKey),void 0!==e.nodeChunksHash&&n.push(e.nodeChunksHash),n.join()},getUniforms:function(t){const e=A[t.type];let n;if(e){const t=Vi[e];n=pi.clone(t.uniforms)}else n=t.uniforms;return n},acquireProgram:function(e,n){let o;for(let t=0,e=l.length;t<e;t++){const e=l[t];if(e.cacheKey===n){o=e,++o.usedTimes;break}}void 0===o&&(o=new $s(t,n,e,r),l.push(o),d++);const i=o.profile.materials;return e.materialName&&!i.has(e.materialName)&&i.add(e.materialName),o},releaseProgram:function(t){if(0===--t.usedTimes){const e=l.indexOf(t);l[e]=l[l.length-1],l.pop(),t.destroy()}},programs:l,getNumShaderCompiles:function(){return d}}}function ea(){let t=new WeakMap;return{get:function(e){let n=t.get(e);return void 0===n&&(n={},t.set(e,n)),n},remove:function(e){t.delete(e)},update:function(e,n,o){t.get(e)[n]=o},dispose:function(){t=new WeakMap}}}function na(t,e){return t.groupOrder!==e.groupOrder?t.groupOrder-e.groupOrder:t.renderOrder!==e.renderOrder?t.renderOrder-e.renderOrder:t.material.id!==e.material.id?t.material.id-e.material.id:t.z!==e.z?t.z-e.z:t.id-e.id}function oa(t,e){return t.groupOrder!==e.groupOrder?t.groupOrder-e.groupOrder:t.renderOrder!==e.renderOrder?t.renderOrder-e.renderOrder:t.z!==e.z?e.z-t.z:t.id-e.id}function ia(){const t=[];let e=0;const n=[],o=[];function i(n,o,i,r,s,a){let l=t[e];return void 0===l?(l={id:n.id,object:n,geometry:o,material:i,groupOrder:r,renderOrder:n.renderOrder,z:s,group:a},t[e]=l):(l.id=n.id,l.object=n,l.geometry=o,l.material=i,l.groupOrder=r,l.renderOrder=n.renderOrder,l.z=s,l.group=a),e++,l}return{opaque:n,transparent:o,init:function(){e=0,n.length=0,o.length=0},push:function(t,e,r,s,a,l){const c=i(t,e,r,s,a,l);!0===r.transparent?o.push(c):n.push(c)},unshift:function(t,e,r,s,a,l){const c=i(t,e,r,s,a,l);!0===r.transparent?o.unshift(c):n.unshift(c)},finish:function(){for(let n=e,o=t.length;n<o;n++){const e=t[n];if(null===e.id)break;e.id=null,e.object=null,e.geometry=null,e.material=null,e.group=null}},sort:function(t,e){n.length>1&&n.sort(t||na),o.length>1&&o.sort(e||oa)}}}function ra(){let t=new WeakMap;return{get:function(e,n){const o=t.get(e);let i;return void 0===o?(i=new ia,t.set(e,[i])):n>=o.length?(i=new ia,o.push(i)):i=o[n],i},dispose:function(){t=new WeakMap}}}function sa(){const t={};return{get:function(e){if(void 0!==t[e.id])return t[e.id];let n;switch(e.type){case"DirectionalLight":n={direction:new An,color:new tn};break;case"SpotLight":n={position:new An,direction:new An,color:new tn,distance:0,coneCos:0,penumbraCos:0,decay:0};break;case"PointLight":n={position:new An,color:new tn,distance:0,decay:0};break;case"RectAreaLight":n={color:new tn,position:new An,halfWidth:new An,halfHeight:new An}}return t[e.id]=n,n}}}let aa=0;function la(t,e){const n=t.shadow,o=e.shadow;let i=0;return n&&n.isDirectionalLightShadowCSM&&o&&o.isDirectionalLightShadowCSM&&(i+=(0!=o.fade?1:0)-(0!=n.fade?1:0)),(e.castShadow?4:0)-(t.castShadow?4:0)+(e.map?2:0)-(t.map?2:0)+i}function ca(t,e){const n=new sa,o=function(){const t={};return{get:function(e){if(void 0!==t[e.id])return t[e.id];let n;switch(e.type){case"DirectionalLight":n={cascadeIdxEnd:1,cameraNear:1,shadowFar:0,fade:.25};break;case"SpotLight":n={shadowBias:0,shadowNormalBias:0,shadowRadius:1,shadowMapSize:new we,shadow:0,shadowCameraNear:1,shadowCameraFar:1e3,expBias:1};break;case"PointLight":case"RectAreaLight":n={shadowBias:0,shadowNormalBias:0,shadowRadius:1,shadowMapSize:new we,shadowCameraNear:1,shadowCameraFar:1e3,expBias:1}}return t[e.id]=n,n}}}(),i={version:0,hash:{directionalLength:-1,pointLength:-1,spotLength:-1,rectAreaLength:-1,numPointShadows:-1,numSpotShadows:-1,numRectAreaShadows:-1,numDirectionalShadowsCSM:-1,numDirectionalShadowsCSMCascade:-1,numDirectionalShadowsCSMWithFade:-1},ambient:[0,0,0],probe:[],directional:[],directionalShadow:[],directionalShadowMap:[],directionalShadowMatrix:[],spot:[],spotShadow:[],spotShadowMap:[],spotShadowMatrix:[],rectArea:[],rectAreaLTC1:null,rectAreaLTC2:null,point:[],pointShadow:[],pointShadowMap:[],pointShadowMatrix:[],rectAreaShadow:[],rectAreaShadowMap:[],rectAreaShadowMatrix:[],directionalShadowCSM:[],directionalShadowCSMMap:[],directionalShadowCSMMatrix:[],directionalShadowCSMCascade:[],directionalShadowCSMLUT:[],numDirectionalShadowsCSMWithFade:0};for(let t=0;t<9;t++)i.probe.push(new An);const r=new An,s=new Hn,a=new Hn;return{setup:function(r){let s=0,a=0,l=0;for(let t=0;t<9;t++)i.probe[t].set(0,0,0);let c=0,u=0,h=0,f=0,d=0,A=0,v=0,m=0,p=0,g=0;r.sort(la);for(let t=0,e=r.length;t<e;t++){const e=r[t],_=e.color,E=e.intensity,C=e.distance,w=e.shadow&&e.shadow.map?e.shadow.map.texture:null;if(e.isAmbientLight)s+=_.r*E,a+=_.g*E,l+=_.b*E;else if(e.isLightProbe)for(let t=0;t<9;t++)i.probe[t].addScaledVector(e.sh.coefficients[t],E);else if(e.isDirectionalLight){const t=n.get(e);if(t.color.copy(e.color).multiplyScalar(e.intensity),e.castShadow){const t=e.shadow,n=o.get(e);n.cascadeIdxEnd=g+t.numCascades,n.fade=t.fade,p+=0!=t.fade?t.numCascades:0;for(let e=0;e<t.numCascades;e++){let n=g+e;i.directionalShadowCSMCascade[n]||(i.directionalShadowCSMCascade[n]={shadowBias:0,shadowNormalBias:0,shadowRadius:1,shadowMapSize:new we,shadowCameraNear:1,shadowCameraFar:1,cascade:new we,expBias:1,position:new An,csmIdx:0},i.directionalShadowCSMMap[n]=null,i.directionalShadowCSMMatrix[n]=t.matrix)}for(let e=0;e<t.numCascades;e++){const n=g+e,o=i.directionalShadowCSMCascade[n],r=t.Ht[e],s=r.map?r.map.texture:null;i.directionalShadowCSMMap[n]=s,i.directionalShadowCSMMatrix[n]=r.matrix,o.shadowBias=r.bias,o.shadowNormalBias=r.normalBias,o.shadowRadius=r.radius,o.shadowMapSize=r.mapSize,o.position.setFromMatrixPosition(r.camera.matrixWorld),o.shadowCameraNear=r.camera.near,o.shadowCameraFar=r.camera.far,t.getCascadeRange(o.cascade,e),o.expBias=r.expBias,o.csmIdx=m,i.directionalShadowCSMLUT[n]=m}g+=t.numCascades,i.directionalShadowCSM[m]=n,m++}i.directional[c]=t,c++}else if(e.isSpotLight){const t=n.get(e);if(t.position.setFromMatrixPosition(e.matrixWorld),t.color.copy(_).multiplyScalar(E),t.distance=C,t.coneCos=Math.cos(e.angle),t.penumbraCos=Math.cos(e.angle*(1-e.penumbra)),t.decay=e.decay,i.spot[h]=t,e.castShadow){const t=e.shadow,n=o.get(e);n.shadowBias=t.bias,n.shadowNormalBias=t.normalBias,n.shadowRadius=t.radius,n.shadowMapSize=t.mapSize,i.spotShadow[h]=n,i.spotShadowMap[h]=w,i.spotShadowMatrix[h]=t.matrix,n.shadow=e.castShadow?t.calcUseOmniMaps(e.angle)?2:1:0,n.shadowCameraNear=t.camera.near,n.shadowCameraFar=t.camera.far,n.expBias=t.expBias,A++}h++}else if(e.isRectAreaLight){const t=n.get(e);if(t.color.copy(_).multiplyScalar(E),t.halfWidth.set(.5*e.width,0,0),t.halfHeight.set(0,.5*e.height,0),e.castShadow){const t=e.shadow,n=o.get(e);n.shadowBias=t.bias,n.shadowNormalBias=t.normalBias,n.shadowRadius=t.radius,n.shadowMapSize=t.mapSize,n.shadowCameraNear=t.camera.near,n.shadowCameraFar=t.camera.far,n.expBias=t.expBias,i.rectAreaShadow[f]=n,i.rectAreaShadowMap[f]=w,i.rectAreaShadowMatrix[f]=t.matrix,v++}i.rectArea[f]=t,f++}else if(e.isPointLight){const t=n.get(e);if(t.color.copy(e.color).multiplyScalar(e.intensity),t.distance=e.distance,t.decay=e.decay,e.castShadow){const t=e.shadow,n=o.get(e);n.shadowBias=t.bias,n.shadowNormalBias=t.normalBias,n.shadowRadius=t.radius,n.shadowMapSize=t.mapSize,n.shadowCameraNear=t.camera.near,n.shadowCameraFar=t.camera.far,n.expBias=t.expBias,i.pointShadow[u]=n,i.pointShadowMap[u]=w,i.pointShadowMatrix[u]=t.matrix,d++}i.point[u]=t,u++}}f>0&&(e.isWebGL2||!0===t.has("OES_texture_float_linear")?(i.rectAreaLTC1=Ui.LTC_FLOAT_1,i.rectAreaLTC2=Ui.LTC_FLOAT_2):!0===t.has("OES_texture_half_float_linear")?(i.rectAreaLTC1=Ui.LTC_HALF_1,i.rectAreaLTC2=Ui.LTC_HALF_2):console.error("v3d.WebGLRenderer: Unable to use RectAreaLight. Missing WebGL extensions.")),i.ambient[0]=s,i.ambient[1]=a,i.ambient[2]=l;const _=i.hash;_.directionalLength===c&&_.pointLength===u&&_.spotLength===h&&_.rectAreaLength===f&&_.numPointShadows===d&&_.numSpotShadows===A&&_.numRectAreaShadows===v&&_.numDirectionalShadowsCSM===m&&_.numDirectionalShadowsCSMCascade===g&&_.numDirectionalShadowsCSMWithFade===p||(i.directional.length=c,i.spot.length=h,i.rectArea.length=f,i.point.length=u,i.pointShadow.length=d,i.pointShadowMap.length=d,i.spotShadow.length=A,i.spotShadowMap.length=A,i.pointShadowMatrix.length=d,i.spotShadowMatrix.length=A,_.directionalLength=c,_.pointLength=u,_.spotLength=h,_.rectAreaLength=f,_.numPointShadows=d,_.numSpotShadows=A,i.rectAreaShadow.length=v,i.rectAreaShadowMap.length=v,i.rectAreaShadowMatrix.length=v,i.directionalShadowCSM.length=m,i.directionalShadowCSMMap.length=g,i.directionalShadowCSMMatrix.length=g,i.directionalShadowCSMCascade.length=g,i.directionalShadowCSMLUT.length=g,i.numDirectionalShadowsCSMWithFade=p,_.numRectAreaShadows=v,_.numDirectionalShadowsCSM=m,_.numDirectionalShadowsCSMCascade=g,_.numDirectionalShadowsCSMWithFade=p,i.version=aa++)},setupView:function(t,e){let n=0,l=0,c=0,u=0,h=0;const f=e.matrixWorldInverse;for(let d=0,A=t.length;d<A;d++){const A=t[d];if(A.isDirectionalLight){const t=i.directional[n];if(t.direction.setFromMatrixPosition(A.matrixWorld),r.setFromMatrixPosition(A.target.matrixWorld),t.direction.sub(r),t.direction.transformDirection(f),A.castShadow){const t=A.shadow,n=o.get(A);n.cameraNear=Math.min(t.maxDistance,e.near),n.shadowFar=Math.min(t.maxDistance,e.far);for(let e=0;e<t.numCascades;e++){const n=h+e,o=i.directionalShadowCSMCascade[n],r=t.Ht[e];o.shadowCameraFar=r.camera.far,o.position.setFromMatrixPosition(r.camera.matrixWorld),o.position.applyMatrix4(f)}h+=t.numCascades}n++}else if(A.isSpotLight){const t=i.spot[c];t.position.setFromMatrixPosition(A.matrixWorld),t.position.applyMatrix4(f),t.direction.setFromMatrixPosition(A.matrixWorld),r.setFromMatrixPosition(A.target.matrixWorld),t.direction.sub(r),t.direction.transformDirection(f),c++}else if(A.isRectAreaLight){const t=i.rectArea[u];t.position.setFromMatrixPosition(A.matrixWorld),t.position.applyMatrix4(f),a.identity(),s.copy(A.matrixWorld),s.premultiply(f),a.extractRotation(s),t.halfWidth.set(.5*A.width,0,0),t.halfHeight.set(0,.5*A.height,0),t.halfWidth.applyMatrix4(a),t.halfHeight.applyMatrix4(a),u++}else if(A.isPointLight){const t=i.point[l];t.position.setFromMatrixPosition(A.matrixWorld),t.position.applyMatrix4(f),l++}}},state:i}}function ua(t,e){const n=new ca(t,e),o=[],i=[],r=[],s=[];return{init:function(){o.length=0,i.length=0,r.length=0,s.length=0},state:{lightsArray:o,shadowsArray:i,envMapProbeArray:r,planeReflProbeArray:s,lights:n},setupLights:function(){n.setup(o)},setupLightsView:function(t){n.setupView(o,t)},pushLight:function(t){o.push(t)},pushShadow:function(t){i.push(t)},pushEnvMapProbe:function(t){r.push(t)},sortEnvMapProbes:function(){r.sort((t,e)=>t.influenceDistance-e.influenceDistance)},pushPlaneReflProbe:function(t){s.push(t)}}}function ha(t,e){let n=new WeakMap;return{get:function(o,i=0){const r=n.get(o);let s;return void 0===r?(s=new ua(t,e),n.set(o,[s])):i>=r.length?(s=new ua(t,e),r.push(s)):s=r[i],s},dispose:function(){n=new WeakMap}}}class fa extends Lo{constructor(t){super(),this.isMeshDepthMaterial=!0,this.type="MeshDepthMaterial",this.depthPacking=3200,this.useSlopeScaledBias=!1,this.slopeScaledBias=0,this.map=null,this.alphaMap=null,this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.wireframe=!1,this.wireframeLinewidth=1,this.setValues(t)}copy(t){return super.copy(t),this.depthPacking=t.depthPacking,this.useSlopeScaledBias=t.useSlopeScaledBias,this.slopeScaledBias=t.slopeScaledBias,this.map=t.map,this.alphaMap=t.alphaMap,this.displacementMap=t.displacementMap,this.displacementScale=t.displacementScale,this.displacementBias=t.displacementBias,this.wireframe=t.wireframe,this.wireframeLinewidth=t.wireframeLinewidth,this}}class da extends Lo{constructor(t){super(),this.isMeshDistanceMaterial=!0,this.type="MeshDistanceMaterial",this.referencePosition=new An,this.nearDistance=1,this.farDistance=1e3,this.map=null,this.alphaMap=null,this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.defines={DISTANCE_SCALE:"1.0"},this.distancePacking=Gt,this.useSlopeScaledBias=!1,this.slopeScaledBias=0,this.setValues(t)}copy(t){return super.copy(t),this.referencePosition.copy(t.referencePosition),this.nearDistance=t.nearDistance,this.farDistance=t.farDistance,this.map=t.map,this.alphaMap=t.alphaMap,this.displacementMap=t.displacementMap,this.displacementScale=t.displacementScale,this.displacementBias=t.displacementBias,this.distancePacking=t.distancePacking,this.useSlopeScaledBias=t.useSlopeScaledBias,this.slopeScaledBias=t.slopeScaledBias,this}}const Aa=new Hn,va=new An,ma=new An;class pa{constructor(t){this.camera=t,this.bias=0,this.normalBias=0,this.radius=1,this.mapSize=new we(512,512),this.map=null,this.matrix=new Hn,this.autoUpdate=!0,this.needsUpdate=!1,this.Wt=new Li,this.Yt=new we(1,1),this.Xt=1,this.Kt=[new ln(0,0,1,1)],this.expBias=1,this.slopeScaledBias=0,this.jt=null,this.Zt=null,this.isLightShadow=!0}getViewportCount(){return this.Xt}getFrustum(){return this.Wt}updateMatrices(t){const e=this.camera,n=this.matrix;va.setFromMatrixPosition(t.matrixWorld),e.position.copy(va),ma.setFromMatrixPosition(t.target.matrixWorld),e.lookAt(ma),e.updateMatrixWorld(),Aa.multiplyMatrices(e.projectionMatrix,e.matrixWorldInverse),this.Wt.setFromProjectionMatrix(Aa),n.set(.5,0,0,.5,0,.5,0,.5,0,0,.5,.5,0,0,0,1),n.multiply(Aa)}getViewport(t){return this.Kt[t]}getFrameExtents(){return this.Yt}dispose(){this.map&&this.map.dispose(),null!==this.jt&&this.jt.dispose(),null!==this.Zt&&this.Zt.dispose()}removeMaps(){this.map=null,this.jt=null,this.Zt=null}copy(t){return this.camera=t.camera.clone(),this.bias=t.bias,this.radius=t.radius,this.mapSize.copy(t.mapSize),this.expBias=t.expBias,this.slopeScaledBias=t.slopeScaledBias,this}clone(){return(new this.constructor).copy(this)}}const ga=Math.PI/4,_a=new Hn,Ea=new An,Ca=new An;class wa extends pa{constructor(){super(new Ei(50,1,.5,500)),this.isSpotLightShadow=!0,this.focus=1,this.useOmniMaps=!1,this.useMinFov90=!1,this.qt=new we(4,2),this.Jt=6,this.$t=[new ln(2,1,1,1),new ln(0,1,1,1),new ln(3,1,1,1),new ln(1,1,1,1),new ln(3,0,1,1),new ln(1,0,1,1)],this.te=[new An(1,0,0),new An(-1,0,0),new An(0,0,1),new An(0,0,-1),new An(0,1,0),new An(0,-1,0)],this.ee=[new An(0,1,0),new An(0,1,0),new An(0,1,0),new An(0,1,0),new An(0,0,1),new An(0,0,-1)]}updateMatrices(t,e=0){if(this.useOmniMaps){const n=this.camera,o=this.matrix;Ea.setFromMatrixPosition(t.matrixWorld),n.position.copy(Ea),Ca.copy(n.position),Ca.add(this.te[e]),n.up.copy(this.ee[e]),n.lookAt(Ca),n.updateMatrixWorld(),o.makeTranslation(-Ea.x,-Ea.y,-Ea.z),_a.multiplyMatrices(n.projectionMatrix,n.matrixWorldInverse),this.Wt.setFromProjectionMatrix(_a)}else{const e=this.camera,n=2*$t*t.angle*this.focus,o=this.mapSize.width/this.mapSize.height,i=t.distance||e.far;n===e.fov&&o===e.aspect&&i===e.far||(e.fov=n,e.aspect=o,e.far=i,e.updateProjectionMatrix()),super.updateMatrices(t)}}getViewportCount(){return this.useOmniMaps?this.Jt:super.getViewportCount()}getViewport(t){return this.useOmniMaps?this.$t[t]:super.getViewport(t)}getFrameExtents(){return this.useOmniMaps?this.qt:super.getFrameExtents()}calcUseOmniMaps(t){return this.useOmniMaps=t>ga,this.useOmniMaps}copy(t){return super.copy(t),this.focus=t.focus,this.useOmniMaps=t.useOmniMaps,this.useMinFov90=t.useMinFov90,this}}function xa(t,e,n){let o=new Li;const i=new we,r=new we,s=new ln,a=new fa({depthPacking:Ut}),l=new da,c={},u=n.maxTextureSize,h=n.isWebGL2,f={0:1,1:0,2:2},d=new Hn;new Hn;const A=new we(u,u),v=new An,m=new An;new An;const p=[new An(1,0,0),new An(-1,0,0),new An(0,1,0),new An(0,-1,0),new An(0,0,1),new An(0,0,-1)],g=[new An(0,1,0),new An(0,1,0),new An(0,0,1),new An(0,0,-1),new An(0,1,0),new An(0,1,0)];new ln,new ln,new ln,new ln,new ln,new ln,new Pn,new An,new An,new An,new An,new An,new An,new An,new An;const _=new hi(new Oi(1,1,1,1));_.name="esmFarPlane",_.castShadow=!0,_.material.shadowSide=0;const E=new Xi(-1,1,1,-1,0,10),C=new hi(new Oi(2,2)),w=new gi({type:"ShadowCubeOctahedral",defines:Object.assign({},Vi.cubeOctahedral.defines),uniforms:pi.clone(Vi.cubeOctahedral.uniforms),vertexShader:Vi.cubeOctahedral.vertexShader,fragmentShader:Vi.cubeOctahedral.fragmentShader}),x={},I={},M=this;function S(e,n,o,i,r,s,u,h,d){let A=null;const v=h||3===u?e.customDistanceMaterial:e.customDepthMaterial;if(A=void 0!==v?v:h||3===u?l:a,t.localClippingEnabled&&!0===o.clipShadows&&Array.isArray(o.clippingPlanes)&&0!==o.clippingPlanes.length||o.displacementMap&&0!==o.displacementScale||o.alphaMap&&o.alphaTest>0||o.map&&o.alphaTest>0){const t=A.uuid,e=o.uuid;let n=c[t];void 0===n&&(n={},c[t]=n);let i=n[e];void 0===i&&(i=A.clone(),n[e]=i),A=i}A.visible=o.visible,A.wireframe=o.wireframe,A.side=null!==o.shadowSide?o.shadowSide:f[o.side],A.alphaMap=o.alphaMap,A.alphaTest=o.alphaTest,A.map=o.map,A.clipShadows=o.clipShadows,A.clippingPlanes=o.clippingPlanes,A.clipIntersection=o.clipIntersection,A.displacementMap=o.displacementMap,A.displacementScale=o.displacementScale,A.displacementBias=o.displacementBias,A.wireframeLinewidth=o.wireframeLinewidth,A.linewidth=o.linewidth;const m=(h||3===u)&&!0===A.isMeshDistanceMaterial;switch(m&&(A.referencePosition.copy(d),A.nearDistance=r,A.farDistance=s,A.distancePacking=3===u?3302:Gt),3===u&&(A.defines.DISTANCE_SCALE=Oe(M.esmDistanceScale)),i.shadow.isDirectionalLightShadowCascade&&i.shadow.pancakeDepth&&(A.defines.PANCAKE_DEPTH="",m&&(A.defines.CAM_WIDTH=Oe(i.shadow.camera.right),A.defines.CAM_HEIGHT=Oe(i.shadow.camera.top))),u){case 0:case 1:case 2:A.useSlopeScaledBias=!0,A.slopeScaledBias=i.shadow.slopeScaledBias;break;case 3:A.useSlopeScaledBias=!0,A.slopeScaledBias=.5}return A}function b(n,i,r,s,a,l){if(!1===n.visible)return;if((i.ignoreShadowLayers||n.layers.test(i.layers))&&(n.isMesh||n.isLine||n.isPoints)&&n.castShadow&&(!n.frustumCulled||o.intersectsObject(n))){n.modelViewMatrix.multiplyMatrices(r.matrixWorldInverse,n.matrixWorld);const o=e.update(n),i=n.material;if(Array.isArray(i)){const e=o.groups;for(let c=0,u=e.length;c<u;c++){const u=e[c],h=i[u.materialIndex];if(h&&h.visible){const e=S(n,0,h,s,r.near,r.far,a,l,m);t.renderBufferDirect(r,null,o,e,n,u)}}}else if(i.visible){const e=S(n,0,i,s,r.near,r.far,a,l,m);t.renderBufferDirect(r,null,o,e,n,null)}}const c=n.children;for(let t=0,e=c.length;t<e;t++)b(c[t],i,r,s,a,l)}function y(e,n,a,l){const c=a.shadow,h=c.camera;c.isDirectionalLightShadowCascade?m.setFromMatrixPosition(h.matrixWorld):m.setFromMatrixPosition(a.matrixWorld),i.copy(c.mapSize);const f=c.getFrameExtents();if(i.multiply(f),r.copy(c.mapSize),(i.x>u||i.y>u)&&(i.x>u&&(r.x=Math.floor(u/f.x),i.x=r.x*f.x,c.mapSize.x=r.x),i.y>u&&(r.y=Math.floor(u/f.y),i.y=r.y*f.y,c.mapSize.y=r.y)),a.isSpotLight&&c.map&&c.map.width/c.map.height!==2){const t=c.map;c.map=c.jt,c.jt=t}const d=a.isPointLight||a.isRectAreaLight||a.isSpotLight&&c.useOmniMaps;if(d?a.isSpotLight&&(h.fov=90,h.updateProjectionMatrix()):a.isSpotLight&&c.useMinFov90&&(h.fov=90,h.updateProjectionMatrix()),null===c.map){const t={minFilter:T,magFilter:T,format:W};c.map=new cn(i.x,i.y,t),c.map.texture.name=a.name+".shadowMap",h.updateProjectionMatrix()}t.state.buffers.color.setClear(1,1,1,1),t.setRenderTarget(c.map),t.clear();const A=c.getViewportCount();for(let i=0;i<A;i++){const u=c.getViewport(i);s.set(r.x*u.x,r.y*u.y,r.x*u.z,r.y*u.w),t.state.viewport(s),c.updateMatrices(a,i),o.copy(c.getFrustum()),b(e,n,c.camera,a,l,d)}}function R(e,n,r,s){const a=r.shadow,l=a.camera,c=a.matrix,u=r.isPointLight||r.isRectAreaLight?2:1,f=i.copy(a.mapSize).multiplyScalar(u).min(A).multiplyScalar(1/u);null===a.Zt&&(a.Zt=new Ii(f.x,{minFilter:N,magFilter:N,format:h?K:W,type:Q}),a.Zt.texture.name=r.name+".shadowMap.tmpCube"),null===a.jt&&(a.jt=new cn(f.x*u,f.y*u,{minFilter:N,magFilter:N,format:h?K:W,type:Q}),a.jt.texture.name=r.name+".shadowMap.tmp2D"),null===a.map&&(a.map=new cn(f.x*u,f.y*u,{minFilter:N,magFilter:N,format:h?K:W,type:Q}),a.map.texture.name=r.name+".shadowMap"),m.setFromMatrixPosition(r.matrixWorld),l.position.copy(m),r.isSpotLight&&(l.fov=90,l.updateProjectionMatrix()),c.makeTranslation(-m.x,-m.y,-m.z);for(let i=0;i<6;i++)v.copy(l.position),v.add(p[i]),l.up.copy(g[i]),2!==i&&3!==i&&l.up.multiplyScalar(-1),l.lookAt(v),l.updateMatrixWorld(),d.multiplyMatrices(l.projectionMatrix,l.matrixWorldInverse),o.setFromProjectionMatrix(d),t.setRenderTarget(a.Zt,i),t.clearDepth(),D(n,l,r,s),b(e,n,l,r,s,!0);const _=Math.max(a.radius*u,.001),x=function(t){return Math.ceil(.2*t)}(_);!function(t,e,n){const o=C.material=w;o.uniforms.tCube.value=e.texture,o.uniforms.texelSize.value.set(1/n.width,1/n.height),o.uniformsNeedUpdate=!0,t.setRenderTarget(n),t.clear(),t.updateGeometry(C),t.renderBufferDirect(E,null,C.geometry,o,C,null)}(t,a.Zt,a.map),B(t,a.map,a.jt,x,_,1,0),B(t,a.jt,a.map,x,_,0,0)}function B(t,e,n,o,i,r,s){const a=C.material=0===s?function(t){if(!(t in x)){(x[t]=new gi({type:"ShadowBlur",defines:Object.assign({},Vi.blur.defines,{LOG_SPACE:1,OCTAHEDRAL_MAP:1}),uniforms:pi.clone(Vi.blur.uniforms),customPrepTokens:Object.assign({},Vi.blur.customPrepTokens),vertexShader:Vi.blur.vertexShader,fragmentShader:Vi.blur.fragmentShader})).customPrepTokens.MAX_SAMPLE_RADIUS=t}return x[t]}(o):function(t){if(!(t in I)){(I[t]=new gi({type:"ShadowBlur",defines:Object.assign({},Vi.blur.defines,{LOG_SPACE:1}),uniforms:pi.clone(Vi.blur.uniforms),customPrepTokens:Object.assign({},Vi.blur.customPrepTokens),vertexShader:Vi.blur.vertexShader,fragmentShader:Vi.blur.fragmentShader})).customPrepTokens.MAX_SAMPLE_RADIUS=t}return I[t]}(o);a.uniforms.direction.value.set(+(0===r),+(1===r)),a.uniforms.colorTexture.value=e.texture,a.uniforms.texSize.value.set(e.width,e.height),a.uniforms.kernelRadius.value=i,a.uniformsNeedUpdate=!0,t.setRenderTarget(n),t.clear(),t.updateGeometry(C),t.renderBufferDirect(E,null,C.geometry,a,C,null)}function L(e,n,r,s){const a=r.shadow,l=a.camera,c=a.matrix,u=i.copy(a.mapSize).min(A);let f;null===a.jt&&(a.jt=new cn(u.x,u.y,{minFilter:N,magFilter:N,format:h?K:W,type:Q}),a.jt.texture.name=r.name+".shadowMap.tmp2D"),null===a.map&&(a.map=new cn(u.x,u.y,{minFilter:N,magFilter:N,format:h?K:W,type:Q}),a.map.texture.name=r.name+".shadowMap"),a.isDirectionalLightShadowCascade?m.setFromMatrixPosition(l.matrixWorld):(m.setFromMatrixPosition(r.matrixWorld),l.position.copy(m),v.setFromMatrixPosition(r.target.matrixWorld),l.lookAt(v),l.updateMatrixWorld()),r.isSpotLight&&a.useMinFov90&&(l.fov=90,l.updateProjectionMatrix()),a.isDirectionalLightShadowCascade?(a.updateMatrices(r),o.copy(a.getFrustum())):(c.set(.5,0,0,.5,0,.5,0,.5,0,0,.5,.5,0,0,0,1),c.multiply(l.projectionMatrix),c.multiply(l.matrixWorldInverse),d.multiplyMatrices(l.projectionMatrix,l.matrixWorldInverse),o.setFromProjectionMatrix(d)),t.setRenderTarget(a.map),t.clearDepth(),D(n,l,r,s),b(e,n,l,r,s,!1),f=r.isDirectionalLight&&r.shadow.isDirectionalLightShadowCascade?50*a.esmBlurRadius:r.isSpotLight?.8*a.radius:a.radius,f=Math.max(f,.001);const p=function(t){return Math.ceil(.8*t)}(f);B(t,a.map,a.jt,p,f,0,1),B(t,a.jt,a.map,p,f,1,1)}function D(t,e,n,o){let i,r,s,a,l,c;e.isPerspectiveCamera?(i=r=0,s=-.999*e.far,a=l=2*-s*Math.tan(le(e.fov)/2),c=1):e.isOrthographicCamera&&(i=(e.right+e.left)/2,r=(e.top+e.bottom)/2,s=-.999*e.far,a=e.right-e.left,l=e.top-e.bottom,c=1),e.add(_),_.scale.set(a,l,c),_.position.set(i,r,s),_.updateMatrixWorld(),b(_,t,e,n,o,!0)}this.enabled=!1,this.autoUpdate=!0,this.needsUpdate=!1,this.type=2,this.esmDistanceScale=1,this.render=function(e,n,o){if(!1===M.enabled)return;if(!1===M.autoUpdate&&!1===M.needsUpdate)return;if(0===e.length)return;const i=t.getRenderTarget(),r=t.getActiveCubeFace(),s=t.getActiveMipmapLevel(),a=t.state;a.setBlending(0),a.buffers.color.setClear(1,1,1,1),a.buffers.depth.setTest(!0),a.setScissorTest(!1);for(let t=0,i=e.length;t<i;t++){const i=e[t],r=i.shadow;if(void 0!==r){if(!1!==r.autoUpdate||!1!==r.needsUpdate){if(i.isSpotLight&&r.calcUseOmniMaps(i.angle),i.isPointLight||i.isRectAreaLight||i.isSpotLight&&r.useOmniMaps)switch(M.type){case 0:case 1:case 2:y(n,o,i,M.type);break;case 3:R(n,o,i,M.type);break;default:continue}else{if(!i.isSpotLight&&!i.isDirectionalLight)continue;switch(M.type){case 0:case 1:case 2:if(r.isDirectionalLightShadowCSM){r.update(o,i);const t=i.shadow;for(let e=0;e<t.numCascades;e++)i.shadow=t.Ht[e],y(n,o,i,M.type);i.shadow=t}else y(n,o,i,M.type);break;case 3:if(r.isDirectionalLightShadowCSM){r.update(o,i);const t=i.shadow;for(let e=0;e<t.numCascades;e++)i.shadow=t.Ht[e],L(n,o,i,M.type);i.shadow=t}else L(n,o,i,M.type);break;default:continue}}r.needsUpdate=!1}}else console.warn("v3d.WebGLShadowMap:",i,"has no shadow.")}M.needsUpdate=!1,t.setRenderTarget(i,r,s)}}function Ia(t,e,n){const o=n.isWebGL2;const i=new function(){let e=!1;const n=new ln;let o=null;const i=new ln(0,0,0,0);return{setMask:function(n){o===n||e||(t.colorMask(n,n,n,n),o=n)},getMask:function(){return o},setLocked:function(t){e=t},setClear:function(e,o,r,s,a){!0===a&&(e*=s,o*=s,r*=s),n.set(e,o,r,s),!1===i.equals(n)&&(t.clearColor(e,o,r,s),i.copy(n))},reset:function(){e=!1,o=null,i.set(-1,0,0,0)}}},r=new function(){let e=!1,n=null,o=null,i=null,r=null;return{setTest:function(t){t!==r&&(t?tt(2929):et(2929),r=t)},getTest:function(){return r},setMask:function(o){n===o||e||(t.depthMask(o),n=o)},setFunc:function(e){if(o!==e){switch(e){case 0:t.depthFunc(512);break;case 1:t.depthFunc(519);break;case 2:t.depthFunc(513);break;case 3:default:t.depthFunc(515);break;case 4:t.depthFunc(514);break;case 5:t.depthFunc(518);break;case 6:t.depthFunc(516);break;case 7:t.depthFunc(517)}o=e}},setLocked:function(t){e=t},setClear:function(e){i!==e&&(t.clearDepth(e),i=e)},reset:function(){e=!1,n=null,o=null,i=null}}},s=new function(){let e=!1,n=null,o=null,i=null,r=null,s=null,a=null,l=null,c=null;return{setTest:function(t){e||(t?tt(2960):et(2960))},setMask:function(o){n===o||e||(t.stencilMask(o),n=o)},setFunc:function(e,n,s){o===e&&i===n&&r===s||(t.stencilFunc(e,n,s),o=e,i=n,r=s)},setOp:function(e,n,o){s===e&&a===n&&l===o||(t.stencilOp(e,n,o),s=e,a=n,l=o)},setLocked:function(t){e=t},setClear:function(e){c!==e&&(t.clearStencil(e),c=e)},reset:function(){e=!1,n=null,o=null,i=null,r=null,s=null,a=null,l=null,c=null}}},C=new WeakMap,w=new WeakMap;let x={},I={},M=new WeakMap,S=[],b=null,y=!1,R=null,T=null,B=null,L=null,N=null,D=null,P=null,O=!1,F=null,U=null,V=null,G=null,Q=null;const z=t.getParameter(35661);let k=!1,H=0;const W=t.getParameter(7938);-1!==W.indexOf("WebGL")?(H=parseFloat(/^WebGL (\d)/.exec(W)[1]),k=H>=1):-1!==W.indexOf("OpenGL ES")&&(H=parseFloat(/^OpenGL ES (\d)/.exec(W)[1]),k=H>=2);let Y=null,X={};const K=t.getParameter(3088),j=t.getParameter(2978),Z=(new ln).fromArray(K),q=(new ln).fromArray(j);function J(e,n,o){const i=new Uint8Array(4),r=t.createTexture();t.bindTexture(e,r),t.texParameteri(e,10241,9728),t.texParameteri(e,10240,9728);for(let e=0;e<o;e++)t.texImage2D(n+e,0,6408,1,1,0,6408,5121,i);return r}const $={};function tt(e){!0!==x[e]&&(t.enable(e),x[e]=!0)}function et(e){!1!==x[e]&&(t.disable(e),x[e]=!1)}$[3553]=J(3553,3553,1),$[34067]=J(34067,34069,6),i.setClear(0,0,0,1),r.setClear(1),s.setClear(0),tt(2929),r.setFunc(3),rt(!1),st(1),tt(2884),it(0);const nt={[a]:32774,[l]:32778,[c]:32779};if(o)nt[103]=32775,nt[104]=32776;else{const t=e.get("EXT_blend_minmax");null!==t&&(nt[103]=t.MIN_EXT,nt[104]=t.MAX_EXT)}const ot={[u]:0,[h]:1,[f]:768,[A]:770,[E]:776,[g]:774,[m]:772,[d]:769,[v]:771,[_]:775,[p]:773};function it(e,n,o,i,r,s,l,c){if(0!==e){if(!1===y&&(tt(3042),y=!0),5===e)r=r||n,s=s||o,l=l||i,n===T&&r===N||(t.blendEquationSeparate(nt[n],nt[r]),T=n,N=r),o===B&&i===L&&s===D&&l===P||(t.blendFuncSeparate(ot[o],ot[i],ot[s],ot[l]),B=o,L=i,D=s,P=l),R=e,O=!1;else if(e!==R||c!==O){if(T===a&&N===a||(t.blendEquation(32774),T=a,N=a),c)switch(e){case 1:t.blendFuncSeparate(1,771,1,771);break;case 2:t.blendFunc(1,1);break;case 3:t.blendFuncSeparate(0,769,0,1);break;case 4:t.blendFuncSeparate(0,768,0,770);break;default:console.error("v3d.WebGLState: Invalid blending: ",e)}else switch(e){case 1:t.blendFuncSeparate(770,771,1,771);break;case 2:t.blendFunc(770,1);break;case 3:t.blendFuncSeparate(0,769,0,1);break;case 4:t.blendFunc(0,768);break;default:console.error("v3d.WebGLState: Invalid blending: ",e)}B=null,L=null,D=null,P=null,R=e,O=c}}else!0===y&&(et(3042),y=!1)}function rt(e){F!==e&&(e?t.frontFace(2304):t.frontFace(2305),F=e)}function st(e){0!==e?(tt(2884),e!==U&&(1===e?t.cullFace(1029):2===e?t.cullFace(1028):t.cullFace(1032))):et(2884),U=e}function at(e,n,o){e?(tt(32823),G===n&&Q===o||(t.polygonOffset(n,o),G=n,Q=o)):et(32823)}return{buffers:{color:i,depth:r,stencil:s},enable:tt,disable:et,bindFramebuffer:function(e,n){return I[e]!==n&&(t.bindFramebuffer(e,n),I[e]=n,o&&(36009===e&&(I[36160]=n),36160===e&&(I[36009]=n)),!0)},drawBuffers:function(e,n){let o=S,i=!1;if(e)if(o=M.get(n),void 0===o&&(o=[],M.set(n,o)),e.isWebGLMultipleRenderTargets){const t=e.texture;if(o.length!==t.length||36064!==o[0]){for(let e=0,n=t.length;e<n;e++)o[e]=36064+e;o.length=t.length,i=!0}}else 36064!==o[0]&&(o[0]=36064,i=!0);else 1029!==o[0]&&(o[0]=1029,i=!0);i&&t.drawBuffers(o)},useProgram:function(e){return b!==e&&(t.useProgram(e),b=e,!0)},setBlending:it,setMaterial:function(t,e){2===t.side?et(2884):tt(2884);let n=1===t.side;e&&(n=!n),rt(n),1===t.blending&&!1===t.transparent?it(0):it(t.blending,t.blendEquation,t.blendSrc,t.blendDst,t.blendEquationAlpha,t.blendSrcAlpha,t.blendDstAlpha,t.premultipliedAlpha),r.setFunc(t.depthFunc),r.setTest(t.depthTest),r.setMask(t.depthWrite),i.setMask(t.colorWrite);const o=t.stencilWrite;s.setTest(o),o&&(s.setMask(t.stencilWriteMask),s.setFunc(t.stencilFunc,t.stencilRef,t.stencilFuncMask),s.setOp(t.stencilFail,t.stencilZFail,t.stencilZPass)),at(t.polygonOffset,t.polygonOffsetFactor,t.polygonOffsetUnits),!0===t.alphaToCoverage?tt(32926):et(32926)},setFlipSided:rt,setCullFace:st,setLineWidth:function(e){e!==V&&(k&&t.lineWidth(e),V=e)},setPolygonOffset:at,setScissorTest:function(t){t?tt(3089):et(3089)},activeTexture:function(e){void 0===e&&(e=33984+z-1),Y!==e&&(t.activeTexture(e),Y=e)},bindTexture:function(e,n,o){void 0===o&&(o=null===Y?33984+z-1:Y);let i=X[o];void 0===i&&(i={type:void 0,texture:void 0},X[o]=i),i.type===e&&i.texture===n||(Y!==o&&(t.activeTexture(o),Y=o),t.bindTexture(e,n||$[e]),i.type=e,i.texture=n)},unbindTexture:function(){const e=X[Y];void 0!==e&&void 0!==e.type&&(t.bindTexture(e.type,null),e.type=void 0,e.texture=void 0)},compressedTexImage2D:function(){try{t.compressedTexImage2D.apply(t,arguments)}catch(t){console.error("v3d.WebGLState:",t)}},compressedTexImage3D:function(){try{t.compressedTexImage3D.apply(t,arguments)}catch(t){console.error("v3d.WebGLState:",t)}},texImage2D:function(){try{t.texImage2D.apply(t,arguments)}catch(t){console.error("v3d.WebGLState:",t)}},texImage3D:function(){try{t.texImage3D.apply(t,arguments)}catch(t){console.error("v3d.WebGLState:",t)}},updateUBOMapping:function(e,n){let o=w.get(n);void 0===o&&(o=new WeakMap,w.set(n,o));let i=o.get(e);void 0===i&&(i=t.getUniformBlockIndex(n,e.name),o.set(e,i))},uniformBlockBinding:function(e,n){const o=w.get(n).get(e);C.get(e)!==o&&(t.uniformBlockBinding(n,o,e.ne),C.set(e,o))},texStorage2D:function(){try{t.texStorage2D.apply(t,arguments)}catch(t){console.error("v3d.WebGLState:",t)}},texStorage3D:function(){try{t.texStorage3D.apply(t,arguments)}catch(t){console.error("v3d.WebGLState:",t)}},texSubImage2D:function(){try{t.texSubImage2D.apply(t,arguments)}catch(t){console.error("v3d.WebGLState:",t)}},texSubImage3D:function(){try{t.texSubImage3D.apply(t,arguments)}catch(t){console.error("v3d.WebGLState:",t)}},compressedTexSubImage2D:function(){try{t.compressedTexSubImage2D.apply(t,arguments)}catch(t){console.error("v3d.WebGLState:",t)}},compressedTexSubImage3D:function(){try{t.compressedTexSubImage3D.apply(t,arguments)}catch(t){console.error("v3d.WebGLState:",t)}},scissor:function(e){!1===Z.equals(e)&&(t.scissor(e.x,e.y,e.z,e.w),Z.copy(e))},viewport:function(e){!1===q.equals(e)&&(t.viewport(e.x,e.y,e.z,e.w),q.copy(e))},reset:function(){t.disable(3042),t.disable(2884),t.disable(2929),t.disable(32823),t.disable(3089),t.disable(2960),t.disable(32926),t.blendEquation(32774),t.blendFunc(1,0),t.blendFuncSeparate(1,0,1,0),t.colorMask(!0,!0,!0,!0),t.clearColor(0,0,0,0),t.depthMask(!0),t.depthFunc(513),t.clearDepth(1),t.stencilMask(4294967295),t.stencilFunc(519,0,4294967295),t.stencilOp(7680,7680,7680),t.clearStencil(0),t.cullFace(1029),t.frontFace(2305),t.polygonOffset(0,0),t.activeTexture(33984),t.bindFramebuffer(36160,null),!0===o&&(t.bindFramebuffer(36009,null),t.bindFramebuffer(36008,null)),t.useProgram(null),t.lineWidth(1),t.scissor(0,0,t.canvas.width,t.canvas.height),t.viewport(0,0,t.canvas.width,t.canvas.height),x={},Y=null,X={},I={},M=new WeakMap,S=[],b=null,y=!1,R=null,T=null,B=null,L=null,N=null,D=null,P=null,O=!1,F=null,U=null,V=null,G=null,Q=null,Z.set(0,0,t.canvas.width,t.canvas.height),q.set(0,0,t.canvas.width,t.canvas.height),i.reset(),r.reset(),s.reset()}}}function Ma(t,e,n,o,i,r,s){const a=i.isWebGL2,l=i.maxTextures,c=i.maxCubemapSize,u=i.maxTextureSize,h=i.maxSamples,f=e.has("WEBGL_multisampled_render_to_texture")?e.get("WEBGL_multisampled_render_to_texture"):null,d="undefined"!=typeof navigator&&/OculusBrowser/g.test(navigator.userAgent),A=new WeakMap;let v;const m=new WeakMap;let p=!1;try{p="undefined"!=typeof OffscreenCanvas&&null!==new OffscreenCanvas(1,1).getContext("2d")}catch(t){}function g(t,e){return p?new OffscreenCanvas(t,e):be("canvas")}function _(t,e,n,o){let i=1;if((t.width>o||t.height>o)&&(i=o/Math.max(t.width,t.height)),i<1||!0===e){if("undefined"!=typeof HTMLImageElement&&t instanceof HTMLImageElement||"undefined"!=typeof HTMLCanvasElement&&t instanceof HTMLCanvasElement||"undefined"!=typeof ImageBitmap&&t instanceof ImageBitmap){const o=e?fe:Math.floor,r=o(i*t.width),s=o(i*t.height);void 0===v&&(v=g(r,s));const a=n?g(r,s):v;a.width=r,a.height=s;return a.getContext("2d").drawImage(t,0,0,r,s),console.warn("v3d.WebGLRenderer: Texture has been resized from ("+t.width+"x"+t.height+") to ("+r+"x"+s+")."),a}return"data"in t&&console.warn("v3d.WebGLRenderer: Image in DataTexture is too big ("+t.width+"x"+t.height+")."),t}return t}function E(t){return ue(t.width)&&ue(t.height)}function C(t,e){return t.generateMipmaps&&e&&t.minFilter!==T&&t.minFilter!==N}function w(e){t.generateMipmap(e)}function x(n,o,i,r,s=!1){if(!1===a)return o;if(null!==n){if(void 0!==t[n])return t[n];console.warn("v3d.WebGLRenderer: Attempt to use non-existing WebGL internal format '"+n+"'")}let l=o;return 6403===o&&(5126===i&&(l=33326),5131===i&&(l=33325),5121===i&&(l=33321)),36244===o&&(5121===i&&(l=33330),5123===i&&(l=33332),5125===i&&(l=33334),5120===i&&(l=33329),5122===i&&(l=33331),5124===i&&(l=33333)),33319===o&&(5126===i&&(l=33328),5131===i&&(l=33327),5121===i&&(l=33323)),33320===o&&(5121===i&&(l=33336),5123===i&&(l=33338),5125===i&&(l=33340),5120===i&&(l=33335),5122===i&&(l=33337),5124===i&&(l=33339)),36248===o&&(5121===i&&(l=36221),5123===i&&(l=36215),5125===i&&(l=36209),5120===i&&(l=36239),5122===i&&(l=36233),5124===i&&(l=36227)),36249===o&&(5121===i&&(l=36220),5123===i&&(l=36214),5125===i&&(l=36208),5120===i&&(l=36238),5122===i&&(l=36232),5124===i&&(l=36226)),6407===o&&35902===i&&(l=35901),6408===o&&(5126===i&&(l=34836),5131===i&&(l=34842),5121===i&&(l=r===Ft&&!1===s?35907:32856),32819===i&&(l=32854),32820===i&&(l=32855)),33325!==l&&33326!==l&&33327!==l&&33328!==l&&34842!==l&&34836!==l||e.get("EXT_color_buffer_float"),l}function I(t,e,n){return!0===C(t,n)||t.isFramebufferTexture&&t.minFilter!==T&&t.minFilter!==N?Math.log2(Math.max(e.width,e.height))+1:void 0!==t.mipmaps&&t.mipmaps.length>0?t.mipmaps.length:t.isCompressedTexture&&Array.isArray(t.image)?e.mipmaps.length:1}function M(t){return t===T||t===B||t===L?9728:9729}function S(t){const e=t.target;e.removeEventListener("dispose",S),function(t){const e=o.get(t);if(void 0===e.oe)return;const n=t.source,i=m.get(n);if(i){const o=i[e.ie];o.usedTimes--,0===o.usedTimes&&z(t),0===Object.keys(i).length&&m.delete(n)}o.remove(t)}(e),e.isVideoTexture&&A.delete(e)}function U(e){const n=e.target;n.removeEventListener("dispose",U),function(e){const n=e.texture,i=o.get(e),r=o.get(n);void 0!==r.Qt&&(t.deleteTexture(r.Qt),s.memory.textures--);e.depthTexture&&e.depthTexture.dispose();if(e.isWebGLCubeRenderTarget)for(let e=0;e<6;e++)t.deleteFramebuffer(i.Ut[e]),i.Gt&&t.deleteRenderbuffer(i.Gt[e]);else{if(t.deleteFramebuffer(i.Ut),i.Gt&&t.deleteRenderbuffer(i.Gt),i.Vt&&t.deleteFramebuffer(i.Vt),i.re)for(let e=0;e<i.re.length;e++)i.re[e]&&t.deleteRenderbuffer(i.re[e]);i.Ft&&t.deleteRenderbuffer(i.Ft)}if(e.isWebGLMultipleRenderTargets)for(let e=0,i=n.length;e<i;e++){const i=o.get(n[e]);i.Qt&&(t.deleteTexture(i.Qt),s.memory.textures--),o.remove(n[e])}o.remove(n),o.remove(e)}(n),s.removeTextureSpec(n)}function z(e){const n=o.get(e);t.deleteTexture(n.Qt);const i=e.source;delete m.get(i)[n.ie],s.memory.textures--,s.removeTextureSpec(e)}let k=0;function K(t,e){const i=o.get(t);if(t.isVideoTexture&&function(t){const e=s.render.frame;A.get(t)!==e&&(A.set(t,e),t.update())}(t),!1===t.isRenderTargetTexture&&t.version>0&&i.se!==t.version){const n=t.image;if(null===n)console.warn("v3d.WebGLRenderer: Texture marked for update but no image data found.");else{if(!1!==n.complete)return void $(i,t,e);console.warn("v3d.WebGLRenderer: Texture marked for update but image is incomplete")}}n.bindTexture(3553,i.Qt,33984+e)}const j={[b]:10497,[y]:33071,[R]:33648},Z={[T]:9728,[B]:9984,[L]:9986,[N]:9729,[D]:9985,[P]:9987};function q(n,r,s){if(s?(t.texParameteri(n,10242,j[r.wrapS]),t.texParameteri(n,10243,j[r.wrapT]),32879!==n&&35866!==n||t.texParameteri(n,32882,j[r.wrapR]),t.texParameteri(n,10240,Z[r.magFilter]),t.texParameteri(n,10241,Z[r.minFilter])):(t.texParameteri(n,10242,33071),t.texParameteri(n,10243,33071),32879!==n&&35866!==n||t.texParameteri(n,32882,33071),r.wrapS===y&&r.wrapT===y||console.warn("v3d.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to v3d.ClampToEdgeWrapping."),t.texParameteri(n,10240,M(r.magFilter)),t.texParameteri(n,10241,M(r.minFilter)),r.minFilter!==T&&r.minFilter!==N&&console.warn("v3d.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to v3d.NearestFilter or v3d.LinearFilter.")),!0===e.has("EXT_texture_filter_anisotropic")){const s=e.get("EXT_texture_filter_anisotropic");if(r.magFilter===T)return;if(r.minFilter!==L&&r.minFilter!==P)return;if(r.type===G&&!1===e.has("OES_texture_float_linear"))return;if(!1===a&&r.type===Q&&!1===e.has("OES_texture_half_float_linear"))return;(r.anisotropy>1||o.get(r).ae)&&(t.texParameterf(n,s.TEXTURE_MAX_ANISOTROPY_EXT,Math.min(r.anisotropy,i.getMaxAnisotropy())),o.get(r).ae=r.anisotropy)}}function J(e,n){let o=!1;void 0===e.oe&&(e.oe=!0,n.addEventListener("dispose",S));const i=n.source;let r=m.get(i);void 0===r&&(r={},m.set(i,r));const a=function(t){const e=[];return e.push(t.wrapS),e.push(t.wrapT),e.push(t.wrapR||0),e.push(t.magFilter),e.push(t.minFilter),e.push(t.anisotropy),e.push(t.internalFormat),e.push(t.format),e.push(t.type),e.push(t.generateMipmaps),e.push(t.premultiplyAlpha),e.push(t.flipY),e.push(t.unpackAlignment),e.push(t.encoding),e.join()}(n);if(a!==e.ie){void 0===r[a]&&(r[a]={texture:t.createTexture(),usedTimes:0},s.memory.textures++,s.addTextureSpec(n),o=!0),r[a].usedTimes++;const i=r[e.ie];void 0!==i&&(r[e.ie].usedTimes--,0===i.usedTimes&&z(n)),e.ie=a,e.Qt=r[a].texture}return o}function $(e,i,s){let l=3553;(i.isDataArrayTexture||i.isCompressedArrayTexture)&&(l=35866),i.isData3DTexture&&(l=32879);const c=J(e,i),h=i.source;n.bindTexture(l,e.Qt,33984+s);const f=o.get(h);if(h.version!==f.se||!0===c){n.activeTexture(33984+s),t.pixelStorei(37440,i.flipY),t.pixelStorei(37441,i.premultiplyAlpha),t.pixelStorei(3317,i.unpackAlignment),t.pixelStorei(37443,0);const e=function(t){return!a&&(t.wrapS!==y||t.wrapT!==y||t.minFilter!==T&&t.minFilter!==N)}(i)&&!1===E(i.image);let o=_(i.image,e,!1,u);o=rt(i,o);const d=E(o)||a,A=r.convert(i.format,i.encoding);let v,m=r.convert(i.type),p=x(i.internalFormat,A,m,i.encoding,i.isVideoTexture);q(l,i,d);const g=i.mipmaps,M=a&&!0!==i.isVideoTexture,S=void 0===f.se||!0===c,b=I(i,o,d);if(i.isDepthTexture)p=6402,a?p=i.type===G?36012:i.type===V?33190:i.type===H?35056:33189:i.type===G&&console.error("WebGLRenderer: Floating point depth texture requires WebGL2."),i.format===Y&&6402===p&&i.type!==F&&i.type!==V&&(console.warn("v3d.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture."),i.type=V,m=r.convert(i.type)),i.format===X&&6402===p&&(p=34041,i.type!==H&&(console.warn("v3d.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture."),i.type=H,m=r.convert(i.type))),S&&(M?n.texStorage2D(3553,1,p,o.width,o.height):n.texImage2D(3553,0,p,o.width,o.height,0,A,m,null));else if(i.isDataTexture)if(g.length>0&&d){M&&S&&n.texStorage2D(3553,b,p,g[0].width,g[0].height);for(let t=0,e=g.length;t<e;t++)v=g[t],M?n.texSubImage2D(3553,t,0,0,v.width,v.height,A,m,v.data):n.texImage2D(3553,t,p,v.width,v.height,0,A,m,v.data);i.generateMipmaps=!1}else M?(S&&n.texStorage2D(3553,b,p,o.width,o.height),n.texSubImage2D(3553,0,0,0,o.width,o.height,A,m,o.data)):n.texImage2D(3553,0,p,o.width,o.height,0,A,m,o.data);else if(i.isCompressedTexture)if(i.isCompressedArrayTexture){M&&S&&n.texStorage3D(35866,b,p,g[0].width,g[0].height,o.depth);for(let t=0,e=g.length;t<e;t++)v=g[t],i.format!==W?null!==A?M?n.compressedTexSubImage3D(35866,t,0,0,0,v.width,v.height,o.depth,A,v.data,0,0):n.compressedTexImage3D(35866,t,p,v.width,v.height,o.depth,0,v.data,0,0):console.warn("v3d.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()"):M?n.texSubImage3D(35866,t,0,0,0,v.width,v.height,o.depth,A,m,v.data):n.texImage3D(35866,t,p,v.width,v.height,o.depth,0,A,m,v.data)}else{M&&S&&n.texStorage2D(3553,b,p,g[0].width,g[0].height);for(let t=0,e=g.length;t<e;t++)v=g[t],i.format!==W?null!==A?M?n.compressedTexSubImage2D(3553,t,0,0,v.width,v.height,A,v.data):n.compressedTexImage2D(3553,t,p,v.width,v.height,0,v.data):console.warn("v3d.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()"):M?n.texSubImage2D(3553,t,0,0,v.width,v.height,A,m,v.data):n.texImage2D(3553,t,p,v.width,v.height,0,A,m,v.data)}else if(i.isDataArrayTexture)M?(S&&n.texStorage3D(35866,b,p,o.width,o.height,o.depth),n.texSubImage3D(35866,0,0,0,0,o.width,o.height,o.depth,A,m,o.data)):n.texImage3D(35866,0,p,o.width,o.height,o.depth,0,A,m,o.data);else if(i.isData3DTexture)M?(S&&n.texStorage3D(32879,b,p,o.width,o.height,o.depth),n.texSubImage3D(32879,0,0,0,0,o.width,o.height,o.depth,A,m,o.data)):n.texImage3D(32879,0,p,o.width,o.height,o.depth,0,A,m,o.data);else if(i.isFramebufferTexture){if(S)if(M)n.texStorage2D(3553,b,p,o.width,o.height);else{let t=o.width,e=o.height;for(let o=0;o<b;o++)n.texImage2D(3553,o,p,t,e,0,A,m,null),t>>=1,e>>=1}}else if(g.length>0&&d){M&&S&&n.texStorage2D(3553,b,p,g[0].width,g[0].height);for(let t=0,e=g.length;t<e;t++)v=g[t],M?n.texSubImage2D(3553,t,0,0,A,m,v):n.texImage2D(3553,t,p,A,m,v);i.generateMipmaps=!1}else M?(S&&n.texStorage2D(3553,b,p,o.width,o.height),n.texSubImage2D(3553,0,0,0,A,m,o)):n.texImage2D(3553,0,p,A,m,o);C(i,d)&&w(l),f.se=h.version,i.onUpdate&&i.onUpdate(i)}e.se=i.version}function tt(e,i,s,a,l){const c=r.convert(s.format,s.encoding),u=r.convert(s.type),h=x(s.internalFormat,c,u,s.encoding);o.get(i).le||(32879===l||35866===l?n.texImage3D(l,0,h,i.width,i.height,i.depth,0,c,u,null):n.texImage2D(l,0,h,i.width,i.height,0,c,u,null)),n.bindFramebuffer(36160,e),it(i)?f.framebufferTexture2DMultisampleEXT(36160,a,l,o.get(s).Qt,0,ot(i)):(3553===l||l>=34069&&l<=34074)&&t.framebufferTexture2D(36160,a,l,o.get(s).Qt,0),n.bindFramebuffer(36160,null)}function et(e,n,o){if(t.bindRenderbuffer(36161,e),n.depthBuffer&&!n.stencilBuffer){let i=33189;if(a&&(i=33190),o||it(n)){const e=n.depthTexture;e&&e.isDepthTexture&&(e.type===G?i=36012:e.type===V&&(i=33190));const o=ot(n);it(n)?f.renderbufferStorageMultisampleEXT(36161,o,i,n.width,n.height):t.renderbufferStorageMultisample(36161,o,i,n.width,n.height)}else t.renderbufferStorage(36161,i,n.width,n.height);t.framebufferRenderbuffer(36160,36096,36161,e)}else if(n.depthBuffer&&n.stencilBuffer){const i=ot(n);o&&!1===it(n)?t.renderbufferStorageMultisample(36161,i,35056,n.width,n.height):it(n)?f.renderbufferStorageMultisampleEXT(36161,i,35056,n.width,n.height):t.renderbufferStorage(36161,34041,n.width,n.height),t.framebufferRenderbuffer(36160,33306,36161,e)}else{const e=!0===n.isWebGLMultipleRenderTargets?n.texture:[n.texture];for(let i=0;i<e.length;i++){const s=e[i],a=r.convert(s.format,s.encoding),l=r.convert(s.type),c=x(s.internalFormat,a,l,s.encoding),u=ot(n);o&&!1===it(n)?t.renderbufferStorageMultisample(36161,u,c,n.width,n.height):it(n)?f.renderbufferStorageMultisampleEXT(36161,u,c,n.width,n.height):t.renderbufferStorage(36161,c,n.width,n.height)}}t.bindRenderbuffer(36161,null)}function nt(e){const i=o.get(e),r=!0===e.isWebGLCubeRenderTarget;if(e.depthTexture&&!i.ce){if(r)throw new Error("target.depthTexture not supported in Cube render targets");!function(e,i){if(i&&i.isWebGLCubeRenderTarget)throw new Error("Depth Texture with cube render targets is not supported");if(n.bindFramebuffer(36160,e),!i.depthTexture||!i.depthTexture.isDepthTexture)throw new Error("renderTarget.depthTexture must be an instance of v3d.DepthTexture");o.get(i.depthTexture).Qt&&i.depthTexture.image.width===i.width&&i.depthTexture.image.height===i.height||(i.depthTexture.image.width=i.width,i.depthTexture.image.height=i.height,i.depthTexture.needsUpdate=!0),K(i.depthTexture,0);const r=o.get(i.depthTexture).Qt,s=ot(i);if(i.depthTexture.format===Y)it(i)?f.framebufferTexture2DMultisampleEXT(36160,36096,3553,r,0,s):t.framebufferTexture2D(36160,36096,3553,r,0);else{if(i.depthTexture.format!==X)throw new Error("Unknown depthTexture format");it(i)?f.framebufferTexture2DMultisampleEXT(36160,33306,3553,r,0,s):t.framebufferTexture2D(36160,33306,3553,r,0)}}(i.Ut,e)}else if(r){i.Gt=[];for(let o=0;o<6;o++)n.bindFramebuffer(36160,i.Ut[o]),i.Gt[o]=t.createRenderbuffer(),et(i.Gt[o],e,!1)}else n.bindFramebuffer(36160,i.Ut),i.Gt=t.createRenderbuffer(),et(i.Gt,e,!1);n.bindFramebuffer(36160,null)}function ot(t){return Math.min(h,t.samples)}function it(t){const n=o.get(t);return a&&t.samples>0&&!0===e.has("WEBGL_multisampled_render_to_texture")&&!1!==n.ue}function rt(t,n){const o=t.encoding,i=t.format,r=t.type;return!0===t.isCompressedTexture||!0===t.isVideoTexture||t.format===jt||o!==Ot&&(o===Ft?!1===a?!0===e.has("EXT_sRGB")&&i===W?(t.format=jt,t.minFilter=N,t.generateMipmaps=!1):n=nn.sRGBToLinear(n):i===W&&r===O||console.warn("v3d.WebGLTextures: sRGB encoded textures have to use RGBAFormat and UnsignedByteType. Perhaps you've set sRGB color space for an HDR image?"):console.error("v3d.WebGLTextures: Unsupported texture encoding:",o)),n}this.allocateTextureUnit=function(){const t=k;return t>=l&&console.warn("v3d.WebGLTextures: Trying to use "+t+" texture units while this GPU supports only "+l),k+=1,t},this.resetTextureUnits=function(){k=0},this.setTexture2D=K,this.setTexture2DArray=function(t,e){const i=o.get(t);t.version>0&&i.se!==t.version?$(i,t,e):n.bindTexture(35866,i.Qt,33984+e)},this.setTexture3D=function(t,e){const i=o.get(t);t.version>0&&i.se!==t.version?$(i,t,e):n.bindTexture(32879,i.Qt,33984+e)},this.setTextureCube=function(e,i){const s=o.get(e);e.version>0&&s.se!==e.version?function(e,i,s){if(6!==i.image.length)return;const l=J(e,i),u=i.source;n.bindTexture(34067,e.Qt,33984+s);const h=o.get(u);if(u.version!==h.se||!0===l){n.activeTexture(33984+s),t.pixelStorei(37440,i.flipY),t.pixelStorei(37441,i.premultiplyAlpha),t.pixelStorei(3317,i.unpackAlignment),t.pixelStorei(37443,0);const e=i.isCompressedTexture||i.image[0].isCompressedTexture,o=i.image[0]&&i.image[0].isDataTexture,f=[];for(let t=0;t<6;t++)f[t]=e||o?o?i.image[t].image:i.image[t]:_(i.image[t],!1,!0,c),f[t]=rt(i,f[t]);const d=f[0],A=E(d)||a,v=r.convert(i.format,i.encoding),m=r.convert(i.type),p=x(i.internalFormat,v,m,i.encoding),g=a&&!0!==i.isVideoTexture,M=void 0===h.se||!0===l;let S,b=I(i,d,A);if(q(34067,i,A),e){g&&M&&n.texStorage2D(34067,b,p,d.width,d.height);for(let t=0;t<6;t++){S=f[t].mipmaps;for(let e=0;e<S.length;e++){const o=S[e];i.format!==W?null!==v?g?n.compressedTexSubImage2D(34069+t,e,0,0,o.width,o.height,v,o.data):n.compressedTexImage2D(34069+t,e,p,o.width,o.height,0,o.data):console.warn("v3d.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()"):g?n.texSubImage2D(34069+t,e,0,0,o.width,o.height,v,m,o.data):n.texImage2D(34069+t,e,p,o.width,o.height,0,v,m,o.data)}}}else{S=i.mipmaps,g&&M&&(S.length>0&&b++,n.texStorage2D(34067,b,p,f[0].width,f[0].height));for(let t=0;t<6;t++)if(o){g?n.texSubImage2D(34069+t,0,0,0,f[t].width,f[t].height,v,m,f[t].data):n.texImage2D(34069+t,0,p,f[t].width,f[t].height,0,v,m,f[t].data);for(let e=0;e<S.length;e++){const o=S[e].image[t].image;g?n.texSubImage2D(34069+t,e+1,0,0,o.width,o.height,v,m,o.data):n.texImage2D(34069+t,e+1,p,o.width,o.height,0,v,m,o.data)}}else{g?n.texSubImage2D(34069+t,0,0,0,v,m,f[t]):n.texImage2D(34069+t,0,p,v,m,f[t]);for(let e=0;e<S.length;e++){const o=S[e];g?n.texSubImage2D(34069+t,e+1,0,0,v,m,o.image[t]):n.texImage2D(34069+t,e+1,p,v,m,o.image[t])}}}C(i,A)&&w(34067),h.se=u.version,i.onUpdate&&i.onUpdate(i)}e.se=i.version}(s,e,i):n.bindTexture(34067,s.Qt,33984+i)},this.rebindTextures=function(t,e,n){const i=o.get(t);void 0!==e&&tt(i.Ut,t,t.texture,36064,3553),void 0!==n&&nt(t)},this.setupRenderTarget=function(e){const l=e.texture,c=o.get(e),u=o.get(l);e.addEventListener("dispose",U),!0!==e.isWebGLMultipleRenderTargets&&(void 0===u.Qt&&(u.Qt=t.createTexture()),u.se=l.version,s.memory.textures++),s.addTextureSpec(e);const h=!0===e.isWebGLCubeRenderTarget,f=!0===e.isWebGLMultipleRenderTargets,d=E(e)||a;if(h){c.Ut=[];for(let e=0;e<6;e++)c.Ut[e]=t.createFramebuffer()}else{if(c.Ut=t.createFramebuffer(),f)if(i.isWebGL2){const n=e.texture;for(let e=0,i=n.length;e<i;e++){const i=o.get(n[e]);void 0===i.Qt&&(i.Qt=t.createTexture(),s.memory.textures++)}}else console.warn("v3d.WebGLRenderer: WebGLMultipleRenderTargets can only be used with WebGL2.");if(a&&e.samples>0&&!1===it(e)){const o=f?l:[l];c.Vt=t.createFramebuffer(),c.re=[],n.bindFramebuffer(36160,c.Vt);for(let n=0;n<o.length;n++){const i=o[n];c.re[n]=t.createRenderbuffer(),t.bindRenderbuffer(36161,c.re[n]);const s=r.convert(i.format,i.encoding),a=r.convert(i.type),l=x(i.internalFormat,s,a,i.encoding,!0===e.isXRRenderTarget),u=ot(e);t.renderbufferStorageMultisample(36161,u,l,e.width,e.height),t.framebufferRenderbuffer(36160,36064+n,36161,c.re[n])}t.bindRenderbuffer(36161,null),e.depthBuffer&&(c.Ft=t.createRenderbuffer(),et(c.Ft,e,!0)),n.bindFramebuffer(36160,null)}}if(h){n.bindTexture(34067,u.Qt),q(34067,l,d);for(let t=0;t<6;t++)tt(c.Ut[t],e,l,36064,34069+t);C(l,d)&&w(34067),n.unbindTexture()}else if(f){const t=e.texture;for(let i=0,r=t.length;i<r;i++){const r=t[i],s=o.get(r);n.bindTexture(3553,s.Qt),q(3553,r,d),tt(c.Ut,e,r,36064+i,3553),C(r,d)&&w(3553)}n.unbindTexture()}else{let t=3553;(e.isWebGL3DRenderTarget||e.isWebGLArrayRenderTarget)&&(a?t=e.isWebGL3DRenderTarget?32879:35866:console.error("v3d.WebGLTextures: v3d.Data3DTexture and v3d.DataArrayTexture only supported with WebGL2.")),n.bindTexture(t,u.Qt),q(t,l,d),tt(c.Ut,e,l,36064,t),C(l,d)&&w(t),n.unbindTexture()}e.depthBuffer&&nt(e)},this.updateRenderTargetMipmap=function(t){const e=E(t)||a,i=!0===t.isWebGLMultipleRenderTargets?t.texture:[t.texture];for(let r=0,s=i.length;r<s;r++){const s=i[r];if(C(s,e)){const e=t.isWebGLCubeRenderTarget?34067:3553,i=o.get(s).Qt;n.bindTexture(e,i),w(e),n.unbindTexture()}}},this.updateMultisampleRenderTarget=function(e){if(a&&e.samples>0&&!1===it(e)){const i=e.isWebGLMultipleRenderTargets?e.texture:[e.texture],r=e.width,s=e.height;let a=16384;const l=[],c=e.stencilBuffer?33306:36096,u=o.get(e),h=!0===e.isWebGLMultipleRenderTargets;if(h)for(let e=0;e<i.length;e++)n.bindFramebuffer(36160,u.Vt),t.framebufferRenderbuffer(36160,36064+e,36161,null),n.bindFramebuffer(36160,u.Ut),t.framebufferTexture2D(36009,36064+e,3553,null,0);n.bindFramebuffer(36008,u.Vt),n.bindFramebuffer(36009,u.Ut);for(let n=0;n<i.length;n++){l.push(36064+n),e.depthBuffer&&l.push(c);const f=void 0!==u.he&&u.he;if(!1===f&&(e.depthBuffer&&(a|=256),e.stencilBuffer&&(a|=1024)),h&&t.framebufferRenderbuffer(36008,36064,36161,u.re[n]),!0===f&&(t.invalidateFramebuffer(36008,[c]),t.invalidateFramebuffer(36009,[c])),h){const e=o.get(i[n]).Qt;t.framebufferTexture2D(36009,36064,3553,e,0)}t.blitFramebuffer(0,0,r,s,0,0,r,s,a,9728),d&&t.invalidateFramebuffer(36008,l)}if(n.bindFramebuffer(36008,null),n.bindFramebuffer(36009,null),h)for(let e=0;e<i.length;e++){n.bindFramebuffer(36160,u.Vt),t.framebufferRenderbuffer(36160,36064+e,36161,u.re[e]);const r=o.get(i[e]).Qt;n.bindFramebuffer(36160,u.Ut),t.framebufferTexture2D(36009,36064+e,3553,r,0)}n.bindFramebuffer(36009,u.Vt)}},this.setupDepthRenderbuffer=nt,this.setupFrameBufferTexture=tt,this.useMultisampledRTT=it}function Sa(t,e,n,o){let i={},r={},s=[];const a=n.isWebGL2?t.getParameter(35375):0;function l(t,e,n){const o=t.value;if(void 0===n[e]){if("number"==typeof o)n[e]=o;else{const t=Array.isArray(o)?o:[o],i=[];for(let e=0;e<t.length;e++)i.push(t[e].clone());n[e]=i}return!0}if("number"==typeof o){if(n[e]!==o)return n[e]=o,!0}else{const t=Array.isArray(n[e])?n[e]:[n[e]],i=Array.isArray(o)?o:[o];for(let e=0;e<t.length;e++){const n=t[e];if(!1===n.equals(i[e]))return n.copy(i[e]),!0}}return!1}function c(t){const e={boundary:0,storage:0};return"number"==typeof t?(e.boundary=4,e.storage=4):t.isVector2?(e.boundary=8,e.storage=8):t.isVector3||t.isColor?(e.boundary=16,e.storage=12):t.isVector4?(e.boundary=16,e.storage=16):t.isMatrix3?(e.boundary=48,e.storage=48):t.isMatrix4?(e.boundary=64,e.storage=64):t.isTexture?console.warn("v3d.WebGLRenderer: Texture samplers can not be part of an uniforms group."):console.warn("v3d.WebGLRenderer: Unsupported uniform value type.",t),e}function u(e){const n=e.target;n.removeEventListener("dispose",u);const o=s.indexOf(n.ne);s.splice(o,1),t.deleteBuffer(i[n.id]),delete i[n.id],delete r[n.id]}return{bind:function(t,e){const n=e.program;o.uniformBlockBinding(t,n)},update:function(n,h){let f=i[n.id];void 0===f&&(!function(t){const e=t.uniforms;let n=0;const o=16;let i=0;for(let t=0,r=e.length;t<r;t++){const r=e[t],s={boundary:0,storage:0},a=Array.isArray(r.value)?r.value:[r.value];for(let t=0,e=a.length;t<e;t++){const e=c(a[t]);s.boundary+=e.boundary,s.storage+=e.storage}if(r.fe=new Float32Array(s.storage/Float32Array.BYTES_PER_ELEMENT),r.de=n,t>0){i=n%o;0!==i&&o-i-s.boundary<0&&(n+=o-i,r.de=n)}n+=s.storage}i=n%o,i>0&&(n+=o-i);t.Ae=n,t.ve={}}(n),f=function(e){const n=function(){for(let t=0;t<a;t++)if(-1===s.indexOf(t))return s.push(t),t;return console.error("v3d.WebGLRenderer: Maximum number of simultaneously usable uniforms groups reached."),0}();e.ne=n;const o=t.createBuffer(),i=e.Ae,r=e.usage;return t.bindBuffer(35345,o),t.bufferData(35345,i,r),t.bindBuffer(35345,null),t.bindBufferBase(35345,n,o),o}(n),i[n.id]=f,n.addEventListener("dispose",u));const d=h.program;o.updateUBOMapping(n,d);const A=e.render.frame;r[n.id]!==A&&(!function(e){const n=i[e.id],o=e.uniforms,r=e.ve;t.bindBuffer(35345,n);for(let e=0,n=o.length;e<n;e++){const n=o[e];if(!0===l(n,e,r)){const e=n.de,o=Array.isArray(n.value)?n.value:[n.value];let i=0;for(let r=0;r<o.length;r++){const s=o[r],a=c(s);"number"==typeof s?(n.fe[0]=s,t.bufferSubData(35345,e+i,n.fe)):s.isMatrix3?(n.fe[0]=s.elements[0],n.fe[1]=s.elements[1],n.fe[2]=s.elements[2],n.fe[3]=s.elements[0],n.fe[4]=s.elements[3],n.fe[5]=s.elements[4],n.fe[6]=s.elements[5],n.fe[7]=s.elements[0],n.fe[8]=s.elements[6],n.fe[9]=s.elements[7],n.fe[10]=s.elements[8],n.fe[11]=s.elements[0]):(s.toArray(n.fe,i),i+=a.storage/Float32Array.BYTES_PER_ELEMENT)}t.bufferSubData(35345,e,n.fe)}}t.bindBuffer(35345,null)}(n),r[n.id]=A)},dispose:function(){for(const e in i)t.deleteBuffer(i[e]);s=[],i={},r={}}}}function ba(t,e,n){const o=n.isWebGL2;return{convert:function(n,i=null){let r;if(n===O)return 5121;if(n===z)return 32819;if(n===k)return 32820;if(1010===n)return 5120;if(1011===n)return 5122;if(n===F)return 5123;if(n===U)return 5124;if(n===V)return 5125;if(n===G)return 5126;if(n===Q)return o?5131:(r=e.get("OES_texture_half_float"),null!==r?r.HALF_FLOAT_OES:null);if(1021===n)return 6406;if(n===W)return 6408;if(1024===n)return 6409;if(1025===n)return 6410;if(n===Y)return 6402;if(n===X)return 34041;if(n===jt)return r=e.get("EXT_sRGB"),null!==r?r.SRGB_ALPHA_EXT:null;if(n===K)return 6403;if(n===j)return 36244;if(n===Z)return 33319;if(n===q)return 33320;if(n===J)return 36249;if(n===$||n===tt||n===et||n===nt)if(i===Ft){if(r=e.get("WEBGL_compressed_texture_s3tc_srgb"),null===r)return null;if(n===$)return r.COMPRESSED_SRGB_S3TC_DXT1_EXT;if(n===tt)return r.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT;if(n===et)return r.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT;if(n===nt)return r.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT}else{if(r=e.get("WEBGL_compressed_texture_s3tc"),null===r)return null;if(n===$)return r.COMPRESSED_RGB_S3TC_DXT1_EXT;if(n===tt)return r.COMPRESSED_RGBA_S3TC_DXT1_EXT;if(n===et)return r.COMPRESSED_RGBA_S3TC_DXT3_EXT;if(n===nt)return r.COMPRESSED_RGBA_S3TC_DXT5_EXT}if(n===ot||n===it||n===rt||n===st){if(r=e.get("WEBGL_compressed_texture_pvrtc"),null===r)return null;if(n===ot)return r.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;if(n===it)return r.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;if(n===rt)return r.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;if(n===st)return r.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG}if(n===at)return r=e.get("WEBGL_compressed_texture_etc1"),null!==r?r.COMPRESSED_RGB_ETC1_WEBGL:null;if(n===lt||n===ct){if(r=e.get("WEBGL_compressed_texture_etc"),null===r)return null;if(n===lt)return i===Ft?r.COMPRESSED_SRGB8_ETC2:r.COMPRESSED_RGB8_ETC2;if(n===ct)return i===Ft?r.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC:r.COMPRESSED_RGBA8_ETC2_EAC}if(n===ut||n===ht||n===ft||n===dt||n===At||n===vt||n===mt||n===pt||n===gt||n===_t||n===Et||n===Ct||n===wt||n===xt){if(r=e.get("WEBGL_compressed_texture_astc"),null===r)return null;if(n===ut)return i===Ft?r.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR:r.COMPRESSED_RGBA_ASTC_4x4_KHR;if(n===ht)return i===Ft?r.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR:r.COMPRESSED_RGBA_ASTC_5x4_KHR;if(n===ft)return i===Ft?r.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR:r.COMPRESSED_RGBA_ASTC_5x5_KHR;if(n===dt)return i===Ft?r.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR:r.COMPRESSED_RGBA_ASTC_6x5_KHR;if(n===At)return i===Ft?r.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR:r.COMPRESSED_RGBA_ASTC_6x6_KHR;if(n===vt)return i===Ft?r.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR:r.COMPRESSED_RGBA_ASTC_8x5_KHR;if(n===mt)return i===Ft?r.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR:r.COMPRESSED_RGBA_ASTC_8x6_KHR;if(n===pt)return i===Ft?r.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR:r.COMPRESSED_RGBA_ASTC_8x8_KHR;if(n===gt)return i===Ft?r.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR:r.COMPRESSED_RGBA_ASTC_10x5_KHR;if(n===_t)return i===Ft?r.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR:r.COMPRESSED_RGBA_ASTC_10x6_KHR;if(n===Et)return i===Ft?r.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR:r.COMPRESSED_RGBA_ASTC_10x8_KHR;if(n===Ct)return i===Ft?r.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR:r.COMPRESSED_RGBA_ASTC_10x10_KHR;if(n===wt)return i===Ft?r.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR:r.COMPRESSED_RGBA_ASTC_12x10_KHR;if(n===xt)return i===Ft?r.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR:r.COMPRESSED_RGBA_ASTC_12x12_KHR}if(n===It){if(r=e.get("EXT_texture_compression_bptc"),null===r)return null;if(n===It)return i===Ft?r.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT:r.COMPRESSED_RGBA_BPTC_UNORM_EXT}return n===H?o?34042:(r=e.get("WEBGL_depth_texture"),null!==r?r.UNSIGNED_INT_24_8_WEBGL:null):void 0!==t[n]?t[n]:null}}}class ya extends Ei{constructor(t=[]){super(),this.isArrayCamera=!0,this.cameras=t}}class Ra extends mo{constructor(){super(),this.isGroup=!0,this.type="Group"}getWorldDirection(t){this.updateWorldMatrix(!0,!1);const e=this.matrixWorld.elements;return t.set(e[8],e[9],e[10]).normalize()}}const Ta={type:"move"};class Ba{constructor(){this.me=null,this.pe=null,this.ge=null}getHandSpace(){return null===this.ge&&(this.ge=new Ra,this.ge.matrixAutoUpdate=!1,this.ge.visible=!1,this.ge.joints={},this.ge.inputState={pinching:!1}),this.ge}getTargetRaySpace(t){return null===this.me&&(this.me=new Ra,this.me.matrixAutoUpdate=!1,this.me.visible=!1,this.me.hasLinearVelocity=!1,this.me.linearVelocity=new An,this.me.hasAngularVelocity=!1,this.me.angularVelocity=new An,this.me.name="XR_CONTROLLER_"+String(t)),this.me}getGripSpace(){return null===this.pe&&(this.pe=new Ra,this.pe.matrixAutoUpdate=!1,this.pe.visible=!1,this.pe.hasLinearVelocity=!1,this.pe.linearVelocity=new An,this.pe.hasAngularVelocity=!1,this.pe.angularVelocity=new An),this.pe}dispatchEvent(t){return null!==this.me&&this.me.dispatchEvent(t),null!==this.pe&&this.pe.dispatchEvent(t),null!==this.ge&&this.ge.dispatchEvent(t),this}connect(t){if(t&&t.hand){const e=this.ge;if(e)for(const n of t.hand.values())this._e(e,n)}return this.dispatchEvent({type:"connected",data:t}),this}disconnect(t){return this.dispatchEvent({type:"disconnected",data:t}),null!==this.me&&(this.me.visible=!1),null!==this.pe&&(this.pe.visible=!1),null!==this.ge&&(this.ge.visible=!1),this}update(t,e,n){let o=null,i=null,r=null;const s=this.me,a=this.pe,l=this.ge;if(t&&"visible-blurred"!==e.session.visibilityState){if(l&&t.hand){r=!0;for(const o of t.hand.values()){const t=e.getJointPose(o,n),i=this._e(l,o);null!==t&&(i.matrix.fromArray(t.transform.matrix),i.matrix.decompose(i.position,i.rotation,i.scale),i.jointRadius=t.radius),i.visible=null!==t}const o=l.joints["index-finger-tip"],i=l.joints["thumb-tip"],s=o.position.distanceTo(i.position),a=.02,c=.005;l.inputState.pinching&&s>a+c?(l.inputState.pinching=!1,this.dispatchEvent({type:"pinchend",handedness:t.handedness,target:this})):!l.inputState.pinching&&s<=a-c&&(l.inputState.pinching=!0,this.dispatchEvent({type:"pinchstart",handedness:t.handedness,target:this}))}else null!==a&&t.gripSpace&&(i=e.getPose(t.gripSpace,n),null!==i&&(a.matrix.fromArray(i.transform.matrix),a.matrix.decompose(a.position,a.rotation,a.scale),i.linearVelocity?(a.hasLinearVelocity=!0,a.linearVelocity.copy(i.linearVelocity)):a.hasLinearVelocity=!1,i.angularVelocity?(a.hasAngularVelocity=!0,a.angularVelocity.copy(i.angularVelocity)):a.hasAngularVelocity=!1));null!==s&&(o=e.getPose(t.targetRaySpace,n),null===o&&null!==i&&(o=i),null!==o&&(s.matrix.fromArray(o.transform.matrix),s.matrix.decompose(s.position,s.rotation,s.scale),o.linearVelocity?(s.hasLinearVelocity=!0,s.linearVelocity.copy(o.linearVelocity)):s.hasLinearVelocity=!1,o.angularVelocity?(s.hasAngularVelocity=!0,s.angularVelocity.copy(o.angularVelocity)):s.hasAngularVelocity=!1,this.dispatchEvent(Ta)))}return null!==s&&(s.visible=null!==o),null!==a&&(a.visible=null!==i),null!==l&&(l.visible=null!==r),this}_e(t,e){if(void 0===t.joints[e.jointName]){const n=new Ra;n.matrixAutoUpdate=!1,n.visible=!1,t.joints[e.jointName]=n,t.add(n)}return t.joints[e.jointName]}}class La{constructor(t,e,n=0,o=1/0){this.ray=new kn(t,e),this.near=n,this.far=o,this.camera=null,this.layers=new eo,this.params={Mesh:{omitGeometry:!1},Line:{threshold:.1},LOD:{},Points:{threshold:.1},Sprite:{},checkVisibility:!0},this.layers.enable(3),this.layers.enable(4),this.layers.enable(5),this.layers.enable(6),this.layers.enable(7)}set(t,e){this.ray.set(t,e)}setFromCamera(t,e){e.isPerspectiveCamera?(this.ray.origin.setFromMatrixPosition(e.matrixWorld),this.ray.direction.set(t.x,t.y,.5).unproject(e).sub(this.ray.origin).normalize(),this.camera=e):e.isOrthographicCamera?(this.ray.origin.set(t.x,t.y,(e.near+e.far)/(e.near-e.far)).unproject(e),this.ray.direction.set(0,0,-1).transformDirection(e.matrixWorld),this.camera=e):console.error("v3d.Raycaster: Unsupported camera type: "+e.type)}intersectObject(t,e=!0,n=[]){return Da(t,this,n,e,this.params.checkVisibility),n.sort(Na),n}intersectObjects(t,e=!0,n=[]){for(let o=0,i=t.length;o<i;o++)Da(t[o],this,n,e,this.params.checkVisibility);return n.sort(Na),n}}function Na(t,e){return t.distance-e.distance}function Da(t,e,n,o,i){if(!(i&&(!1===t.visible||t.isMesh&&t.isMaterialGeneratedMesh&&t.parent&&!t.parent.visible)||(t.layers.test(e.layers)&&t.raycast(e,n),!0!==o))){const o=t.children;for(let t=0,r=o.length;t<r;t++)Da(o[t],e,n,!0,i)}}class Pa extends Zt{constructor(t,e){super();const n=this;let o=null,i=1,r=null,s="local-floor",a=null,l=null,c=null,u=null,h=null,f=null;const d=e.getContextAttributes();let A=null,v=null;const m=[],p=[],g=new Set,_=new Map,E=new we;let C=null;const w=new Ei;w.layers.enable(1),w.viewport=new ln;const x=new Ei;x.layers.enable(2),x.viewport=new ln;const I=[w,x],M=new ya;M.layers.enable(1),M.layers.enable(2),M.matrixAutoUpdate=!1;let S=null,b=null,y=null,R=null,T=null,B=new Hn;const L=new An,N=new An,D=new dn;function P(t){const e=p.indexOf(t.inputSource);if(-1===e)return;const n=m[e];void 0!==n&&n.dispatchEvent({type:t.type,data:t.inputSource})}function F(){o.removeEventListener("select",P),o.removeEventListener("selectstart",P),o.removeEventListener("selectend",P),o.removeEventListener("squeeze",P),o.removeEventListener("squeezestart",P),o.removeEventListener("squeezeend",P),o.removeEventListener("end",F),o.removeEventListener("inputsourceschange",U);for(let t=0;t<m.length;t++){const e=p[t];null!==e&&(p[t]=null,m[t].disconnect(e))}S=null,b=null,t.setRenderTarget(A),h=null,u=null,c=null,o=null,v=null,y=null,K.stop(),n.isPresenting=!1,t.setPixelRatio(C),t.setSize(E.width,E.height,!1),n.dispatchEvent({type:"sessionend"})}function U(t){for(let e=0;e<t.removed.length;e++){const n=t.removed[e],o=p.indexOf(n);o>=0&&(p[o]=null,m[o].disconnect(n))}for(let e=0;e<t.added.length;e++){const n=t.added[e];let o=p.indexOf(n);if(-1===o){for(let t=0;t<m.length;t++){if(t>=p.length){p.push(n),o=t;break}if(null===p[t]){p[t]=n,o=t;break}}if(-1===o)break}const i=m[o];i&&i.connect(n)}}this.cameraAutoUpdate=!0,this.enabled=!1,this.isPresenting=!1,this.getController=function(t){let e=m[t];return void 0===e&&(e=new Ba,m[t]=e),e.getTargetRaySpace(t)},this.getControllerGrip=function(t){let e=m[t];return void 0===e&&(e=new Ba,m[t]=e),e.getGripSpace()},this.getHand=function(t){let e=m[t];return void 0===e&&(e=new Ba,m[t]=e),e.getHandSpace()},this.setFramebufferScaleFactor=function(t){i=t,!0===n.isPresenting&&console.warn("v3d.WebXRManager: Cannot change framebuffer scale while presenting.")},this.setReferenceSpaceType=function(t){s=t,!0===n.isPresenting&&console.warn("v3d.WebXRManager: Cannot change reference space type while presenting.")},this.getReferenceSpace=function(){return a||r},this.setReferenceSpace=function(t){a=t},this.getBaseLayer=function(){return null!==u?u:h},this.getBinding=function(){return c},this.getFrame=function(){return f},this.getSession=function(){return o},this.setSession=async function(l){if(o=l,null!==o){if(A=t.getRenderTarget(),o.addEventListener("select",P),o.addEventListener("selectstart",P),o.addEventListener("selectend",P),o.addEventListener("squeeze",P),o.addEventListener("squeezestart",P),o.addEventListener("squeezeend",P),o.addEventListener("end",F),o.addEventListener("inputsourceschange",U),!0!==d.xrCompatible&&await e.makeXRCompatible(),C=t.getPixelRatio(),t.getSize(E),void 0===o.renderState.layers||!1===t.capabilities.isWebGL2){const n={antialias:void 0!==o.renderState.layers||d.antialias,alpha:d.alpha,depth:d.depth,stencil:d.stencil,framebufferScaleFactor:i};h=new XRWebGLLayer(o,e,n),o.updateRenderState({baseLayer:h}),t.setPixelRatio(1),t.setSize(h.framebufferWidth,h.framebufferHeight,!1),v=new cn(h.framebufferWidth,h.framebufferHeight,{format:W,type:O,encoding:t.outputEncoding,stencilBuffer:d.stencil})}else{let n=null,r=null,s=null;d.depth&&(s=d.stencil?35056:33190,n=d.stencil?X:Y,r=d.stencil?H:V);const a={colorFormat:32856,depthFormat:s,scaleFactor:i};c=new XRWebGLBinding(o,e),u=c.createProjectionLayer(a),o.updateRenderState({layers:[u]}),t.setPixelRatio(1),t.setSize(u.textureWidth,u.textureHeight,!1),v=new cn(u.textureWidth,u.textureHeight,{format:W,type:O,depthTexture:new Er(u.textureWidth,u.textureHeight,r,void 0,void 0,void 0,void 0,void 0,void 0,n),stencilBuffer:d.stencil,encoding:t.outputEncoding,samples:d.antialias?4:0});t.properties.get(v).he=u.ignoreDepthValues}v.isXRRenderTarget=!0,this.setFoveation(1),a=null,r=await o.requestReferenceSpace(s),K.setContext(o),K.start(),n.isPresenting=!0,n.dispatchEvent({type:"sessionstart"})}};const G=new An,Q=new An;function z(t,e){if(null===e)t.matrixWorld.copy(t.matrix),B.identity(),a=null;else{t.matrixWorld.copy(t.matrix),B.copy(e.matrixWorld).invert().decompose(L,D,N);var n=new XRRigidTransform({x:L.x,y:L.y,z:L.z},{x:D.x,y:D.y,z:D.z,w:D.w});a=r.getOffsetReferenceSpace(n)}t.matrixWorldInverse.copy(t.matrixWorld).invert()}this.updateCamera=function(t){if(null===o)return;M.near=x.near=w.near=t.near,M.far=x.far=w.far=t.far,S===M.near&&b===M.far||(o.updateRenderState({depthNear:M.near,depthFar:M.far}),S=M.near,b=M.far);const e=t.parent,n=M.cameras;z(M,e);for(let t=0;t<n.length;t++)z(n[t],e);M.matrixWorld.decompose(M.position,M.quaternion,M.scale),t.matrixWorld.copy(M.matrixWorld),null===e?t.matrix.copy(t.matrixWorld):(t.matrix.copy(e.matrixWorld).invert(),t.matrix.multiply(t.matrixWorld)),t.matrix.decompose(t.position,t.quaternion,t.scale);const i=t.children;for(let t=0,e=i.length;t<e;t++)i[t].updateWorldMatrix(!1,!0);2===n.length?function(t,e,n){G.setFromMatrixPosition(e.matrixWorld),Q.setFromMatrixPosition(n.matrixWorld);const o=G.distanceTo(Q),i=e.projectionMatrix.elements,r=n.projectionMatrix.elements,s=i[14]/(i[10]-1),a=i[14]/(i[10]+1),l=(i[9]+1)/i[5],c=(i[9]-1)/i[5],u=(i[8]-1)/i[0],h=(r[8]+1)/r[0],f=s*u,d=s*h,A=o/(-u+h),v=A*-u;e.matrixWorld.decompose(t.position,t.quaternion,t.scale),t.translateX(v),t.translateZ(A),t.matrixWorld.compose(t.position,t.quaternion,t.scale),t.matrixWorldInverse.copy(t.matrixWorld).invert();const m=s+A,p=a+A,g=f-v,_=d+(o-v),E=l*a/p*m,C=c*a/p*m;t.projectionMatrix.makePerspective(g,_,E,C,m,p)}(M,w,x):M.projectionMatrix.copy(w.projectionMatrix);const r=M.projectionMatrix.elements;M.fov=ce(2*Math.atan(1/r[5])),M.aspect=r[5]/r[0],M.projectionMatrixInverse.copy(M.projectionMatrix).invert()},this.getCamera=function(){return M},this.getFoveation=function(){return null!==u?u.fixedFoveation:null!==h?h.fixedFoveation:void 0},this.setFoveation=function(t){null!==u&&(u.fixedFoveation=t),null!==h&&void 0!==h.fixedFoveation&&(h.fixedFoveation=t)},this.getPlanes=function(){return g};let k=null;const K=new Di;function j(t){if(y){const e=t.getHitTestResults(y);if(e.length){const t=e[0].getPose(n.getReferenceSpace()),o=(new Hn).fromArray(t.transform.matrix),i=new An;i.setFromMatrixPosition(o);const r=new An(0,1,0);r.applyNormalMatrix((new xe).setFromMatrix4(o)),R(i,r)}else T()}}K.setAnimationLoop(function(e,o){if(l=o.getViewerPose(a||r),f=o,null!==l){const e=l.views;null!==h&&(t.setRenderTargetFramebuffer(v,h.framebuffer),t.setRenderTarget(v));let n=!1;e.length!==M.cameras.length&&(M.cameras.length=0,n=!0);for(let o=0;o<e.length;o++){const i=e[o];let r=null;if(null!==h)r=h.getViewport(i);else{const e=c.getViewSubImage(u,i);r=e.viewport,0===o&&(t.setRenderTargetTextures(v,e.colorTexture,u.ignoreDepthValues?void 0:e.depthStencilTexture),t.setRenderTarget(v))}let s=I[o];void 0===s&&(s=new Ei,s.layers.enable(o),s.viewport=new ln,I[o]=s),s.matrix.fromArray(i.transform.matrix),s.projectionMatrix.fromArray(i.projectionMatrix),s.viewport.set(r.x,r.y,r.width,r.height),0===o&&M.matrix.copy(s.matrix),!0===n&&M.cameras.push(s)}}for(let t=0;t<m.length;t++){const e=p[t],n=m[t];null!==e&&void 0!==n&&n.update(e,o,a||r),j(o)}if(k&&k(e,o),o.detectedPlanes){n.dispatchEvent({type:"planesdetected",data:o.detectedPlanes});let t=null;for(const e of g)o.detectedPlanes.has(e)||(null===t&&(t=[]),t.push(e));if(null!==t)for(const e of t)g.delete(e),_.delete(e),n.dispatchEvent({type:"planeremoved",data:e});for(const t of o.detectedPlanes)if(g.has(t)){const e=_.get(t);t.lastChangedTime>e&&(_.set(t,t.lastChangedTime),n.dispatchEvent({type:"planechanged",data:t}))}else g.add(t),_.set(t,o.lastChangedTime),n.dispatchEvent({type:"planeadded",data:t})}f=null}),this.setAnimationLoop=function(t){k=t},this.dispose=function(){},this.arHitTest=function(t,e,n,i){if(!o||!XRSession.prototype.requestHitTestSource)return;R=n||function(){},T=i||function(){},this.raycaster=this.raycaster||new La,this.raycaster.setFromCamera({x:t,y:e},I[0]);const r=this.raycaster.ray;new XRRay(r.origin,r.direction),o.requestReferenceSpace("viewer").then(function(t){const e={space:t};o.requestHitTestSource(e).then(function(t){y=t})})}}}function Oa(t={}){this.isWebGLRenderer=!0;const e=void 0!==t.canvas?t.canvas:function(){const t=be("canvas");return t.style.display="block",t}(),o=void 0!==t.context?t.context:null,i=void 0===t.depth||t.depth,s=void 0===t.stencil||t.stencil,a=void 0!==t.antialias&&t.antialias,l=void 0===t.premultipliedAlpha||t.premultipliedAlpha,c=void 0!==t.preserveDrawingBuffer&&t.preserveDrawingBuffer,u=void 0!==t.powerPreference?t.powerPreference:"default",h=void 0!==t.failIfMajorPerformanceCaveat&&t.failIfMajorPerformanceCaveat;let f;f=null!==o?o.getContextAttributes().alpha:void 0!==t.alpha&&t.alpha;const d=new Uint32Array(4),A=new Int32Array(4);let v=null,m=null;const p=[],g=[];this.domElement=e,this.debug={checkShaderErrors:!0,disableCompiledShaderCache:!1,random:Math.random()},this.autoClear=!0,this.autoClearColor=!0,this.autoClearDepth=!0,this.autoClearStencil=!0,this.sortObjects=!0,this.clippingPlanes=[],this.localClippingEnabled=!1,this.outputEncoding=Ot,this.unitsScaleFactor=1,this.toneMapping=0,this.toneMappingLook=0,this.toneMappingExposure=1,this.gtaoMap=null,this.gtaoMapEnabled=!1,this.compatSettings={gtaoDisableBkgFix:!1};const _=this;let E=!1,C=0,w=0,x=null,I=-1,M=null;const S=new ln,b=new ln;let y=null,R=e.width,T=e.height,B=1,L=null,N=null;const D=new ln(0,0,R,T),P=new ln(0,0,R,T);let U=!1;const Y=new Li;let X=!1,K=!1;const Z=new Hn,$=new we,tt=new An,et=new Ni,nt=new Hn,ot=new Hn,it=new ln,rt=new Hn;new pn;let st=!1;function at(){return null===x?B:1}this.oitRenderer=new Rr(new we(R,T));let lt,ct,ut,ht,ft,dt,At,vt,mt,pt,gt,_t,Et,Ct,wt,xt,It,Mt,St,bt,yt,Rt,Tt,Bt,Lt=o;function Nt(t,n){for(let o=0;o<t.length;o++){const i=t[o],r=e.getContext(i,n);if(null!==r)return r}return null}try{const t={alpha:!0,depth:i,stencil:s,antialias:a,premultipliedAlpha:l,preserveDrawingBuffer:c,powerPreference:u,xrCompatible:!Mi.checkSafari(),failIfMajorPerformanceCaveat:h};if("setAttribute"in e&&e.setAttribute("data-engine",`Verge3D ${n}`),e.addEventListener("webglcontextlost",Ft,!1),e.addEventListener("webglcontextrestored",Ut,!1),e.addEventListener("webglcontextcreationerror",Vt,!1),null===Lt){const e=["webgl2","webgl"];if(Lt=Nt(e,t),null===Lt)throw Nt(e)?new Error("Error creating WebGL context with your selected attributes."):new Error("Error creating WebGL context.");{const t="undefined"!=typeof WebGL2RenderingContext&&Lt instanceof WebGL2RenderingContext;console.log("Verge3D "+n+" "+Le()+" ("+(3483952072==ve(r)?"Trial":"License")+", "+(t?"WebGL 2.0":"WebGL 1.0")+")")}}}catch(t){throw console.error("v3d.WebGLRenderer: "+t.message),t}function Dt(){lt=new fr(Lt),ct=new Hi(Lt,lt,t),lt.init(ct),Rt=new ba(Lt,lt,ct),ut=new Ia(Lt,lt,ct),ht=new vr,ft=new ea,dt=new Ma(Lt,lt,ut,ft,ct,Rt,ht),At=new Yi(_),vt=new hr(_),mt=new Pi(Lt,ct),Tt=new zi(Lt,lt,mt,ct),pt=new dr(Lt,mt,ht,Tt),gt=new Tr(Lt,pt,mt,ht),St=new _r(Lt,ct,dt),xt=new Wi(ft),_t=new ta(_,At,vt,lt,ct,Tt,xt),Et=new mr(_,ft),Ct=new ra,wt=new ha(lt,ct),Mt=new Qi(_,At,vt,ut,gt,f,l),It=new xa(_,gt,ct),Bt=new Sa(Lt,ht,ct,ut),bt=new ki(Lt,lt,ht,ct),yt=new Ar(Lt,lt,ht,ct),ht.programs=_t.programs,_.capabilities=ct,_.extensions=lt,_.properties=ft,_.renderLists=Ct,_.shadowMap=It,_.state=ut,_.info=ht}Dt();const Pt=new Pa(_,Lt);function Ft(t){t.preventDefault(),console.log("v3d.WebGLRenderer: Context Lost."),E=!0}function Ut(){console.log("v3d.WebGLRenderer: Context Restored."),E=!1;const t=It.enabled,e=It.autoUpdate,n=It.needsUpdate,o=It.type;Dt(),It.enabled=t,It.autoUpdate=e,It.needsUpdate=n,It.type=o}function Vt(t){console.error("v3d.WebGLRenderer: A WebGL context could not be created. Reason:",t.statusMessage)}function Gt(t){const e=t.target;e.removeEventListener("dispose",Gt),function(t){(function(t){const e=ft.get(t).programs;void 0!==e&&e.forEach(function(t){_t.releaseProgram(t)})})(t),ft.remove(t)}(e)}this.xr=Pt,this.getContext=function(){return Lt},this.getContextAttributes=function(){return Lt.getContextAttributes()},this.forceContextLoss=function(){const t=lt.get("WEBGL_lose_context");t&&t.loseContext()},this.forceContextRestore=function(){const t=lt.get("WEBGL_lose_context");t&&t.restoreContext()},this.getTextureUtils=function(){return dt},this.getPixelRatio=function(){return B},this.setPixelRatio=function(t){void 0!==t&&(B=t,this.setSize(R,T,!1))},this.getSize=function(t){return t.set(R,T)},this.setSize=function(t,n,o){Pt.isPresenting?console.warn("v3d.WebGLRenderer: Can't change size while VR device is presenting."):(R=t,T=n,e.width=Math.floor(t*B),e.height=Math.floor(n*B),!1!==o&&(e.style.width=t+"px",e.style.height=n+"px"),this.setViewport(0,0,t,n),this.oitRenderer&&(this.getDrawingBufferSize($),this.oitRenderer.setSize($.x,$.y)))},this.getDrawingBufferSize=function(t){return t.set(R*B,T*B).floor()},this.setDrawingBufferSize=function(t,n,o){R=t,T=n,B=o,e.width=Math.floor(t*o),e.height=Math.floor(n*o),this.setViewport(0,0,t,n)},this.getCurrentViewport=function(t){return t.copy(S)},this.getViewport=function(t){return t.copy(D)},this.setViewport=function(t,e,n,o){t.isVector4?D.set(t.x,t.y,t.z,t.w):D.set(t,e,n,o),ut.viewport(S.copy(D).multiplyScalar(B).floor())},this.getScissor=function(t){return t.copy(P)},this.setScissor=function(t,e,n,o){t.isVector4?P.set(t.x,t.y,t.z,t.w):P.set(t,e,n,o),ut.scissor(b.copy(P).multiplyScalar(B).floor())},this.getScissorTest=function(){return U},this.setScissorTest=function(t){ut.setScissorTest(U=t)},this.setOpaqueSort=function(t){L=t},this.setTransparentSort=function(t){N=t},this.getClearColor=function(t){return t.copy(Mt.getClearColor())},this.setClearColor=function(){Mt.setClearColor.apply(Mt,arguments)},this.getClearAlpha=function(){return Mt.getClearAlpha()},this.setClearAlpha=function(){Mt.setClearAlpha.apply(Mt,arguments)},this.clear=function(t=!0,e=!0,n=!0){let o=0;if(t){let t=!1;if(null!==x){const e=x.texture.format;t=e===J||e===q||e===j}if(t){const t=x.texture.type,e=t===O||t===V||t===F||t===H||t===z||t===k,n=Mt.getClearColor(),o=Mt.getClearAlpha(),i=n.r,r=n.g,s=n.b;e?(d[0]=i,d[1]=r,d[2]=s,d[3]=o,Lt.clearBufferuiv(6144,0,d)):(A[0]=i,A[1]=r,A[2]=s,A[3]=o,Lt.clearBufferiv(6144,0,A))}else o|=16384}e&&(o|=256),n&&(o|=1024),Lt.clear(o)},this.clearColor=function(){this.clear(!0,!1,!1)},this.clearDepth=function(){this.clear(!1,!0,!1)},this.clearStencil=function(){this.clear(!1,!1,!0)},this.dispose=function(){e.removeEventListener("webglcontextlost",Ft,!1),e.removeEventListener("webglcontextrestored",Ut,!1),e.removeEventListener("webglcontextcreationerror",Vt,!1),this.disposeGTAO(),this.disposeOIT(),this.disposeInternalCaches(),Pt.dispose(),Pt.removeEventListener("sessionstart",zt),Pt.removeEventListener("sessionend",kt),Ht.stop()},this.canUseGTAO=function(){return this.gtaoMap&&this.gtaoMapEnabled},this.disposeGTAO=function(){var t;null==(t=this.gtaoMap)||t.dispose(),this.gtaoMap=null},this.disposeOIT=function(){this.oitRenderer&&this.oitRenderer.dispose(),this.useOIT=!1},this.disposeInternalCaches=function(){Ct.dispose(),wt.dispose(),ft.dispose(),At.dispose(),vt.dispose(),gt.dispose(),Tt.dispose(),Bt.dispose(),Mt.dispose(),mt.dispose()},this.renderBufferDirect=function(t,e,n,o,i,r){null===e&&(e=et);const s=i.isMesh&&i.matrixWorld.determinant()<0,a=function(t,e,n,o,i){!0!==e.isScene&&(e=et);dt.resetTextureUnits();const r=e.fog,s=o.isMeshNodeMaterial||o.isMeshStandardMaterial?e.environment:null,a=null===x?_.outputEncoding:!0===x.isXRRenderTarget?x.texture.encoding:Ot;if(o.envMapAutoAssign&&(o.isMeshNodeMaterial||o.isMeshStandardMaterial)){const t=m.state.envMapProbeArray.find(t=>{if(null===t.influenceGroup)return t.intersectsMesh(i);return i.groupNames.includes(t.influenceGroup)^t.influenceGroupInv})||e.worldEnvMapProbe;if(t){var l;o.envMap=(null==(l=t.renderTarget)?void 0:l.texture)||null;const e=t.parallaxDistance;o.envMapParallaxMatrix.copy(t.matrixWorldInverse).premultiply(rt.makeScale(1/e,1/e,1/e)),o.envMapParallaxMatrixInv.copy(t.matrixWorld).multiply(rt.makeScale(e,e,e)),o.envMapParallaxType=t.parallaxType}}const c=(o.isMeshNodeMaterial||o.isMeshStandardMaterial?vt:At).get(o.envMap||s),u=!0===o.vertexColors&&!!n.attributes.color&&4===n.attributes.color.itemSize,h=!!o.normalMap&&!!n.attributes.tangent,f=!!n.morphAttributes.position,d=!!n.morphAttributes.normal,A=o.toneMapped?_.toneMapping:0,v=n.morphAttributes.position||n.morphAttributes.normal,p=void 0!==v?v.length:0,g=1===o.side,E=ft.get(o),C=m.state.lights;if(!0===X&&(!0===K||t!==M)){const e=t===M&&o.id===I;xt.setState(o,t,e)}const w=Jt(i,o,m),b=_.canUseGTAO()&&o.isMeshNodeMaterial&&o.canUseGTAO();let y=!1,L=!1;o.version===E.se?E.needsLights&&E.lightsStateVersion!==C.state.version||E.outputEncoding!==a||i.isInstancedMesh&&!1===E.instancing?y=!0:i.isInstancedMesh||!0!==E.instancing?i.isSkinnedMesh&&!1===E.skinning?y=!0:i.isSkinnedMesh||!0!==E.skinning?E.envMap!==c?(y=!0,L=!0):!0===o.fog&&E.fog!==r?y=!0:void 0===E.numClippingPlanes||E.numClippingPlanes===xt.numPlanes&&E.numIntersection===xt.numIntersection?(E.vertexAlphas!==u||E.vertexTangents!==h||E.morphTargets!==f||E.morphNormals!==d||E.toneMapping!==A||!0===ct.isWebGL2&&E.morphTargetsCount!==p||E.planeReflProbe!==w||o.isMeshNormalMaterial&&E.flipSided!==g||E.useGTAO!==b)&&(y=!0):y=!0:y=!0:y=!0:y=!0;let N=E.currentProgram;!0===y&&(N=jt(o,e,i,m));let D=!1,P=!1,O=!1;const F=N.getUniforms(),U=E.uniforms;ut.useProgram(N.program)&&(D=!0,P=!0,O=!0);o.id!==I&&(I=o.id,P=!0);L&&(P=!0);if(D||M!==t){if(F.setValue(Lt,"projectionMatrix",t.projectionMatrix),ct.logarithmicDepthBuffer&&F.setValue(Lt,"logDepthBufFC",2/(Math.log(t.far+1)/Math.LN2)),M!==t&&(M=t,P=!0,O=!0),o.isMeshNodeMaterial||o.isShaderMaterial||o.isMeshStandardMaterial||o.envMap){const e=F.map.cameraPosition;void 0!==e&&e.setValue(Lt,tt.setFromMatrixPosition(t.matrixWorld))}(o.isMeshNodeMaterial||o.isMeshLambertMaterial||o.isMeshBasicMaterial||o.isMeshStandardMaterial||o.isShaderMaterial)&&F.setValue(Lt,"isOrthographic",!0===t.isOrthographicCamera),(o.isMeshNodeMaterial||o.isMeshLambertMaterial||o.isMeshBasicMaterial||o.isMeshStandardMaterial||o.isShaderMaterial||o.isShadowMaterial||i.isSkinnedMesh)&&F.setValue(Lt,"viewMatrix",t.matrixWorldInverse),(o.isMeshNodeMaterial||o.isMeshLambertMaterial||o.isMeshStandardMaterial||o.isShadowMaterial)&&F.setValue(Lt,"invViewMatrix",t.matrixWorld)}if(i.isSkinnedMesh){F.setOptional(Lt,i,"bindMatrix"),F.setOptional(Lt,i,"bindMatrixInverse");const t=i.skeleton;t&&(ct.floatVertexTextures?(null===t.boneTexture&&t.computeBoneTexture(),F.setValue(Lt,"boneTexture",t.boneTexture,dt),F.setValue(Lt,"boneTextureSize",t.boneTextureSize)):console.warn("v3d.WebGLRenderer: SkinnedMesh can only be used with WebGL 2. With WebGL 1 OES_texture_float and vertex textures support is required."))}const V=n.morphAttributes;void 0===V.position&&void 0===V.normal||St.update(i,n,o,N);(P||E.receiveShadow!==i.receiveShadow)&&(E.receiveShadow=i.receiveShadow,F.setValue(Lt,"receiveShadow",i.receiveShadow));if(P){if(F.setValue(Lt,"toneMappingExposure",_.toneMappingExposure),6==_.toneMapping?(F.setValue(Lt,"toneMappingBrightness",_.toneMappingBrightness),F.setValue(Lt,"toneMappingContrast",_.toneMappingContrast),F.setValue(Lt,"toneMappingMidTones",_.toneMappingMidTones),F.setValue(Lt,"toneMappingPhysicalScale",_.toneMappingPhysicalScale),F.setValue(Lt,"toneMappingChromaticAdaptation",_.toneMappingChromaticAdaptation),F.setValue(Lt,"toneMappingWhiteColor",_.toneMappingWhiteColor),F.setValue(Lt,"toneMappingColorDifferentiation",_.toneMappingColorDifferentiation),F.setValue(Lt,"toneMappingExteriorDaylight",_.toneMappingExteriorDaylight)):7==_.toneMapping&&(F.setValue(Lt,"toneMappingResolution",$.set(R,T)),F.setValue(Lt,"toneMappingWhiteBalance",_.toneMappingWhiteBalance),F.setValue(Lt,"toneMappingHighlights",_.toneMappingHighlights),F.setValue(Lt,"toneMappingMidTones",_.toneMappingMidTones),F.setValue(Lt,"toneMappingShadows",_.toneMappingShadows),F.setValue(Lt,"toneMappingSaturation",_.toneMappingSaturation),F.setValue(Lt,"toneMappingPhysicalScale",_.toneMappingPhysicalScale),F.setValue(Lt,"toneMappingAperture",_.toneMappingAperture),F.setValue(Lt,"toneMappingShutter",_.toneMappingShutter),F.setValue(Lt,"toneMappingISO",_.toneMappingISO),F.setValue(Lt,"toneMappingVignetting",_.toneMappingVignetting)),E.needsLights&&(W=O,(H=U).ambientLightColor.needsUpdate=W,H.lightProbe.needsUpdate=W,H.directionalLights.needsUpdate=W,H.directionalLightShadowsCSM.needsUpdate=W,H.directionalLightShadowsCSMCascade.needsUpdate=W,H.pointLights.needsUpdate=W,H.pointLightShadows.needsUpdate=W,H.spotLights.needsUpdate=W,H.spotLightShadows.needsUpdate=W,H.rectAreaLights.needsUpdate=W,H.rectAreaLightShadows.needsUpdate=W),r&&!0===o.fog&&Et.refreshFogUniforms(U,r),E.useGTAO){var G,Q,z,k;const t=null!=(G=null==(Q=x)?void 0:Q.width)?G:R,e=null!=(z=null==(k=x)?void 0:k.height)?z:T;F.setValue(Lt,"currResolution",$.set(t,e)),Et.refreshGTAOUniforms(U,_.gtaoMap)}if(Et.refreshMaterialUniforms(U,o,B,T),w&&Et.refreshPlaneReflProbeUniforms(U,w),o.isMeshNodeMaterial)for(const t in o.nodeTextures)F.setValue(Lt,t,o.nodeTextures[t],dt);o.isMeshLineMaterial&&F.setValue(Lt,"resolution",$.set(R,T)),Ds.upload(Lt,Zt(E),U,dt)}var H,W;o.isShaderMaterial&&!0===o.uniformsNeedUpdate&&(Ds.upload(Lt,Zt(E),U,dt),o.uniformsNeedUpdate=!1);o.isSpriteMaterial&&F.setValue(Lt,"center",i.center);if(o.isMeshNodeMaterial){o.needsBoundingBox&&(null===n.boundingBox&&n.computeBoundingBox(),F.setValue(Lt,"boundingBoxMin",n.boundingBox.min),F.setValue(Lt,"boundingBoxMax",n.boundingBox.max)),F.setValue(Lt,"viewWidthHeight",$.set(S.z-S.x,S.w-S.y));const t=F.map.invModelMatrix;(t||o.nodeTexCoordObject.includes(null))&&(nt.copy(i.matrixWorld).invert(),t&&t.setValue(Lt,nt)),o.nodeTexCoordObject.forEach(function(t,e){(null===t?nt:ot.copy(t.matrixWorld).invert()).toArray(E.nodeTexCoordObjectMatrices,16*e)}),F.setValue(Lt,"nodeTexCoordObjectMatrices",E.nodeTexCoordObjectMatrices),F.setValue(Lt,"objectIndex",i.objectIndex);const e=i.objectColor;F.setValue(Lt,"objectColor",it.set(e.r,e.g,e.b,i.objectAlpha)),F.setValue(Lt,"objectRandom",ve(i.uuid)/Math.pow(2,32))}if(F.setValue(Lt,"modelViewMatrix",i.modelViewMatrix),F.setValue(Lt,"normalMatrix",i.normalMatrix),F.setValue(Lt,"modelMatrix",i.matrixWorld),o.isShaderMaterial||o.isRawShaderMaterial){const t=o.uniformsGroups;for(let e=0,n=t.length;e<n;e++)if(ct.isWebGL2){const n=t[e];Bt.update(n,N),Bt.bind(n,N)}else console.warn("v3d.WebGLRenderer: Uniform Buffer Objects can only be used with WebGL 2.")}return N}(t,e,n,o,i);ut.setMaterial(o,s);let l=n.index,c=1;!0===o.wireframe&&(l=pt.getWireframeAttribute(n),c=2);const u=n.drawRange,h=n.attributes.position;let f=u.start*c,d=(u.start+u.count)*c;null!==r&&(f=Math.max(f,r.start*c),d=Math.min(d,(r.start+r.count)*c)),null!==l?(f=Math.max(f,0),d=Math.min(d,l.count)):null!=h&&(f=Math.max(f,0),d=Math.min(d,h.count));const A=d-f;if(A<0||A===1/0)return;let v;Tt.setup(i,o,a,n,l);let p=bt;if(null!==l&&(v=mt.get(l),p=yt,p.setIndex(v)),i.isMesh)!0===o.wireframe?(ut.setLineWidth(o.wireframeLinewidth*at()),p.setMode(1)):p.setMode(4);else if(i.isLine){let t=o.linewidth;void 0===t&&(t=1),ut.setLineWidth(t*at()),i.isLineSegments?p.setMode(1):i.isLineLoop?p.setMode(2):p.setMode(3)}else i.isPoints?p.setMode(0):i.isSprite&&p.setMode(4);if(a.beginTimerQuery(Lt,ct.isWebGL2),o.depthPrepass&&o.transparent){const t=ut.buffers.depth.getTest(),e=ut.buffers.color.getMask();if(ut.buffers.depth.setTest(!0),ut.buffers.color.setMask(0),i.isInstancedMesh)p.renderInstances(f,A,i.count);else if(n.isInstancedBufferGeometry){const t=void 0!==n.st?n.st:1/0,e=Math.min(n.instanceCount,t);p.renderInstances(f,A,e)}else p.render(f,A);ut.buffers.depth.setTest(t),ut.buffers.color.setMask(e)}if(i.isInstancedMesh)p.renderInstances(f,A,i.count);else if(n.isInstancedBufferGeometry){const t=void 0!==n.st?n.st:1/0,e=Math.min(n.instanceCount,t);p.renderInstances(f,A,e)}else p.render(f,A);a.endTimerQuery(Lt,ct.isWebGL2)},this.Ee=function(t,e,n){K=this.localClippingEnabled,X=xt.init(this.clippingPlanes,K,e),n.init(),t.traverse(t=>{t.isLight?(n.pushLight(t),t.castShadow&&n.pushShadow(t)):t.isCubeReflectionProbe?n.pushEnvMapProbe(t):t.isPlaneReflectionProbe&&(n.pushPlaneReflProbe(t),t.calcLocalBounding())}),n.setupLights(),n.sortEnvMapProbes();let o=null;return t.worldEnvMapProbe&&null!==t.worldEnvMapProbe.renderTarget&&(o=t.worldEnvMapProbe.renderTarget.texture),t.traverse(t=>{if(t.material){(Array.isArray(t.material)?t.material:[t.material]).forEach(e=>{(e.isMeshNodeMaterial||e.isMeshStandardMaterial)&&(t.material.envMap=o,t.material.needsUpdate=!0)})}}),n},this.compile=function(t,e){this.gtaoMapEnabled=!0;const n=wt.get(t,g.length);this.Ee(t,e,n);const o={};t.traverse(function(e){const i=e.material;if(i)if(Array.isArray(i))for(let r=0;r<i.length;r++){const s=i[r];s.uuid in o==!1&&(jt(s,t,e,n),o[s.uuid]=!0)}else i.uuid in o==!1&&(jt(i,t,e,n),o[i.uuid]=!0)}),this.gtaoMapEnabled=!1},this.compileAsync=function(t,e,n){const o=new ua(lt,ct);this.Ee(t,e,o);const i=[];if(t.traverse(function(e){if(e.material&&!e.hidpiCompositing){(Array.isArray(e.material)?e.material:[e.material]).forEach(function(n){i.push({scene:t,obj:e,mat:n})})}}),0===i.length)n(1);else{const t=lt.get("KHR_parallel_shader_compile"),r=(null===t?1:2)*i.length;let s=0,a=0;const l={};if(Qe(i,function(i,c,u){_.gtaoMapEnabled=!0,!0===X&&xt.setState(i.mat,e,!1);const h=jt(i.mat,i.scene,i.obj,o);if(_.gtaoMapEnabled=!1,t){const t=h.id;t in l||(l[t]={program:h,weight:0}),l[t].weight++}n&&(s++,n((s+a)/r))},16),t){const e=setInterval(function(){let o=0;for(let e in l){const n=l[e];(void 0===n.program.program||Lt.getProgramParameter(n.program.program,t.COMPLETION_STATUS_KHR))&&(o+=n.weight)}a=Math.max(a,o),n&&n((s+a)/r),a===i.length&&clearInterval(e)},16)}}};let Qt=null;function zt(){Ht.stop()}function kt(){Ht.start()}const Ht=new Di;function Wt(t,e,n,o){t.isAnnotationControl&&t.update(e);let i=!1;if(t.visible&&(i=t.layers.test(e.layers),i))if(t.isGroup)n=t.renderOrder;else if(t.isLOD)!0===t.autoUpdate&&t.update(e);else if(t.isLight)m.pushLight(t),t.castShadow&&m.pushShadow(t);else if(t.isCubeReflectionProbe)m.pushEnvMapProbe(t);else if(t.isPlaneReflectionProbe)m.pushPlaneReflProbe(t);else if(t.isSprite){if(!t.frustumCulled||Y.intersectsSprite(t)){o&&tt.setFromMatrixPosition(t.matrixWorld).applyMatrix4(Z);const e=gt.update(t),i=t.material;v.push(t,e,i,n,tt.z,null)}}else if((t.isMesh||t.isLine||t.isPoints)&&(t.isSkinnedMesh&&t.skeleton.frame!==ht.render.frame&&(t.skeleton.update(),t.skeleton.frame=ht.render.frame),!t.frustumCulled||Y.intersectsObject(t))){o&&tt.setFromMatrixPosition(t.matrixWorld).applyMatrix4(Z);const e=gt.update(t),i=t.material;if(Array.isArray(i)){const o=e.groups;for(let r=0,s=o.length;r<s;r++){const s=o[r],a=i[s.materialIndex];a&&a.visible&&v.push(t,e,a,n,tt.z,s)}}else i.visible&&v.push(t,e,i,n,tt.z,null)}if(t.disableChildRendering)return;const r=t.children;for(let t=0,s=r.length;t<s;t++){const s=r[t];!i&&s.isMesh&&s.isMaterialGeneratedMesh||Wt(s,e,n,o)}}function Yt(t,e,n,o){const i=t.opaque,r=t.transparent;m.setupLightsView(n),o&&ut.viewport(S.copy(o)),i.length>0&&Xt(i,e,n),r.length>0&&(st&&0!==_.oitRenderer.method?_.oitRenderer.render(_,Xt,r,e,n):Xt(r,e,n)),ut.buffers.depth.setTest(!0),ut.buffers.depth.setMask(!0),ut.buffers.color.setMask(!0),ut.setPolygonOffset(!1)}function Xt(t,e,n){const o=!0===e.isScene?e.overrideMaterial:null;for(let i=0,r=t.length;i<r;i++){const r=t[i],s=r.object,a=r.geometry,l=null===o?r.material:o,c=r.group;s.layers.test(n.layers)&&Kt(s,e,n,a,l,c)}}function Kt(t,e,n,o,i,r){t.onBeforeRender(_,e,n,o,i,r),t.modelViewMatrix.multiplyMatrices(n.matrixWorldInverse,t.matrixWorld),t.normalMatrix.getNormalMatrix(t.modelViewMatrix),i.onBeforeRender(_,e,n,o,t,r),!0===i.transparent&&3===i.side?(i.side=1,i.needsUpdate=!0,_.renderBufferDirect(n,e,o,i,t,r),i.side=0,i.needsUpdate=!0,_.renderBufferDirect(n,e,o,i,t,r),i.side=3):_.renderBufferDirect(n,e,o,i,t,r),t.onAfterRender(_,e,n,o,i,r)}function jt(t,e,n,o){!0!==e.isScene&&(e=et);const i=ft.get(t);i.se=t.version;const r=o.state.lights,s=o.state.shadowsArray,a=function(t){return t.isMeshNodeMaterial||t.isMeshLambertMaterial||t.isMeshStandardMaterial||t.isShadowMaterial||t.isShaderMaterial&&!0===t.lights}(t),l=r.state.version,c=Jt(n,t,o);i.planeReflProbe=c;const u=_t.getParameters(t,a?r.state:null,s,e,n,c),h=_t.getProgramCacheKey(u);let f=i.programs;i.environment=t.isMeshNodeMaterial||t.isMeshStandardMaterial?e.environment:null,i.fog=e.fog,i.envMap=(t.isMeshNodeMaterial||t.isMeshStandardMaterial?vt:At).get(t.envMap||i.environment),i.useGTAO=_.canUseGTAO()&&t.isMeshNodeMaterial&&t.canUseGTAO(),void 0===f&&(t.addEventListener("dispose",Gt),f=new Map,i.programs=f);let d=f.get(h);if(void 0!==d){if(i.currentProgram===d&&i.lightsStateVersion===l)return qt(t,u),d}else u.uniforms=_t.getUniforms(t),t.onBuild(n,u,_),t.onBeforeCompile(u,_),d=_t.acquireProgram(u,h),f.set(h,d),ht.numShaderCompiles=_t.getNumShaderCompiles(),i.uniforms=u.uniforms;const A=i.uniforms;if((t.isShaderMaterial||t.isRawShaderMaterial)&&!0!==t.clipping||t.defines.WORLD_NODES||(A.clippingPlanes=xt.uniform),qt(t,u),i.needsLights=a,i.lightsStateVersion=l,a&&(A.ambientLightColor.value=r.state.ambient,A.lightProbe.value=r.state.probe,A.directionalLights.value=r.state.directional,A.spotLights.value=r.state.spot,A.spotLightShadows.value=r.state.spotShadow,A.rectAreaLights.value=r.state.rectArea,A.ltc_1.value=r.state.rectAreaLTC1,A.ltc_2.value=r.state.rectAreaLTC2,A.pointLights.value=r.state.point,A.pointLightShadows.value=r.state.pointShadow,A.spotShadowMap.value=r.state.spotShadowMap,A.spotShadowMatrix.value=r.state.spotShadowMatrix,A.pointShadowMap.value=r.state.pointShadowMap,A.pointShadowMatrix.value=r.state.pointShadowMatrix,A.rectAreaLightShadows.value=r.state.rectAreaShadow,A.rectAreaShadowMap.value=r.state.rectAreaShadowMap,A.rectAreaShadowMatrix.value=r.state.rectAreaShadowMatrix,A.directionalLightShadowsCSM.value=r.state.directionalShadowCSM,A.directionalShadowCSMMap.value=r.state.directionalShadowCSMMap,A.directionalShadowCSMMatrix.value=r.state.directionalShadowCSMMatrix,A.directionalLightShadowsCSMCascade.value=r.state.directionalShadowCSMCascade),t.isMeshNodeMaterial){A.nodeRGB.value!==4*t.nodeRGB.length&&(A.nodeRGB.value=new Float32Array(4*t.nodeRGB.length)),A.nodeValue.value.length!==t.nodeValue.length&&(A.nodeValue.value=new Float32Array(t.nodeValue.length));for(const e in t.nodeInputs){const n=`nodeInputs${Te(e)}`;A[n].value.length!==t.nodeInputs[e]&&(A[n].value=t.nodeInputs[e])}i.nodeTexCoordObjectMatrices&&i.nodeTexCoordObjectMatrices.length===16*t.nodeTexCoordObject.length||(i.nodeTexCoordObjectMatrices=new Float32Array(16*t.nodeTexCoordObject.length))}else i.nodeTexCoordObjectMatrices=new Float32Array(0);return i.currentProgram=d,i.uniformsList=null,d}function Zt(t){if(null===t.uniformsList){const e=t.currentProgram.getUniforms();t.uniformsList=Ds.seqWithValue(e.seq,t.uniforms)}return t.uniformsList}function qt(t,e){const n=ft.get(t);n.outputEncoding=e.outputEncoding,n.instancing=e.instancing,n.skinning=e.skinning,n.morphTargets=e.morphTargets,n.morphNormals=e.morphNormals,n.morphTargetsCount=e.morphTargetsCount,n.numClippingPlanes=e.numClippingPlanes,n.numIntersection=e.numClipIntersection,n.vertexAlphas=e.vertexAlphas,n.vertexTangents=e.vertexTangents,n.toneMapping=e.toneMapping,n.flipSided=e.flipSided}function Jt(t,e,n){return(e.isMeshNodeMaterial||e.isMeshStandardMaterial)&&n.state.planeReflProbeArray.find(e=>e.intersectsMesh(t))||null}Ht.setAnimationLoop(function(t){Qt&&Qt(t)}),"undefined"!=typeof self&&Ht.setContext(self),this.setAnimationLoop=function(t){Qt=t,Pt.setAnimationLoop(t),null===t?Ht.stop():Ht.start()},Pt.addEventListener("sessionstart",zt),Pt.addEventListener("sessionend",kt),this.render=function(t,e){if(void 0!==e&&!0!==e.isCamera)return void console.error("v3d.WebGLRenderer.render: camera is not an instance of v3d.Camera.");if(!0===E)return;!0===t.matrixWorldAutoUpdate&&t.updateMatrixWorld(),null===e.parent&&!0===e.matrixWorldAutoUpdate&&e.updateMatrixWorld(),!0===Pt.enabled&&!0===Pt.isPresenting&&(!0===Pt.cameraAutoUpdate&&Pt.updateCamera(e),e=Pt.getCamera()),!0===t.isScene&&t.onBeforeRender(_,t,e,x),m=wt.get(t,g.length),m.init(),g.push(m),Z.multiplyMatrices(e.projectionMatrix,e.matrixWorldInverse),Y.setFromProjectionMatrix(Z),K=this.localClippingEnabled,X=xt.init(this.clippingPlanes,K,e),v=Ct.get(t,p.length),v.init(),p.push(v),Wt(t,e,0,_.sortObjects),v.finish(),!0===_.sortObjects&&v.sort(L,N),!0===X&&xt.beginShadows();const n=m.state.shadowsArray;if(It.render(n,t,e),!0===X&&xt.endShadows(),this.info.render.frame++,Mt.render(v,t),m.setupLights(),m.sortEnvMapProbes(),e.isArrayCamera){const n=e.cameras;for(let e=0,o=n.length;e<o;e++){const o=n[e];Yt(v,t,o,o.viewport)}}else Yt(v,t,e);null!==x&&(dt.updateMultisampleRenderTarget(x),dt.updateRenderTargetMipmap(x)),!0===t.isScene&&t.onAfterRender(_,t,e),Tt.resetDefaultState(),I=-1,M=null,g.pop(),m=g.length>0?g[g.length-1]:null,p.pop(),v=p.length>0?p[p.length-1]:null},this.getActiveCubeFace=function(){return C},this.getActiveMipmapLevel=function(){return w},this.getRenderTarget=function(){return x},this.setRenderTargetTextures=function(t,e,n){ft.get(t.texture).Qt=e,ft.get(t.depthTexture).Qt=n;const o=ft.get(t);o.le=!0,o.ce=void 0===n,o.ce||!0===lt.has("WEBGL_multisampled_render_to_texture")&&(console.warn("v3d.WebGLRenderer: Render-to-texture extension was disabled because an external texture was provided"),o.ue=!1)},this.setRenderTargetFramebuffer=function(t,e){const n=ft.get(t);n.Ut=e,n.Ce=void 0===e},this.setRenderTarget=function(t,e=0,n=0){x=t,C=e,w=n;let o=!0,i=null,r=!1,s=!1;if(t){const n=ft.get(t);void 0!==n.Ce?(ut.bindFramebuffer(36160,null),o=!1):void 0===n.Ut?dt.setupRenderTarget(t):n.le&&dt.rebindTextures(t,ft.get(t.texture).Qt,ft.get(t.depthTexture).Qt);const a=t.texture;(a.isData3DTexture||a.isDataArrayTexture||a.isCompressedArrayTexture)&&(s=!0);const l=ft.get(t).Ut;t.isWebGLCubeRenderTarget?(i=l[e],r=!0):i=ct.isWebGL2&&t.samples>0&&!1===dt.useMultisampledRTT(t)?ft.get(t).Vt:l,S.copy(t.viewport),b.copy(t.scissor),y=t.scissorTest}else S.copy(D).multiplyScalar(B).floor(),b.copy(P).multiplyScalar(B).floor(),y=U;if(ut.bindFramebuffer(36160,i)&&ct.isWebGL2&&o&&ut.drawBuffers(t,i),ut.viewport(S),ut.scissor(b),ut.setScissorTest(y),r){const o=ft.get(t.texture);Lt.framebufferTexture2D(36160,36064,34069+e,o.Qt,n)}else if(s){const o=ft.get(t.texture),i=e||0;Lt.framebufferTextureLayer(36160,36064,o.Qt,n||0,i)}I=-1},this.readRenderTargetPixels=function(t,e,n,o,i,r,s){if(!t||!t.isWebGLRenderTarget)return void console.error("v3d.WebGLRenderer.readRenderTargetPixels: renderTarget is not v3d.WebGLRenderTarget.");let a=ft.get(t).Ut;if(t.isWebGLCubeRenderTarget&&void 0!==s&&(a=a[s]),a){ut.bindFramebuffer(36160,a);try{const s=t.texture,a=s.format,l=s.type;if(a!==W&&Rt.convert(a)!==Lt.getParameter(35739))return void console.error("v3d.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.");const c=l===Q&&(lt.has("EXT_color_buffer_half_float")||ct.isWebGL2&&lt.has("EXT_color_buffer_float"));if(!(l===O||Rt.convert(l)===Lt.getParameter(35738)||l===G&&(ct.isWebGL2||lt.has("OES_texture_float")||lt.has("WEBGL_color_buffer_float"))||c))return void console.error("v3d.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.");e>=0&&e<=t.width-o&&n>=0&&n<=t.height-i&&Lt.readPixels(e,n,o,i,Rt.convert(a),Rt.convert(l),r)}finally{const t=null!==x?ft.get(x).Ut:null;ut.bindFramebuffer(36160,t)}}},this.readRenderTargetPixelsAsync=async function(t,e,n,o,i,r,s){if(!t||!t.isWebGLRenderTarget)throw new Error("v3d.WebGLRenderer.readRenderTargetPixelsAsync: renderTarget is not v3d.WebGLRenderTarget.");let a=ft.get(t).Ut;if(t.isWebGLCubeRenderTarget&&void 0!==s&&(a=a[s]),a){if(e>=0&&e<=t.width-o&&n>=0&&n<=t.height-i){ut.bindFramebuffer(36160,a);const s=t.texture,l=s.format,c=s.type;if(l!==W&&Rt.convert(l)!==Lt.getParameter(35739))return void console.error("v3d.WebGLRenderer.readRenderTargetPixelsAsync: renderTarget is not in RGBA or implementation defined format.");const u=c===Q&&(lt.has("EXT_color_buffer_half_float")||ct.isWebGL2&&lt.has("EXT_color_buffer_float"));if(!(c===O||Rt.convert(c)===Lt.getParameter(35738)||c===G&&(ct.isWebGL2||lt.has("OES_texture_float")||lt.has("WEBGL_color_buffer_float"))||u))return void console.error("v3d.WebGLRenderer.readRenderTargetPixelsAsync: renderTarget is not in UnsignedByteType or implementation defined type.");const h=Lt.createBuffer();Lt.bindBuffer(35051,h),Lt.bufferData(35051,r.byteLength,35041),Lt.readPixels(e,n,o,i,Rt.convert(l),Rt.convert(c),0);const f=null!==x?ft.get(x).Ut:null;ut.bindFramebuffer(36160,f);const d=Lt.fenceSync(37143,0);return Lt.flush(),await function(t,e,n){return new Promise(function(o,i){setTimeout(function r(){switch(t.clientWaitSync(e,1,0)){case 37149:i();break;case 37147:setTimeout(r,n);break;default:o()}},n)})}(Lt,d,4),Lt.bindBuffer(35051,h),Lt.getBufferSubData(35051,0,r),Lt.deleteBuffer(h),Lt.deleteSync(d),r}throw new Error("v3d.WebGLRenderer.readRenderTargetPixelsAsync: requested read bounds are out of range.")}},this.copyFramebufferToTexture=function(t,e,n=0){const o=Math.pow(2,-n),i=Math.floor(e.image.width*o),r=Math.floor(e.image.height*o);dt.setTexture2D(e,0),Lt.copyTexSubImage2D(3553,n,0,0,t.x,t.y,i,r),ut.unbindTexture()},this.copyTextureToTexture=function(t,e,n,o=0){const i=e.image.width,r=e.image.height,s=Rt.convert(n.format),a=Rt.convert(n.type);dt.setTexture2D(n,0),Lt.pixelStorei(37440,n.flipY),Lt.pixelStorei(37441,n.premultiplyAlpha),Lt.pixelStorei(3317,n.unpackAlignment),e.isDataTexture?Lt.texSubImage2D(3553,o,t.x,t.y,i,r,s,a,e.image.data):e.isCompressedTexture?Lt.compressedTexSubImage2D(3553,o,t.x,t.y,e.mipmaps[0].width,e.mipmaps[0].height,s,e.mipmaps[0].data):Lt.texSubImage2D(3553,o,t.x,t.y,s,a,e.image),0===o&&n.generateMipmaps&&Lt.generateMipmap(3553),ut.unbindTexture()},this.copyTextureToTexture3D=function(t,e,n,o,i=0){if(!ct.isWebGL2)return void console.warn("v3d.WebGLRenderer.copyTextureToTexture3D: can only be used with WebGL2.");const r=t.max.x-t.min.x+1,s=t.max.y-t.min.y+1,a=t.max.z-t.min.z+1,l=Rt.convert(o.format),c=Rt.convert(o.type);let u;if(o.isData3DTexture)dt.setTexture3D(o,0),u=32879;else{if(!o.isDataArrayTexture)return void console.warn("v3d.WebGLRenderer.copyTextureToTexture3D: only supports v3d.DataTexture3D and v3d.DataTexture2DArray.");dt.setTexture2DArray(o,0),u=35866}Lt.pixelStorei(37440,o.flipY),Lt.pixelStorei(37441,o.premultiplyAlpha),Lt.pixelStorei(3317,o.unpackAlignment);const h=Lt.getParameter(3314),f=Lt.getParameter(32878),d=Lt.getParameter(3316),A=Lt.getParameter(3315),v=Lt.getParameter(32877),m=n.isCompressedTexture?n.mipmaps[0]:n.image;Lt.pixelStorei(3314,m.width),Lt.pixelStorei(32878,m.height),Lt.pixelStorei(3316,t.min.x),Lt.pixelStorei(3315,t.min.y),Lt.pixelStorei(32877,t.min.z),n.isDataTexture||n.isData3DTexture?Lt.texSubImage3D(u,i,e.x,e.y,e.z,r,s,a,l,c,m.data):n.isCompressedArrayTexture?(console.warn("v3d.WebGLRenderer.copyTextureToTexture3D: untested support for compressed srcTexture."),Lt.compressedTexSubImage3D(u,i,e.x,e.y,e.z,r,s,a,l,m.data)):Lt.texSubImage3D(u,i,e.x,e.y,e.z,r,s,a,l,c,m),Lt.pixelStorei(3314,h),Lt.pixelStorei(32878,f),Lt.pixelStorei(3316,d),Lt.pixelStorei(3315,A),Lt.pixelStorei(32877,v),0===i&&o.generateMipmaps&&Lt.generateMipmap(u),ut.unbindTexture()},this.initTexture=function(t){t.isCubeTexture?dt.setTextureCube(t,0):t.isData3DTexture?dt.setTexture3D(t,0):t.isDataArrayTexture||t.isCompressedArrayTexture?dt.setTexture2DArray(t,0):dt.setTexture2D(t,0),ut.unbindTexture()},this.resetState=function(){C=0,w=0,x=null,ut.reset(),Tt.reset()},ke("observe",this),this.updateGeometry=function(t){return gt.update(t)},this.setOIT=function(t,e){this.oitRenderer.setSize(R,T),this.oitRenderer.texType=null!==Rt.convert(Q)?Q:O;let n=e||(!0===a?4:0);this.oitRenderer.isMethodCompatible(t,ct)?this.oitRenderer.setMethod(t,n):console.log("v3d.WebGLRenderer: the OIT method is not compatible.")},this.getOIT=function(){return this.oitRenderer.method},Object.defineProperty(this,"useOIT",{get:function(){return st},set:function(t){this.setTransparentSort(t?function(){}:null),st=t}})}class Fa{constructor(t,e=25e-5){this.isFogExp2=!0,this.name="",this.color=new tn(t),this.density=e}clone(){return new Fa(this.color,this.density)}}class Ua{constructor(t,e=1,n=1e3){this.isFog=!0,this.name="",this.color=new tn(t),this.near=e,this.far=n}clone(){return new Ua(this.color,this.near,this.far)}}class Va extends Lo{constructor(t){super(),this.isSpriteMaterial=!0,this.type="SpriteMaterial",this.color=new tn(16777215),this.map=null,this.alphaMap=null,this.rotation=0,this.sizeAttenuation=!0,this.transparent=!0,this.fog=!0,this.setValues(t)}copy(t){return super.copy(t),this.color.copy(t.color),this.map=t.map,this.alphaMap=t.alphaMap,this.rotation=t.rotation,this.sizeAttenuation=t.sizeAttenuation,this.fog=t.fog,this}}let Ga;const Qa=new An,za=new An,ka=new An,Ha=new we,Wa=new we,Ya=new Hn,Xa=new An,Ka=new An,ja=new An,Za=new we,qa=new we,Ja=new we;class $a extends mo{constructor(t){if(super(),this.isSprite=!0,this.type="Sprite",void 0===Ga){Ga=new Xo;const t=new Float32Array([-.5,-.5,0,.5,-.5,0,.5,.5,0,-.5,.5,0]),e=new Float32Array([0,0,1,0,1,1,0,1]);Ga.setIndex([0,1,2,0,2,3]),Ga.setAttribute("position",new Oo(t,3)),Ga.setAttribute("uv",new Oo(e,2))}this.geometry=Ga,this.material=void 0!==t?t:new Va,this.center=new we(.5,.5)}raycast(t,e){if(null===t.camera)return void console.error('v3d.Sprite: "Raycaster.camera" needs to be set in order to raycast against sprites.');za.setFromMatrixScale(this.matrixWorld),Ya.copy(t.camera.matrixWorld),this.modelViewMatrix.multiplyMatrices(t.camera.matrixWorldInverse,this.matrixWorld),ka.setFromMatrixPosition(this.modelViewMatrix),t.camera.isPerspectiveCamera&&!1===this.material.sizeAttenuation&&za.multiplyScalar(-ka.z);const n=this.material.rotation;let o,i;0!==n&&(i=Math.cos(n),o=Math.sin(n));const r=this.center;tl(Xa.set(-.5,-.5,0),ka,r,za,o,i),tl(Ka.set(.5,-.5,0),ka,r,za,o,i),tl(ja.set(.5,.5,0),ka,r,za,o,i),Za.set(0,0),qa.set(1,0),Ja.set(1,1);let s=t.ray.intersectTriangle(Xa,Ka,ja,!1,Qa);if(null===s&&(tl(Ka.set(-.5,.5,0),ka,r,za,o,i),qa.set(0,1),s=t.ray.intersectTriangle(Xa,ja,Ka,!1,Qa),null===s))return;const a=t.ray.origin.distanceTo(Qa);a<t.near||a>t.far||e.push({distance:a,point:Qa.clone(),uv:To.getInterpolation(Qa,Xa,Ka,ja,Za,qa,Ja,new we),face:null,object:this})}copy(t,e){return super.copy(t,e),void 0!==t.center&&this.center.copy(t.center),this.material=t.material,this}}function tl(t,e,n,o,i,r){Ha.subVectors(t,n).addScalar(.5).multiply(o),void 0!==i?(Wa.x=r*Ha.x-i*Ha.y,Wa.y=i*Ha.x+r*Ha.y):Wa.copy(Ha),t.copy(e),t.x+=Wa.x,t.y+=Wa.y,t.applyMatrix4(Ya)}const el=new An,nl=new An;const ol=new An,il=new ln,rl=new ln,sl=new An,al=new Hn;class ll extends hi{constructor(t,e){super(t,e),this.isSkinnedMesh=!0,this.type="SkinnedMesh",this.bindMode="attached",this.bindMatrix=new Hn,this.bindMatrixInverse=new Hn,this.normalizeSkinWeights()}copy(t,e){return super.copy(t,e),this.bindMode=t.bindMode,this.bindMatrix.copy(t.bindMatrix),this.bindMatrixInverse.copy(t.bindMatrixInverse),this.skeleton=t.skeleton,this}bind(t,e){this.skeleton=t,void 0===e&&(this.updateMatrixWorld(!0),this.skeleton.calculateInverses(),e=this.matrixWorld),this.bindMatrix.copy(e),this.bindMatrixInverse.copy(e).invert()}pose(){this.skeleton.pose()}normalizeSkinWeights(){const t=new ln,e=this.geometry.attributes.skinWeight;for(let n=0,o=e.count;n<o;n++){t.fromBufferAttribute(e,n);const o=1/t.manhattanLength();o!==1/0?t.multiplyScalar(o):t.set(1,0,0,0),e.setXYZW(n,t.x,t.y,t.z,t.w)}}updateMatrixWorld(t){super.updateMatrixWorld(t),"attached"===this.bindMode?this.bindMatrixInverse.copy(this.matrixWorld).invert():"detached"===this.bindMode?this.bindMatrixInverse.copy(this.bindMatrix).invert():console.warn("v3d.SkinnedMesh: Unrecognized bindMode: "+this.bindMode)}boneTransform(t,e){const n=this.skeleton,o=this.geometry;il.fromBufferAttribute(o.attributes.skinIndex,t),rl.fromBufferAttribute(o.attributes.skinWeight,t),ol.copy(e).applyMatrix4(this.bindMatrix),e.set(0,0,0);for(let t=0;t<4;t++){const o=rl.getComponent(t);if(0!==o){const i=il.getComponent(t);al.multiplyMatrices(n.bones[i].matrixWorld,n.boneInverses[i]),e.addScaledVector(sl.copy(ol).applyMatrix4(al),o)}}return e.applyMatrix4(this.bindMatrixInverse)}}class cl extends mo{constructor(){super(),this.isBone=!0,this.type="Bone"}}class ul extends an{constructor(t=null,e=1,n=1,o,i,r,s,a,l=1003,c=1003,u,h){super(null,r,s,a,l,c,o,i,u,h),this.isDataTexture=!0,this.image={data:t,width:e,height:n},this.generateMipmaps=!1,this.flipY=!1,this.unpackAlignment=1}}const hl=new Hn,fl=new Hn;class dl{constructor(t=[],e=[]){this.uuid=ne(),this.bones=t.slice(0),this.boneInverses=e,this.boneMatrices=null,this.boneTexture=null,this.boneTextureSize=0,this.frame=-1,this.init()}init(){const t=this.bones,e=this.boneInverses;if(this.boneMatrices=new Float32Array(16*t.length),0===e.length)this.calculateInverses();else if(t.length!==e.length){console.warn("v3d.Skeleton: Number of inverse bone matrices does not match amount of bones."),this.boneInverses=[];for(let t=0,e=this.bones.length;t<e;t++)this.boneInverses.push(new Hn)}}calculateInverses(){this.boneInverses.length=0;for(let t=0,e=this.bones.length;t<e;t++){const e=new Hn;this.bones[t]&&e.copy(this.bones[t].matrixWorld).invert(),this.boneInverses.push(e)}}pose(){for(let t=0,e=this.bones.length;t<e;t++){const e=this.bones[t];e&&e.matrixWorld.copy(this.boneInverses[t]).invert()}for(let t=0,e=this.bones.length;t<e;t++){const e=this.bones[t];e&&(e.parent&&e.parent.isBone?(e.matrix.copy(e.parent.matrixWorld).invert(),e.matrix.multiply(e.matrixWorld)):e.matrix.copy(e.matrixWorld),e.matrix.decompose(e.position,e.quaternion,e.scale))}}update(){const t=this.bones,e=this.boneInverses,n=this.boneMatrices,o=this.boneTexture;for(let o=0,i=t.length;o<i;o++){const i=t[o]?t[o].matrixWorld:fl;hl.multiplyMatrices(i,e[o]),hl.toArray(n,16*o)}null!==o&&(o.needsUpdate=!0)}clone(){return new dl(this.bones,this.boneInverses)}computeBoneTexture(){let t=Math.sqrt(4*this.bones.length);t=he(t),t=Math.max(t,4);const e=new Float32Array(t*t*4);e.set(this.boneMatrices);const n=new ul(e,t,t,W,G);return n.name="Skeleton.bone",n.needsUpdate=!0,this.boneMatrices=e,this.boneTexture=n,this.boneTextureSize=t,this}getBoneByName(t){for(let e=0,n=this.bones.length;e<n;e++){const n=this.bones[e];if(n.name===t)return n}}dispose(){null!==this.boneTexture&&(this.boneTexture.dispose(),this.boneTexture=null)}}let Al=class extends Oo{constructor(t,e,n,o=1){super(t,e,n),this.isInstancedBufferAttribute=!0,this.meshPerAttribute=o}copy(t){return super.copy(t),this.meshPerAttribute=t.meshPerAttribute,this}};const vl=new Hn,ml=new Hn,pl=[],gl=new Hn,_l=new hi;class El extends Lo{constructor(t){super(),this.isLineBasicMaterial=!0,this.type="LineBasicMaterial",this.color=new tn(16777215),this.linewidth=1,this.linecap="round",this.linejoin="round",this.fog=!0,this.setValues(t)}copy(t){return super.copy(t),this.color.copy(t.color),this.linewidth=t.linewidth,this.linecap=t.linecap,this.linejoin=t.linejoin,this.fog=t.fog,this}}const Cl=new An,wl=new An,xl=new Hn,Il=new kn,Ml=new Pn;class Sl extends mo{constructor(t=new Xo,e=new El){super(),this.isLine=!0,this.type="Line",this.geometry=t,this.material=e,this.updateMorphTargets()}copy(t,e){return super.copy(t,e),this.material=t.material,this.geometry=t.geometry,this}computeLineDistances(){const t=this.geometry;if(null===t.index){const e=t.attributes.position,n=[0];for(let t=1,o=e.count;t<o;t++)Cl.fromBufferAttribute(e,t-1),wl.fromBufferAttribute(e,t),n[t]=n[t-1],n[t]+=Cl.distanceTo(wl);t.setAttribute("lineDistance",new Vo(n,1))}else console.warn("v3d.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");return this}raycast(t,e){const n=this.geometry,o=this.matrixWorld,i=t.params.Line.threshold,r=n.drawRange;if(null===n.boundingSphere&&n.computeBoundingSphere(),Ml.copy(n.boundingSphere),Ml.applyMatrix4(o),Ml.radius+=i,!1===t.ray.intersectsSphere(Ml))return;xl.copy(o).invert(),Il.copy(t.ray).applyMatrix4(xl);const s=i/((this.scale.x+this.scale.y+this.scale.z)/3),a=s*s,l=new An,c=new An,u=new An,h=new An,f=this.isLineSegments?2:1,d=n.index,A=n.attributes.position;if(null!==d){for(let n=Math.max(0,r.start),o=Math.min(d.count,r.start+r.count)-1;n<o;n+=f){const o=d.getX(n),i=d.getX(n+1);l.fromBufferAttribute(A,o),c.fromBufferAttribute(A,i);if(Il.distanceSqToSegment(l,c,h,u)>a)continue;h.applyMatrix4(this.matrixWorld);const r=t.ray.origin.distanceTo(h);r<t.near||r>t.far||e.push({distance:r,point:u.clone().applyMatrix4(this.matrixWorld),index:n,face:null,faceIndex:null,object:this})}}else{for(let n=Math.max(0,r.start),o=Math.min(A.count,r.start+r.count)-1;n<o;n+=f){l.fromBufferAttribute(A,n),c.fromBufferAttribute(A,n+1);if(Il.distanceSqToSegment(l,c,h,u)>a)continue;h.applyMatrix4(this.matrixWorld);const o=t.ray.origin.distanceTo(h);o<t.near||o>t.far||e.push({distance:o,point:u.clone().applyMatrix4(this.matrixWorld),index:n,face:null,faceIndex:null,object:this})}}}updateMorphTargets(){const t=this.geometry.morphAttributes,e=Object.keys(t);if(e.length>0){const n=t[e[0]];if(void 0!==n){this.morphTargetInfluences=[],this.morphTargetDictionary={};for(let t=0,e=n.length;t<e;t++){const e=n[t].name||String(t);this.morphTargetInfluences.push(0),this.morphTargetDictionary[e]=t}}}}}const bl=new An,yl=new An;class Rl extends Sl{constructor(t,e){super(t,e),this.isLineSegments=!0,this.type="LineSegments"}computeLineDistances(){const t=this.geometry;if(null===t.index){const e=t.attributes.position,n=[];for(let t=0,o=e.count;t<o;t+=2)bl.fromBufferAttribute(e,t),yl.fromBufferAttribute(e,t+1),n[t]=0===t?0:n[t-1],n[t+1]=n[t]+bl.distanceTo(yl);t.setAttribute("lineDistance",new Vo(n,1))}else console.warn("v3d.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");return this}}class Tl extends Sl{constructor(t,e){super(t,e),this.isLineLoop=!0,this.type="LineLoop"}}class Bl extends Lo{constructor(t){super(),this.isPointsMaterial=!0,this.type="PointsMaterial",this.color=new tn(16777215),this.map=null,this.alphaMap=null,this.size=1,this.sizeAttenuation=!0,this.fog=!0,this.setValues(t)}copy(t){return super.copy(t),this.color.copy(t.color),this.map=t.map,this.alphaMap=t.alphaMap,this.size=t.size,this.sizeAttenuation=t.sizeAttenuation,this.fog=t.fog,this}}const Ll=new Hn,Nl=new kn,Dl=new Pn,Pl=new An;class Ol extends mo{constructor(t=new Xo,e=new Bl){super(),this.isPoints=!0,this.type="Points",this.geometry=t,this.material=e,this.updateMorphTargets()}copy(t,e){return super.copy(t,e),this.material=t.material,this.geometry=t.geometry,this}raycast(t,e){const n=this.geometry,o=this.matrixWorld,i=t.params.Points.threshold,r=n.drawRange;if(null===n.boundingSphere&&n.computeBoundingSphere(),Dl.copy(n.boundingSphere),Dl.applyMatrix4(o),Dl.radius+=i,!1===t.ray.intersectsSphere(Dl))return;Ll.copy(o).invert(),Nl.copy(t.ray).applyMatrix4(Ll);const s=i/((this.scale.x+this.scale.y+this.scale.z)/3),a=s*s,l=n.index,c=n.attributes.position;if(null!==l){for(let n=Math.max(0,r.start),i=Math.min(l.count,r.start+r.count);n<i;n++){const i=l.getX(n);Pl.fromBufferAttribute(c,i),Fl(Pl,i,a,o,t,e,this)}}else{for(let n=Math.max(0,r.start),i=Math.min(c.count,r.start+r.count);n<i;n++)Pl.fromBufferAttribute(c,n),Fl(Pl,n,a,o,t,e,this)}}updateMorphTargets(){const t=this.geometry.morphAttributes,e=Object.keys(t);if(e.length>0){const n=t[e[0]];if(void 0!==n){this.morphTargetInfluences=[],this.morphTargetDictionary={};for(let t=0,e=n.length;t<e;t++){const e=n[t].name||String(t);this.morphTargetInfluences.push(0),this.morphTargetDictionary[e]=t}}}}}function Fl(t,e,n,o,i,r,s){const a=Nl.distanceSqToPoint(t);if(a<n){const n=new An;Nl.closestPointToPoint(t,n),n.applyMatrix4(o);const l=i.ray.origin.distanceTo(n);if(l<i.near||l>i.far)return;r.push({distance:l,distanceToRay:Math.sqrt(a),point:n,index:e,face:null,object:s})}}class Ul extends an{constructor(t,e,n,o,i,r,s,a,l,c,u,h){super(null,r,s,a,l,c,o,i,u,h),this.isCompressedTexture=!0,this.image={width:e,height:n},this.mipmaps=t,this.flipY=!1,this.generateMipmaps=!1}}class Vl extends an{constructor(t,e,n,o,i,r,s,a,l){super(t,e,n,o,i,r,s,a,l),this.isCanvasTexture=!0,this.needsUpdate=!0}}class Gl{constructor(){this.type="Curve",this.arcLengthDivisions=200}getPoint(){return console.warn("v3d.Curve: .getPoint() not implemented."),null}getPointAt(t,e){const n=this.getUtoTmapping(t);return this.getPoint(n,e)}getPoints(t=5){const e=[];for(let n=0;n<=t;n++)e.push(this.getPoint(n/t));return e}getSpacedPoints(t=5){const e=[];for(let n=0;n<=t;n++)e.push(this.getPointAt(n/t));return e}getLength(){const t=this.getLengths();return t[t.length-1]}getLengths(t=this.arcLengthDivisions){if(this.cacheArcLengths&&this.cacheArcLengths.length===t+1&&!this.needsUpdate)return this.cacheArcLengths;this.needsUpdate=!1;const e=[];let n,o=this.getPoint(0),i=0;e.push(0);for(let r=1;r<=t;r++)n=this.getPoint(r/t),i+=n.distanceTo(o),e.push(i),o=n;return this.cacheArcLengths=e,e}updateArcLengths(){this.needsUpdate=!0,this.getLengths()}getUtoTmapping(t,e){const n=this.getLengths();let o=0;const i=n.length;let r;r=e||t*n[i-1];let s,a=0,l=i-1;for(;a<=l;)if(o=Math.floor(a+(l-a)/2),s=n[o]-r,s<0)a=o+1;else{if(!(s>0)){l=o;break}l=o-1}if(o=l,n[o]===r)return o/(i-1);const c=n[o];return(o+(r-c)/(n[o+1]-c))/(i-1)}getTangent(t,e){const n=1e-4;let o=t-n,i=t+n;o<0&&(o=0),i>1&&(i=1);const r=this.getPoint(o),s=this.getPoint(i),a=e||(r.isVector2?new we:new An);return a.copy(s).sub(r).normalize(),a}getTangentAt(t,e){const n=this.getUtoTmapping(t);return this.getTangent(n,e)}computeFrenetFrames(t,e){const n=new An,o=[],i=[],r=[],s=new An,a=new Hn;for(let e=0;e<=t;e++){const n=e/t;o[e]=this.getTangentAt(n,new An)}i[0]=new An,r[0]=new An;let l=Number.MAX_VALUE;const c=Math.abs(o[0].x),u=Math.abs(o[0].y),h=Math.abs(o[0].z);c<=l&&(l=c,n.set(1,0,0)),u<=l&&(l=u,n.set(0,1,0)),h<=l&&n.set(0,0,1),s.crossVectors(o[0],n).normalize(),i[0].crossVectors(o[0],s),r[0].crossVectors(o[0],i[0]);for(let e=1;e<=t;e++){if(i[e]=i[e-1].clone(),r[e]=r[e-1].clone(),s.crossVectors(o[e-1],o[e]),s.length()>Number.EPSILON){s.normalize();const t=Math.acos(ie(o[e-1].dot(o[e]),-1,1));i[e].applyMatrix4(a.makeRotationAxis(s,t))}r[e].crossVectors(o[e],i[e])}if(!0===e){let e=Math.acos(ie(i[0].dot(i[t]),-1,1));e/=t,o[0].dot(s.crossVectors(i[0],i[t]))>0&&(e=-e);for(let n=1;n<=t;n++)i[n].applyMatrix4(a.makeRotationAxis(o[n],e*n)),r[n].crossVectors(o[n],i[n])}return{tangents:o,normals:i,binormals:r}}clone(){return(new this.constructor).copy(this)}copy(t){return this.arcLengthDivisions=t.arcLengthDivisions,this}}class Ql extends Gl{constructor(t=0,e=0,n=1,o=1,i=0,r=2*Math.PI,s=!1,a=0){super(),this.isEllipseCurve=!0,this.type="EllipseCurve",this.aX=t,this.aY=e,this.xRadius=n,this.yRadius=o,this.aStartAngle=i,this.aEndAngle=r,this.aClockwise=s,this.aRotation=a}getPoint(t,e){const n=e||new we,o=2*Math.PI;let i=this.aEndAngle-this.aStartAngle;const r=Math.abs(i)<Number.EPSILON;for(;i<0;)i+=o;for(;i>o;)i-=o;i<Number.EPSILON&&(i=r?0:o),!0!==this.aClockwise||r||(i===o?i=-o:i-=o);const s=this.aStartAngle+t*i;let a=this.aX+this.xRadius*Math.cos(s),l=this.aY+this.yRadius*Math.sin(s);if(0!==this.aRotation){const t=Math.cos(this.aRotation),e=Math.sin(this.aRotation),n=a-this.aX,o=l-this.aY;a=n*t-o*e+this.aX,l=n*e+o*t+this.aY}return n.set(a,l)}copy(t){return super.copy(t),this.aX=t.aX,this.aY=t.aY,this.xRadius=t.xRadius,this.yRadius=t.yRadius,this.aStartAngle=t.aStartAngle,this.aEndAngle=t.aEndAngle,this.aClockwise=t.aClockwise,this.aRotation=t.aRotation,this}}function zl(){let t=0,e=0,n=0,o=0;function i(i,r,s,a){t=i,e=s,n=-3*i+3*r-2*s-a,o=2*i-2*r+s+a}return{initCatmullRom:function(t,e,n,o,r){i(e,n,r*(n-t),r*(o-e))},initNonuniformCatmullRom:function(t,e,n,o,r,s,a){let l=(e-t)/r-(n-t)/(r+s)+(n-e)/s,c=(n-e)/s-(o-e)/(s+a)+(o-n)/a;l*=s,c*=s,i(e,n,l,c)},calc:function(i){const r=i*i;return t+e*i+n*r+o*(r*i)}}}const kl=new An,Hl=new zl,Wl=new zl,Yl=new zl;function Xl(t,e,n,o,i){const r=.5*(o-e),s=.5*(i-n),a=t*t;return(2*n-2*o+r+s)*(t*a)+(-3*n+3*o-2*r-s)*a+r*t+n}function Kl(t,e,n,o){return function(t,e){const n=1-t;return n*n*e}(t,e)+function(t,e){return 2*(1-t)*t*e}(t,n)+function(t,e){return t*t*e}(t,o)}function jl(t,e,n,o,i){return function(t,e){const n=1-t;return n*n*n*e}(t,e)+function(t,e){const n=1-t;return 3*n*n*t*e}(t,n)+function(t,e){return 3*(1-t)*t*t*e}(t,o)+function(t,e){return t*t*t*e}(t,i)}class Zl extends Gl{constructor(t=new we,e=new we,n=new we,o=new we){super(),this.isCubicBezierCurve=!0,this.type="CubicBezierCurve",this.v0=t,this.v1=e,this.v2=n,this.v3=o}getPoint(t,e=new we){const n=e,o=this.v0,i=this.v1,r=this.v2,s=this.v3;return n.set(jl(t,o.x,i.x,r.x,s.x),jl(t,o.y,i.y,r.y,s.y)),n}copy(t){return super.copy(t),this.v0.copy(t.v0),this.v1.copy(t.v1),this.v2.copy(t.v2),this.v3.copy(t.v3),this}}class ql extends Gl{constructor(t=new we,e=new we){super(),this.isLineCurve=!0,this.type="LineCurve",this.v1=t,this.v2=e}getPoint(t,e=new we){const n=e;return 1===t?n.copy(this.v2):(n.copy(this.v2).sub(this.v1),n.multiplyScalar(t).add(this.v1)),n}getPointAt(t,e){return this.getPoint(t,e)}getTangent(t,e){const n=e||new we;return n.copy(this.v2).sub(this.v1).normalize(),n}copy(t){return super.copy(t),this.v1.copy(t.v1),this.v2.copy(t.v2),this}}class Jl extends Gl{constructor(t=new we,e=new we,n=new we){super(),this.isQuadraticBezierCurve=!0,this.type="QuadraticBezierCurve",this.v0=t,this.v1=e,this.v2=n}getPoint(t,e=new we){const n=e,o=this.v0,i=this.v1,r=this.v2;return n.set(Kl(t,o.x,i.x,r.x),Kl(t,o.y,i.y,r.y)),n}copy(t){return super.copy(t),this.v0.copy(t.v0),this.v1.copy(t.v1),this.v2.copy(t.v2),this}}class $l extends Gl{constructor(t=new An,e=new An,n=new An){super(),this.isQuadraticBezierCurve3=!0,this.type="QuadraticBezierCurve3",this.v0=t,this.v1=e,this.v2=n}getPoint(t,e=new An){const n=e,o=this.v0,i=this.v1,r=this.v2;return n.set(Kl(t,o.x,i.x,r.x),Kl(t,o.y,i.y,r.y),Kl(t,o.z,i.z,r.z)),n}copy(t){return super.copy(t),this.v0.copy(t.v0),this.v1.copy(t.v1),this.v2.copy(t.v2),this}}class tc extends Gl{constructor(t=[]){super(),this.isSplineCurve=!0,this.type="SplineCurve",this.points=t}getPoint(t,e=new we){const n=e,o=this.points,i=(o.length-1)*t,r=Math.floor(i),s=i-r,a=o[0===r?r:r-1],l=o[r],c=o[r>o.length-2?o.length-1:r+1],u=o[r>o.length-3?o.length-1:r+2];return n.set(Xl(s,a.x,l.x,c.x,u.x),Xl(s,a.y,l.y,c.y,u.y)),n}copy(t){super.copy(t),this.points=[];for(let e=0,n=t.points.length;e<n;e++){const n=t.points[e];this.points.push(n.clone())}return this}}class ec extends Gl{constructor(){super(),this.type="CurvePath",this.curves=[],this.autoClose=!1}add(t){this.curves.push(t)}closePath(){const t=this.curves[0].getPoint(0),e=this.curves[this.curves.length-1].getPoint(1);t.equals(e)||this.curves.push(new ql(e,t))}getPoint(t,e){const n=t*this.getLength(),o=this.getCurveLengths();let i=0;for(;i<o.length;){if(o[i]>=n){const t=o[i]-n,r=this.curves[i],s=r.getLength(),a=0===s?0:1-t/s;return r.getPointAt(a,e)}i++}return null}getLength(){const t=this.getCurveLengths();return t[t.length-1]}updateArcLengths(){this.needsUpdate=!0,this.cacheLengths=null,this.getCurveLengths()}getCurveLengths(){if(this.cacheLengths&&this.cacheLengths.length===this.curves.length)return this.cacheLengths;const t=[];let e=0;for(let n=0,o=this.curves.length;n<o;n++)e+=this.curves[n].getLength(),t.push(e);return this.cacheLengths=t,t}getSpacedPoints(t=40){const e=[];for(let n=0;n<=t;n++)e.push(this.getPoint(n/t));return this.autoClose&&e.push(e[0]),e}getPoints(t=12){const e=[];let n;for(let o=0,i=this.curves;o<i.length;o++){const r=i[o],s=r.isEllipseCurve?2*t:r.isLineCurve||r.isLineCurve3?1:r.isSplineCurve?t*r.points.length:t,a=r.getPoints(s);for(let t=0;t<a.length;t++){const o=a[t];n&&n.equals(o)||(e.push(o),n=o)}}return this.autoClose&&e.length>1&&!e[e.length-1].equals(e[0])&&e.push(e[0]),e}copy(t){super.copy(t),this.curves=[];for(let e=0,n=t.curves.length;e<n;e++){const n=t.curves[e];this.curves.push(n.clone())}return this.autoClose=t.autoClose,this}}class nc extends ec{constructor(t){super(),this.type="Path",this.currentPoint=new we,t&&this.setFromPoints(t)}setFromPoints(t){this.moveTo(t[0].x,t[0].y);for(let e=1,n=t.length;e<n;e++)this.lineTo(t[e].x,t[e].y);return this}moveTo(t,e){return this.currentPoint.set(t,e),this}lineTo(t,e){const n=new ql(this.currentPoint.clone(),new we(t,e));return this.curves.push(n),this.currentPoint.set(t,e),this}quadraticCurveTo(t,e,n,o){const i=new Jl(this.currentPoint.clone(),new we(t,e),new we(n,o));return this.curves.push(i),this.currentPoint.set(n,o),this}bezierCurveTo(t,e,n,o,i,r){const s=new Zl(this.currentPoint.clone(),new we(t,e),new we(n,o),new we(i,r));return this.curves.push(s),this.currentPoint.set(i,r),this}splineThru(t){const e=[this.currentPoint.clone()].concat(t),n=new tc(e);return this.curves.push(n),this.currentPoint.copy(t[t.length-1]),this}arc(t,e,n,o,i,r){const s=this.currentPoint.x,a=this.currentPoint.y;return this.absarc(t+s,e+a,n,o,i,r),this}absarc(t,e,n,o,i,r){return this.absellipse(t,e,n,n,o,i,r),this}ellipse(t,e,n,o,i,r,s,a){const l=this.currentPoint.x,c=this.currentPoint.y;return this.absellipse(t+l,e+c,n,o,i,r,s,a),this}absellipse(t,e,n,o,i,r,s,a){const l=new Ql(t,e,n,o,i,r,s,a);if(this.curves.length>0){const t=l.getPoint(0);t.equals(this.currentPoint)||this.lineTo(t.x,t.y)}this.curves.push(l);const c=l.getPoint(1);return this.currentPoint.copy(c),this}copy(t){return super.copy(t),this.currentPoint.copy(t.currentPoint),this}}class oc extends Xo{constructor(t=[new we(0,-.5),new we(.5,0),new we(0,.5)],e=12,n=0,o=2*Math.PI){super(),this.type="LatheGeometry",this.parameters={points:t,segments:e,phiStart:n,phiLength:o},e=Math.floor(e),o=ie(o,0,2*Math.PI);const i=[],r=[],s=[],a=[],l=[],c=1/e,u=new An,h=new we,f=new An,d=new An,A=new An;let v=0,m=0;for(let e=0;e<=t.length-1;e++)switch(e){case 0:v=t[e+1].x-t[e].x,m=t[e+1].y-t[e].y,f.x=1*m,f.y=-v,f.z=0*m,A.copy(f),f.normalize(),a.push(f.x,f.y,f.z);break;case t.length-1:a.push(A.x,A.y,A.z);break;default:v=t[e+1].x-t[e].x,m=t[e+1].y-t[e].y,f.x=1*m,f.y=-v,f.z=0*m,d.copy(f),f.x+=A.x,f.y+=A.y,f.z+=A.z,f.normalize(),a.push(f.x,f.y,f.z),A.copy(d)}for(let i=0;i<=e;i++){const f=n+i*c*o,d=Math.sin(f),A=Math.cos(f);for(let n=0;n<=t.length-1;n++){u.x=t[n].x*d,u.y=t[n].y,u.z=t[n].x*A,r.push(u.x,u.y,u.z),h.x=i/e,h.y=n/(t.length-1),s.push(h.x,h.y);const o=a[3*n+0]*d,c=a[3*n+1],f=a[3*n+0]*A;l.push(o,c,f)}}for(let n=0;n<e;n++)for(let e=0;e<t.length-1;e++){const o=e+n*t.length,r=o,s=o+t.length,a=o+t.length+1,l=o+1;i.push(r,s,l),i.push(a,l,s)}this.setIndex(i),this.setAttribute("position",new Vo(r,3)),this.setAttribute("uv",new Vo(s,2)),this.setAttribute("normal",new Vo(l,3))}}class ic extends Xo{constructor(t=1,e=1,n=1,o=32,i=1,r=!1,s=0,a=2*Math.PI){super(),this.type="CylinderGeometry",this.parameters={radiusTop:t,radiusBottom:e,height:n,radialSegments:o,heightSegments:i,openEnded:r,thetaStart:s,thetaLength:a};const l=this;o=Math.floor(o),i=Math.floor(i);const c=[],u=[],h=[],f=[];let d=0;const A=[],v=n/2;let m=0;function p(n){const i=d,r=new we,A=new An;let p=0;const g=!0===n?t:e,_=!0===n?1:-1;for(let t=1;t<=o;t++)u.push(0,v*_,0),h.push(0,_,0),f.push(.5,.5),d++;const E=d;for(let t=0;t<=o;t++){const e=t/o*a+s,n=Math.cos(e),i=Math.sin(e);A.x=g*i,A.y=v*_,A.z=g*n,u.push(A.x,A.y,A.z),h.push(0,_,0),r.x=.5*n+.5,r.y=.5*i*_+.5,f.push(r.x,r.y),d++}for(let t=0;t<o;t++){const e=i+t,o=E+t;!0===n?c.push(o,o+1,e):c.push(o+1,o,e),p+=3}l.addGroup(m,p,!0===n?1:2),m+=p}!function(){const r=new An,p=new An;let g=0;const _=(e-t)/n;for(let l=0;l<=i;l++){const c=[],m=l/i,g=m*(e-t)+t;for(let t=0;t<=o;t++){const e=t/o,i=e*a+s,l=Math.sin(i),A=Math.cos(i);p.x=g*l,p.y=-m*n+v,p.z=g*A,u.push(p.x,p.y,p.z),r.set(l,_,A).normalize(),h.push(r.x,r.y,r.z),f.push(e,1-m),c.push(d++)}A.push(c)}for(let t=0;t<o;t++)for(let e=0;e<i;e++){const n=A[e][t],o=A[e+1][t],i=A[e+1][t+1],r=A[e][t+1];c.push(n,o,r),c.push(o,i,r),g+=6}l.addGroup(m,g,0),m+=g}(),!1===r&&(t>0&&p(!0),e>0&&p(!1)),this.setIndex(c),this.setAttribute("position",new Vo(u,3)),this.setAttribute("normal",new Vo(h,3)),this.setAttribute("uv",new Vo(f,2))}}const rc=new An,sc=new An,ac=new An,lc=new To;class cc extends nc{constructor(t){super(t),this.uuid=ne(),this.type="Shape",this.holes=[]}getPointsHoles(t){const e=[];for(let n=0,o=this.holes.length;n<o;n++)e[n]=this.holes[n].getPoints(t);return e}extractPoints(t){return{shape:this.getPoints(t),holes:this.getPointsHoles(t)}}copy(t){super.copy(t),this.holes=[];for(let e=0,n=t.holes.length;e<n;e++){const n=t.holes[e];this.holes.push(n.clone())}return this}}const uc=function(t,e,n=2){const o=e&&e.length,i=o?e[0]*n:t.length;let r=hc(t,0,i,n,!0);const s=[];if(!r||r.next===r.prev)return s;let a,l,c,u,h,f,d;if(o&&(r=function(t,e,n,o){const i=[];let r,s,a,l,c;for(r=0,s=e.length;r<s;r++)a=e[r]*o,l=r<s-1?e[r+1]*o:t.length,c=hc(t,a,l,o,!1),c===c.next&&(c.steiner=!0),i.push(wc(c));for(i.sort(gc),r=0;r<i.length;r++)n=_c(i[r],n);return n}(t,e,r,n)),t.length>80*n){a=c=t[0],l=u=t[1];for(let e=n;e<i;e+=n)h=t[e],f=t[e+1],h<a&&(a=h),f<l&&(l=f),h>c&&(c=h),f>u&&(u=f);d=Math.max(c-a,u-l),d=0!==d?32767/d:0}return dc(r,s,n,a,l,d,0),s};function hc(t,e,n,o,i){let r,s;if(i===function(t,e,n,o){let i=0;for(let r=e,s=n-o;r<n;r+=o)i+=(t[s]-t[r])*(t[r+1]+t[s+1]),s=r;return i}(t,e,n,o)>0)for(r=e;r<n;r+=o)s=Lc(r,t[r],t[r+1],s);else for(r=n-o;r>=e;r-=o)s=Lc(r,t[r],t[r+1],s);return s&&Sc(s,s.next)&&(Nc(s),s=s.next),s}function fc(t,e){if(!t)return t;e||(e=t);let n,o=t;do{if(n=!1,o.steiner||!Sc(o,o.next)&&0!==Mc(o.prev,o,o.next))o=o.next;else{if(Nc(o),o=e=o.prev,o===o.next)break;n=!0}}while(n||o!==e);return e}function dc(t,e,n,o,i,r,s){if(!t)return;!s&&r&&function(t,e,n,o){let i=t;do{0===i.z&&(i.z=Cc(i.x,i.y,e,n,o)),i.prevZ=i.prev,i.nextZ=i.next,i=i.next}while(i!==t);i.prevZ.nextZ=null,i.prevZ=null,function(t){let e,n,o,i,r,s,a,l,c=1;do{for(n=t,t=null,r=null,s=0;n;){for(s++,o=n,a=0,e=0;e<c&&(a++,o=o.nextZ,o);e++);for(l=c;a>0||l>0&&o;)0!==a&&(0===l||!o||n.z<=o.z)?(i=n,n=n.nextZ,a--):(i=o,o=o.nextZ,l--),r?r.nextZ=i:t=i,i.prevZ=r,r=i;n=o}r.nextZ=null,c*=2}while(s>1)}(i)}(t,o,i,r);let a,l,c=t;for(;t.prev!==t.next;)if(a=t.prev,l=t.next,r?vc(t,o,i,r):Ac(t))e.push(a.i/n|0),e.push(t.i/n|0),e.push(l.i/n|0),Nc(t),t=l.next,c=l.next;else if((t=l)===c){s?1===s?dc(t=mc(fc(t),e,n),e,n,o,i,r,2):2===s&&pc(t,e,n,o,i,r):dc(fc(t),e,n,o,i,r,1);break}}function Ac(t){const e=t.prev,n=t,o=t.next;if(Mc(e,n,o)>=0)return!1;const i=e.x,r=n.x,s=o.x,a=e.y,l=n.y,c=o.y,u=i<r?i<s?i:s:r<s?r:s,h=a<l?a<c?a:c:l<c?l:c,f=i>r?i>s?i:s:r>s?r:s,d=a>l?a>c?a:c:l>c?l:c;let A=o.next;for(;A!==e;){if(A.x>=u&&A.x<=f&&A.y>=h&&A.y<=d&&xc(i,a,r,l,s,c,A.x,A.y)&&Mc(A.prev,A,A.next)>=0)return!1;A=A.next}return!0}function vc(t,e,n,o){const i=t.prev,r=t,s=t.next;if(Mc(i,r,s)>=0)return!1;const a=i.x,l=r.x,c=s.x,u=i.y,h=r.y,f=s.y,d=a<l?a<c?a:c:l<c?l:c,A=u<h?u<f?u:f:h<f?h:f,v=a>l?a>c?a:c:l>c?l:c,m=u>h?u>f?u:f:h>f?h:f,p=Cc(d,A,e,n,o),g=Cc(v,m,e,n,o);let _=t.prevZ,E=t.nextZ;for(;_&&_.z>=p&&E&&E.z<=g;){if(_.x>=d&&_.x<=v&&_.y>=A&&_.y<=m&&_!==i&&_!==s&&xc(a,u,l,h,c,f,_.x,_.y)&&Mc(_.prev,_,_.next)>=0)return!1;if(_=_.prevZ,E.x>=d&&E.x<=v&&E.y>=A&&E.y<=m&&E!==i&&E!==s&&xc(a,u,l,h,c,f,E.x,E.y)&&Mc(E.prev,E,E.next)>=0)return!1;E=E.nextZ}for(;_&&_.z>=p;){if(_.x>=d&&_.x<=v&&_.y>=A&&_.y<=m&&_!==i&&_!==s&&xc(a,u,l,h,c,f,_.x,_.y)&&Mc(_.prev,_,_.next)>=0)return!1;_=_.prevZ}for(;E&&E.z<=g;){if(E.x>=d&&E.x<=v&&E.y>=A&&E.y<=m&&E!==i&&E!==s&&xc(a,u,l,h,c,f,E.x,E.y)&&Mc(E.prev,E,E.next)>=0)return!1;E=E.nextZ}return!0}function mc(t,e,n){let o=t;do{const i=o.prev,r=o.next.next;!Sc(i,r)&&bc(i,o,o.next,r)&&Tc(i,r)&&Tc(r,i)&&(e.push(i.i/n|0),e.push(o.i/n|0),e.push(r.i/n|0),Nc(o),Nc(o.next),o=t=r),o=o.next}while(o!==t);return fc(o)}function pc(t,e,n,o,i,r){let s=t;do{let t=s.next.next;for(;t!==s.prev;){if(s.i!==t.i&&Ic(s,t)){let a=Bc(s,t);return s=fc(s,s.next),a=fc(a,a.next),dc(s,e,n,o,i,r,0),void dc(a,e,n,o,i,r,0)}t=t.next}s=s.next}while(s!==t)}function gc(t,e){return t.x-e.x}function _c(t,e){const n=function(t,e){let n,o=e,i=-1/0;const r=t.x,s=t.y;do{if(s<=o.y&&s>=o.next.y&&o.next.y!==o.y){const t=o.x+(s-o.y)*(o.next.x-o.x)/(o.next.y-o.y);if(t<=r&&t>i&&(i=t,n=o.x<o.next.x?o:o.next,t===r))return n}o=o.next}while(o!==e);if(!n)return null;const a=n,l=n.x,c=n.y;let u,h=1/0;o=n;do{r>=o.x&&o.x>=l&&r!==o.x&&xc(s<c?r:i,s,l,c,s<c?i:r,s,o.x,o.y)&&(u=Math.abs(s-o.y)/(r-o.x),Tc(o,t)&&(u<h||u===h&&(o.x>n.x||o.x===n.x&&Ec(n,o)))&&(n=o,h=u)),o=o.next}while(o!==a);return n}(t,e);if(!n)return e;const o=Bc(n,t);return fc(o,o.next),fc(n,n.next)}function Ec(t,e){return Mc(t.prev,t,e.prev)<0&&Mc(e.next,t,t.next)<0}function Cc(t,e,n,o,i){return(t=1431655765&((t=858993459&((t=252645135&((t=16711935&((t=(t-n)*i|0)|t<<8))|t<<4))|t<<2))|t<<1))|(e=1431655765&((e=858993459&((e=252645135&((e=16711935&((e=(e-o)*i|0)|e<<8))|e<<4))|e<<2))|e<<1))<<1}function wc(t){let e=t,n=t;do{(e.x<n.x||e.x===n.x&&e.y<n.y)&&(n=e),e=e.next}while(e!==t);return n}function xc(t,e,n,o,i,r,s,a){return(i-s)*(e-a)>=(t-s)*(r-a)&&(t-s)*(o-a)>=(n-s)*(e-a)&&(n-s)*(r-a)>=(i-s)*(o-a)}function Ic(t,e){return t.next.i!==e.i&&t.prev.i!==e.i&&!function(t,e){let n=t;do{if(n.i!==t.i&&n.next.i!==t.i&&n.i!==e.i&&n.next.i!==e.i&&bc(n,n.next,t,e))return!0;n=n.next}while(n!==t);return!1}(t,e)&&(Tc(t,e)&&Tc(e,t)&&function(t,e){let n=t,o=!1;const i=(t.x+e.x)/2,r=(t.y+e.y)/2;do{n.y>r!=n.next.y>r&&n.next.y!==n.y&&i<(n.next.x-n.x)*(r-n.y)/(n.next.y-n.y)+n.x&&(o=!o),n=n.next}while(n!==t);return o}(t,e)&&(Mc(t.prev,t,e.prev)||Mc(t,e.prev,e))||Sc(t,e)&&Mc(t.prev,t,t.next)>0&&Mc(e.prev,e,e.next)>0)}function Mc(t,e,n){return(e.y-t.y)*(n.x-e.x)-(e.x-t.x)*(n.y-e.y)}function Sc(t,e){return t.x===e.x&&t.y===e.y}function bc(t,e,n,o){const i=Rc(Mc(t,e,n)),r=Rc(Mc(t,e,o)),s=Rc(Mc(n,o,t)),a=Rc(Mc(n,o,e));return i!==r&&s!==a||(!(0!==i||!yc(t,n,e))||(!(0!==r||!yc(t,o,e))||(!(0!==s||!yc(n,t,o))||!(0!==a||!yc(n,e,o)))))}function yc(t,e,n){return e.x<=Math.max(t.x,n.x)&&e.x>=Math.min(t.x,n.x)&&e.y<=Math.max(t.y,n.y)&&e.y>=Math.min(t.y,n.y)}function Rc(t){return t>0?1:t<0?-1:0}function Tc(t,e){return Mc(t.prev,t,t.next)<0?Mc(t,e,t.next)>=0&&Mc(t,t.prev,e)>=0:Mc(t,e,t.prev)<0||Mc(t,t.next,e)<0}function Bc(t,e){const n=new Dc(t.i,t.x,t.y),o=new Dc(e.i,e.x,e.y),i=t.next,r=e.prev;return t.next=e,e.prev=t,n.next=i,i.prev=n,o.next=n,n.prev=o,r.next=o,o.prev=r,o}function Lc(t,e,n,o){const i=new Dc(t,e,n);return o?(i.next=o.next,i.prev=o,o.next.prev=i,o.next=i):(i.prev=i,i.next=i),i}function Nc(t){t.next.prev=t.prev,t.prev.next=t.next,t.prevZ&&(t.prevZ.nextZ=t.nextZ),t.nextZ&&(t.nextZ.prevZ=t.prevZ)}function Dc(t,e,n){this.i=t,this.x=e,this.y=n,this.prev=null,this.next=null,this.z=0,this.prevZ=null,this.nextZ=null,this.steiner=!1}class Pc{static area(t){const e=t.length;let n=0;for(let o=e-1,i=0;i<e;o=i++)n+=t[o].x*t[i].y-t[i].x*t[o].y;return.5*n}static isClockWise(t){return Pc.area(t)<0}static triangulateShape(t,e){const n=[],o=[],i=[];Oc(t),Fc(n,t);let r=t.length;e.forEach(Oc);for(let t=0;t<e.length;t++)o.push(r),r+=e[t].length,Fc(n,e[t]);const s=uc(n,o);for(let t=0;t<s.length;t+=3)i.push(s.slice(t,t+3));return i}}function Oc(t){const e=t.length;e>2&&t[e-1].equals(t[0])&&t.pop()}function Fc(t,e){for(let n=0;n<e.length;n++)t.push(e[n].x),t.push(e[n].y)}class Uc extends Xo{constructor(t=new cc([new we(.5,.5),new we(-.5,.5),new we(-.5,-.5),new we(.5,-.5)]),e={}){super(),this.type="ExtrudeGeometry",this.parameters={shapes:t,options:e},t=Array.isArray(t)?t:[t];const n=this,o=[],i=[];for(let e=0,n=t.length;e<n;e++){r(t[e])}function r(t){const r=[],s=void 0!==e.curveSegments?e.curveSegments:12,a=void 0!==e.steps?e.steps:1,l=void 0!==e.depth?e.depth:1;let c=void 0===e.bevelEnabled||e.bevelEnabled,u=void 0!==e.bevelThickness?e.bevelThickness:.2,h=void 0!==e.bevelSize?e.bevelSize:u-.1,f=void 0!==e.bevelOffset?e.bevelOffset:0,d=void 0!==e.bevelSegments?e.bevelSegments:3;const A=e.extrudePath,v=void 0!==e.UVGenerator?e.UVGenerator:Vc;let m,p,g,_,E,C=!1;A&&(m=A.getSpacedPoints(a),C=!0,c=!1,p=A.computeFrenetFrames(a,!1),g=new An,_=new An,E=new An),c||(d=0,u=0,h=0,f=0);const w=t.extractPoints(s);let x=w.shape;const I=w.holes;if(!Pc.isClockWise(x)){x=x.reverse();for(let t=0,e=I.length;t<e;t++){const e=I[t];Pc.isClockWise(e)&&(I[t]=e.reverse())}}const M=Pc.triangulateShape(x,I),S=x;for(let t=0,e=I.length;t<e;t++){const e=I[t];x=x.concat(e)}function b(t,e,n){return e||console.error("v3d.ExtrudeGeometry: vec does not exist"),e.clone().multiplyScalar(n).add(t)}const y=x.length,R=M.length;function T(t,e,n){let o,i,r;const s=t.x-e.x,a=t.y-e.y,l=n.x-t.x,c=n.y-t.y,u=s*s+a*a,h=s*c-a*l;if(Math.abs(h)>Number.EPSILON){const h=Math.sqrt(u),f=Math.sqrt(l*l+c*c),d=e.x-a/h,A=e.y+s/h,v=((n.x-c/f-d)*c-(n.y+l/f-A)*l)/(s*c-a*l);o=d+s*v-t.x,i=A+a*v-t.y;const m=o*o+i*i;if(m<=2)return new we(o,i);r=Math.sqrt(m/2)}else{let t=!1;s>Number.EPSILON?l>Number.EPSILON&&(t=!0):s<-Number.EPSILON?l<-Number.EPSILON&&(t=!0):Math.sign(a)===Math.sign(c)&&(t=!0),t?(o=-a,i=s,r=Math.sqrt(u)):(o=s,i=a,r=Math.sqrt(u/2))}return new we(o/r,i/r)}const B=[];for(let t=0,e=S.length,n=e-1,o=t+1;t<e;t++,n++,o++)n===e&&(n=0),o===e&&(o=0),B[t]=T(S[t],S[n],S[o]);const L=[];let N,D=B.concat();for(let t=0,e=I.length;t<e;t++){const e=I[t];N=[];for(let t=0,n=e.length,o=n-1,i=t+1;t<n;t++,o++,i++)o===n&&(o=0),i===n&&(i=0),N[t]=T(e[t],e[o],e[i]);L.push(N),D=D.concat(N)}for(let t=0;t<d;t++){const e=t/d,n=u*Math.cos(e*Math.PI/2),o=h*Math.sin(e*Math.PI/2)+f;for(let t=0,e=S.length;t<e;t++){const e=b(S[t],B[t],o);F(e.x,e.y,-n)}for(let t=0,e=I.length;t<e;t++){const e=I[t];N=L[t];for(let t=0,i=e.length;t<i;t++){const i=b(e[t],N[t],o);F(i.x,i.y,-n)}}}const P=h+f;for(let t=0;t<y;t++){const e=c?b(x[t],D[t],P):x[t];C?(_.copy(p.normals[0]).multiplyScalar(e.x),g.copy(p.binormals[0]).multiplyScalar(e.y),E.copy(m[0]).add(_).add(g),F(E.x,E.y,E.z)):F(e.x,e.y,0)}for(let t=1;t<=a;t++)for(let e=0;e<y;e++){const n=c?b(x[e],D[e],P):x[e];C?(_.copy(p.normals[t]).multiplyScalar(n.x),g.copy(p.binormals[t]).multiplyScalar(n.y),E.copy(m[t]).add(_).add(g),F(E.x,E.y,E.z)):F(n.x,n.y,l/a*t)}for(let t=d-1;t>=0;t--){const e=t/d,n=u*Math.cos(e*Math.PI/2),o=h*Math.sin(e*Math.PI/2)+f;for(let t=0,e=S.length;t<e;t++){const e=b(S[t],B[t],o);F(e.x,e.y,l+n)}for(let t=0,e=I.length;t<e;t++){const e=I[t];N=L[t];for(let t=0,i=e.length;t<i;t++){const i=b(e[t],N[t],o);C?F(i.x,i.y+m[a-1].y,m[a-1].x+n):F(i.x,i.y,l+n)}}}function O(t,e){let n=t.length;for(;--n>=0;){const o=n;let i=n-1;i<0&&(i=t.length-1);for(let t=0,n=a+2*d;t<n;t++){const n=y*t,r=y*(t+1);V(e+o+n,e+i+n,e+i+r,e+o+r)}}}function F(t,e,n){r.push(t),r.push(e),r.push(n)}function U(t,e,i){G(t),G(e),G(i);const r=o.length/3,s=v.generateTopUV(n,o,r-3,r-2,r-1);Q(s[0]),Q(s[1]),Q(s[2])}function V(t,e,i,r){G(t),G(e),G(r),G(e),G(i),G(r);const s=o.length/3,a=v.generateSideWallUV(n,o,s-6,s-3,s-2,s-1);Q(a[0]),Q(a[1]),Q(a[3]),Q(a[1]),Q(a[2]),Q(a[3])}function G(t){o.push(r[3*t+0]),o.push(r[3*t+1]),o.push(r[3*t+2])}function Q(t){i.push(t.x),i.push(t.y)}!function(){const t=o.length/3;if(c){let t=0,e=y*t;for(let t=0;t<R;t++){const n=M[t];U(n[2]+e,n[1]+e,n[0]+e)}t=a+2*d,e=y*t;for(let t=0;t<R;t++){const n=M[t];U(n[0]+e,n[1]+e,n[2]+e)}}else{for(let t=0;t<R;t++){const e=M[t];U(e[2],e[1],e[0])}for(let t=0;t<R;t++){const e=M[t];U(e[0]+y*a,e[1]+y*a,e[2]+y*a)}}n.addGroup(t,o.length/3-t,0)}(),function(){const t=o.length/3;let e=0;O(S,e),e+=S.length;for(let t=0,n=I.length;t<n;t++){const n=I[t];O(n,e),e+=n.length}n.addGroup(t,o.length/3-t,1)}()}this.setAttribute("position",new Vo(o,3)),this.setAttribute("uv",new Vo(i,2)),this.computeVertexNormals()}}const Vc={generateTopUV:function(t,e,n,o,i){const r=e[3*n],s=e[3*n+1],a=e[3*o],l=e[3*o+1],c=e[3*i],u=e[3*i+1];return[new we(r,s),new we(a,l),new we(c,u)]},generateSideWallUV:function(t,e,n,o,i,r){const s=e[3*n],a=e[3*n+1],l=e[3*n+2],c=e[3*o],u=e[3*o+1],h=e[3*o+2],f=e[3*i],d=e[3*i+1],A=e[3*i+2],v=e[3*r],m=e[3*r+1],p=e[3*r+2];return Math.abs(a-u)<Math.abs(s-c)?[new we(s,1-l),new we(c,1-h),new we(f,1-A),new we(v,1-p)]:[new we(a,1-l),new we(u,1-h),new we(d,1-A),new we(m,1-p)]}};class Gc extends Xo{constructor(t=[],e=[],n=1,o=0){super(),this.type="PolyhedronGeometry",this.parameters={vertices:t,indices:e,radius:n,detail:o};const i=[],r=[];function s(t,e,n,o){const i=o+1,r=[];for(let o=0;o<=i;o++){r[o]=[];const s=t.clone().lerp(n,o/i),a=e.clone().lerp(n,o/i),l=i-o;for(let t=0;t<=l;t++)r[o][t]=0===t&&o===i?s:s.clone().lerp(a,t/l)}for(let t=0;t<i;t++)for(let e=0;e<2*(i-t)-1;e++){const n=Math.floor(e/2);e%2==0?(a(r[t][n+1]),a(r[t+1][n]),a(r[t][n])):(a(r[t][n+1]),a(r[t+1][n+1]),a(r[t+1][n]))}}function a(t){i.push(t.x,t.y,t.z)}function l(e,n){const o=3*e;n.x=t[o+0],n.y=t[o+1],n.z=t[o+2]}function c(t,e,n,o){o<0&&1===t.x&&(r[e]=t.x-1),0===n.x&&0===n.z&&(r[e]=o/2/Math.PI+.5)}function u(t){return Math.atan2(t.z,-t.x)}function h(t){return Math.atan2(-t.y,Math.sqrt(t.x*t.x+t.z*t.z))}!function(t){const n=new An,o=new An,i=new An;for(let r=0;r<e.length;r+=3)l(e[r+0],n),l(e[r+1],o),l(e[r+2],i),s(n,o,i,t)}(o),function(t){const e=new An;for(let n=0;n<i.length;n+=3)e.x=i[n+0],e.y=i[n+1],e.z=i[n+2],e.normalize().multiplyScalar(t),i[n+0]=e.x,i[n+1]=e.y,i[n+2]=e.z}(n),function(){const t=new An;for(let e=0;e<i.length;e+=3){t.x=i[e+0],t.y=i[e+1],t.z=i[e+2];const n=u(t)/2/Math.PI+.5,o=h(t)/Math.PI+.5;r.push(n,1-o)}(function(){const t=new An,e=new An,n=new An,o=new An,s=new we,a=new we,l=new we;for(let h=0,f=0;h<i.length;h+=9,f+=6){t.set(i[h+0],i[h+1],i[h+2]),e.set(i[h+3],i[h+4],i[h+5]),n.set(i[h+6],i[h+7],i[h+8]),s.set(r[f+0],r[f+1]),a.set(r[f+2],r[f+3]),l.set(r[f+4],r[f+5]),o.copy(t).add(e).add(n).divideScalar(3);const d=u(o);c(s,f+0,t,d),c(a,f+2,e,d),c(l,f+4,n,d)}})(),function(){for(let t=0;t<r.length;t+=6){const e=r[t+0],n=r[t+2],o=r[t+4],i=Math.max(e,n,o),s=Math.min(e,n,o);i>.9&&s<.1&&(e<.2&&(r[t+0]+=1),n<.2&&(r[t+2]+=1),o<.2&&(r[t+4]+=1))}}()}(),this.setAttribute("position",new Vo(i,3)),this.setAttribute("normal",new Vo(i.slice(),3)),this.setAttribute("uv",new Vo(r,2)),0===o?this.computeVertexNormals():this.normalizeNormals()}}class Qc extends Xo{constructor(t=1,e=32,n=16,o=0,i=2*Math.PI,r=0,s=Math.PI){super(),this.type="SphereGeometry",this.parameters={radius:t,widthSegments:e,heightSegments:n,phiStart:o,phiLength:i,thetaStart:r,thetaLength:s},e=Math.max(3,Math.floor(e)),n=Math.max(2,Math.floor(n));const a=Math.min(r+s,Math.PI);let l=0;const c=[],u=new An,h=new An,f=[],d=[],A=[],v=[];for(let f=0;f<=n;f++){const m=[],p=f/n;let g=0;0==f&&0==r?g=.5/e:f==n&&a==Math.PI&&(g=-.5/e);for(let n=0;n<=e;n++){const a=n/e;u.x=-t*Math.cos(o+a*i)*Math.sin(r+p*s),u.y=t*Math.cos(r+p*s),u.z=t*Math.sin(o+a*i)*Math.sin(r+p*s),d.push(u.x,u.y,u.z),h.copy(u).normalize(),A.push(h.x,h.y,h.z),v.push(a+g,1-p),m.push(l++)}c.push(m)}for(let t=0;t<n;t++)for(let o=0;o<e;o++){const e=c[t][o+1],i=c[t][o],s=c[t+1][o],l=c[t+1][o+1];(0!==t||r>0)&&f.push(e,i,l),(t!==n-1||a<Math.PI)&&f.push(i,s,l)}this.setIndex(f),this.setAttribute("position",new Vo(d,3)),this.setAttribute("normal",new Vo(A,3)),this.setAttribute("uv",new Vo(v,2))}}class zc extends Uc{constructor(t,e={}){const n=e.font;if(!n||!n.isFont)return console.error("v3d.TextGeometry: font parameter is not an instance of v3d.Font."),new Xo;void 0===e.alignX&&(e.alignX="left"),void 0===e.alignY&&(e.alignY="topBaseline"),void 0===e.lineHeight&&(e.lineHeight=-1),void 0===e.scaledEmSize&&(e.scaledEmSize=!1);const o=n.generateShapes(t,e.size,e.alignX,e.alignY,e.lineHeight,e.scaledEmSize);e.depth=void 0!==e.height?e.height:50,void 0===e.bevelThickness&&(e.bevelThickness=10),void 0===e.bevelSize&&(e.bevelSize=8),void 0===e.bevelEnabled&&(e.bevelEnabled=!1),super(o,e),this.type="TextGeometry",this.parameters={text:t,parameters:e}}cloneWithText(t){const e=this.parameters.parameters;return new zc(t,{font:e.font,size:e.size,height:e.height,curveSegments:e.curveSegments,bevelEnabled:e.bevelEnabled,bevelThickness:e.bevelThickness,bevelSize:e.bevelSize,alignX:e.alignX,alignY:e.alignY,lineHeight:e.lineHeight,scaledEmSize:e.scaledEmSize})}}class kc extends Xo{constructor(t=null){if(super(),this.type="WireframeGeometry",this.parameters={geometry:t},null!==t){const e=[],n=new Set,o=new An,i=new An;if(null!==t.index){const r=t.attributes.position,s=t.index;let a=t.groups;0===a.length&&(a=[{start:0,count:s.count,materialIndex:0}]);for(let t=0,l=a.length;t<l;++t){const l=a[t],c=l.start;for(let t=c,a=c+l.count;t<a;t+=3)for(let a=0;a<3;a++){const l=s.getX(t+a),c=s.getX(t+(a+1)%3);o.fromBufferAttribute(r,l),i.fromBufferAttribute(r,c),!0===Hc(o,i,n)&&(e.push(o.x,o.y,o.z),e.push(i.x,i.y,i.z))}}}else{const r=t.attributes.position;for(let t=0,s=r.count/3;t<s;t++)for(let s=0;s<3;s++){const a=3*t+s,l=3*t+(s+1)%3;o.fromBufferAttribute(r,a),i.fromBufferAttribute(r,l),!0===Hc(o,i,n)&&(e.push(o.x,o.y,o.z),e.push(i.x,i.y,i.z))}}this.setAttribute("position",new Vo(e,3))}}}function Hc(t,e,n){const o=`${t.x},${t.y},${t.z}-${e.x},${e.y},${e.z}`,i=`${e.x},${e.y},${e.z}-${t.x},${t.y},${t.z}`;return!0!==n.has(o)&&!0!==n.has(i)&&(n.add(o),n.add(i),!0)}class Wc extends Lo{constructor(t){super(),this.isMeshStandardMaterial=!0,this.defines={STANDARD:""},this.type="MeshStandardMaterial",this.color=new tn(16777215),this.roughness=1,this.metalness=0,this.map=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.emissive=new tn(0),this.emissiveIntensity=1,this.emissiveMap=null,this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=0,this.normalScale=new we(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.roughnessMap=null,this.metalnessMap=null,this.alphaMap=null,this.envMap=null,this.envMapIntensity=1,this.wireframe=!1,this.wireframeLinewidth=1,this.flatShading=!1,this.fog=!0,this.envMapParallaxType=0,this.envMapParallaxMatrix=new Hn,this.envMapParallaxMatrixInv=new Hn,this.setValues(t)}copy(t){return super.copy(t),this.defines={STANDARD:""},this.color.copy(t.color),this.roughness=t.roughness,this.metalness=t.metalness,this.map=t.map,this.lightMap=t.lightMap,this.lightMapIntensity=t.lightMapIntensity,this.aoMap=t.aoMap,this.aoMapIntensity=t.aoMapIntensity,this.emissive.copy(t.emissive),this.emissiveMap=t.emissiveMap,this.emissiveIntensity=t.emissiveIntensity,this.bumpMap=t.bumpMap,this.bumpScale=t.bumpScale,this.normalMap=t.normalMap,this.normalMapType=t.normalMapType,this.normalScale.copy(t.normalScale),this.displacementMap=t.displacementMap,this.displacementScale=t.displacementScale,this.displacementBias=t.displacementBias,this.roughnessMap=t.roughnessMap,this.metalnessMap=t.metalnessMap,this.alphaMap=t.alphaMap,this.envMap=t.envMap,this.envMapIntensity=t.envMapIntensity,this.wireframe=t.wireframe,this.wireframeLinewidth=t.wireframeLinewidth,this.flatShading=t.flatShading,this.fog=t.fog,this.envMapParallaxType=t.envMapParallaxType,this.envMapParallaxMatrix.copy(t.envMapParallaxMatrix),this.envMapParallaxMatrixInv.copy(t.envMapParallaxMatrixInv),this}}class Yc extends Lo{constructor(t){super(),this.isMeshNormalMaterial=!0,this.type="MeshNormalMaterial",this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=0,this.normalScale=new we(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.wireframe=!1,this.wireframeLinewidth=1,this.flatShading=!1,this.setValues(t)}copy(t){return super.copy(t),this.bumpMap=t.bumpMap,this.bumpScale=t.bumpScale,this.normalMap=t.normalMap,this.normalMapType=t.normalMapType,this.normalScale.copy(t.normalScale),this.displacementMap=t.displacementMap,this.displacementScale=t.displacementScale,this.displacementBias=t.displacementBias,this.wireframe=t.wireframe,this.wireframeLinewidth=t.wireframeLinewidth,this.flatShading=t.flatShading,this}}class Xc extends Lo{constructor(t){super(),this.isMeshLambertMaterial=!0,this.type="MeshLambertMaterial",this.color=new tn(16777215),this.map=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.emissive=new tn(0),this.emissiveIntensity=1,this.emissiveMap=null,this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=0,this.normalScale=new we(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.alphaMap=null,this.envMap=null,this.combine=0,this.reflectivity=1,this.refractionRatio=.98,this.wireframe=!1,this.wireframeLinewidth=1,this.flatShading=!1,this.fog=!0,this.setValues(t)}copy(t){return super.copy(t),this.color.copy(t.color),this.map=t.map,this.lightMap=t.lightMap,this.lightMapIntensity=t.lightMapIntensity,this.aoMap=t.aoMap,this.aoMapIntensity=t.aoMapIntensity,this.emissive.copy(t.emissive),this.emissiveMap=t.emissiveMap,this.emissiveIntensity=t.emissiveIntensity,this.bumpMap=t.bumpMap,this.bumpScale=t.bumpScale,this.normalMap=t.normalMap,this.normalMapType=t.normalMapType,this.normalScale.copy(t.normalScale),this.displacementMap=t.displacementMap,this.displacementScale=t.displacementScale,this.displacementBias=t.displacementBias,this.alphaMap=t.alphaMap,this.envMap=t.envMap,this.combine=t.combine,this.reflectivity=t.reflectivity,this.refractionRatio=t.refractionRatio,this.wireframe=t.wireframe,this.wireframeLinewidth=t.wireframeLinewidth,this.flatShading=t.flatShading,this.fog=t.fog,this}}class Kc extends Ki{constructor(t){super(),this.isMeshLineMaterial=!0,this.type="MeshLineMaterial",this.lineWidth=1,this.sizeAttenuation=1,this.color=new tn(16777215),this.opacity=1,this.useMap=0,this.map=null,this.useAlphaMap=0,this.alphaMap=null,this.visibility=1,this.alphaTest=0,this.repeat=new we(1,1),this.uniforms={lineWidth:{value:1},sizeAttenuation:{value:1},color:{value:new tn(16777215)},opacity:{value:1},useMap:{value:0},map:{value:null},alphaMap:{value:null},useAlphaMap:{value:0},visibility:{value:1},alphaTest:{value:0},repeat:{value:new we(1,1)}},this.vertexShader=Fi.raw_meshline_vert,this.fragmentShader=Fi.raw_meshline_frag,this.setValues(t)}copy(t){return super.copy(t),this.lineWidth=t.lineWidth,this.sizeAttenuation=t.sizeAttenuation,this.color.copy(t.color),this.opacity=t.opacity,this.useMap=t.useMap,this.map=t.map,this.useAlphaMap=t.useAlphaMap,this.alphaMap=t.alphaMap,this.visibility=t.visibility,this.alphaTest=t.alphaTest,this.repeat.copy(t.repeat),this}}class jc extends Lo{constructor(t){super(),this.isMeshMaskMaterial=!0,this.type="MeshMaskMaterial",this.side=2,this.map=null,this.alphaMap=null,this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.wireframe=!1,this.wireframeLinewidth=1,this.lights=!1,this.cameraNearFar=null,this.depthTexture=null,this.textureMatrix=null,this.setValues(t)}copy(t){return super.copy(t),this.depthPacking=t.depthPacking,this.map=t.map,this.alphaMap=t.alphaMap,this.displacementMap=t.displacementMap,this.displacementScale=t.displacementScale,this.displacementBias=t.displacementBias,this.wireframe=t.wireframe,this.wireframeLinewidth=t.wireframeLinewidth,t.cameraNearFar&&(this.cameraNearFar=t.cameraNearFar.clone()),t.textureMatrix&&(this.textureMatrix=t.textureMatrix.clone()),t.depthTexture&&(this.depthTexture=t.depthTexture),this}}class Zc{constructor(t,e,n,o){this.parameterPositions=t,this.we=0,this.resultBuffer=void 0!==o?o:new e.constructor(n),this.sampleValues=e,this.valueSize=n,this.settings=null,this.DefaultSettings_={}}evaluate(t){const e=this.parameterPositions;let n=this.we,o=e[n],i=e[n-1];t:{e:{let r;n:{o:if(!(t<o)){for(let r=n+2;;){if(void 0===o){if(t<i)break o;return n=e.length,this.we=n,this.copySampleValue_(n-1)}if(n===r)break;if(i=o,o=e[++n],t<o)break e}r=e.length;break n}if(!(t>=i)){const s=e[1];t<s&&(n=2,i=s);for(let r=n-2;;){if(void 0===i)return this.we=0,this.copySampleValue_(0);if(n===r)break;if(o=i,i=e[--n-1],t>=i)break e}r=n,n=0;break n}break t}for(;n<r;){const o=n+r>>>1;t<e[o]?r=o:n=o+1}if(o=e[n],i=e[n-1],void 0===i)return this.we=0,this.copySampleValue_(0);if(void 0===o)return n=e.length,this.we=n,this.copySampleValue_(n-1)}this.we=n,this.intervalChanged_(n,i,o)}return this.interpolate_(n,i,t,o)}getSettings_(){return this.settings||this.DefaultSettings_}copySampleValue_(t){const e=this.resultBuffer,n=this.sampleValues,o=this.valueSize,i=t*o;for(let t=0;t!==o;++t)e[t]=n[i+t];return e}interpolate_(){throw new Error("call to abstract method")}intervalChanged_(){}}class qc extends Zc{constructor(t,e,n,o){super(t,e,n,o)}interpolate_(t){return this.copySampleValue_(t-1)}}const Jc=function(t){this.value=t,this.next=null},$c=function(){this.N=0,this.first=null};$c.prototype.push=function(t){this.first=this.xe(this.first,t)},$c.prototype.xe=function(t,e){if(null==t)return this.N++,new Jc(e);const n=t;return this.N++,(t=new Jc(e)).next=n,t},$c.prototype.pop=function(){if(null==this.first)return;const t=this.first,e=t.value;return this.first=t.next,this.N--,e},$c.prototype.size=function(){return this.N},$c.prototype.isEmpty=function(){return 0==this.N},$c.prototype.peep=function(){if(null!=this.first)return this.first.value},$c.prototype.toArray=function(){const t=[];let e=this.first;for(;null!=e;)t.push(e.value),e=e.next;return t};const tu=function(t){this.value=t,this.prev=null,this.next=null},eu=function(){this.first=null,this.last=null,this.map={}};eu.prototype.push=function(t,e){this.map[e]=t,null===this.first?(this.first=t,this.last=t):(this.last.next=t,t.prev=this.last,this.last=t)},eu.prototype.removeNodeByKey=function(t){const e=this.map[t],n=e.prev,o=e.next;null!==n&&null!==o?(n.next=o,o.prev=n):null===n&&null!==o?(this.first=o,o.prev=null):null!==n&&null===o?(this.last=n,n.next=null):(this.first=null,this.last=null),delete this.map[t]};const nu=function(t=0){this.V=t,this.adjList=[],this.nodeInfo=[],this.edges={};for(let e=0;e<t;++e)this.adjList.push([]),this.nodeInfo.push({})};nu.prototype.removeAll=function(){this.V=0,this.adjList=[],this.nodeInfo=[],this.edges={}},nu.prototype.addNode=function(t){t=t||{},this.V++,this.adjList.push([]),this.nodeInfo.push(t)},nu.prototype.addNewEdge=function(t,e){this.adjList[t].push(e);const n=t+"_"+e,o=new ou(t,e,0);return this.edges[n]=o,o},nu.prototype.addEdge=function(t){const e=t.v,n=t.w;this.adjList[e].push(n);const o=e+"_"+n;this.edges[o]=t},nu.prototype.removeEdge=function(t,e){const n=this.adjList[t];for(let t=0;t<n.length;t++)n[t]==e&&(n.splice(t,1),t--);const o=t+"_"+e;o in this.edges&&delete this.edges[o]},nu.prototype.edge=function(t,e){const n=t+"_"+e;return n in this.edges?this.edges[n]:null},nu.prototype.adj=function(t){return this.adjList[t]},nu.prototype.node=function(t){return this.nodeInfo[t]},nu.prototype.nodeIndex=function(t){for(let e=0;e<this.V;++e)if(this.nodeInfo[e]==t)return e;return-1},nu.prototype.reverse=function(){const t=new nu(this.V);for(let e=0;e<this.V;++e){const n=this.adjList[e];for(let o=0;o<n.length;++o){const i=n[o];t.addNewEdge(i,e)}}return t},nu.prototype.len=function(){return this.V},nu.prototype.findInEdges=function(t){const e=[];for(let n=0;n<this.V;n++){const o=this.adjList[n];for(let i=0;i<o.length;i++)o[i]==t&&e.push(this.edge(n,t))}return e},nu.prototype.findOutEdges=function(t){const e=[],n=this.adjList[t];for(let o=0;o<n.length;o++)e.push(this.edge(t,n[o]));return e},nu.prototype.disconnect=function(t,e){this.adjList[t].splice(0);for(let e=0;e<this.V;e++){const n=this.adjList[e];for(let e=0;e<n.length;e++)n[e]==t&&(n.splice(e,1),e--);let o=e+"_"+t;o in this.edges&&delete this.edges[o],o=t+"_"+e,o in this.edges&&delete this.edges[o]}if(e){const e=new nu(this.V-1);for(let n=0;n<this.V;n++){if(n==t)continue;const o=this.adjList[n];for(let i=0;i<o.length;i++){const r=o[i],s=n>t?n-1:n,a=r>t?r-1:r,l=this.edge(n,r).copy();l.v=s,l.w=a,e.addEdge(l)}}this.V--,this.adjList=e.adjList,this.nodeInfo.splice(t,1),this.edges=e.edges}},nu.prototype.insert=function(t,e,n,o=t=>t,i=t=>t){const r=this.V,s=t.V;for(let e=0;e<s;e++){this.adjList.push([]),this.nodeInfo.push(o(t.nodeInfo[e]));const n=t.adjList[e];for(let o=0;o<n.length;o++){const s=n[o],a=t.edge(e,s).copy(i);a.v+=r,a.w+=r,this.addEdge(a)}}this.V+=s;for(let t=0;t<e.length;t++){const n=e[t].copy(i);n.w+=r,this.addEdge(n)}for(let t=0;t<n.length;t++){const e=n[t].copy(i);e.v+=r,this.addEdge(e)}},nu.prototype.vis=function(t){t=t||function(t,e){return String(t)};let e="digraph G {";for(let n=0;n<this.V;n++){e+=n+' [label="'+t(n,this.nodeInfo[n])+'"];';const o=this.adjList[n];for(let t=0;t<o.length;t++){e+=n+" -> "+o[t]+";"}}e+="}",console.log(e)};const ou=function(t,e,n=0){this.v=t,this.w=e,this.weight=n};ou.prototype.either=function(){return this.v},ou.prototype.other=function(t){return t==this.v?this.w:this.v},ou.prototype.from=function(){return this.v},ou.prototype.to=function(){return this.w},ou.prototype.copy=function(t=t=>t){const e=new ou(0,0,0);for(const n in this)this.hasOwnProperty(n)&&("object"==typeof this[n]?e[n]=t(this[n]):e[n]=this[n]);return e};const iu=function(t){this.V=t,this.adjList=[],this.nodeInfo=[];for(let e=0;e<t;++e)this.adjList.push([]),this.nodeInfo.push({})};iu.prototype.adj=function(t){return this.adjList[t]},iu.prototype.edge=function(t,e){const n=this.adjList[t];for(let o=0;o<n.length;++o){if(n[o].other(t)==e)return n[o]}return null},iu.prototype.node=function(t){return this.nodeInfo[t]},iu.prototype.addNewEdge=function(t){const e=t.either(),n=t.other(e);this.adjList[e].push(t),this.adjList[n].push(t)};const ru=function(t){iu.call(this,t)};(ru.prototype=Object.create(iu.prototype)).addNewEdge=function(t){const e=t.from();this.adjList[e].push(t)},ru.prototype.edge=function(t,e){const n=this.adjList[t];for(let o=0;o<n.length;++o){if(n[o].other(t)==e)return n[o]}return null},ru.prototype.toDiGraph=function(){const t=new nu(this.V);for(let e=0;e<this.V;++e){const n=this.adjList[e];for(let o=0;o<n.length;++o){const i=n[o].other(e);t.addNewEdge(e,i)}}return t};const su=function(t,e){this.s=e;const n=t.V;this.marked=[],this.edgeTo=[];for(let t=0;t<n;++t)this.marked.push(!1),this.edgeTo.push(-1);this.dfs(t,e)};su.prototype.dfs=function(t,e){this.marked[e]=!0;const n=t.adj(e);for(let o=0;o<n.length;++o){const i=n[o];this.marked[i]||(this.edgeTo[i]=e,this.dfs(t,i))}},su.prototype.hasPathTo=function(t){return this.marked[t]},su.prototype.pathTo=function(t){const e=new $c;if(t==this.s)return[t];for(let n=t;n!=this.s;n=this.edgeTo[n])e.push(n);return e.push(this.s),e.toArray()};const au=function(t){this.postOrder=new $c,this.marked=[];const e=t.V;for(let t=0;t<e;++t)this.marked.push(!1);for(let n=0;n<e;++n)this.marked[n]||this.dfs(t,n)};au.prototype.dfs=function(t,e){this.marked[e]=!0;const n=t.adj(e);for(let e=0;e<n.length;++e){const o=n[e];this.marked[o]||this.dfs(t,o)}this.postOrder.push(e)},au.prototype.order=function(){return this.postOrder.toArray()};var lu=Object.freeze({__proto__:null,DepthFirstSearch:su,DiGraph:nu,Edge:ou,LinkMap:eu,LinkMapNode:tu,TopologicalSort:au});class cu extends Zc{constructor(t,e,n,o){super(t,e,n,o)}interpolate_(t,e,n,o){const i=this.resultBuffer,r=this.sampleValues,s=this.valueSize,a=t*s,l=a-s,c=(n-e)/(o-e),u=1-c;for(let t=0;t!==s;++t)i[t]=r[l+t]*u+r[a+t]*c;return i}}class uu{constructor(t=1,e=0,n=0){return this.radius=t,this.phi=e,this.theta=n,this}set(t,e,n){return this.radius=t,this.phi=e,this.theta=n,this}copy(t){return this.radius=t.radius,this.phi=t.phi,this.theta=t.theta,this}makeSafe(){const t=1e-6;return this.phi=Math.max(t,Math.min(Math.PI-t,this.phi)),this}setFromVector3(t){return this.setFromCartesianCoords(t.x,t.y,t.z)}setFromCartesianCoords(t,e,n){return this.radius=Math.sqrt(t*t+e*e+n*n),0===this.radius?(this.theta=0,this.phi=0):(this.theta=Math.atan2(t,n),this.phi=Math.acos(ie(e/this.radius,-1,1))),this}clone(){return(new this.constructor).copy(this)}}var hu=[[-1.117001,-.1867262,-11.13505,12.59865,-.03937339,1.167571,.007100686,3.592678,.6083296,-1.152006,-.1926669,6.152049,-4.770802,-.08704701,.7483626,.03372718,4.464592,.4036546,-1.072371,-.2696632,.2816168,1.820571,-.3742666,2.080607,-.07675295,-2.835366,1.129329,-1.109935,-.1532764,1.198787,-.9015183,.005173015,.5749178,.1075633,4.387949,.2650413,-1.052297,-.2229452,1.952347,.5727205,-4.88507,1.984016,-.1106197,-.4898361,.8907873,-1.070108,-.1600465,1.593886,-4479251e-11,-3.306541,.9390193,.09513168,2.343583,.5335404,-1.113253,-.16996,-10.38822,11.37513,-.04040911,1.037455,.04991792,4.801919,.630271,-1.135747,-.1678594,4.970755,-4.43023,-.06657408,.3636161,.1558009,6.01337,.3959601,-1.095892,-.2732595,.7666496,1.350731,-.4401401,2.470135,-.1707929,-3.260793,1.170337,-1.073668,-.02603929,-.1944589,.4575207,.6878164,-.139077,.3690299,7.885781,.1877694,-1.070091,-.2798957,2.338478,-2.647221,-7.387808,2.32921,-.1644639,-2.00371,.9874527,-1.06712,-.1418866,1.25409,6.053048,-2.918892,.5322812,.1613053,3.018161,.527409,-1.129483,-.1890619,-9.065101,9.659923,-.03607819,.8314359,.08181661,4.768868,.6339777,-1.14642,-.1883579,3.309173,-3.127882,-.06938176,.3987113,.1400581,6.283042,.5267076,-1.128348,-.2641305,1.223176,.05514952,-.3490649,1.997784,-.04123709,-2.251251,.9483466,-1.02582,.0140469,-1.187406,2.7299,.5877588,-.276114,.4602633,8.305125,.3945001,-1.083957,-.2606679,2.207108,-7.202803,-5.968103,2.129455,-.07789512,-1.137688,.8871769,-1.062465,-.1512189,1.042881,14.27839,-4.242214,.40381,.199778,2.814449,.5803196,-1.175099,-.2410789,-11.08587,11.33404,-.018193,.6772942,.09605043,4.231166,.6239972,-1.224207,-.2883527,3.002206,-2.649612,-.04795418,.4984398,.03251434,4.851611,.6551019,-1.136955,-.2423048,1.058823,-.2489236,-.2462179,1.93314,.09106828,-.1905869,.8171065,-1.014535,-.0082625,-1.448017,2.295788,.3510334,-1.477418,.5432449,5.762796,.4908751,-1.070666,-.237978,1.844589,-5.442448,-4.012768,2.945275,.009854725,.08455959,.814503,-1.071525,-.1777132,.807659,9.925865,-3.324623,-.6367437,.2844581,2.248384,.6544022,-1.218818,-.2952382,-13.45975,13.47153,-.006814585,.5079068,.119723,3.776949,.5836961,-1.409868,-.511433,2.776539,-2.039001,-.02673769,.4145288,.0007829342,2.275883,.6629691,-1.069151,-.09434247,.7293972,-1.222473,-.1533461,2.160357,.04626837,3.852415,.859357,-1.021306,-.1149551,-1.108414,4.178343,.4013665,-2.222814,.6929462,1.392652,.4401662,-1.074251,-.2224002,1.372356,-8.858704,-3.92266,3.020018,-.01458724,1.511186,.8288064,-1.062048,-.1526582,.4921067,14.85522,-3.229936,-.8426604,.3916243,2.678994,.6689264,-1.257023,-.33647,-15.27795,15.04223,.002717715,.302991,.1636851,3.561663,.5283161,-1.635124,-.7329993,3.523939,-2.566337,-.01902543,.5505483,-.06242176,1.065992,.6654236,-.9295823,.04845834,-.299299,-.2001327,-.08019339,1.807806,.09020277,5.095372,.8639936,-1.09374,-.2148608,-.521624,2.119777,.09506454,-1.831439,.6961204,.1102084,.4384319,-1.044181,-.1849257,.9071246,-4.648901,-2.279385,2.356502,-.04169147,1.932557,.829655,-1.061451,-.1458745,.2952267,8.967214,-3.726228,-.5022316,.5684877,3.102347,.6658443,-1.332391,-.4127769,-9.328643,9.046194,.003457775,.3377425,.1530909,3.301209,.4997917,-1.932002,-.9947777,-2.042329,3.58694,-.05642182,.8130478,-.08195988,.1118294,.5617231,-.8707374,.1286999,1.820054,-4.674706,.003317471,.5919018,.1975278,6.686519,.9631727,-1.070378,-.3030579,-.9041938,6.200201,.1232207,-.3650628,.5029403,-2.903162,.3811408,-1.063035,-.1637545,.5853072,-7.889906,-1.200641,1.035018,.1192093,3.267054,.8416151,-1.053655,-.1562286,.2423683,11.28575,-4.363262,-.0731416,.5642088,2.514023,.6670457,-1.366112,-.4718287,-7.876222,7.7469,-.009182309,.4716076,.08320252,3.165603,.5392334,-2.468204,-1.33634,-5.386723,7.072672,-.08329266,.8636876,-.01978177,-.1326218,.2979222,-.9653522,-.02373416,1.81025,-6.467262,.1410706,-.4753717,.3003095,6.551163,1.151083,-.8943186,-.2487152,-.230896,8.512648,.1298402,1.034705,.2303509,-3.924095,.2982717,-1.146999,-.2318784,.08992419,-9.933614,-.886092,-.03071656,.2852012,3.046199,.8599001,-1.032399,-.1645145,.2683599,13.27701,-4.40767,.07709869,.4951727,1.957277,.6630943,-1.46907,-.6135092,-6.506263,6.661315,-.03835383,.7150413,.007784318,2.820577,.6756784,-2.501583,-1.247404,-15.23462,16.33191,-.01204803,.5896471,-.02002023,1.144647,.06177874,-2.438672,-1.127291,5.731172,-10.2135,.0616561,-.7752641,.4708254,4.176847,1.200881,-.1513427,.09792731,-1.612349,9.814289,.05188921,1.716403,-.07039255,-2.815115,.3291874,-1.318511,-.3650554,.4221268,-9.294529,-.0439752,-.8100625,.3742719,1.834166,.822345,-1.016009,-.1820264,.1278426,11.82696,-4.801528,.4947899,.4660378,1.601254,.6702359,-1.84131,-.9781779,-4.610903,4.824662,-.05100806,.6463776,-6377724e-12,2.216875,.861853,-2.376373,-1.108657,-14.89799,15.46458,.04091025,.0976178,-.01048958,2.165834,-.1609171,-4.710318,-2.261963,6.947327,-10.34828,-.1325542,.7508674,.2247553,2.873142,1.2971,.216375,-.1944345,-2.43786,10.11314,.44505,.3111492,.2751323,-1.627906,.2531213,-1.258794,-.3524641,.8425444,-10.85313,-1.154381,-.4638014,-.002781115,.4344498,.8507091,-1.018938,-.1804153,-.06354054,15.7315,-4.386999,.6211115,.5294648,1.580749,.6586655,-1.116416,-.1917524,-10.68233,12.22221,-.03668978,1.054022,.01592132,3.180583,.562737,-1.132341,-.1671286,5.976499,-4.227366,-.09542489,.8664938,.008351793,4.876068,.4492779,-1.087635,-.3173679,.4314407,1.100555,-.4410057,1.677253,-.03005925,-4.201249,1.070902,-1.083031,-.08847705,1.291773,.4546776,.3091894,.726176,.04203659,5.990615,.3704756,-1.057899,-.2246706,2.329563,-1.219656,-5.33526,.8545378,-.03906209,-.9025499,.7797348,-1.073305,-.1522553,1.767063,1.90428,-3.101673,.3995856,.02905192,2.563977,.5753067,-1.113674,-.1759694,-9.754125,10.87391,-.03841093,.9524272,.05680219,4.227034,.6029571,-1.126496,-.1680281,5.332352,-4.575579,-.06761755,.3295335,.1194896,5.570901,.4536185,-1.103074,-.2681801,.06571479,2.396522,-.455128,2.466331,-.1232022,-3.023201,1.086379,-1.053299,-.02697173,.8379121,-.9681458,.5890692,-.4872027,.2936929,7.510139,.3079122,-1.079553,-.2710448,2.462379,-.3713554,-8.534512,1.828242,-.1686398,-1.96134,.8941077,-1.069741,-.1396394,1.657868,3.236313,-2.706344,-.2948122,.1314816,2.868457,.5413403,-1.131649,-.1954455,-7.751595,8.685861,-.04910871,.8992952,.04710143,4.254818,.6821116,-1.156689,-.1884324,3.163519,-3.091522,-.06613927,-.02575883,.1640065,6.073643,.4453468,-1.079224,-.2621389,.9446437,1.448479,-.3969384,2.626638,-.08101186,-3.016355,1.076295,-1.080832,.01033057,-.3500156,-.03281419,.5655512,-1.156742,.453471,8.774122,.2772869,-1.051202,-.2679975,2.719109,-2.190316,-6.878798,2.250481,-.2030252,-2.026527,.9701096,-1.089849,-.1598589,1.564748,6.869187,-3.05367,-.6110435,.1644472,2.370452,.551177,-1.171419,-.2429746,-8.991334,9.571216,-.02772861,.6688262,.07683478,3.785611,.6347635,-1.228554,-.2917562,2.753986,-2.49178,-.04663434,.3118303,.07546506,4.463096,.5955071,-1.093124,-.2447767,.9097406,.5448296,-.2957824,2.024167,-.0005152333,-1.069081,.9369565,-1.056994,.01569507,-.8217491,1.870818,.706193,-1.483928,.5978206,6.864902,.3673332,-1.054871,-.2758129,2.712807,-5.95011,-6.554039,2.447523,-.1895171,-1.454292,.9131738,-1.100218,-.1746241,1.438505,11.15481,-3.266076,-.8837357,.19701,1.991595,.5907821,-1.207267,-.291361,-11.03767,11.40724,-.014168,.5564047,.08476262,3.371255,.6221335,-1.429698,-.5374218,2.837524,-2.221936,-.02422337,.09313758,.0719025,1.869022,.5609035,-1.002274,-.0697281,.4031308,-.3932997,-.1521923,2.390646,-.0689399,2.999661,1.017843,-1.081168,-.1178666,-.496808,3.919299,.6046866,-2.440615,.7891538,2.140835,.274047,-1.050727,-.2307688,2.276396,-9.454407,-5.505176,2.99262,-.2450942,.6078372,.9606765,-1.103752,-.1810202,1.375044,15.89095,-3.438954,-1.265669,.2475172,1.680768,.5978056,-1.244324,-.3378542,-11.11001,11.37784,-.007896794,.4808023,.09249904,3.025816,.5880239,-1.593165,-.7027621,2.220896,-1.437709,-.01534738,.06286958,.06644555,1.091727,.547008,-.9136506,.01344874,.7772636,-1.209396,-.1408978,2.433718,-.1041938,3.791244,1.037916,-1.134968,-.1803315,-.9267335,4.57667,.6851928,-2.805,.8687208,1.161483,.2571688,-1.017037,-.2053943,2.36164,-9.887818,-5.122889,3.287088,-.2594102,.8578927,.959234,-1.118723,-.1934942,1.226023,16.7414,-3.277335,-1.629809,.2765232,1.637713,.6113963,-1.314779,-.4119915,-12.4115,12.41578,.002344284,.2980837,.1414613,2.781731,.4998556,-1.926199,-1.020038,2.5692,-1.081159,-.02266833,.3588668,.008750078,-.2452171,.4796758,-.7780002,.1850647,.04445456,-2.409297,-.07816346,1.54679,-.02807227,5.998176,1.132396,-1.179326,-.357833,-.2392933,6.467883,.5904596,-1.869975,.8045839,-2.498121,.1610633,-1.009956,-.1311896,1.726577,-12.19356,-3.466239,2.343602,-.2252205,2.573681,1.027109,-1.11246,-.2063093,1.233051,20.58946,-4.578074,-1.145643,.3160192,1.420159,.5860212,-1.371689,-.4914196,-10.7661,11.07405,-.01485077,.5936218,.03685482,2.599968,.6002204,-2.436997,-1.377939,.02130141,1.079593,-.01796232,-.03933248,.1610711,-.6901181,.1206416,-.8743368,.0733137,.8734259,-3.743126,-.03151167,1.297596,-.07634926,6.532873,1.435737,-.9810197,-.3521634,-.2855205,7.134674,.6839748,-1.394841,.6952036,-4.633104,-.02173401,-1.122958,-.1691536,1.38236,-11.02913,-2.608171,1.865111,-.1345154,3.112342,1.094134,-1.075586,-.2077415,1.171477,17.9327,-4.656858,-1.036839,.3338295,1.042793,.5739374,-1.465871,-.6364486,-8.833718,9.34365,-.032236,.7552848,-3121341e-12,2.249164,.8094662,-2.448924,-1.270878,-4.823703,5.853058,-.02149127,.03581132,-.001230276,.4892553,-.1597657,-2.419809,-1.071337,1.575648,-4.98358,.009545185,.5032615,.4186266,4.634147,1.433517,-.1383278,-.02797095,-.1943067,6.679623,.411828,-.2744289,-.02118722,-4.337025,.1505072,-1.341872,-.2518572,1.027009,-6.527103,-1.081271,1.015465,.2845789,2.470371,.927812,-1.04064,-.2367454,1.100744,8.827253,-4.560794,-.7287017,.2842503,.6336593,.6327335,-1.877993,-1.025135,-4.311037,4.715016,-.04711631,.6335844,-7665398e-12,1.788017,.9001409,-2.28154,-1.137668,-10.36869,11.36254,.01961739,-.09836174,-.006734567,1.320918,-.2400807,-4.904054,-2.315781,5.735999,-8.626257,-.1255643,1.545446,.139686,2.972897,1.429934,.4077067,-.1833688,-2.450939,9.119433,.4505361,-1.340828,.397369,-1.78537,.09628711,-1.296052,-.3250526,1.813294,-10.31485,-1.38869,1.239733,-.08989196,-.3389637,.963956,-1.062181,-.2423444,.7577592,15.66938,-4.462264,-.574281,.3262259,.9461672,.6232887],[-1.127942,-.1905548,-12.52356,13.75799,-.03624732,1.055453,.01385036,4.17697,.5928345,-1.15526,-.1778135,6.216056,-5.254116,-.08787445,.8434621,.04025734,6.195322,.3111856,-1.125624,-.3217593,.5043919,1.686284,-.3536071,1.476321,-.07899019,-4.522531,1.271691,-1.081801,-.1033234,.999555,.007482946,-.06776018,1.463141,.09492021,5.612723,.1298846,-1.07532,-.2402711,2.141284,-1.203359,-4.945188,1.437221,-.0809675,-1.028378,1.004164,-1.073337,-.1516517,1.639379,2.304669,-3.214244,1.286245,.05613957,2.480902,.4999363,-1.128399,-.1857793,-10.89863,11.72984,-.03768099,.9439285,.04869335,4.845114,.6119211,-1.114002,-.139928,4.9638,-4.6855,-.07780879,.4049736,.1586297,7.770264,.3449006,-1.185472,-.3403543,.6588322,1.133713,-.4118674,2.061191,-.1882768,-4.372586,1.22353,-1.002272,.02000703,.07073269,1.485075,.5005589,.4301494,.3626541,7.921098,.1574766,-1.121006,-.3007777,2.242051,-4.571561,-7.761071,2.053404,-.1524018,-1.886162,1.018208,-1.058864,-.1358673,1.389667,8.633409,-3.437249,.7295429,.15147,2.842513,.5014325,-1.144464,-.2043799,-10.20188,10.71247,-.03256693,.7860205,.06872719,4.824771,.6259836,-1.170104,-.2118626,4.391405,-4.1989,-.07111559,.3890442,.1024831,6.282535,.5365688,-1.129171,-.255288,.2238298,.7314295,-.356273,1.881931,-.03078716,-1.03912,.9096301,-1.042294,.004450203,-.5116033,2.627589,.6098996,-.1264638,.4325281,7.080503,.4583646,-1.082293,-.2723056,2.065076,-8.143133,-7.892212,2.142231,-.0710624,-1.122398,.8338505,-1.071715,-.1426568,1.095351,17.29783,-3.851931,.4360514,.211444,2.970832,.5944389,-1.195909,-.2590449,-11.91037,12.07947,-.01589842,.6297846,.09054772,4.285959,.5933752,-1.245763,-.3316637,4.29366,-3.694011,-.04699947,.4843684,.02130425,4.097549,.6530809,-1.148742,-.1902509,-.2393233,-.2441254,-.2610918,1.846988,.03532866,2.660106,.8358294,-1.01608,-.0744496,-.5053436,4.388855,.6054987,-1.2083,.5817215,2.54357,.4726568,-1.072027,-.210144,1.518378,-10.60119,-6.016546,2.649475,-.05166992,1.571269,.8344622,-1.072365,-.1511201,.747801,19.00732,-3.950387,-.3473907,.3797211,2.782949,.6296808,-1.239423,-.3136289,-13.511,13.49468,-.007070423,.5012315,.1106008,3.803619,.5577948,-1.452524,-.5676944,2.993153,-2.277288,-.02168954,.305672,.01152338,1.852697,.6427228,-1.061421,-.04590521,.6057022,-1.096835,-.1504952,2.344921,-.05491832,5.268322,.9082253,-1.042373,-.1769498,-1.075388,3.831712,.315414,-2.416458,.7909032,-.01492892,.3854049,-1.064159,-.1892684,1.438685,-8.166362,-3.616364,3.275206,-.1203825,2.039491,.8688057,-1.07012,-.1569508,.412476,13.99683,-3.547085,-1.046326,.4973825,2.791231,.6503286,-1.283579,-.3609518,-13.35397,13.15248,-.0004431938,.3769526,.1429824,3.573613,.4998696,-1.657952,-.7627948,1.958222,-.7949816,-.02882837,.5356149,-.05191946,.8869955,.626332,-.95276,.06494189,.5361303,-2.12959,-.0925863,1.604776,.0506777,6.376055,.9138052,-1.080827,-.252312,-.7154262,4.120085,.1878228,-1.492158,.6881655,-1.446611,.4040631,-1.054075,-.1665498,.9191052,-6.636943,-1.894826,2.10781,-.03680499,2.655452,.841384,-1.061127,-.1448849,.2667493,10.34103,-4.285769,-.3874504,.5998752,3.132426,.6652753,-1.347345,-.4287832,-9.305553,9.133813,-.003173527,.3977564,.115142,3.320564,.4998134,-1.927296,-.9901372,-2.593499,4.087421,-.05833993,.8158929,-.04681279,.2423716,.4938052,-.9470092,.07325237,2.064735,-5.16754,-.01313751,.4832169,.1126295,6.970522,1.035022,-1.022557,-.2762616,-.9375748,6.696739,.2200765,-.1133253,.5492505,-3.109391,.3321914,-1.087444,-.1836263,.6225024,-8.576765,-1.107637,.7859427,.09910909,3.112938,.8596261,-1.051544,-.1546262,.2371731,12.00502,-4.527291,.07268862,.5571478,2.532873,.6662,-1.375576,-.4840019,-8.12129,8.05814,-.01445661,.5123314,.05813321,3.203219,.5442318,-2.325221,-1.241463,-7.06343,8.741369,-.0782995,.8844273,-.03471106,.1740583,.2814079,-1.2287,-.2013412,2.949042,-7.371945,.1071753,-.249197,.2265223,6.391504,1.172389,-.7601786,-.1680631,-.7584444,8.541356,.08222291,.6729633,.3206615,-3.70094,.2710054,-1.191166,-.2672347,.2927498,-9.713613,-.4783721,.2352803,.2161949,2.691481,.8745447,-1.030135,-.1653301,.2263443,12.96157,-4.650644,.007055709,.5091975,2.00037,.6603839,-1.508018,-.6460933,-6.402745,6.545995,-.0375032,.6921803,.003309819,2.797527,.6978446,-2.333308,-1.167837,-17.46787,18.6863,-.008948229,.5621946,-.03402626,1.217943,.01149865,-2.665953,-1.226307,7.169725,-11.59434,.0358342,-.3074378,.3412248,4.422122,1.283791,-.09705116,.08312991,-2.160462,10.28235,.03543357,1.032049,.105831,-2.972898,.2418628,-1.329617,-.3699557,.5560117,-9.730113,.09938865,-.3071488,.2510691,1.777111,.8705142,-1.019387,-.1893247,.1194079,12.39436,-4.799224,.2940213,.4841268,1.529724,.6582615,-1.896737,-1.005442,-6.411032,6.54822,-.03227596,.5717262,-8115192e-12,2.296704,.9000749,-2.411116,-1.225587,-17.53629,18.29393,.01247555,.2364616,-.005114637,1.603778,-.2224156,-4.707121,-2.074977,7.9423,-11.32407,-.05415654,.5446811,.1032493,4.010235,1.369802,.1010482,-.4013305,-2.674579,9.779409,.1782506,.7053045,.4200002,-2.400671,.1953165,-1.243526,-.3391255,.8848882,-9.789025,-.3997324,-.9546227,-.1044017,.6010593,.8714462,-1.014633,-.1730009,-.07738934,13.90903,-4.847307,1.076059,.5685743,1.572992,.6561432,-1.122998,-.1881183,-10.30709,11.58932,-.04079495,.9603774,.03079436,4.009235,.5060745,-1.13479,-.1539688,5.478405,-4.21727,-.1043858,.7165008,.01524765,6.473623,.4207882,-1.134957,-.3513318,.7393837,1.354415,-.4764078,1.690441,-.0549264,-5.563523,1.145743,-1.058344,-.05758503,1.16823,.3269824,.1795193,.7849011,.07441853,6.904804,.281879,-1.075194,-.2355813,2.463685,-1.536505,-7.505771,.9619712,-.06465851,-1.355492,.8489847,-1.07903,-.1465328,1.773838,2.310131,-3.136065,.3507952,.04435014,2.819225,.5689008,-1.125833,-.1870849,-9.555833,10.59713,-.04225402,.9164663,.04338796,4.40098,.6056119,-1.12744,-.1551891,4.755621,-4.408806,-.07851763,.2268284,.146007,7.048003,.3525997,-1.143788,-.3170178,.5480669,2.04183,-.4532139,2.302233,-.1887419,-4.489221,1.250967,-1.032849,.007376031,.5666073,-.2312203,.4862894,-.1748294,.357287,8.380522,.1302333,-1.093728,-.2786977,2.641272,-1.507494,-8.731243,1.684055,-.2023377,-2.176398,1.013249,-1.076578,-.1456205,1.693935,2.945003,-2.822673,-.2520033,.1517034,2.649109,.5179094,-1.146417,-.2119353,-7.187525,8.058599,-.05256438,.8375733,.03887093,4.222111,.6695347,-1.173674,-.2067025,2.899359,-2.804918,-.08473899,.003944225,.1340641,6.160887,.4527141,-1.090098,-.2599633,.9180856,1.09271,-.4215019,2.42766,-.09277667,-2.123523,1.058159,-1.08446,.008056181,-.245351,.6619567,.4668118,-.9526719,.4648454,8.001572,.3054194,-1.053728,-.2765784,2.792388,-3.489517,-8.150535,2.195757,-.2017234,-2.128017,.9326589,-1.099348,-.1593939,1.568292,7.247853,-2.933,-.5890481,.172444,2.433484,.5736558,-1.185983,-.2581184,-7.761056,8.317053,-.03351773,.6676667,.05941733,3.820727,.6324032,-1.268591,-.3398067,2.348503,-2.023779,-.05368458,.1083282,.08402858,3.910254,.5577481,-1.071353,-.1992459,.7878387,.1974702,-.3033058,2.335298,-.08205259,.7954454,.9972312,-1.089513,-.03104364,-.5995746,2.330281,.6581939,-1.821467,.6679973,5.090195,.3125161,-1.040214,-.2570934,2.660489,-6.506045,-7.053586,2.763153,-.2433632,-.7648176,.9452937,-1.116052,-.1831993,1.457694,11.63608,-3.216426,-1.045594,.2285002,1.817407,.5810396,-1.230134,-.3136264,-8.909301,9.145006,-.01055387,.4467317,.1016826,3.342964,.563384,-1.442907,-.5593147,2.156447,-1.241657,-.0351213,.3050274,.01797175,1.742358,.5977153,-1.027627,-.06481539,.4351975,-1.051677,-.2030672,1.942684,-.03615993,4.050266,.9801624,-1.08211,-.1578209,-.3397511,4.163851,.6650368,-1.84173,.7062544,.6789881,.3172623,-1.047447,-.197756,2.183364,-8.805249,-5.483962,2.551309,-.177964,1.519501,.9212536,-1.111853,-.1935736,1.394408,13.92405,-3.46543,-1.068432,.2388671,1.455336,.6233425,-1.262238,-.3546341,-10.08703,10.20084,-.001852187,.353758,.1239199,3.056093,.5132052,-1.61381,-.7355585,2.760123,-1.685253,-.02517552,.2914258,.004743448,.8689596,.5674192,-.9462336,.02950767,-.2613816,-.7398653,-.1315558,1.901042,-.06447844,4.969341,1.027342,-1.111481,-.2194054,-.09004538,3.983442,.4871278,-1.965315,.7956121,-.2363225,.2718037,-1.036397,-.1827106,1.964747,-8.870759,-4.208011,2.461215,-.2158905,1.561676,.9436866,-1.113769,-.1947819,1.30072,15.16476,-4.088732,-1.069384,.2836434,1.671451,.6229612,-1.328069,-.4244047,-8.41704,8.552244,-.006813504,.4127422,.09619897,2.854227,.505988,-1.927552,-1.02529,.9529576,.425595,-.03738779,.2584586,.04911004,-.2640913,.4138626,-.8488094,.1435988,.6356807,-2.895732,-.08473961,1.701305,-.1323908,6.499338,1.210928,-1.128313,-.3397048,-.404314,6.265097,.5482395,-2.057614,.8884087,-2.943879,.09760301,-1.039764,-.1494772,1.781915,-11.53012,-3.379232,2.517231,-.2764393,2.588849,1.05212,-1.108447,-.2012251,1.19864,19.25331,-4.423892,-1.257122,.339569,1.48122,.5880175,-1.374185,-.4967434,-7.401318,7.724021,-.02345723,.5979653,.02436346,2.65897,.6014891,-2.310933,-1.29029,-1.301909,2.557806,-.03744449,.08982861,.1090613,-.4398363,.1184329,-1.12473,-.0992183,1.366902,-4.172489,-.05078016,1.393597,-.09323843,6.452721,1.435913,-.8468477,-.2744819,-.43472,6.713362,.6127133,-1.685634,.7360941,-4.535502,-.02920866,-1.165242,-.2008697,1.438778,-10.08936,-2.214771,2.102909,-.1763085,2.859075,1.09347,-1.074614,-.2066374,1.131891,16.30063,-4.801441,-1.11259,.3595785,1.122227,.579461,-1.521515,-.6835604,-5.571044,6.028774,-.04253715,.6875746,-5279456e-12,2.18015,.8487705,-2.240415,-1.171166,-7.182771,8.417068,-.01932866,.1101887,-.01098862,.6242195,-.2393875,-2.712354,-1.19883,3.1802,-6.76813,-.002563386,.7984607,.2764376,4.695358,1.557045,-.03655172,-.02142321,-.913812,7.932786,.3516542,-.7994343,.1786761,-4.208399,.01820576,-1.36861,-.2656212,1.249397,-8.317818,-.8962772,1.423249,.1478381,2.19166,1.007748,-1.041753,-.2453366,1.061102,11.30172,-4.739312,-.9223334,.2982776,.6162931,.6080302,-1.989159,-1.09516,-2.91555,3.275339,-.05735765,.5742174,-7683288e-12,1.7634,.9001342,-2.07002,-1.086338,-10.95898,12.0696,.03780123,-.01774699,-.0005881348,1.333819,-.2605423,-5.249653,-2.38304,6.160406,-9.097138,-.1955319,1.651785,.0006016463,3.021824,1.493574,.4685432,-.2358662,-2.666433,9.685763,.5804928,-1.521875,.5668989,-1.548136,.01688642,-1.296891,-.3449031,1.928548,-11.6756,-1.627615,1.355603,-.1929074,-.6568952,1.009774,-1.067288,-.2410392,.7147961,17.8384,-4.374399,-.6588777,.3329831,1.012066,.6118645],[-1.310023,-.4407658,-36.4034,36.83292,-.008124762,.5297961,.01188633,3.13832,.5134778,-1.4241,-.5501606,-17.5351,18.22769,-.01539272,.6366826,.002661996,2.659915,.4071138,-1.103436,-.1884105,6.425322,-6.910579,-.02019861,.3553271,-.01589061,5.345985,.8790218,-1.1862,-.4307514,-3.957947,5.979352,-.05348869,1.736117,.03491346,-2.692261,.5610506,-1.006038,-.1305995,4.473513,-3.806719,.1419407,-.02148238,-.05081185,3.735362,.535828,-1.078507,-.1633754,-3.812368,4.3817,.02988122,1.754224,.1472376,3.722798,.4999157,-1.333582,-.4649908,-33.59528,34.04375,-.009384242,.5587511,.00572631,3.073145,.5425529,-1.562624,-.7107068,-14.7817,15.59839,-.01462375,.5050133,.02516017,1.604696,.2902403,-.8930158,.04068077,1.373481,-2.342752,-.02098058,.6248686,-.05258363,7.058214,1.150373,-1.262823,-.4818353,889261e-9,1.92312,-.04979718,1.040693,.1558103,-2.85248,.2420691,-.9968383,-.1200648,1.324342,-.9430889,.1931098,.4436916,-.07320456,4.215931,.7898019,-1.078185,-.1718192,-1.720191,2.358918,.02765637,1.260245,.2021941,3.395483,.5173628,-1.353023,-.4813523,-31.0492,31.40156,-.009510741,.554203,.008135471,3.136646,.5215989,-1.624704,-.7990201,-21.67125,22.46341,-.01163533,.5415746,.02618378,1.139214,.3444357,-.798361,.1417476,9.914841,-10.81503,-.01218845,.3411392,-.06137698,7.445848,1.18008,-1.266679,-.4288977,-5.818701,6.986437,-.08180711,1.397403,.2016916,-1.275731,.2592773,-1.009707,-.1537754,3.496378,-3.013726,.242115,-.2831925,.03003395,3.702862,.774632,-1.075646,-.1768747,-1.347762,1.989004,.01375836,1.76481,.1330018,3.230864,.662621,-1.375269,-.5103569,-34.42661,34.78703,-.008460009,.5408643,.004813323,3.016078,.5062069,-1.821679,-.9766461,-19.26488,19.97912,-.009822567,.3649556,.04316092,.893019,.4166527,-.6633542,.1997841,2.395592,-3.117175,-.01080884,.8983814,-.1375825,6.673463,1.115663,-1.30324,-.3612712,.08292959,.3381364,-.06078648,.3229247,.3680987,.7046755,.3144924,-.9952598,-.2039076,.4026851,.2686684,.1640712,.5186341,-.0120552,2.659613,.8030394,-1.098579,-.2151992,.6558198,-74369e-8,-.001421817,1.073701,.1886875,2.536857,.6673923,-1.457986,-.5906842,-38.12464,38.38539,-.006024357,.4741484,.01209223,2.818432,.5012433,-1.835728,-1.003405,-6.848129,7.601943,-.01277375,.4785598,.03366853,1.097701,.4636635,-.8491348,.009466365,-2.685226,2.00406,-.01168708,.6752316,-.1543371,5.674759,1.039534,-1.083379,-.150679,.7328236,-.5095568,-.08609153,.444882,.4174662,1.481556,.3942551,-1.117089,-.3337605,.2502281,.4036323,.2673899,.2829817,.0224245,2.043207,.7706902,-1.071648,-.21262,.6069466,-.00145629,-.551596,1.046755,.1985021,2.290245,.6876058,-1.483903,-.6309647,-43.80213,44.10537,-.005712161,.5195992,.002028428,2.687114,.5098321,-2.053976,-1.141473,.5109183,.08060391,-.01033983,.4066532,.04869627,1.161722,.4039525,-.6348185,.07651292,-10.31327,10.07598,-.02083688,.7359516,-.2029459,5.013257,1.077649,-1.22863,-.1650496,.04077157,-.7189167,-.0509222,.2959814,.5111496,2.540433,.361533,-1.041883,-.3278413,-.06691911,1.307364,.2166663,.3000595,-.003157136,1.389208,.7999026,-1.103556,-.2443602,.4705347,-.0009296482,-.530992,.9654511,.2142587,2.244723,.6839976,-1.555684,-.6962113,-46.47983,46.7427,-.005034895,.475509,-9.502561e-7,2.626569,.5056194,-1.998288,-1.12472,-1.629586,2.187993,-.008284384,.3845258,.0572624,1.185644,.4255812,-1.03257,-.251385,-3.721112,3.506967,-.02186561,.9436049,-.2451412,4.725724,1.039256,-.8597532,.09073332,-2.553741,1.993237,-.04390891,-.2046928,.5515623,1.909127,.3948212,-1.210482,-.4477622,-.2267805,1.219488,.1336186,.6866897,.02808997,1.600403,.7816409,-1.078168,-.2699261,.2537282,.3820684,-.4425103,.5298235,.2185217,1.728679,.6882743,-1.697968,-.8391488,-57.90105,58.1412,-.00340476,.426514,-1796301e-12,2.368442,.5324429,-2.141552,-1.17223,16.77872,-16.4147,-.005732425,.2002199,.06841834,1.485338,.3215763,-1.442946,-.7264245,-9.503706,9.650462,-.02120995,1.419263,-.2893098,3.860731,1.120857,-.5696752,.3411279,-.2931035,-.6512552,-.1068437,-1.085661,.6107549,1.459503,.3210336,-1.313839,-.5921371,-.2332222,1.648196,.2492787,1.381033,-.01993392,.981256,.8316329,-1.087464,-.3195534,.2902095,.3383709,-.8798482,.01494668,.2529703,1.452644,.669387,-2.068582,-1.118605,-50.81598,50.97486,-.003280669,.4067371,-2544951e-12,2.179497,.5778017,-1.744693,-.8537207,22.34361,-22.08318,-.005932616,.1035049,.05742772,1.97788,.2124846,-3.287515,-2.140268,-12.49566,12.40091,-.02409349,1.397821,-.2371627,2.771192,1.170496,.5502311,1.04663,2.193517,-2.2204,-.1064394,-1.017926,.4795457,1.030644,.3177516,-1.719734,-.9536198,-.6586821,1.386361,-.02513065,1.187011,.06542539,.5296055,.808266,-1.0057,-.3028096,.04470957,1.00776,-.8119016,.03153338,.2311321,1.182208,.6824758,-2.728867,-1.580388,-30.79627,30.92586,-.004197673,.3154759,-3897675e-12,1.920567,.6664791,-1.322495,-.7249275,14.7766,-14.68154,-.009044857,.05624314,.06498392,2.047389,.0636754,-6.102376,-3.473018,-9.926071,9.637797,-.01097909,1.103498,-.2424521,2.520748,1.24026,1.351796,1.018588,2.009081,-1.333394,-.1979125,-.3318292,.4476624,.9095235,.2955611,-1.774467,-1.07988,-.0808468,.2577697,-.1149295,.4975303,.002931611,-.3803171,.8002794,-.9898401,-.2542513,-.07530911,1.870355,-1.521918,.2405164,.2964615,1.3348,.6789053,-1.27973,-.4290674,-42.77972,43.43305,-.006541826,.4945086,.01425338,2.685244,.5011313,-1.449506,-.5766374,-16.88496,17.81118,-.01121649,.354502,.02287338,1.904281,.4936998,-1.02198,-.1897574,2.482462,-2.941725,-.01570448,.7532578,-.042568,5.23966,.4983116,-1.162608,-.3428049,3.974358,-1.527935,-.03919201,.8758593,.07291363,-3.455257,.8007426,-.9929985,-.08712006,-.7397313,1.348372,.09511685,.3233584,-.07549148,5.806452,.4990042,-1.084996,-.1739767,.1580475,.908818,.06871433,.5933079,.1188921,3.074079,.4999327,-1.317009,-.4661946,-42.55347,43.12782,-.005727235,.4285447,.02189854,2.60831,.51907,-1.469236,-.6282139,-12.41404,13.48765,-.0120477,.5070285,-.0007280216,1.491533,.3635064,-.9713808,-.08138038,.3709854,-1.041174,-.01814075,.506086,-.02053756,6.161431,1.093736,-1.159057,-.3698074,2.711209,-.6006479,-.04896926,.9273957,.1137712,-3.496828,.2867109,-1.011601,-.0820189,.2105725,.459752,.1478925,.213894,-.0566067,6.057755,.7859121,-1.07802,-.181158,.1646622,.8348426,.1149064,.4985738,.1376605,2.746607,.4999626,-1.325672,-.4769313,-41.11215,41.68293,-.006274997,.4649469,.01119411,2.631267,.5234546,-1.619391,-.8000253,-15.34098,16.32706,-.01012023,.4242255,.02931597,.8925807,.3314765,-.7356979,.1368406,2.972579,-3.535359,-.01318948,.460762,-.07182778,6.2541,1.236299,-1.316217,-.4194427,.03489902,1.289849,-.0475596,1.138222,.1975992,-.8991542,.2290572,-.9502188,-.1172703,1.405202,-.3061919,.1058772,-.3760592,-.01983179,3.562353,.7895959,-1.100117,-.1900567,.492503,.5250225,.1576804,1.042701,.07330743,2.796064,.6749783,-1.354183,-.5130625,-42.19268,42.71772,-.005365373,.4136743,.01235172,2.520122,.5187269,-1.741434,-.9589761,-8.230339,9.296799,-.009600162,.4994969,.02955452,.3667099,.3526999,-.6917347,.2154887,-.8760264,.2334121,-.01909621,.4748033,-.1138514,6.51536,1.225097,-1.293189,-.42187,1.620952,-.7858597,-.0376941,.6636786,.3364945,-.5341017,.2128347,-.9735521,-.1325495,1.007517,.2598258,.06762169,.001421018,-.06915987,3.185897,.8641956,-1.0948,-.1962062,.5755591,.2906259,.2625748,.7644049,.1347492,2.677126,.646546,-1.393063,-.5578338,-41.85249,42.33504,-.00543564,.4743765,.007422477,2.442801,.5211707,-1.939487,-1.128509,-8.974257,9.978383,-.007965597,.294883,.04436763,.2839868,.3440424,-.6011562,.2354877,-3.07982,2.585094,-.02002701,.7793909,-.1598414,5.834678,1.202856,-1.315676,-.3903446,1.7019,-1.304609,-.01045121,.2747707,.4143967,.3197102,.263758,-.9618628,-.1625841,1.187138,.1497802,-5590954e-12,.03178475,-.04153145,2.496096,.8195082,-1.111554,-.2365546,.7831875,.2018684,.2074369,.7395978,.122573,1.876478,.6821167,-1.427879,-.5994879,-35.31016,35.81581,-.006431497,.4554192,.0007348731,2.334619,.5233377,-1.998177,-1.206633,-21.4651,22.42237,-.005857596,.2755663,.06384795,.1358244,.3328437,-.644063,.2058571,2.155499,-2.587968,-.01840023,.8826555,-.2222452,5.847073,1.228387,-1.229071,-.3360441,-.3429599,.6179469,.00202961,.08899319,.5041624,.1882964,.225204,-1.022905,-.2101621,1.915689,-.6498794,-.03463651,.08954605,-.06797854,2.417705,.8568618,-1.082538,-.2007723,.4731009,.4077267,.1324289,.651488,.1702912,2.309383,.6600895,-1.472139,-.6499815,-34.28465,34.69659,-.005747023,.4174167,.001688597,2.323046,.5395191,-2.161176,-1.353089,-22.26827,23.29138,-.005583808,.2364793,.06096656,.001944666,.2861624,-.6593044,.1393558,4.698373,-5.193883,-.0199839,1.095635,-.2391254,5.598103,1.236193,-1.195717,-.2972715,.04648953,.3024588,.005003313,-.3754741,.5247265,-.1381312,.2493896,-1.020139,-.2253524,.3548437,.7030485,-.02107076,.4581395,-.03243757,2.453259,.8323623,-1.09877,-.243578,.8761614,.1941613,-.1990692,.3761139,.1657412,1.590503,.6741417,-1.648007,-.8205121,-44.35106,44.79801,-.004181353,.385483,-1842385e-12,2.000281,.5518363,-2.140986,-1.282239,-3.979213,4.672459,-.005008582,.242192,.06253602,.6612713,.2555851,-1.300502,-.5137898,.5179821,-.4032341,-.02066785,1.087929,-.2615309,4.225887,1.229237,-.696334,.0924106,.06936356,-.3588571,-.05461843,-.5616643,.5484166,-.04776267,.2414935,-1.233179,-.4325498,.6479813,.8368356,.2458875,.6464752,-.02897097,1.561773,.8518598,-1.051023,-.253369,1.004294,.3028083,-1.520108,.1607013,.1619975,1.131094,.6706655,-1.948249,-1.097383,-44.53697,44.94902,-.003579939,.3491605,-2500253e-12,1.740442,.6188022,-2.154253,-1.209559,4.144894,-3.562411,-.005638843,.1067169,.07594858,1.00528,.1072543,-2.513259,-1.507208,-1.602979,1.404154,-.00556075,1.24049,-.2852117,3.485252,1.349321,-.07832214,.3655626,.3856288,.6867894,-.1609523,-.6704306,.5357301,-.6457935,.1479503,-1.354784,-.5454375,.8797469,-1.466514,.713442,.5934903,-.02911178,.8643737,.9030724,-1.048324,-.2738736,.8783074,3.246188,-4.435369,.1251791,.1783486,1.064657,.6522878,-2.770408,-1.618911,-25.04031,25.31674,-.004239279,.3241013,-3764484e-12,1.586843,.7035906,-1.9135,-1.144014,-10.80587,11.53677,-.01003197,.1577515,.05217789,1.225278,.005172771,-5.293208,-2.876463,2.087053,-3.201552,.003892964,.532393,-.2034512,2.61776,1.273597,.906034,.3773409,-.6399945,3.213979,-.09112172,.6494055,.395328,.5047796,.2998695,-1.482179,-.677831,1.161775,-3.004872,.4774797,-.4969248,-.003512074,-1.30719,.7927378,-.9863181,-.1803364,.5810824,4.58057,-3.863454,.5328174,.2272821,1.771114,.6791814]],fu=[[1.560219,1.417388,1.206927,10.91949,5.931416,7.304788,1.533049,1.560532,.3685059,13.5504,5.543711,7.792189,1.471043,1.746088,-.9299697,17.20362,5.473384,8.336416,1.355991,2.109348,-3.295855,22.64843,5.454607,9.304656,1.244963,2.547533,-5.841485,27.56879,5.576104,10.43287,1.175532,2.784634,-7.212225,29.75347,6.47298,10.92331,1.082973,3.118094,-8.934293,31.86879,8.473885,11.74019,.96925,3.349574,-10.0381,31.47654,13.38931,12.72547,.8547044,3.151538,-9.095567,25.54995,22.73219,14.10398,.758034,2.311153,-5.170814,12.29669,36.86529,15.98882,1.664273,1.574468,1.422078,9.768247,14.47338,16.44988,1.638295,1.719586,.5786675,12.39846,14.15419,17.28605,1.572623,1.921559,-.7714802,16.09246,14.20954,18.25908,1.468395,2.21197,-2.845869,20.75027,15.24822,19.37622,1.355047,2.556469,-4.96092,24.60237,16.4836,20.65648,1.291642,2.742036,-6.061967,26.02002,18.19144,21.16712,1.194565,2.97212,-7.295779,26.91805,21.2488,22.01819,1.083631,3.047021,-7.766096,24.96261,27.44264,22.91875,.9707994,2.736459,-6.308284,17.6086,37.76291,23.9215,.8574294,1.865155,-2.364707,4.337793,50.92831,25.23432],[1.632341,1.39523,1.375634,12.38193,5.921102,7.766508,1.597115,1.554617,.3932382,15.05284,5.725234,8.158155,1.522034,1.844545,-1.322862,19.18382,5.440769,8.837119,1.403048,2.290852,-4.013792,24.851,5.521888,9.845547,1.286364,2.774498,-6.648221,29.64151,5.923777,10.97075,1.213544,3.040195,-8.092676,31.86082,6.789782,11.58899,1.122622,3.347465,-9.649016,33.43824,9.347715,12.31374,1.007356,3.543858,-10.5352,32.39842,14.83962,13.31718,.8956642,3.2787,-9.254933,25.57923,24.89677,14.76166,.7985143,2.340404,-4.928274,11.41787,39.61501,16.82448,1.745162,1.639467,1.342721,11.66033,14.90124,17.74031,1.708439,1.819144,.2834399,14.48066,14.59214,18.58679,1.63172,2.094799,-1.378825,18.43198,14.63173,19.62881,1.516536,2.438729,-3.624121,22.98621,15.99782,20.70027,1.405863,2.785191,-5.705236,26.45121,17.6833,21.91903,1.344052,2.951807,-6.683851,27.44271,19.85706,22.29452,1.245827,3.182923,-7.82296,27.91395,23.27254,23.1591,1.132305,3.202593,-8.008429,25.21093,30.00014,24.05306,1.02033,2.820556,-6.238704,17.09276,40.77916,25.09949,.903157,1.863917,-1.955738,3.032665,54.3429,26.4178],[1.168084,2.156455,-3.980314,19.89302,13.28335,14.35621,1.135488,2.294701,-4.585886,20.90208,13.4784,14.67658,1.107408,2.382765,-5.112357,21.47823,14.93128,14.60882,1.054193,2.592891,-6.115,22.68967,16.35672,15.18999,1.006946,2.70542,-6.69893,22.9183,18.34324,15.70651,.9794044,2.74244,-6.805283,22.25271,20.50797,15.6313,.9413577,2.722009,-6.760707,20.98242,23.42588,16.05011,.8917923,2.59278,-6.152635,17.74141,28.58324,16.5791,.8288391,2.153434,-4.118327,10.78118,36.8171,17.38139,.7623528,1.418187,-.8845235,.7590129,46.29859,19.21657,1.352858,2.048862,-2.053393,14.05874,30.45344,30.4443,1.330497,2.126497,-2.466296,14.67559,30.90738,30.69707,1.286344,2.200436,-2.877228,14.92701,32.36288,30.77223,1.234428,2.289628,-3.404699,14.99436,34.6839,30.84842,1.17866,2.306071,-3.549159,14.11006,37.54188,30.7973,1.151366,2.333005,-3.728627,13.63374,39.05894,30.92599,1.101593,2.299422,-3.565787,11.96745,41.88472,31.02755,1.038322,2.083539,-2.649585,8.037389,47.00869,30.65948,.9596146,1.67147,-.8751538,1.679772,53.45784,30.5452,.8640731,.9858301,1.854956,-6.798097,59.36468,31.10255]],du=function(t,e,n,o,i){return hu[t][540*e+54*(n-1)+9*o+i]},Au=function(t,e,n,o){return fu[t][60*e+6*(n-1)+o]};function vu(t,e,n,o,i){return pu(t).reduce(function(t,r,s){return t+r*du(e,n,o,s,i)},0)}function mu(t,e,n,o){return pu(t).reduce(function(t,i,r){return t+i*Au(e,n,o,r)},0)}function pu(t){var e=Math.pow(2*t/Math.PI,1/3);return[Math.pow(1-e,5),5*Math.pow(1-e,4)*e,10*Math.pow(1-e,3)*Math.pow(e,2),10*Math.pow(1-e,2)*Math.pow(e,3),5*(1-e)*Math.pow(e,4),Math.pow(e,5)]}function gu(t,e,n,o){for(var i=new Array(9),r=Math.trunc(t),s=t-r,a=0;a<9;a++){var l=vu(n,o,0,r,a),c=vu(n,o,1,r,a);if(i[a]=(1-e)*(1-s)*l+e*(1-s)*c,10!=r){var u=vu(n,o,0,r+1,a),h=vu(n,o,1,r+1,a);i[a]+=(1-e)*s*u+e*s*h}}return i}function _u(t,e,n,o){var i=Math.trunc(t),r=t-i,s=(1-e)*(1-r)*mu(n,o,0,i)+e*(1-r)*mu(n,o,1,i);10!=i&&(s+=(1-e)*r*mu(n,o,0,i+1)+e*r*mu(n,o,1,i+1));return s}var Eu=[[.1787,-1.463,-.3554,.4275,-.0227,5.3251,.1206,-2.5771,-.067,.3703],[-.0193,-.2592,-.0665,8e-4,-4e-4,.2125,-.0641,-.8989,-.0033,.0452],[-.0167,-.2608,-.095,.0092,-.0079,.2102,-.0441,-1.6537,-.0109,.0529]],Cu=[[4.0453,-4.971,-.2155,2.4192],[.00166,-.00375,.00209,0,-.02903,.06377,-.03202,.00394,.11693,-.21196,.06052,.25886],[.00275,-.0061,.00317,0,-.04214,.0897,-.04153,.00516,.15346,-.26756,.0667,.26688]],wu=function(t,e,n){return Eu[t][2*e+n]},xu=function(t){return Cu[t]};function Iu(t,e,n){return(1+t[0]*Math.exp(t[1]/Math.cos(e)))*(1+t[2]*Math.exp(t[3]*n)+t[4]*Math.pow(Math.cos(n),2))}function Mu(t){return.212671*t+.71516*t+.072169*t}function Su(t,e){for(var n=new Array(5),o=0;o<5;o++)n[o]=wu(e,o,0)*t+wu(e,o,1);return n}function bu(t,e,n){switch(n){case 0:var o=xu(n),i=new ln(o[0],o[1],o[2],o[3]),r=Math.tan((4/9-t/120)*(Math.PI-2*e)),s=new ln(t*r,r,t,1);return.06*i.dot(s)/Iu(Su(t,n),0,e);case 1:case 2:o=xu(n);var a=Math.pow(e,2),l=Math.pow(e,3),c=o[0]*l+o[1]*a+o[2]*e+o[3],u=o[4]*l+o[5]*a+o[6]*e+o[7],h=o[8]*l+o[9]*a+o[10]*e+o[11];i=new An(c,u,h);return new An(Math.pow(t,2),t,1).dot(i)/Iu(Su(t,n),0,e)}}function yu(t,e){var n=[0,0,0];if(t[1]<0)return n;for(var o=[.605,.54,.445],i=[12.25,7.5,.3],r=.04608*e-.04586,s=1/(t[1]+.15*Math.pow(93.885-Math.acos(t[1])*(180/Math.PI),-1.253)),a=[1.05513096,.993359745,.903543472],l=0;l<3;l++){var c=Math.exp(.008735*-s*Math.pow(o[l],-4.08)),u=Math.exp(-s*r*Math.pow(o[l],-1.3)),h=Math.exp(.0035*-i[l]*s);n[l]=128e3*a[l]/Mu(a[l]),n[l]*=c*u*h}return n}const Ru=2e-5,Tu=636e4,Bu=[1.45756829855593,1.5659630555973838,1.6514844906767046,1.7149624273720931,1.7579798380502054,1.7825640788592454,1.7909510847583856,1.7854155013341066,1.7681555486430685,1.741220696472504,1.7064712716494368,1.6655608745273989,1.6199343724245185,1.5708359736889208,1.5193233505930548,1.466284949652144,1.4124585274017245,1.358449619703841,1.3047491384473928,1.2517496327261082,1.1997599875542062],Lu=[5424820087636473e-20,4418549866505454e-20,3635151910165377e-20,3017929012024763e-20,2526320226989157e-20,2130859310621843e-20,1809838025320633e-20,1547057129129042e-20,133028497733685e-19,1150184784075764e-20,999557429990163e-20,872799973630707e-20,765513700977967e-20,674217203751443e-20,596134125832052e-20,52903459806581e-19,471115687557433e-20,420910481110487e-20,377218381260133e-20,33905125547728e-19,305591531679811e-20],Nu=[3.25126849861e-9,5.85395365047e-9,1.977191155085e-8,7.309568762914e-8,2.0084561514287e-7,4.0383958096161e-7,6.3551335912363e-7,9.670704118097e-7,15479740042441e-19,209038647223331e-20,246128056164565e-20,273551299461512e-20,215125863128643e-20,159051840791988e-20,112356197979857e-20,7.3527551487574e-7,4.6450130357806e-7,3.3096079921048e-7,2.2512612292678e-7,1.487912926649e-7,1.6828623364192e-7],Du=[[.001368,39e-6,.006450001],[.01431,396e-6,.06785001],[.13438,.004,.6456],[.34828,.023,1.74706],[.2908,.06,1.6692],[.09564,.13902,.8129501],[.0049,.323,.272],[.06327,.71,.07824999],[.2904,.954,.0203],[.5945,.995,.0039],[.9163,.87,.001650001],[1.0622,.631,8e-4],[.8544499,.381,19e-5],[.4479,.175,2e-5],[.1649,.061,0],[.04677,.017,0],[.01135916,.004102,0],[.002899327,.001047,0],[.0006900786,2492e-7,0],[.0001661505,6e-5,0],[4150994e-11,1499e-8,0]],Pu=[.006811185292,.03614807107,.09004346519,.1706680068,.2818362161,.4303406404,.6296271457,.9145252695],Ou=[.01750893642,.04135477391,.06678839063,.09507698807,.1283416365,.1707430204,.2327233347,.3562490486],Fu=new An,Uu=new An,Vu=new An,Gu=new An,Qu=new An,zu=new An,ku=new An,Hu=new An,Wu=new An,Yu=new An,Xu=new An,Ku=new An,ju=new An;function Zu(t,e,n){return n.set(Math.cos(t)*Math.cos(e),Math.cos(t)*Math.sin(e),Math.sin(t))}function qu(t,e){e.set(0,0,0);for(let n=0;n<21;n++)e.x+=Du[n][0]*t[n],e.y+=Du[n][1]*t[n],e.z+=Du[n][2]*t[n];return e.multiplyScalar(20)}function Ju(t){return Math.exp(-t/8e3)}function $u(t){return Math.exp(-t/1200)}function th(t){let e=0;return t>=1e4&&t<25e3?e=1/15e3*t-2/3:t>=25e3&&t<4e4&&(e=-(1/15e3*t-8/3)),e}function eh(t,e){if(e.z>=0)return!1;const n=-2*e.dot(Fu.copy(t).negate());return n*n-4*(t.lengthSq()-Math.pow(Tu,2))>=0}function nh(t,e,n){const o=-2*e.dot(Fu.copy(t).negate()),i=t.lengthSq()-Math.pow(642e4,2),r=(-o+Math.sqrt(o*o-4*i))/2;return n.set(t.x+e.x*r,t.y+e.y*r,t.z+e.z*r)}function oh(t,e,n){nh(t,e,Qu);const o=t.distanceTo(Qu),i=Hu.copy(e).multiplyScalar(o);n.set(0,0,0);const r=Fu,s=Uu;for(let e=0;e<8;e++){r.copy(t).addScaledVector(i,Pu[e]);const o=r.length()-Tu;s.set(Ju(o),$u(o),th(o)),n.addScaledVector(s,Ou[e])}return n.multiplyScalar(o)}function ih(t){return t.x+t.y+t.z}function rh(t,e,n,o,i,r,s){nh(n,t,Qu);const a=n.distanceTo(Qu)/32,l=Wu.copy(t).multiplyScalar(a);Ku.set(0,0,0);for(let t=0;t<21;t++)s[t]=0;const c=t.dot(e);Yu.set(function(t){return 3/(16*Math.PI)*(1+Math.pow(t,2))}(c),function(t){return 3*.4224*(1+Math.pow(t,2))/(8*Math.PI*2.5776*Math.pow(1.5776-1.52*t,1.5))}(c),0),Xu.set(o,i,r),ju.copy(n).addScaledVector(l,.5);for(let t=0;t<32;t++){const t=ju.length()-Tu;if(Vu.set(Ju(t),$u(t),th(t)),Vu.multiply(Xu),Ku.addScaledVector(Vu,a),!eh(ju,e)){oh(ju,e,Gu).multiply(Xu);const t=Gu.add(Ku);for(let e=0;e<21;e++){zu.set(Lu[e],1.11*Ru,Nu[e]).multiply(t);const n=Math.exp(-ih(zu));ku.set(Lu[e],Ru,0).multiply(Vu),s[e]+=n*ih(ku.multiply(Yu))*Bu[e]*a}}ju.add(l)}}function sh(t,e,n,o,i,r,s,a){const l=Array(21),c=e/2,u=new An(0,0,Tu+i),h=new An;Zu(o,0,h);const f=Math.PI/2/n,d=2*Math.PI/e,A=f/2,v=new An,m=new An;for(let o=0;o<n;o++){const i=(Math.PI/2+A)*Math.pow(o/n,2),f=o*e*4;for(let n=0;n<c;n++){Zu(i,d*n-Math.PI,v),rh(v,h,u,r,s,a,l),qu(l,m);const o=4*n;t[f+o]=m.x,t[f+o+1]=m.y,t[f+o+2]=m.z;const c=4*(e-n-1);t[f+c]=m.x,t[f+c+1]=m.y,t[f+c+2]=m.z}}}const ah={BACKGROUND_BL:{color:0,strength:1},BSDF_DIFFUSE_BL:{color:0,roughness:1,normal:2},BSDF_GLOSSY_BL:{color:0,roughness:1,anisotropy:2,rotation:3,normal:4,tangent:5},BSDF_METALLIC_BL:{baseColor:0,edgeTint:1,ior:2,extinction:3,roughness:4,anisotropy:5,rotation:6,normal:7,tangent:8},BSDF_PRINCIPLED_BL:{baseColor:0,metallic:1,roughness:2,ior:3,alpha:4,normal:5,diffuseRoughness:6,subsurface:7,subsurfaceRadius:8,subsurfaceScale:9,subsurfaceIor:10,subsurfaceAnisotropy:11,specularIORLevel:12,specularTint:13,anisotropic:14,anisotropicRotation:15,tangent:16,transmission:17,clearcoat:18,clearcoatRoughness:19,clearcoatIor:20,clearcoatTint:21,clearcoatNormal:22,sheen:23,sheenRoughness:24,sheenTint:25,emission:26,emissionStrength:27,thinFilmThickness:28,thinFilmIOR:29},BSDF_PRINCIPLED_BF43_BL:{baseColor:0,metallic:1,roughness:2,ior:3,alpha:4,normal:5,subsurface:6,subsurfaceRadius:7,subsurfaceScale:8,subsurfaceIor:9,subsurfaceAnisotropy:10,specularIORLevel:11,specularTint:12,anisotropic:13,anisotropicRotation:14,tangent:15,transmission:16,clearcoat:17,clearcoatRoughness:18,clearcoatIor:19,clearcoatTint:20,clearcoatNormal:21,sheen:22,sheenRoughness:23,sheenTint:24,emission:25,emissionStrength:26},BSDF_TRANSLUCENT_BL:{color:0,normal:1},BSDF_TRANSPARENT_BL:{color:0},DIFFUSE_BSDF_BL:{color:0,roughness:1,normal:2},EEVEE_SPECULAR_BL:{baseColor:0,specular:1,roughness:2,emissiveColor:3,transparency:4,normal:5,clearcoat:6,clearcoatRoughness:7,clearcoatNormal:8,ambientOcclusion:9},EMISSION_BL:{color:0,strength:1},LIGHT_PATH_BL:{},MIX_BL:{fac:0,col1:1,col2:2},MIX_SHADER_BL:{fac:0,color1:1,color2:2},NEW_GEOMETRY_BL:{},NORMAL_MAP_BL:{strength:0,normalColor:1},OUTPUT_MATERIAL_BL:{surface:0,volume:1,displacement:2,thickness:3},OUTPUT_WORLD_BL:{surface:0,volume:1},RGB_BL:{},SEPARATE_COLOR_BL:{color:0},TEX_COORD_BL:{},TEX_ENVIRONMENT_BL:{vector:0},TEX_IMAGE_BL:{vector:0},UVMAP_BL:{uv:0},VALUE_BL:{},BITMAP_MX:{uOffset:0,vOffset:1,uTiling:2,vTiling:3,wAngle:4},BITMAP_ENV_MX:{uOffset:0,vOffset:1,uTiling:2,vTiling:3,wAngle:4,normal:5},FALLOFF_MX:{normal:2},MATERIAL_MX:{ambientColor:0,diffuseColor:1,specularColor:2,glossiness:3,specularLevel:4,selfIllum:5,opacity:6,filterColor:7,normal:8,reflection:9,refraction:10,displacement:11},NORMAL_BUMP_MX:{normalColor:0,additionalBump:1,normalMult:2,addBumpMult:3},OPENPBR_SURFACE_MX:{baseWeight:0,baseColor:1,baseMetalness:2,baseDiffuseRoughness:3,specularWeight:4,specularColor:5,specularRoughness:6,specularIOR:7,transmissionWeight:8,transmissionColor:9,transmissionDepth:10,fuzzWeight:11,fuzzColor:12,fuzzRoughness:13,coatWeight:14,coatColor:15,coatRoughness:16,emissionWeight:17,emissionColor:18,emissionLuminance:19,geometryOpacity:20,normal:21,clearcoatNormal:22},OUTPUT_MX:{color:0},PHYSICAL_MX:{base:0,baseColor:1,reflectivity:2,reflColor:3,roughness:4,metalness:5,diffRoughness:6,anisotropy:7,anisoangle:8,transparency:9,transColor:10,transRoughness:11,ior:12,scattering:13,sssColor:14,sssScale:15,emission:16,emitColor:17,clearcoat:18,clearcoatColor:19,clearcoatRoughness:20,normal:21,clearcoatNormal:22,displacement:23,opacity:24},REFLECT_REFRACT_MX:{normal:0},RGB_MX:{},SUB_TRANSFORM_MX:{scale:0,rotate:1,offset:2},VALUE_MX:{},BUMP_2D_MY:{bumpDepth:0,bumpValue:1},COLOR_CONSTANT_MY:{color:0,alpha:1},FILE_MY:{uvCoord:0},FLOAT_CONSTANT_MY:{value:0},LAMBERT_MY:{color:0,ambientColor:1,incandescence:2,matteOpacity:3,diffuse:4,normal:5,translucence:6,transparency:7},OPENPBR_SURFACE_MY:{baseWeight:0,baseColor:1,baseDiffuseRoughness:2,baseMetalness:3,specularWeight:4,specularColor:5,specularRoughness:6,specularIOR:7,transmissionWeight:8,transmissionColor:9,transmissionDepth:10,transmissionScatter:11,fuzzWeight:12,fuzzColor:13,fuzzRoughness:14,coatWeight:15,coatColor:16,coatRoughness:17,emissionLuminance:18,emissionColor:19,geometryOpacity:20,normal:21},PLACE_2D_TEXTURE_MY:{offset:0,repeatUv:1,rotateUv:2},RAMP_MY:{uvCoord:0},SAMPLER_INFO_MY:{viewNorm:0},SHADING_ENGINE_MY:{surface:0,volume:1,displacement:2},SUB_TRANSFORM_MY:{scale:0,rotate:1,offset:2},SURFACE_SHADER_MY:{color:0,glowColor:1,matteOpacity:2,transparency:3},IMAGE_AR:{multiply:0,offset:1,uvcoords:2,soffset:3,toffset:4,sscale:5,tscale:6,sflip:7,tflip:8,swapSt:9,duvdx:10,duvdy:11},LAMBERT_AR:{base:0,baseColor:1,normalCamera:2,opacity:3},MAP_TO_MTL_AR:{color:0},NORMAL_MAP_AR:{inputVal:0,normal:1,strength:2,tangent:3},STANDARD_SURFACE_AR:{base:0,baseColor:1,diffuseRoughness:2,metalness:3,specular:4,specularColor:5,specularRoughness:6,trans:7,transColor:8,transDepth:9,transScatter:10,transExtraRoughness:11,subsurface:12,subsurfaceColor:13,subsurfaceRadius:14,clearcoat:15,clearcoatColor:16,clearcoatRoughness:17,sheen:18,sheenColor:19,sheenRoughness:20,emission:21,emissionColor:22,opacity:23,normal:24,clearcoatNormal:25,specularIOR:26},TRIPLANAR_AR:{inputColor:0,inputColorY:1,inputColorZ:2,scale:3,rotate:4,offset:5,normal:6},TRIPLANAR_UV_AR:{vector:0,normal:1},UV_PROJECTION_AR:{projectionColor:0,uAngle:1,vAngle:2,matrix:3},NORMAL:{},RGB_ALPHA:{},VALUE:{}},lh={BACKGROUND_BL:{color:0},BSDF_DIFFUSE_BL:{color:0},BSDF_GLOSSY_BL:{color:0},BSDF_METALLIC_BL:{color:0},BSDF_PRINCIPLED_BL:{color:0},BSDF_TRANSLUCENT_BL:{color:0},BSDF_TRANSPARENT_BL:{color:0},EEVEE_SPECULAR_BL:{color:0},EMISSION_BL:{color:0},DIFFUSE_BSDF_BL:{color:0},LIGHT_PATH_BL:{isCameraRay:0,isShadowRay:1,isDiffuseRay:2,isGlossyRay:3,isSingularRay:4,isReflectionRay:5,isTransmissionRay:6,rayLength:7,rayDepth:8,diffuseDepth:9,glossyDepth:10,transparentDepth:11,transmissionDepth:12},MIX_BL:{col:0},MIX_SHADER_BL:{color:0},NEW_GEOMETRY_BL:{position:0,normal:1,tangent:2,trueNormal:3,incoming:4,parametric:5,backfacing:6,pointiness:7,randomPerIsland:8},NORMAL_MAP_BL:{normal:0},OUTPUT_MATERIAL_BL:{outgoingLight:0},OUTPUT_WORLD_BL:{outgoingLight:0},RGB_BL:{color:0},SEPARATE_COLOR_BL:{r:0,g:1,b:2},TEX_COORD_BL:{generated:0,normal:1,uv:2,object:3,camera:4,window:5,reflection:6},TEX_ENVIRONMENT_BL:{color:0},TEX_IMAGE_BL:{color:0,alpha:0},UVMAP_BL:{uv:0},VALUE_BL:{value:0},BITMAP_MX:{color:0,value:1},BITMAP_ENV_MX:{color:0,value:1},FALLOFF_MX:{color:0},MATERIAL_MX:{color:0},NORMAL_BUMP_MX:{normal:0},OPENPBR_SURFACE_MX:{color:0},OUTPUT_MX:{outgoingLight:0},PHYSICAL_MX:{color:0},RGB_MX:{color:0},REFLECT_REFRACT_MX:{color:0},SUB_TRANSFORM_MX:{vector:0,normal:1},VALUE_MX:{value:0},BUMP_2D_MY:{normal:0},COLOR_CONSTANT_MY:{color:0,alpha:1},FILE_MY:{alpha:0,color:1,size:2,transparency:3},FLOAT_CONSTANT_MY:{value:0},LAMBERT_MY:{color:0},OPENPBR_SURFACE_MY:{color:0},PLACE_2D_TEXTURE_MY:{uv:0},RAMP_MY:{alpha:0,color:1},SAMPLER_INFO_MY:{facingRatio:0,flippedNormal:1,matrixEyeToWorld:2,normalCamera:3,pixelCenter:4,pointCamera:5,pointObj:6,pointWorld:7,tangentUCamera:8,tangentVCamera:9,uvCoord:10},SHADING_ENGINE_MY:{outgoingLight:0},SUB_TRANSFORM_MY:{vector:0,normal:1},SURFACE_SHADER_MY:{color:0,glowColor:1,matteOpacity:2,transparency:3},IMAGE_AR:{color:0,alpha:1,transparency:2},LAMBERT_AR:{color:0,alpha:1,transparency:2},MAP_TO_MTL_AR:{color:0},NORMAL_MAP_AR:{value:0},STANDARD_SURFACE_AR:{color:0,transparency:1},TRIPLANAR_AR:{color:0},TRIPLANAR_UV_AR:{uv:0,duvdx:1,duvdy:2},UV_PROJECTION_AR:{uv:0},NORMAL:{normal:0},RGB_ALPHA:{color:0,alpha:1},VALUE:{value:0}};function ch(t,e="",n={}){let o;switch(t){case"BACKGROUND_BL":o={inputs:[[0,0,0,1],1],outputs:[[0,0,0,0]]};break;case"BSDF_DIFFUSE_BL":case"DIFFUSE_BSDF_BL":o={inputs:[[.8,.8,.8,1],0,[0,0,0]],outputs:[[0,0,0,0]]};break;case"BSDF_PRINCIPLED_BL":o={inputs:[[.8,.8,.8,1],0,.5,1.5,1,[0,0,0],0,[1,.2,.1],.05,1.4,0,.5,[1,1,1,1],0,0,[0,0,0],0,0,.03,1.5,[1,1,1,1],[0,0,0],0,.5,[0,0,0,1],[1,1,1,1],0,0,0],outputs:[[0,0,0,0]]};break;case"BSDF_TRANSPARENT_BL":o={inputs:[[1,1,1,1]],outputs:[[0,0,0,0]]};break;case"LIGHT_PATH_BL":o={inputs:[],outputs:[0,0,0,0,0,0,0,0,0,0,0,0,0]};break;case"MIX_BL":o={dataType:"RGBA",clampFactor:!0,blendType:"MIX",clampResult:!1,factorMode:"UNIFORM",inputs:[.5,[.5,.5,.5,1],[.5,.5,.5,1]],outputs:[[0,0,0,0]]};break;case"MIX_SHADER_BL":o={inputs:[.5,[0,0,0,0],[0,0,0,0]],outputs:[[0,0,0,0]]};break;case"OUTPUT_MATERIAL_BL":o={inputs:[[0,0,0,0],[0,0,0,0],[0,0,0],0],outputs:[]};break;case"OUTPUT_WORLD_BL":o={inputs:[[0,0,0,1],[0,0,0,0]],outputs:[]};break;case"RGB_BL":o={inputs:[],outputs:[[.5,.5,.5,1]]};break;case"TEX_ENVIRONMENT_BL":o={projection:"EQUIRECTANGULAR",texture:-1,inputs:[[0,0,0]],outputs:[[0,0,0,0]]};break;case"TEX_IMAGE_BL":o={alphaMode:"STRAIGHT",clampToEdgeNoExtend:!1,projection:"FLAT",projectionBlend:0,texture:-1,inputs:[[0,0,0]],outputs:[[0,0,0,0],0]};break;case"UVMAP_BL":o={uvLayer:"",inputs:[],outputs:[[0,0,0]]};break;case"VALUE_BL":case"VALUE_MX":case"VALUE":o={inputs:[],outputs:[0]};break;case"BITMAP_MX":o={alphaAsMono:!1,alphaAsRGB:!1,alphaSource:"NONE",axis:"XY",clampToEdgeNoExtend:[!1,!1],mapping:"EXPLICIT_MAP_CHANNEL",texture:-1,uvIndex:0,inputs:[0,0,1,1,0],outputs:[[0,0,0,0]]};break;case"PHYSICAL_MX":o={brdfCurve:5,brdfHigh:1,brdfLow:.05,brdfMode:!0,emitLuminance:1500,roughnessInv:!1,thinWalled:!1,transRoughnessInv:!1,transRoughnessLock:!0,inputFactors:[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],inputs:[1,[1,1,1,1],1,[1,1,1,1],.5,0,0,0,0,0,[1,1,1,1],0,1.5,0,[0,0,0,0],0,0,[1,1,1,1],0,[1,1,1,1],0,[0,0,0],[0,0,0],0,1],outputs:[[0,0,0,0]]};break;case"OUTPUT_MX":o={inputs:[[0,0,0,0]],outputs:[]};break;case"RGB_MX":o={inputs:[],outputs:[[0,0,0,1]]};break;case"COLOR_CONSTANT_MY":o={inputs:[[0,0,0],1],outputs:[[0,0,0],0]};break;case"FILE_MY":o={fileHasAlpha:!1,texture:-1,inputs:[[0,0]],outputs:[1,[0,0,0],[2048,2048],[0,0,0]]};break;case"FLOAT_CONSTANT_MY":o={inputs:[0],outputs:[0]};break;case"LAMBERT_MY":o={inputs:[[.5,.5,.5],[0,0,0],[0,0,0],1,.8,[0,0,0],0,[0,0,0]],outputs:[[0,0,0,0]]};break;case"PLACE_2D_TEXTURE_MY":o={uvIndex:0,inputs:[[0,0],[1,1],0],outputs:[[0,0]]};break;case"SHADING_ENGINE_MY":o={inputs:[[0,0,0,0],[0,0,0,0],[0,0,0]],outputs:[]};break;case"LAMBERT_AR":o={inputs:[.7,[1,1,1],[0,0,0],[0,0,0]],outputs:[[0,0,0,0],0,[0,0,0]]};break;case"STANDARD_SURFACE_AR":o={thinWalled:!0,inputs:[1,[.8,.8,.8],0,0,1,[1,1,1],.2,0,[0,0,0],0,[0,0,0],0,0,[1,1,1],[1,1,1],0,[1,1,1],.1,0,[1,1,1],.3,0,[1,1,1],[1,1,1],[0,0,0],[0,0,0],1.5],outputs:[[0,0,0,0],[0,0,0]]};break;case"RGB_ALPHA":o={inputs:[],outputs:[[0,0,0],1]};break;default:console.error("v3d.NodeUtils.createNode: Invalid node:",t)}return o?(o.name=e,o.type=t,["OUTPUT_MATERIAL_BL","OUTPUT_WORLD_BL","OUTPUT_MX","SHADING_ENGINE_MY"].includes(t)?o.is_active_output=!0:o.is_active_output=!1,Object.assign(o,n),{originData:o}):void 0}function uh(t){return t.originData.type}function hh(t){let e=uh(t);const n=t.originData;if("BSDF_PRINCIPLED_BL"==e&&29===n.inputs.length)e="BSDF_PRINCIPLED_BF43_BL";if("BUMP_BL"==e&&4===n.inputs.length)e="BUMP_BF44_BL";return e}function fh(t,e){const n=uh(t);return Array.isArray(e)?e.includes(n):e===n}function dh(t,e){for(let n=0;n<t.len();n++){if(uh(t.node(n))==e)return n}return-1}function Ah(t,e){for(let n=0;n<t.len();n++){if(t.node(n).originData.name==e)return n}return-1}function vh(t,e,n,o=""){if(!Number.isFinite(n))return console.error("v3d.NodeUtils.findConnectedNode: Invalid input index"),null;"object"==typeof e&&(e=t.nodeIndex(e));for(let i in t.edges){const r=t.edges[i];if(r.to()==e){const e=t.node(r.from());for(let t=0;t<r.connections.length;t++){if(r.connections[t].to===n&&(""===o||fh(e,o)))return e}}}return null}function mh(t,e,n,o=""){if(!Number.isFinite(n))return console.error("v3d.NodeUtils.findAllConnectedNodes: Invalid input index"),null;"object"==typeof e&&(e=t.nodeIndex(e));const i=[];for(let r in t.edges){const s=t.edges[r];if(s.to()==e){const e=t.node(s.from());if(o&&!fh(e,o))continue;for(let t=0;t<s.connections.length;t++){const o=s.connections[t];o.to===n&&i.push({node:e,nodeIdx:s.from(),outputIdx:o.from,channelMatrix:o.channelMatrix})}}}return i}function ph(t,e,n){if(!Number.isFinite(n))return console.error("v3d.NodeUtils.isConnInput: Invalid input index"),!1;const o=t.findInEdges(e);for(let t=0;t<o.length;t++){const e=o[t];for(let t=0;t<e.connections.length;t++){if(e.connections[t].to==n)return!0}}return!1}function gh(t,e,n){if(!Number.isFinite(n))return console.error("v3d.NodeUtils.isConnOutput: Invalid output index"),!1;for(let o in t.edges){const i=t.edges[o];if(i.from()==e)for(let t=0;t<i.connections.length;t++){if(i.connections[t].from==n)return!0}}return!1}function _h(t,e,n,o,i,r){if(!Number.isFinite(n)||!Number.isFinite(i))return void console.error("v3d.NodeUtils.connectNodes: Invalid input/output index");t.edge(e,o)||t.addNewEdge(e,o);const s=t.edge(e,o);s.connections=s.connections||[];const a={from:n,to:i};r&&(a.channelMatrix=r),s.connections.push(a)}function Eh(t){return t.endsWith("_AR")||t.endsWith("_BL")||t.endsWith("_MX")||t.endsWith("_MY")?t.slice(0,-3):t}function Ch(t,e){return Be("NODE_"+Eh(t))+"Uni"+e}function wh(t){const e=new nu(t.len());for(let n=0;n<e.len();n++)xh(t.node(n),e.node(n));for(let n in t.edges){const o=t.edges[n];e.addNewEdge(o.from(),o.to()).connections=o.connections.slice()}return e}function xh(t,e){e||(e={}),e.originData={};for(const n in t.originData)e.originData[n]="texture"==n?t.originData[n]:JSON.parse(JSON.stringify(t.originData[n]));return t.attributes&&(e.attributes=JSON.parse(JSON.stringify(t.attributes))),t.params&&(e.params=JSON.parse(JSON.stringify(t.params))),t.inputFactors&&(e.inputFactors=t.inputFactors.slice(0)),t.inputs&&(e.inputs=JSON.parse(JSON.stringify(t.inputs))),t.outputs&&(e.outputs=JSON.parse(JSON.stringify(t.outputs))),e}function Ih(t){let e=-1;for(let n=0;n<t.len();n++)if(t.node(n).originData.is_active_output){e=n;break}if(-1==e)t.removeAll();else{const n=new su(t.reverse(),e),o=[];for(let e=0;e<t.len();e++)n.hasPathTo(e)||o.push(t.node(e));o.forEach(function(e){t.disconnect(t.nodeIndex(e),!0)})}}function Mh(t,e,n,o=""){if(!Number.isFinite(n))return console.error("v3d.NodeUtils.disconnectInputNode: Invalid input index"),null;"object"==typeof e&&(e=t.nodeIndex(e));for(let i in t.edges){const r=t.edges[i];if(r.to()==e){const i=t.node(r.from());if(o&&!fh(i,o))continue;for(let o=0;o<r.connections.length;o++){const s=r.connections[o];if(s.to===n)return t.removeEdge(r.from(),e),{node:i,outputIdx:s.from}}}}return null}function Sh(t,e,n,o=""){if(!Number.isFinite(n))return console.error("v3d.NodeUtils.disconnectOutputNode: Invalid output index"),null;"object"==typeof e&&(e=t.nodeIndex(e));for(let i in t.edges){const r=t.edges[i];if(r.from()==e){const i=t.node(r.to());if(o&&!fh(i,o))continue;for(let o=0;o<r.connections.length;o++){const s=r.connections[o];if(s.from==n)return t.removeEdge(e,r.to()),{node:i,inputIdx:s.to}}}}return null}const bh=256,yh=512,Rh=1500/Math.PI,Th={LAMBERT_AR:2,STANDARD_SURFACE_AR:24,BEVEL_BL:1,BSDF_DIFFUSE_BL:2,BSDF_GLASS_BL:3,BSDF_GLOSSY_BL:4,BSDF_METALLIC_BL:7,BSDF_PRINCIPLED_BL:5,BSDF_PRINCIPLED_BF43_BL:5,BSDF_REFRACTION_BL:3,BSDF_SHEEN_BL:2,BSDF_TRANSLUCENT_BL:1,BUMP_BL:4,BUMP_BF44_BL:3,DIFFUSE_BSDF_BL:2,EEVEE_SPECULAR_BL:5,FRESNEL_BL:1,LAYER_WEIGHT_BL:1,BLINN_MY:5,LAMBERT_MY:5,OPENPBR_SURFACE_MY:21,PHONG_MY:5,PHONG_E_MY:5,SAMPLER_INFO_MY:0},Bh=["BSDF_DIFFUSE_BL","BSDF_GLOSSY_BL","BSDF_METALLIC_BL","BSDF_PRINCIPLED_BL","DIFFUSE_BSDF_BL","EEVEE_SPECULAR_BL","EMISSION_BL"],Lh=["PHYSICAL_MX","LAMBERT_AR","OPENPBR_SURFACE_MX","STANDARD_SURFACE_AR","MAP_TO_MTL_AR"],Nh=["STANDARD_SURFACE_AR","LAMBERT_MY","LAMBERT_AR","OPENPBR_SURFACE_MY","SURFACE_SHADER_MY"],Dh={color:new tn(16777215),map:null,opacity:1,alphaMap:null,metalness:.5,metalnessMap:null,roughness:.5,roughnessMap:null,normalMap:null,normalScale:new we(1,1),aoMap:null,aoMapIntensity:1,emissive:new tn(0),emissiveMap:null,emissiveIntensity:0};class Ph extends Lo{constructor(t){super();const e=this;function n(t,e){const n=t.node(e);n.originData.type;for(let i=0;i<n.originData.inputs.length;i++)o(t,e,n.originData,i)}function o(t,e,n,o,i){if(ph(t,e,o))return!1;const r=n.name+" "+(i||"Input "+o),s=n.inputs[o],a=D(s);let l,c,u=n.type.slice(-3);switch("_BL"!=u&&"_MX"!=u&&(u="float"==a?"":"_ALPHA"),a){case"float":l=ch("VALUE"+u,r),c=lh[uh(l)].value,l.originData.outputs[c]=s;break;case"vec3":l=ch("RGB"+u,r),c=lh[uh(l)].color,l.originData.outputs[c][0]=s[0],l.originData.outputs[c][1]=s[1],l.originData.outputs[c][2]=s[2];break;case"vec4":l=ch("RGB"+u,r),c=lh[uh(l)].color,l.originData.outputs[c][0]=s[0],l.originData.outputs[c][1]=s[1],l.originData.outputs[c][2]=s[2],fh(l,"RGB_ALPHA")?l.originData.outputs[lh[uh(l)].alpha]=s[3]:l.originData.outputs[c][3]=s[3];break;default:throw new Error("Unsupported group input")}return t.addNode(l),_h(t,t.len()-1,c,e,o),!0}function i(t,e,n){const o={inputs:[],outputs:[],removedNodes:[]};o.removedNodes.push(n);const i=dh(e,"GROUP_INPUT_BL");if(i>-1){o.removedNodes.push(i+t.len());const r=t.findInEdges(n),a=e.findOutEdges(i);for(let t=0;t<r.length;t++){const e=r[t];for(let t=0;t<a.length;t++){const n=a[t];for(let t=0;t<e.connections.length;t++){const i=e.connections[t];for(let t=0;t<n.connections.length;t++){const r=n.connections[t];if(i.to==r.from){let t=s(o.inputs,e.from(),n.to());t||(t=new ou(e.from(),n.to()),t.connections=[],o.inputs.push(t));const a={from:i.from,to:r.to};t.connections.push(a)}}}}}}const r=dh(e,"GROUP_OUTPUT_BL");o.removedNodes.push(r+t.len());const a=t.findOutEdges(n),l=e.findInEdges(r);for(let t=0;t<a.length;t++){const e=a[t];for(let t=0;t<l.length;t++){const n=l[t];for(let t=0;t<e.connections.length;t++){const i=e.connections[t];for(let t=0;t<n.connections.length;t++){const r=n.connections[t];if(i.from==r.to){let t=s(o.outputs,n.from(),e.to());t||(t=new ou(n.from(),e.to()),t.connections=[],o.outputs.push(t));const a={from:r.from,to:i.to};t.connections.push(a)}}}}}return o}function r(t,e){Array.isArray(e)||(e=[e]);let n=0;for(let o=0;o<t.len();o++){const i=t.node(o);for(let t=0;t<e.length;t++){const o=e[t];i.originData.type==o&&n++}}return n}function s(t,e,n){for(let o=0;o<t.length;o++){const i=t[o];if(i.from()==e&&i.to()==n)return i}return null}function a(t,e,n){const o=n.type;let i=t.findInEdges(e);for(let r=0;r<i.length;r++){const s=i[r];let a=t.node(s.from()).originData;for(let h=0;h<s.connections.length;h++){const f=s.connections[h];if("MATERIAL_MX"==o&&c(a.type)&&(f.to==ah[o].reflection?a.reflectMode="MAX_ENV_COORDS_REFLECT":f.to==ah[o].refraction&&(a.reflectMode="MAX_ENV_COORDS_REFRACT")),u(o,f.to)){if("BITMAP_MX"==a.type||"OUTPUT_MAP_MX"==a.type){t.removeEdge(s.from(),s.to()),"OUTPUT_MAP_MX"==a.type&&(a=vh(t,s.from(),0).originData);const n={originData:{name:a.name+"Bump"+r,type:"BUMP_MX",texture:a.texture,uvIndex:a.uvIndex,inputs:JSON.parse(JSON.stringify(a.inputs)),outputs:[[0,0,0]]}};t.addNode(n),_h(t,t.len()-1,0,e,f.to),r=-1,i=t.findInEdges(e);break}for(let e=0;e<t.len();e++){const o=t.node(e).originData;if(l(o.type)){const i=o.inputs.length-1;_h(t,s.from(),f.from,e,i),o.inputFactors[i]=n.inputFactors[f.to]}}}}}}function l(t){return!(!c(t)&&"FALLOFF_MX"!=t)}function c(t){return"BITMAP_ENV_MX"==t||"REFLECT_REFRACT_MX"==t}function u(t,e){switch(t){case"BITMAP_ENV_MX":case"FALLOFF_MX":case"MATERIAL_MX":case"REFLECT_REFRACT_MX":return e==ah[t].normal;case"OPENPBR_SURFACE_MX":case"PHYSICAL_MX":return e==ah[t].normal||e==ah[t].clearcoatNormal;default:return!1}}function h(t,e,n){const o=n.blendMode.length,i=t.findInEdges(e),r=t.findOutEdges(e);for(let e=0;e<o;e++){const o={originData:{name:n.name+"Layer"+e,type:"COMPOSITE_LAYER_MX",blendMode:0!=e?n.blendMode[e]:0,opacity:n.opacity[e],inputs:[[0,0,0,0]].concat(n.inputs.slice(2*e,2*e+2)),outputs:[n.outputs[e]]}};t.addNode(o);for(let o=0;o<i.length;o++){const r=i[o];for(let o=0;o<r.connections.length;o++){const i=r.connections[o];i.to==2*e&&n.mapEnabled[e]?_h(t,r.from(),i.from,t.len()-1,1):i.to==2*e+1&&n.maskEnabled[e]&&_h(t,r.from(),i.from,t.len()-1,2)}}e>0&&_h(t,t.len()-2,0,t.len()-1,0)}for(let e=0;e<r.length;e++){const n=r[e];for(let e=0;e<n.connections.length;e++){const o=n.connections[e];_h(t,t.len()-1,0,n.to(),o.to)}}}function f(t,e,n){const o=n.output,i=t.findInEdges(e),r=t.findOutEdges(e),s={originData:{name:n.name+"Output",type:"OUTPUT_MAP_MX",invert:o.invert,clamp:o.clamp,alphaFromRGB:o.alphaFromRGB,inputs:[[0,0,0,0],o.rgbLevel,o.rgbOffset,o.outputAmount,o.bumpAmount],outputs:[[0,0,0,0]]}};ye(o.colorMap)&&(s.originData.colorMap=o.colorMap),t.addNode(s);for(let e=0;e<r.length;e++){const n=r[e];for(let e=0;e<n.connections.length;e++){const o=n.connections[e];_h(t,t.len()-1,0,n.to(),o.to)}}t.disconnect(e,!1);for(let e=0;e<i.length;e++)t.addEdge(i[e]);_h(t,e,0,t.len()-1,0),delete n.output}function d(t,e,n){const o=n.inputs.length/4,i=t.findInEdges(e),r=t.findOutEdges(e);for(let e=0;e<o;e++){const o={originData:{name:n.name+"Layer"+e,type:"LAYERED_TEXTURE_LAYER_MY",inputs:[0,[0,0,0]].concat(n.inputs.slice(4*e,4*e+4)),outputs:[0,[0,0,0]]}};t.addNode(o);for(let n=0;n<i.length;n++){const o=i[n];for(let n=0;n<o.connections.length;n++){const i=o.connections[n];i.to==4*e?_h(t,o.from(),i.from,t.len()-1,2,i.channelMatrix):i.to==4*e+1?_h(t,o.from(),i.from,t.len()-1,3,i.channelMatrix):i.to==4*e+2?_h(t,o.from(),i.from,t.len()-1,4,i.channelMatrix):i.to==4*e+3&&_h(t,o.from(),i.from,t.len()-1,5,i.channelMatrix)}}e>0&&(_h(t,t.len()-1,0,t.len()-2,0),_h(t,t.len()-1,1,t.len()-2,1))}for(let e=0;e<r.length;e++){const n=r[e];for(let e=0;e<n.connections.length;e++){const i=n.connections[e];_h(t,t.len()-o,i.from,n.to(),i.to,i.channelMatrix)}}}function A(t){return t.type.indexOf("uniform")>-1}function v(t){return t.type.indexOf("varying")>-1}function m(t){return e.nodeUVAliases[t]||"uv"}function p(t,n){return n=ye(n)?n:"color",e.nodeVCAliases[t]||n}function g(t,e,n,o){const i=new ul(t,e,1,n,o,an.DEFAULT_MAPPING,y,y,N,N);return i.name="Node.parametric",i.needsUpdate=!0,i}function _(t){return!0===t.isVideoTexture&&t.encoding===Ft?"1":!t.isDataTexture||t.encoding!==Ft||t.type!=G&&t.type!=Q?"0":"1"}function E(t,e,n,o,i){let r;return e==n?r=t:"float"==e&&"vec3"==n?r="vec3("+[t,t,t].join(",")+")":"float"==e&&"vec4"==n?r="vec4("+[t,t,t,t].join(",")+")":"vec3"==e&&"float"==n||"vec4"==e&&"float"==n?r="("+[t+"[0]",t+"[1]",t+"[2]"].join("+")+")/3.0":"vec3"==e&&"vec4"==n?r="vec4("+t+", 1.0)":"vec4"==e&&"vec3"==n?r="vec3("+[t+"[0]",t+"[1]",t+"[2]"].join(",")+")":"float"==e&&"int"==n?r="int("+t+")":"int"==e&&"float"==n?r="float("+t+")":"int"==e&&"vec3"==n?r="vec3("+[t,t,t].join(",")+")":"int"==e&&"vec4"==n?r="vec4("+[t,t,t,t].join(",")+")":"bool"==e&&"float"==n?r="float("+t+")":console.error("MeshNodeMaterial: Missing type conversion: "+e+" -> "+n),(i<1||1!=i&&"normal"==o)&&(r="mix("+o+","+r+","+V(i)+")","normal"==o&&(r="normalize("+r+")")),r}function C(t,e,n,o,i){let r;const s=[],a=F(n),l=F(o);for(let n=0;n<l;n++){let o=1==l?i:i+"["+n+"]";for(let i=0;i<t.length;i++){const r=t[i],s=e[i];for(let t=0;t<a;t++)s[t][n]&&(o=1==a?r:r+"["+t+"]")}s.push(o)}return r=o+"("+s.join(",")+")",r}function w(t,e,n,o,i,r){for(let s in t.edges){const a=t.edges[s];if(a.to()==e){const e=t.node(a.from());for(let t=0;t<a.connections.length;t++){const s=a.connections[t];if(s.to==n){const t=e.originData.type;"BITMAP_MX"!=t&&"BITMAP_ENV_MX"!=t||"float"!=D(o)?i.push(e.outputs[s.from]):i.push(e.outputs[s.from+1]),s.channelMatrix&&r.push(s.channelMatrix)}}}}}function x(t){return{name:"",type:D(t),value:t}}function I(t,n){const o=Ch(t,n);return{name:o,type:e.nodeTextures[o].isCubeTexture?"uniform samplerCube":"uniform sampler2D",value:""}}function M(t){return{name:"",type:"int",value:t}}function S(t){return R(t?"true":"false")}function R(t){return{name:t,type:"",value:""}}function B(t,e,n){return n=n||t,{name:"nodeVaryParam"+Te(t),type:"varying "+P(e),value:"",attrBindName:n}}function L(t){return t?1:0}function D(t){return"number"==typeof t?"float":"boolean"==typeof t?"bool":P(t.length)}function P(t){switch(t){case 1:return"float";case 2:return"vec2";case 3:return"vec3";case 4:return"vec4";case 9:return"mat3";case 16:return"mat4"}}function F(t){switch(t){case"float":case"int":case"bool":return 1;case"vec2":return 2;case"vec3":return 3;case"vec4":return 4;case"mat3":return 9;case"mat4":return 16}}function U(t,e){switch(t){case"float":return V(e);case"bool":case"int":return String(e);default:const n=[];for(let t=0;t<e.length;t++)n.push(V(e[t]));return t+"("+n.join(",")+")"}}function V(t){return t%1?String(t):String(t)+".0"}this.isMeshNodeMaterial=!0,this.type="MeshNodeMaterial",this.defines={LIGHT_PATH_IS_CAM_RAY:1,WORLD_NODES:0,NORMAL_OUTPUT:0},this.definesFragOnly=new Set(["LIGHT_PATH_IS_CAM_RAY","WORLD_NODES","NORMAL_OUTPUT"]),this.wireframe=!1,this.wireframeLinewidth=1,this.flatShading=!1,this.fog=!0,this.profile="blender",this.nodeTextures={},this.nodeValue=[],this.nodeValueMap={},this.nodeRGB=[],this.nodeRGBMap={},this.nodeTexCoordObject=[],this.nodeTexCoordObjectMap={},this.nodeInputs={},this.needsBoundingBox=!1,this.useFloatTex=!1,this.nodeGraph=null,this.additionalNodeGraphs={},this.nodeChunks={},this.nodeChunksHash=0,this.nodeVCAliases={},this.nodeUVAliases={},this.envMap=null,this.envMapIntensity=1,this.envMapParallaxType=0,this.envMapParallaxMatrix=new Hn,this.envMapParallaxMatrixInv=new Hn,this.materialIndex=0,this.ssrParams=null,ye(t)&&this.setValues(t),this.nodeGraph||(this.nodeGraph=function(){const t=new nu(1),n=e.color;return t.node(0).originData={name:"ShadelessOutput",type:"OUTPUT_MATERIAL_BL",inputs:[[n.r,n.g,n.b,1],[0,0,0,0],[0,0,0]],outputs:[],is_active_output:!0},t}()),this.updateNodeGraph=function(t=!1){const n=this.nodeValue,o=this.nodeRGB,i=this.nodeTexCoordObject;this.nodeTextures={},this.nodeRGB=[],this.nodeRGBMap={},this.nodeValue=[],this.nodeValueMap={},this.nodeTexCoordObject=[],this.nodeTexCoordObjectMap={},this.needsBoundingBox=!1,this.nodeChunks={};const s=this.nodeGraph;if(function(t){var n;let o=0,i=0,s=0,a=0,l=0;for(let c=0;c<t.len();c++){const u=t.node(c),h=u.originData,f=h.type;let d,A,v,E,C,w,P,F,V,Q,z;u.attributes=[],u.params=[],u.inputFactors=[],u.inputs=[],u.outputs=[],ye(h.inputFactors)&&(u.inputFactors=h.inputFactors.slice(0));for(let t=0;t<h.outputs.length;t++){const e=h.outputs[t],n=h.outputTypes?h.outputTypes[t]:D(e);u.outputs.push({name:Be(Eh(f))+c+"Out"+t,type:n,clamp:!1,normalize:!1})}switch("OUTPUT_MATERIAL_BL"!=f&&"OUTPUT_WORLD_BL"!=f&&"OUTPUT_MX"!=f&&"SHADING_ENGINE_MY"!=f&&"SKYDOME_LIGHT_AR"!=f||u.outputs.push({name:"outgoingLight",type:"",clamp:!1,normalize:!1}),f){case"ATAN_AR":u.params.push(R(h.units));break;case"CLAMP_AR":case"COLOR_TO_FLOAT_AR":case"COLOR_TO_FLOAT_AR":case"FLOAT_TO_INT_AR":case"LENGTH_AR":case"MIX_SHADER_AR":case"RGB_TO_FLOAT_AR":case"RGB_TO_VECTOR_AR":case"RGBA_TO_FLOAT_AR":case"RGB_TO_VECTOR_AR":case"VECTOR_TO_RGB_AR":u.params.push(R(h.mode));break;case"COLOR_CONVERT_AR":u.params.push(R(h.from)),u.params.push(R(h.to));break;case"CHECKERBOARD_AR":case"PLACE_2D_TEXTURE_MY":d=h.uvIndex?"uv"+String(h.uvIndex+1):"uv",A=B(d,2),u.attributes.push({name:d,type:"attribute vec2"}),u.params.push(A);break;case"COMPOSITE_AR":u.params.push(R(h.operation)),u.params.push(R(h.alphaOperation));break;case"FACING_RATIO_AR":case"FACING_RATIO_AR":case"SHADOW_MATTE_AR":case"NORMAL":u.params.push(R("normal"));break;case"COMPARE_AR":u.params.push(R(h.test));break;case"IMAGE_AR":w=h.texture,e.nodeTextures[Ch(f,o)]=w,u.params.push(I(f,o)),o++,u.params.push(R(_(w)));break;case"LAMBERT_AR":case"BSDF_GLASS_BL":case"BSDF_GLOSSY_BL":case"BLINN_MY":case"LAMBERT_MY":case"PHONG_MY":case"PHONG_E_MY":u.params.push(R("geometryNormal"));break;case"MAP_TO_MTL_AR":u.params.push(S(h.opaqueEnabled));break;case"MATRIX_TRANSFORM_AR":u.params.push(R(h.transformOrder)),u.params.push(R(h.rotationType)),u.params.push(R(h.rotationUnits)),u.params.push(R(h.rotationOrder));break;case"NORMAL_MAP_AR":d="tangent",A=B(d,4),u.attributes.push({name:d,type:"attribute vec4"}),u.params.push(A);break;case"SHUFFLE_AR":case"CHANNELS_MY":u.params.push(R(h.channelR)),u.params.push(R(h.channelG)),u.params.push(R(h.channelB)),u.params.push(R(h.channelA));break;case"STANDARD_SURFACE_AR":u.params.push(R("geometryNormal")),u.params.push(S(h.thinWalled)),(h.inputs[ah[f].clearcoat]>0||ph(t,c,ah[f].clearcoat))&&(e.defines.USE_CLEARCOAT=""),(h.inputs[ah[f].sheen]>0||ph(t,c,ah[f].sheen))&&(e.defines.USE_SHEEN=""),u.inputFactors.length=0;break;case"TRIGO_AR":u.params.push(R(h.function)),u.params.push(R(h.units));break;case"TRIPLANAR_AR":u.params.push(R(h.coordSpace)),u.params.push(S(h.inputPerAxis)),u.params.push(S(h.flipOnOppositeDirection)),u.params.push(x(h.blendFactor));break;case"TRIPLANAR_UV_AR":u.params.push(S(h.flipOnOppositeDirection)),void 0!==h.blendFactor&&u.params.push(x(h.blendFactor)),void 0!==h.projectionAxis&&u.params.push(R(h.projectionAxis));break;case"TWO_SIDED_AR":u.params.push(R("faceDirection"));break;case"USER_DATA_COLOR_AR":d=p(h.colorLayer,""),d?(A=B(d,4),u.attributes.push({name:d,type:"attribute vec4"}),u.params.push(A)):u.params.push(R(U("vec4",h.defaultColor)));break;case"UV_PROJECTION_AR":u.params.push(R(h.projectionType)),u.params.push(R(h.coordSpace));break;case"ATTRIBUTE_BL":case"VERTEX_COLOR_BL":d=p(h.colorLayer,""),d?(A=B(d,4),u.attributes.push({name:d,type:"attribute vec4"}),u.params.push(A)):u.params.push(R("vec4(0.0, 0.0, 0.0, 1.0)"));break;case"BSDF_METALLIC_BL":u.params.push(R("geometryNormal")),u.params.push(R("BSDF_METALLIC_"+h.distribution)),u.params.push(S("PHYSICAL_CONDUCTOR"===h.fresnelType));break;case"BSDF_PRINCIPLED_BL":u.params.push(R("geometryNormal"));const D=hh(u);(h.inputs[ah[D].clearcoat]>0||ph(t,c,ah[D].clearcoat))&&(e.defines.USE_CLEARCOAT=""),(h.inputs[ah[D].sheen]>0||ph(t,c,ah[D].sheen))&&(e.defines.USE_SHEEN_BLENDER="");break;case"BSDF_REFRACTION_BL":u.params.push(R("geometryNormal")),u.params.push(R("BSDF_REFRACTION_"+h.distribution));break;case"BUMP_BL":u.params.push(x(h.invert));break;case"CAMERA_BL":u.params.push(R("vViewPosition")),r(t,"OUTPUT_MATERIAL_BL")>0||r(t,"OUTPUT_WORLD_BL")>0?u.params.push(S(!0)):u.params.push(S(!1));break;case"CLAMP_BL":u.params.push(R("RANGE"==h.clampType));break;case"COMBINE_COLOR_BL":u.params.push(R("NODE_COMB_COL_"+h.mode));break;case"CURVE_FLOAT_BL":e.useFloatTex?(v=new Float32Array(1024),E=1):(v=new Uint8Array(1024),E=255);for(let t=0;t<bh;t++){let e=E*(h.curveData[t]/2+.5);v[4*t]=ie(e,0,E)}w=g(v,bh,W,e.useFloatTex?G:O),P=Ch(f,i),e.nodeTextures[P]=w,u.params.push(I(f,i)),i++;break;case"CURVE_RGB_BL":case"CURVE_VEC_BL":e.useFloatTex?(v=new Float32Array(1024),E=1):(v=new Uint8Array(1024),E=255);for(let t=0;t<bh;t++){let e,n,o,i;V=h.curveData.length/bh,V>3?(e=E*h.curveData[V*t],n=E*h.curveData[V*t+1],o=E*h.curveData[V*t+2],i=E*h.curveData[V*t+3]):(e=E*(h.curveData[V*t]/2+.5),n=E*(h.curveData[V*t+1]/2+.5),o=E*(h.curveData[V*t+2]/2+.5),i=E),v[4*t]=ie(e,0,E),v[4*t+1]=ie(n,0,E),v[4*t+2]=ie(o,0,E),v[4*t+3]=ie(i,0,E)}w=g(v,bh,W,e.useFloatTex?G:O),P=Ch(f,i),e.nodeTextures[P]=w,u.params.push(I(f,i)),i++;break;case"EEVEE_SPECULAR_BL":u.params.push(R("geometryNormal")),(h.inputs[ah[f].clearcoat]>0||ph(t,c,ah[f].clearcoat))&&(e.defines.USE_CLEARCOAT="");break;case"FRESNEL_BL":case"LAYER_WEIGHT_BL":case"INCIDENT":case"POSITION":u.params.push(R("vViewPosition"));break;case"GRADIENT_MX":u.params.push(R(U("float",h.color2Pos))),u.params.push(R(U("int",h.gradientType))),d=h.uvIndex?"uv"+String(h.uvIndex+1):"uv",A=B(d,2),u.attributes.push({name:d,type:"attribute vec2"}),u.params.push(A),u.params.push(R("vViewPosition")),u.params.push(R("MAPPING_"+h.mapping)),u.params.push(R("AXIS_"+h.axis)),u.params.push(R(U("ivec2",[L(h.clampToEdgeNoExtend[0]),L(h.clampToEdgeNoExtend[1])])));break;case"GRADIENT_RAMP_MX":e.useFloatTex?(v=new Float32Array(2048),E=1):(v=new Uint8Array(2048),E=255);for(let t=0;t<yh;t++){let e,n,o,i;e=E*h.gradientData[3*t],n=E*h.gradientData[3*t+1],o=E*h.gradientData[3*t+2],i=1,v[4*t]=ie(e,0,E),v[4*t+1]=ie(n,0,E),v[4*t+2]=ie(o,0,E),v[4*t+3]=ie(i,0,E)}w=g(v,yh,W,e.useFloatTex?G:O),P=Ch(f,i),e.nodeTextures[P]=w,u.params.push(I(f,i)),i++,u.params.push(R(U("int",h.gradientType))),d=h.uvIndex?"uv"+String(h.uvIndex+1):"uv",A=B(d,2),u.attributes.push({name:d,type:"attribute vec2"}),u.params.push(A),u.params.push(R("geometryNormal")),u.params.push(R("vViewPosition")),["SPHERICAL_ENVIRONMENT","CYLINDRICAL_ENVIRONMENT","SHRINK_WRAP_ENVIRONMENT","SCREEN"].indexOf(h.mapping)>-1?u.params.push(R("MAPPING_EXPLICIT_MAP_CHANNEL")):u.params.push(R("MAPPING_"+h.mapping)),u.params.push(R("AXIS_"+h.axis)),u.params.push(R(U("ivec2",[L(h.clampToEdgeNoExtend[0]),L(h.clampToEdgeNoExtend[1])])));break;case"MAPPING_BL":u.params.push(R("NODE_MAPPING_"+h.vectorType));break;case"MAP_RANGE_BL":ye(h.dataType)&&u.params.push(R("NODE_MAP_RANGE_TYPE_"+h.dataType)),u.params.push(R("NODE_MAP_RANGE_INTERP_"+h.interpolationType)),u.params.push(S(h.clamp));break;case"NEW_GEOMETRY_BL":u.params.push(R("faceDirection")),u.params.push(R("vViewPosition")),u.params.push(R("normal")),gh(t,c,lh.NEW_GEOMETRY_BL.tangent)&&(e.needsBoundingBox=!0);break;case"NORMAL_MAP_BL":d="tangent",A=B(d,4),u.attributes.push({name:d,type:"attribute vec4"}),u.params.push(A),u.params.push(R("vNormal"));break;case"SEPARATE_COLOR_BL":u.params.push(R("NODE_SEP_COL_"+h.mode));break;case"TANGENT_BL":"RADIAL"===h.directionType?(u.params.push(R("TANGENT_AXIS_"+h.axis)),u.params.push(R("vViewPosition")),u.params.push(R("normal")),e.needsBoundingBox=!0):"UV_MAP"===h.directionType&&(d="tangent",A=B(d,4),u.attributes.push({name:d,type:"attribute vec4"}),u.params.push(A));break;case"TEX_BRICK_BL":u.params.push(R(U("float",h.offset))),u.params.push(R(U("int",h.offsetFrequency))),u.params.push(R(U("float",h.squash))),u.params.push(R(U("int",h.squashFrequency)));break;case"TEX_COORD_BL":u.params.push(R(`nodeTexCoordObjectMatrices[${a}]`)),u.params.push(R("vViewPosition")),u.params.push(R("normal")),d="uv",A=B(d,2),u.attributes.push({name:d,type:"attribute vec2"}),u.params.push(A),gh(t,c,lh.TEX_COORD_BL.generated)&&(e.needsBoundingBox=!0),e.nodeTexCoordObject.push(null),e.nodeTexCoordObjectMap[h.name]=a,a++;break;case"TEX_ENVIRONMENT_BL":case"TEX_IMAGE_BL":if(w=h.texture,e.nodeTextures[Ch(f,o)]=w,u.params.push(I(f,o)),o++,u.params.push(R(_(w))),"TEX_ENVIRONMENT_BL"==f){const t=h.projection;u.params.push(R("TEX_PROJ_"+t))}else if("TEX_IMAGE_BL"==f){let e;switch(h.alphaMode){case"STRAIGHT":e=gh(t,c,1)?"TEX_ALPHA_CLEAR":"TEX_ALPHA_PREMUL";break;case"PREMUL":e=gh(t,c,1)?"TEX_ALPHA_UNPREMUL":"TEX_ALPHA_CLEAR";break;case"CHANNEL_PACKED":e="TEX_ALPHA_CLEAR";break;case"NONE":e="TEX_ALPHA_ONE";break;default:console.error("MeshNodeMaterial: incorrect TEX_IMAGE_BL alpha mode"),e="TEX_ALPHA_ONE"}u.params.push(R(e)),u.params.push(R("normal"));const n=h.projection;u.params.push(R("TEX_PROJ_"+n)),u.params.push(x(h.projectionBlend)),u.params.push(S(h.clampToEdgeNoExtend))}break;case"TEX_GABOR_BL":u.params.push(R("TEX_GABOR_"+h.gaborType));break;case"TEX_GRADIENT_BL":u.params.push(R("TEX_GRAD_"+h.gradientType));break;case"TEX_MAGIC_BL":u.params.push(M(null!=(n=h.turbulenceDepth)?n:2));break;case"TEX_NOISE_BL":ye(h.noiseType)&&u.params.push(R("TEX_NOISE_"+h.noiseType)),u.params.push(R(U("float",h.falloffFactor))),u.params.push(R(U("float",h.dispersionFactor)));break;case"TEX_SKY_BL":if("PREETHAM"==h.skyType||"HOSEK_WILKIE"==h.skyType){let t,e,n,o,i,r;if(z=(new An).fromArray(h.sunDirection).angleTo(new An(0,0,1)),"PREETHAM"==h.skyType)t=Su(h.turbidity,0).concat([0,0,0,0]),e=Su(h.turbidity,1).concat([0,0,0,0]),n=Su(h.turbidity,2).concat([0,0,0,0]),o=bu(h.turbidity,z,0),i=bu(h.turbidity,z,1),r=bu(h.turbidity,z,2);else{const s=Math.max(Math.PI/2-z,0);t=gu(h.turbidity,h.groundAlbedo,s,0),e=gu(h.turbidity,h.groundAlbedo,s,1),n=gu(h.turbidity,h.groundAlbedo,s,2),o=_u(h.turbidity,h.groundAlbedo,s,0),i=_u(h.turbidity,h.groundAlbedo,s,1),r=_u(h.turbidity,h.groundAlbedo,s,2)}u.params.push(R("TEX_SKY_"+h.skyType)),u.params.push(x([t[0],e[0],n[0]])),u.params.push(x([t[1],e[1],n[1]])),u.params.push(x([t[2],e[2],n[2]])),u.params.push(x([t[3],e[3],n[3]])),u.params.push(x([t[4],e[4],n[4]])),u.params.push(x([t[5],e[5],n[5]])),u.params.push(x([t[6],e[6],n[6]])),u.params.push(x([t[7],e[7],n[7]])),u.params.push(x([t[8],e[8],n[8]])),u.params.push(x([o,i,r])),u.params.push(x(h.sunDirection))}else{v=new Float32Array(65536),sh(v,256,64,h.sunElevation,h.altitude,h.airDensity,h.aerosolDensity,h.ozoneDensity),w=new ul(v,256,64,W,G,an.DEFAULT_MAPPING,b,y,N,N),w.name="Node.nishita",w.needsUpdate=!0,P=Ch(f,i),e.nodeTextures[P]=w,u.params.push(I(f,i)),i++;let t=ge(h.sunRotation);t=2*Math.PI-t,u.params.push(x(t))}break;case"TEX_VORONOI_BL":u.params.push(R("DISTANCE_"+h.distance)),u.params.push(R("FEATURE_"+h.feature));break;case"TEX_WAVE_BL":u.params.push(R("TEX_WAVE_TYPE_"+h.waveType)),u.params.push(R("TEX_WAVE_PROFILE_"+h.waveProfile)),u.params.push(R(`TEX_WAVE_BANDS_DIR_${h.bandsDirection}`)),u.params.push(R(`TEX_WAVE_RINGS_DIR_${h.ringsDirection}`));break;case"MATH_BL":u.outputs[0].clamp=h.useClamp;break;case"MIX_BL":switch(u.originData.blendType){case"HUE":case"SATURATION":case"VALUE":case"COLOR":e.defines.HSV_NODES=""}"RGBA"==h.dataType&&(u.outputs[0].clamp=h.clampResult);break;case"MIX_SHADER_BL":let k=-1;for(let e=1;e<3;e++){const n=vh(t,c,e);n&&"BSDF_TRANSPARENT_BL"==n.originData.type&&(k=e-1)}u.params.push(R(String(k)));break;case"NORMAL_BL":u.params.push(x(h.outputs[0]));break;case"RGB_BL":case"RGB_MX":F=(new ln).fromArray(h.outputs[0]),e.nodeRGB.push(F),e.nodeRGBMap[h.name]=s,u.params.push(R("nodeRGB["+s+"]")),s++;break;case"SUB_TRANSFORM_MX":case"SUB_TRANSFORM_MY":u.params.push(R(h.coordSpace));break;case"UVMAP_BL":d=m(h.uvLayer),A=B(d,2),u.attributes.push({name:d,type:"attribute vec2"}),u.params.push(A);break;case"VALUE_BL":case"VALUE_MX":case"ANIM_CURVE_TA_MY":case"ANIM_CURVE_TU_MY":case"VALUE":F=h.outputs[0],e.nodeValue.push(F),e.nodeValueMap[h.name]=l,u.params.push(R("nodeValue["+l+"]")),l++;break;case"VALTORGB_BL":Q=h.curve;const H=new("STEP"==Q.interpolation?qc:cu)(new Float32Array(Q.input),new Float32Array(Q.output),4);e.useFloatTex?(v=new Float32Array(1024),E=1):(v=new Uint8Array(1024),E=255);for(let t=0;t<bh;t++){const e=H.evaluate(t/255);v[4*t]=E*e[0],v[4*t+1]=E*e[1],v[4*t+2]=E*e[2],v[4*t+3]=E*e[3]}w=g(v,bh,W,e.useFloatTex?G:O),"STEP"==Q.interpolation&&(w.minFilter=T,w.magFilter=T),P=Ch(f,i),e.nodeTextures[P]=w,u.params.push(I(f,i)),i++;break;case"VECTOR_ROTATE_BL":u.params.push(R(U("float",h.invert?-1:1)));break;case"VECT_TRANSFORM_BL":const Y=h.vectorType,X=h.convertFrom,K=h.convertTo;"NORMAL"==Y&&(u.outputs[0].normalize=!0);let j="";X==K?j="VEC_TRANS_NONE":(j="VEC_TRANS_"+X[0]+"_"+K[0],"VECTOR"!=Y&&"NORMAL"!=Y||(j+="_DIR")),u.params.push(R(j)),r(t,"OUTPUT_MATERIAL_BL")>0||r(t,"OUTPUT_WORLD_BL")>0?u.params.push(S(!0)):u.params.push(S(!1));break;case"BITMAP_MX":case"BITMAP_ENV_MX":case"REFLECT_REFRACT_MX":if(w=h.texture,e.nodeTextures[Ch(f,o)]=w,u.params.push(I(f,o)),o++,"BITMAP_MX"==f){d=h.uvIndex?"uv"+String(h.uvIndex+1):"uv",A=B(d,2),u.attributes.push({name:d,type:"attribute vec2"}),u.params.push(A),u.params.push(R("MAPPING_"+h.mapping)),u.params.push(R("AXIS_"+h.axis));const t=U("ivec2",[L(h.clampToEdgeNoExtend[0]),L(h.clampToEdgeNoExtend[1])]);u.params.push(R(t))}else u.params.push(R(h.reflectMode)),u.params.push(x(h.IOR));u.params.push(R(_(w))),"BITMAP_MX"!=f&&"BITMAP_ENV_MX"!=f||(u.params.push(S(h.alphaAsMono)),u.params.push(S(h.alphaAsRGB)),u.outputs.push({name:f.toLowerCase()+"_out1_n"+c,type:"float",clamp:!1,normalize:!1}));break;case"BLEND_MX":u.params.push(S(h.useCurve)),u.params.push(x(h.curveLower)),u.params.push(x(h.curveUpper));break;case"BUMP_MX":w=h.texture,e.nodeTextures[Ch(f,o)]=w,u.params.push(I(f,o)),o++,u.params.push(R("-vViewPosition")),u.params.push(R("normal")),d=h.uvIndex?"uv"+String(h.uvIndex+1):"uv",A=B(d,2),u.attributes.push({name:d,type:"attribute vec2"}),u.params.push(A);break;case"COLOR_CORRECTION_MX":const Z=U("ivec4",[h.rewireR,h.rewireG,h.rewireB,h.rewireA]);u.params.push(R(Z)),h.gainPivotGammaLift&&(u.params.push(x(h.gainPivotGammaLift)),u.params.push(S(h.enableR)),u.params.push(S(h.enableG)),u.params.push(S(h.enableB)),u.params.push(M(h.exposureMode)),u.params.push(x(h.printerLights)));break;case"COMPOSITE_LAYER_MX":u.params.push(R(U("int",h.blendMode)));const q=ph(t,c,1)?h.opacity:0;u.params.push(x(q));break;case"COLOR_MAP_MX":u.params.push(S(h.reverseGamma));break;case"FALLOFF_MX":if(u.params.push(R("-vViewPosition")),4!=h.falloffType)u.params.push(x(h.IOR)),u.params.push(M(h.falloffType));else{const t=void 0!==h.extrapolateOn&&h.extrapolateOn,e=void 0===h.nearDistance?0:h.nearDistance,n=void 0===h.farDistance?100:h.farDistance;u.params.push(S(t)),u.params.push(x(e)),u.params.push(x(n))}break;case"MASK_MX":u.params.push(S(h.maskInverted));break;case"MATERIAL_MX":u.params.push(x(h.inputFactors[ah[f].reflection])),u.params.push(x(h.inputFactors[ah[f].refraction])),h.inputFactors[ah[f].reflection]=1,h.inputFactors[ah[f].refraction]=1,u.params.push(S(h.selfIllumColorOn));break;case"MATTE_SHADOW_MX":u.params.push(R("normal")),u.params.push(S(h.receiveShadows)),u.params.push(x(h.shadowBrightness)),u.params.push(x(h.color));break;case"NOISE_MX":2==h.coordType?(d=h.uvIndex?"uv"+String(h.uvIndex+1):"uv",A=B(d,2),u.attributes.push({name:d,type:"attribute vec2"}),u.params.push(A)):u.params.push(R("vViewPosition")),u.params.push(M(h.noiseType)),u.params.push(M(h.coordType));break;case"NORMAL_BUMP_MX":d="tangent",A=B(d,4),u.attributes.push({name:d,type:"attribute vec4"}),u.params.push(A),u.params.push(R("normal"));const J="ivec2("+L(h.flip[0])+","+L(h.flip[1])+")";u.params.push(R(J));break;case"OPENPBR_SURFACE_MX":case"OPENPBR_SURFACE_MY":u.params.push(R("geometryNormal")),u.params.push(S(h.thinWalled)),(h.inputs[ah[f].coatWeight]>0||ph(t,c,ah[f].coatWeight))&&(e.defines.USE_CLEARCOAT=""),(h.inputs[ah[f].fuzzWeight]>0||ph(t,c,ah[f].fuzzWeight))&&(e.defines.USE_SHEEN="");break;case"OUTPUT_MAP_MX":if(u.params.push(S(h.invert)),u.params.push(S(h.clamp)),u.params.push(S(h.alphaFromRGB)),h.colorMap){e.useFloatTex?(C=h.colorMap,v=new Float32Array(1024),E=1):(C=Re(h.colorMap.slice(),0,1),v=new Uint8Array(1024),E=255),V=C.length/bh;for(let t=0;t<bh;t++)v[4*t]=E*C[V*t],3==V?(v[4*t+1]=E*C[V*t+1],v[4*t+2]=E*C[V*t+2]):(v[4*t+1]=v[4*t],v[4*t+2]=v[4*t]),v[4*t+3]=E;w=g(v,bh,W,e.useFloatTex?G:O),P=Ch(f,i),e.nodeTextures[P]=w,u.params.push(I(f,i)),i++}break;case"PHYSICAL_MX":u.params.push(R("geometryNormal")),u.params.push(x(h.emitLuminance));const $=void 0===h.brdfMode||h.brdfMode,tt=void 0===h.brdfLow?0:h.brdfLow,et=void 0===h.brdfHigh?0:h.brdfHigh,nt=void 0===h.brdfCurve?0:h.brdfCurve;u.params.push(S(!$)),u.params.push(R(U("float",tt))),u.params.push(R(U("float",et))),u.params.push(R(U("float",nt))),u.params.push(S(ye(h.roughnessInv)&&h.roughnessInv)),u.params.push(S(ye(h.transRoughnessLock)&&h.transRoughnessLock)),u.params.push(S(ye(h.transRoughnessInv)&&h.transRoughnessInv)),u.params.push(S(ye(h.thinWalled)&&h.thinWalled)),(h.inputs[ah[f].clearcoat]>0||ph(t,c,ah[f].clearcoat))&&(e.defines.USE_CLEARCOAT="");break;case"PHY_SUN_SKY_ENV_MX":const ot=15*h.haze+2,it=new uu;z=Math.PI/2-h.sunPolarAngle;const rt=Math.PI-h.sunAzimuthAngle;it.phi=z,it.theta=rt;const st=(new An).setFromSpherical(it).toArray();let at,lt,ct,ut,ht,ft;at=Su(ot,0),lt=Su(ot,1),ct=Su(ot,2),ut=bu(ot,z,0),ht=bu(ot,z,1),ft=bu(ot,z,2),ut/=.06,ut*=1e3,u.params.push(x([at[0],lt[0],ct[0]])),u.params.push(x([at[1],lt[1],ct[1]])),u.params.push(x([at[2],lt[2],ct[2]])),u.params.push(x([at[3],lt[3],ct[3]])),u.params.push(x([at[4],lt[4],ct[4]])),u.params.push(x([ut,ht,ft]));const dt=yu(st,ot),At=[0,0,0];u.params.push(x(st)),u.params.push(x(dt)),u.params.push(x(At)),u.params.push(x(h.globalIntensity/Rh)),u.params.push(x(h.groundColor));break;case"REFLECT_REFRACT_COLOR_MX":F=h.outputs[0],u.params.push(x(F));break;case"VERTEX_COLOR_MX":d="color",A=B(d,3),u.attributes.push({name:d,type:"attribute vec3"}),u.params.push(A);break;case"BUMP_2D_MY":u.params.push(R("vNormal")),h.bumpInterp>0&&(d="tangent",A=B(d,4),u.attributes.push({name:d,type:"attribute vec4"}),u.params.push(A));break;case"COLOR_COMPOSITE_MY":case"COLOR_LOGIC_MY":case"COLOR_MATH_MY":case"CONDITION_MY":case"FLOAT_COMPOSITE_MY":case"FLOAT_LOGIC_MY":case"FLOAT_MATH_MY":case"MULTIPLY_DIVIDE_MY":u.params.push(R(h.operation));break;case"COLOR_CORRECT_MY":u.params.push(S(h.colClamp)),u.params.push(x(h.colClampMin)),u.params.push(x(h.colClampMax)),u.params.push(S(h.alphaClamp)),u.params.push(x(h.alphaClampMin)),u.params.push(x(h.alphaClampMax)),u.params.push(S(h.unpremultiplyInput)),u.params.push(S(h.premultiplyResult));break;case"COLOR_MASK_MY":u.params.push(S(h.maskAlphaIsLuminance));break;case"COMPOSE_MATRIX_MY":u.params.push(S(h.useEulerRotation)),u.params.push(R(h.inputRotateOrder));break;case"FILE_MY":case"ENV_SPHERE_MY":if(w=h.texture,e.nodeTextures[Ch(f,o)]=w,u.params.push(I(f,o)),o++,u.params.push(R(_(w))),"ENV_SPHERE_MY"==f)u.params.push(R("normal"));else{const e=!1===h.fileHasAlpha;u.params.push(S(e&&gh(t,c,lh.FILE_MY.alpha)))}break;case"RAMP_MY":e.useFloatTex?(v=new Float32Array(2048),E=1):(v=new Uint8Array(2048),E=255);for(let t=0;t<yh;t++){const e=E*h.rampData[3*t],n=E*h.rampData[3*t+1],o=E*h.rampData[3*t+2];v[4*t]=ie(e,0,E),v[4*t+1]=ie(n,0,E),v[4*t+2]=ie(o,0,E),v[4*t+3]=E}w=g(v,yh,W,e.useFloatTex?G:O),P=Ch(f,i),e.nodeTextures[P]=w,u.params.push(I(f,i)),i++,u.params.push(R(U("int",h.rampType))),u.params.push(R(U("int",h.wrapS))),u.params.push(R(U("int",h.wrapT))),e.defines.RAMP_TEX_SIZE=yh,e.definesFragOnly.add("RAMP_TEX_SIZE");break;case"SAMPLER_INFO_MY":u.params.push(R("faceDirection")),d="tangent",A=B(d,4),u.attributes.push({name:d,type:"attribute vec4"}),u.params.push(A),d="uv",A=B(d,2),u.attributes.push({name:d,type:"attribute vec2"}),u.params.push(A);break;case"UNIT_CONVERSION_MY":u.params.push(x(h.conversionFactor));break;case"VECTOR_PRODUCT_MY":u.params.push(R(h.operation)),u.params.push(S(h.normalizeOutput));break;case"OSL_NODE":ye(h.texture)&&(w=h.texture,e.nodeTextures[Ch(f,o)]=w,u.params.push(I(f,o)),o++);const vt=h.globalVariables||[];vt.indexOf("P")>-1&&u.params.push(R("oslGetP(vViewPosition)")),vt.indexOf("I")>-1&&u.params.push(R("oslGetI(vViewPosition)")),vt.indexOf("N")>-1&&u.params.push(R("oslGetN(normal)")),(vt.indexOf("u")>-1||vt.indexOf("v")>-1)&&(d="uv",u.attributes.push({name:d,type:"attribute vec2"}),vt.indexOf("u")>-1&&u.params.push(B(d+"_u",1,d+".x")),vt.indexOf("v")>-1&&u.params.push(B(d+"_v",1,"1.0 - "+d+".y")));break;case"RGB_ALPHA":F=(new ln).fromArray(h.outputs[0].concat([h.outputs[1]])),e.nodeRGB.push(F),e.nodeRGBMap[h.name]=s,u.params.push(R("nodeRGB["+s+"]")),s++;break;case"U_FLOAT":d="uv",A=B(d,2),u.attributes.push({name:d,type:"attribute vec2"}),u.params.push(A)}}const c={},h={};for(let e=0;e<t.len();e++){const n=t.node(e),o=n.originData,i=o.type;for(let r=0;r<o.inputs.length;r++){const s=o.inputs[r],a=o.inputTypes?o.inputTypes[r]:D(s),l=[],f=[];w(t,e,r,s,l,f);const d=u(i,r);if(l.length){let t,e;if(t=n.inputFactors.length?n.inputFactors[r]:1,e=d?"normal":U(a,s),f.length){const t=l.map(function(t){return t.name});n.inputs.push({code:C(t,f,l[0].type,a,e)})}else 1==l.length||console.error(`MeshNodeMaterial: wrong ${i} node connections`),n.inputs.push({code:E(l[0].name,l[0].type,a,e,t)})}else if(d)n.inputs.push({code:"normal"});else if("string"==typeof s)n.inputs.push({code:s});else{c[a]=c[a]||[],Array.isArray(s)?c[a].push(...s):c[a].push(s),a in h||(h[a]=0);let t=h[a];n.inputs.push({code:`nodeInputs${Te(a)}[${t}]`}),h[a]++}}}e.nodeInputs={};for(const t in c)e.nodeInputs[t]="int"==t||"bool"==t?new Int32Array(c[t]):new Float32Array(c[t])}(s),function(t){const n=[],o=[],i=[],r=[],s=new au(t).order();e.defines.NODE_RGB_NUM=e.nodeRGB.length,e.defines.NODE_VALUE_NUM=e.nodeValue.length,e.defines.NODE_TEX_COORD_NUM=e.nodeTexCoordObject.length,e.definesFragOnly.add("NODE_RGB_NUM"),e.definesFragOnly.add("NODE_VALUE_NUM"),e.definesFragOnly.add("NODE_TEX_COORD_NUM");for(let o=0;o<s.length;o++){const r=t.node(s[o]),a=r.originData.type;let l,c;if(e.defines["NODE_"+a]="","REFLECT_REFRACT_MX"!=a&&"BITMAP_ENV_MX"!=a&&"BUMP_BL"!=a&&"PHY_SUN_SKY_ENV_MX"!=a&&"ENV_SPHERE_MY"!=a&&"UV_PROJECTION_AR"!=a&&"TRIPLANAR_AR"!=a&&"TRIPLANAR_UV_AR"!=a&&"SUB_TRANSFORM_MX"!=a&&"SUB_TRANSFORM_MY"!=a&&e.definesFragOnly.add("NODE_"+a),"OSL_NODE"==a&&(e.defines.USE_OSL=""),"OSL_NODE"!=a){const t="node_"+a.toLowerCase()+"_vert";l=Fi[t]}else l=r.originData.vertCode;if(l&&n.indexOf(l)<0&&n.push(l),"OSL_NODE"!=a){const t="node_"+a.toLowerCase()+"_frag";c=Fi[t]}else c=r.originData.fragCode;c&&i.indexOf(c)<0&&i.push(c);for(let t=0;t<r.attributes.length;t++){const e=r.attributes[t],o=e.type+" "+e.name+";";"uv"!=e.name&&n.indexOf(o)<0&&n.push(o)}for(let t=0;t<r.params.length;t++){const e=r.params[t];if(A(e)){const t=e.type+" "+e.name+";";i.indexOf(t)<0&&i.push(t)}else if(v(e)){const t=e.type+" "+e.name+";";n.indexOf(t)<0&&n.push(t);const o=e.type+" "+e.name+";";i.indexOf(o)<0&&i.push(o)}}}for(const t in e.nodeInputs){const n=e.nodeInputs[t].length/F(t);i.push(`uniform ${t} nodeInputs${Te(t)}[${n}];`)}ye(e.defines.USE_OSL)&&i.unshift("#include <node_osl_frag>");for(let e=0;e<s.length;e++){const n=t.node(s[e]),i=n.originData.type;if("CHECKERBOARD_AR"==i||"IMAGE_AR"==i||"TWO_SIDED_AR"==i||"USER_DATA_COLOR_AR"==i||"ATTRIBUTE_BL"==i||"NEW_GEOMETRY_BL"==i||"NORMAL_MAP_BL"==i||"TANGENT_BL"==i||"TEX_COORD_BL"==i||"UVMAP_BL"==i||"VERTEX_COLOR_BL"==i||"BITMAP_MX"==i||"NOISE_MX"==i||"NORMAL_BUMP_MX"==i||"BUMP_MX"==i||"VERTEX_COLOR_MX"==i||"GRADIENT_MX"==i||"GRADIENT_RAMP_MX"==i||"BUMP_2D_MY"==i||"PLACE_2D_TEXTURE_MY"==i||"SAMPLER_INFO_MY"==i||"OSL_NODE"==i||"U_FLOAT"==i)for(let t=0;t<n.params.length;t++){const e=n.params[t];if(v(e)){const t=e.name+"="+e.attrBindName+";";o.includes(t)||(o.push(t),e.name.includes("Tangent")&&o.push(["#ifdef USE_SKINNING",`    ${e.name}.xyz = vec4(skinMatrix * vec4(${e.name}.xyz, 0.0)).xyz;`,"#endif"].join("\n")))}}for(let t=0;t<n.outputs.length;t++){const e=n.outputs[t];e.type&&r.push(e.type+" "+e.name+";")}const a=[];for(let t=0;t<n.params.length;t++){const e=n.params[t];!e.type||A(e)||v(e)?a.push(e.name):a.push(U(e.type,e.value))}for(let t=0;t<n.inputs.length;t++){const e=n.inputs[t];a.push(e.code)}for(let t=0;t<n.outputs.length;t++){const e=n.outputs[t];a.push(e.name)}let l;switch(l="OSL_NODE"!=i?"node_"+Eh(i).toLowerCase():n.originData.shaderName,i){case"MATH_BL":case"VECT_MATH_BL":l+="_"+n.originData.operation.toLowerCase();break;case"VECTOR_ROTATE_BL":l+="_"+n.originData.rotationType.toLowerCase();break;case"MIX_BL":l+="_"+n.originData.dataType.toLowerCase(),"RGBA"==n.originData.dataType?l+="_"+n.originData.blendType.toLowerCase():"VECTOR"==n.originData.dataType&&(l+="_"+n.originData.factorMode.toLowerCase());break;case"TEX_WHITE_NOISE_BL":l+="_"+n.originData.noise_dimension.toLowerCase()}r.push(l+"("+a.join(",")+");");for(let t=0;t<n.outputs.length;t++){const e=n.outputs[t],o=e.name;if(e.clamp){const t=e.type;r.push(o+"=clamp("+o+","+t+"(0.0),"+t+"(1.0));")}e.normalize&&r.push(o+"=normalize("+o+");")}}e.nodeChunks.node_pars_vertex=n.join("\n"),e.nodeChunks.node_vertex=o.join("\n"),e.nodeChunks.node_pars_fragment=i.join("\n"),e.nodeChunks.node_fragment=r.join("\n"),e.nodeChunksHash=ve(JSON.stringify(e.nodeChunks))}(s),t)if(this.nodeValue.length==n.length&&this.nodeRGB.length==o.length&&this.nodeTexCoordObject.length==i.length){for(let t=0;t<this.nodeValue.length;t++)this.nodeValue[t]=n[t];for(let t=0;t<this.nodeRGB.length;t++)this.nodeRGB[t]=o[t];for(let t=0;t<this.nodeTexCoordObject.length;t++)this.nodeTexCoordObject[t]=i[t]}else console.error("v3d.MeshNodeMaterial: Unable to preserve node variables");this.needsUpdate=!0},function(t){for(let o=0;o<t.len();o++){const r=t.node(o),s=r.originData.type;if("GROUP_BL"==s){const s=r.originData.nodeGraph,a=e.additionalNodeGraphs[s];if(n(t,o),a.len()<=2){const e=t.findInEdges(o),n=t.findOutEdges(o),i=Math.min(e.length,n.length);for(let o=0;o<i;o++){const i=e[o],r=n[o],s=new ou(i.from(),r.to());s.connections=[];const a=Math.min(i.connections.length,r.connections.length);for(let t=0;t<a;t++){const e=i.connections[t],n=r.connections[t],o={from:e.from,to:n.to};s.connections.push(o)}t.addEdge(s)}t.disconnect(o,!0),o=-1;continue}const l=i(t,a,o);t.insert(a,l.inputs,l.outputs);const c=l.removedNodes.sort(function(t,e){return e-t});for(let e=0;e<c.length;e++)t.disconnect(c[e],!0);o=-1;continue}if("REROUTE_BL"==s){t.findInEdges(o).length<1&&n(t,o);const e=t.findInEdges(o),i=t.findOutEdges(o),r=e[0],s=r.connections[0];for(let e=0;e<i.length;e++){const n=i[e];let o=t.edge(r.from(),n.to());o||(o=new ou(r.from(),n.to()),o.connections=[],t.addEdge(o));for(let t=0;t<n.connections.length;t++){const e=n.connections[t],i={from:s.from,to:e.to};o.connections.push(i)}}t.disconnect(o,!0),o=-1;continue}if("OSL_OUTPUT_SELECTOR_MX"==s){const e=t.findInEdges(o),n=t.findOutEdges(o),i=e[0],r=i.connections[0];for(let e=0;e<n.length;e++){const o=n[e],s=new ou(i.from(),o.to());s.connections=[];for(let t=0;t<o.connections.length;t++){const e=o.connections[t],n={from:r.from,to:e.to};s.connections.push(n)}t.addEdge(s)}t.disconnect(o,!0),o=-1;continue}}}(e.nodeGraph),function(t){for(let e=0;e<t.len();e++){const n=t.node(e),o=n.originData,i=o.type;if("TEX_IMAGE_BL"==i&&!ph(t,e,0)){const n={originData:{name:"UVMapGenerated",type:"UVMAP_BL",uvLayer:"",inputs:[],outputs:[[0,0,0]]}};t.addNode(n),_h(t,t.len()-1,0,e,0)}if(("TEX_BRICK_BL"==i||"TEX_CHECKER_BL"==i||"TEX_GABOR_BL"==i||"TEX_GRADIENT_BL"==i||"TEX_MAGIC_BL"==i||"TEX_NOISE_BL"==i||"TEX_WAVE_BL"==i||"TEX_VORONOI_BL"==i||"TEX_SKY_BL"==i)&&!ph(t,e,0)){const n={originData:{name:"TexCoordGenerated",type:"TEX_COORD_BL",inputs:[],outputs:[[0,0,0],[0,0,0],[0,0,0],[0,0,0],[0,0,0],[0,0,0],[0,0,0]]}};t.addNode(n),_h(t,t.len()-1,0,e,0)}if("TEX_ENVIRONMENT_BL"==i&&!ph(t,e,0)){const n={originData:{name:"TexCoordObject",type:"TEX_COORD_BL",inputs:[],outputs:[[0,0,0],[0,0,0],[0,0,0],[0,0,0],[0,0,0],[0,0,0],[0,0,0]]}};t.addNode(n),_h(t,t.len()-1,3,e,0)}const r=hh(n);if(r in Th&&!ph(t,e,Th[r])){const n={originData:{name:"Normal",type:"NORMAL",inputs:[],outputs:[[0,0,0]]}};t.addNode(n),_h(t,t.len()-1,lh.NORMAL.normal,e,Th[r])}if(["BSDF_PRINCIPLED_BL","BSDF_PRINCIPLED_BF43_BL","EEVEE_SPECULAR_BL"].includes(r)&&!ph(t,e,ah[r].clearcoatNormal)&&(o.inputs[ah[r].clearcoat]>0||ph(t,e,ah[r].clearcoat))){const n={originData:{name:"CoatNormal",type:"NORMAL",inputs:[],outputs:[[0,0,0]]}};t.addNode(n),_h(t,t.len()-1,lh.NORMAL.normal,e,ah[r].clearcoatNormal)}if("EEVEE_SPECULAR_BL"!=r||ph(t,e,ah.EEVEE_SPECULAR_BL.ambientOcclusion)||(o.inputs[ah.EEVEE_SPECULAR_BL.ambientOcclusion]=1),"OSL_NODE"==r){const n=o.initializers;for(let i=0;i<n.length;i++){const s=n[i];if(s&&!ph(t,e,i)){const n={originData:{name:r+"init"+i,type:"OSL_NODE",shaderName:o.shaderName+"_init_"+i,inputs:[],outputs:[o.inputs[0]],fragCode:s[0],globalVariables:s[1],initializers:[]}};t.addNode(n),_h(t,t.len()-1,0,e,i)}}}if(!("NORMAL_MAP_AR"!=r||ph(t,e,ah.NORMAL_MAP_AR.normal)&&ph(t,e,ah.NORMAL_MAP_AR.tangent))){const n={originData:{name:"SamplerInfo",type:"SAMPLER_INFO_MY",inputs:[[0,0,0]],outputs:[0,!1,[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0],[0,0],[0,0,0],[0,0,0],[0,0,0],[0,0,0],[0,0,0],[0,0]]}};t.addNode(n),ph(t,e,ah.NORMAL_MAP_AR.normal)||_h(t,t.len()-1,lh.SAMPLER_INFO_MY.normalCamera,e,ah.NORMAL_MAP_AR.normal),ph(t,e,ah.NORMAL_MAP_AR.tangent)||_h(t,t.len()-1,lh.SAMPLER_INFO_MY.tangentUCamera,e,ah.NORMAL_MAP_AR.tangent)}if("IMAGE_AR"==r&&!ph(t,e,ah.IMAGE_AR.uvcoords)){const n={originData:{name:"place2dTexture",type:"PLACE_2D_TEXTURE_MY",inputs:[[0,0],[1,1],0],outputs:[[0,0]],uvIndex:0}};t.addNode(n),_h(t,t.len()-1,lh.PLACE_2D_TEXTURE_MY.uv,e,ah.IMAGE_AR.uvcoords)}if("FILE_MY"==r&&!ph(t,e,ah.FILE_MY.uvCoord)){const n={originData:{name:"place2dTexture",type:"PLACE_2D_TEXTURE_MY",inputs:[[0,0],[1,1],0],outputs:[[0,0]],uvIndex:0}};t.addNode(n),_h(t,t.len()-1,lh.PLACE_2D_TEXTURE_MY.uv,e,ah.FILE_MY.uvCoord)}if("RAMP_MY"==r&&!ph(t,e,ah.RAMP_MY.uvCoord)){const n={originData:{name:"place2dTexture",type:"PLACE_2D_TEXTURE_MY",inputs:[[0,0],[1,1],0],outputs:[[0,0]],uvIndex:0}};t.addNode(n),_h(t,t.len()-1,lh.PLACE_2D_TEXTURE_MY.uv,e,ah.RAMP_MY.uvCoord)}if(ye(o.output)&&f(t,e,o),l(i)){if(!ye(o.inputFactors)){o.inputFactors=[];for(let t=0;t<o.inputs.length;t++)o.inputFactors.push(1)}o.inputs.push([0,0,0]),o.inputFactors.push(0)}if("STANDARD_SURFACE_AR"==r&&!ph(t,e,ah[r].clearcoatNormal)&&(o.inputs[ah[r].clearcoat]>0||ph(t,e,ah[r].clearcoat))){const n={originData:{name:"CoatNormal",type:"NORMAL",inputs:[],outputs:[[0,0,0]]}};t.addNode(n),_h(t,t.len()-1,0,e,ah[r].clearcoatNormal)}if("MIX_BL"==r&&o.outputs.length>1){const n=[-1,-1,-1,-1,-1,-1,-1,-1],i=[-1,-1,-1];switch(o.dataType){case"RGBA":o.inputs=[o.inputs[0],o.inputs[6],o.inputs[7]],n[0]=0,n[6]=1,n[7]=2,o.outputs=[o.outputs[2]],i[2]=0;break;case"VECTOR":o.inputs=[o.inputs[0],o.inputs[1],o.inputs[4],o.inputs[5]],n[0]=0,n[1]=1,n[4]=2,n[5]=3,o.outputs=[o.outputs[1]],i[1]=0;break;case"FLOAT":o.inputs=[o.inputs[0],o.inputs[2],o.inputs[3]],n[0]=0,n[2]=1,n[3]=2,o.outputs=[o.outputs[0]],i[0]=0}const r=t.findInEdges(e);for(let t=0;t<r.length;t++){const e=r[t];for(let t=e.connections.length-1;t>=0;t--){const o=e.connections[t];n[o.to]>-1?o.to=n[o.to]:e.connections.splice(t,1)}}const s=t.findOutEdges(e);for(let t=0;t<s.length;t++){const e=s[t];for(let t=e.connections.length-1;t>=0;t--){const n=e.connections[t];i[n.from]>-1?n.from=i[n.from]:e.connections.splice(t,1)}}}if("BUMP_2D_MY"==i&&o.bumpInterp>0){o.inputs[ah.BUMP_2D_MY.bumpValue]=[0,0,0];const n=t.findInEdges(e);for(let e=0;e<n.length;e++){const o=n[e],i=t.node(o.from()).originData;for(let t=0;t<o.connections.length;t++){const e=o.connections[t];e.to==ah.BUMP_2D_MY.bumpValue&&"FILE_MY"==i.type?e.from=lh.FILE_MY.color:e.to==ah.BUMP_2D_MY.bumpValue&&"IMAGE_AR"==i.type&&(e.from=lh.IMAGE_AR.color)}}}if("COLOR_CONSTANT_MY"!=i||ph(t,e,0)||ph(t,e,1)||(o.type="RGB_ALPHA",o.inputs=[]),"FLOAT_CONSTANT_MY"!=i||ph(t,e,0)||(o.type="VALUE",o.inputs=[]),"TRIPLANAR_AR"==i){const n=function(){const n=["scale","rotate","offset"],i=n.map(n=>mh(t,e,ah.TRIPLANAR_AR[n])),r="Y_UP_RIGHT"===o.coordSystem?"SUB_TRANSFORM_MY":"SUB_TRANSFORM_MX",s={originData:{name:"subTransform",type:r,inputs:n.map(t=>o.inputs[ah.TRIPLANAR_AR[t]]),outputs:[[0,0,0],[0,0,0]],coordSpace:o.coordSpace}};t.addNode(s);const a=t.len()-1;return i.forEach((e,o)=>{e.forEach(e=>{const i=e.nodeIdx,s=e.outputIdx,l=e.channelMatrix;_h(t,i,s,a,ah[r][n[o]],l)})}),e=>{const n=t.node(e);"TRIPLANAR_AR"==n.originData.type?_h(t,a,lh[r].normal,e,ah.TRIPLANAR_AR.normal):"TRIPLANAR_UV_AR"==n.originData.type&&(_h(t,a,lh[r].vector,e,ah.TRIPLANAR_UV_AR.vector),_h(t,a,lh[r].normal,e,ah.TRIPLANAR_UV_AR.normal))}}();o.inputs.push([0,0,0]),n(e);const i=e=>{const i={originData:{name:"triplanarUV",type:"TRIPLANAR_UV_AR",inputs:[[0,0,0],[0,0,0]],outputs:4==e?[[0,0],[0,0],[0,0]]:[[0,0]],flipOnOppositeDirection:o.flipOnOppositeDirection}};4==e?i.originData.blendFactor=o.blendFactor:i.originData.projectionAxis=e,t.addNode(i);const r=t.len()-1;return n(r),r};if(o.inputPerAxis){const n=[ah.TRIPLANAR_AR.inputColor,ah.TRIPLANAR_AR.inputColorY,ah.TRIPLANAR_AR.inputColorZ];for(let o=0;o<3;o++){const r=n[o],s=vh(t,e,r,"IMAGE_AR");if(!s){vh(t,e,r)&&console.error("MeshNodeMaterial: TRIPLANAR_AR texture inputs accept only IMAGE_AR or color.");continue}const a=t.nodeIndex(s);Mh(t,a,ah.IMAGE_AR.uvcoords);const l=i(o);_h(t,l,lh.TRIPLANAR_UV_AR.uv,a,ah.IMAGE_AR.uvcoords)}}else{const n=vh(t,e,ah.TRIPLANAR_AR.inputColor,"IMAGE_AR");if(!n){vh(t,e,ah.TRIPLANAR_AR.inputColor)&&console.error("MeshNodeMaterial: TRIPLANAR_AR texture inputs accept only IMAGE_AR or color.");continue}const r=t.nodeIndex(n);if(Mh(t,r,ah.IMAGE_AR.uvcoords),Mh(t,e,ah.TRIPLANAR_AR.inputColorY),Mh(t,e,ah.TRIPLANAR_AR.inputColorZ),o.blendFactor<.001){const e=i(3);_h(t,e,lh.TRIPLANAR_UV_AR.uv,r,ah.IMAGE_AR.uvcoords)}else{const e=i(4);_h(t,e,lh.TRIPLANAR_UV_AR.uv,r,ah.IMAGE_AR.uvcoords),n.originData.inputs.push([0,0],[0,0]),_h(t,e,lh.TRIPLANAR_UV_AR.duvdx,r,ah.IMAGE_AR.duvdx),_h(t,e,lh.TRIPLANAR_UV_AR.duvdy,r,ah.IMAGE_AR.duvdy)}}}if("UV_PROJECTION_AR"==i){const n=Sh(t,e,lh.UV_PROJECTION_AR.uv),o=Mh(t,e,ah.UV_PROJECTION_AR.projectionColor,"IMAGE_AR");if(!o){console.error("MeshNodeMaterial: UV_PROJECTION_AR.projectionColor input accepts only IMAGE_AR.");continue}const i=o.node;if(n){const r=t.nodeIndex(i);_h(t,r,o.outputIdx,t.nodeIndex(n.node),n.inputIdx),Mh(t,r,ah.IMAGE_AR.uvcoords),_h(t,e,lh.UV_PROJECTION_AR.uv,r,ah.IMAGE_AR.uvcoords)}}}let n=0;for(let e=0;e<t.len();e++){const o=t.node(e).originData,i=o.type;"MATERIAL_MX"!=i&&"PHYSICAL_MX"!=i&&"OPENPBR_SURFACE_MX"!=i||(a(t,e,o),"MATERIAL_MX"==i&&(n=o.IOR))}for(let e=0;e<t.len();e++){const o=t.node(e).originData,i=o.type;c(i)&&(o.IOR=n),c(i)&&!ye(o.reflectMode)&&(o.reflectMode="MAX_ENV_COORDS_REFLECT")}for(let e=0;e<t.len();e++){const n=t.node(e).originData;"COMPOSITE_MX"==n.type&&(h(t,e,n),t.disconnect(e,!0))}for(let e=0;e<t.len();e++){const n=t.node(e).originData;"LAYERED_TEXTURE_MY"==n.type&&(d(t,e,n),t.disconnect(e,!0))}if(e.hasNode("SKYDOME_LIGHT_AR"))for(let e=0;e<t.len();e++){const n=t.node(e).originData;if("FILE_MY"==n.type||"IMAGE_AR"==n.type){const o={originData:{name:"envSphere",type:"ENV_SPHERE_MY",inputs:[[-1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1]],outputs:[0,[0,0,0]],texture:n.texture}};t.addNode(o);const i=t.findOutEdges(e);for(let e=0;e<i.length;e++){const n=i[e];for(let e=0;e<n.connections.length;e++){const o=n.connections[e];o.from<2&&_h(t,t.len()-1,o.from,n.to(),o.to)}}t.disconnect(e,!0),e=-1}}for(let e=0;e<t.len();e++){const n=t.node(e).originData;if("ENV_SPHERE_MY"==n.type&&2==n.inputs.length){const o=t.findInEdges(e);for(let e=0;e<o.length;e++){const i=o[e],r=t.node(i.from()).originData;"FILE_MY"!=r.type&&"IMAGE_AR"!=r.type||(n.inputs.splice(0,1),n.texture=r.texture,t.removeEdge(i.from(),i.to()))}}}for(let e=0;e<t.len();e++){const n=t.node(e).originData;switch(n.type){case"BSDF_DIFFUSE_BL":case"BSDF_GLOSSY_BL":case"BSDF_TRANSLUCENT_BL":case"DIFFUSE_BSDF_BL":o(t,e,n,ah[n.type].color,"Color");break;case"BSDF_METALLIC_BL":o(t,e,n,ah[n.type].baseColor,"Base Color");break;case"BSDF_PRINCIPLED_BL":o(t,e,n,ah.BSDF_PRINCIPLED_BL.baseColor,"Color");break;case"MATERIAL_MX":o(t,e,n,ah.MATERIAL_MX.ambientColor,"Ambient Color")&&(n.inputFactors[0]=1),o(t,e,n,ah.MATERIAL_MX.diffuseColor,"Diffuse Color")&&(n.inputFactors[1]=1);break;case"PHYSICAL_MX":o(t,e,n,ah.PHYSICAL_MX.baseColor,"Base Color")&&(n.inputFactors[1]=1);break;case"OPENPBR_SURFACE_MX":o(t,e,n,ah.OPENPBR_SURFACE_MY.baseColor,"Base Color")&&(n.inputFactors[1]=1);break;case"OPENPBR_SURFACE_MY":o(t,e,n,ah.OPENPBR_SURFACE_MY.baseColor,"Base Color");break;case"STANDARD_SURFACE_AR":o(t,e,n,ah.STANDARD_SURFACE_AR.baseColor,"Base Color")}}}(e.nodeGraph),Ih(e.nodeGraph),this.updateNodeGraph()}static nodeGraphFromExtGraph(t){let e=t.nodes,n=t.edges;const o=e.slice().sort(function(t,e){return t.name.localeCompare(e.name)}),i=[];for(let t=0;t<n.length;t++){const r=n[t],s=Object.assign({},r);s.fromNode=o.indexOf(e[r.fromNode]),s.toNode=o.indexOf(e[r.toNode]),i.push(s)}e=o,n=i;const r=new nu(e.length);for(let t=0;t<e.length;t++)e[t],xh({originData:e[t]},r.node(t));for(let t=0;t<n.length;t++){const e=n[t];r.edge(e.fromNode,e.toNode)||r.addNewEdge(e.fromNode,e.toNode);const o=r.edge(e.fromNode,e.toNode);if(o.connections=o.connections||[],ye(e.fromChannel)||ye(e.toChannel)){let t=null;for(let n=0;n<o.connections.length;n++){const i=o.connections[n];if(i.from==e.fromOutput&&i.to==e.toInput&&i.channelMatrix){t=i.channelMatrix;break}}if(!t){t=[[0,0,0],[0,0,0],[0,0,0]];const n={from:e.fromOutput,to:e.toInput,channelMatrix:t};o.connections.push(n)}const n=e.fromChannel||0,i=e.toChannel||0;t[n][i]=1}else{const t={from:e.fromOutput,to:e.toInput};o.connections.push(t)}}return Ih(r),r}static nodeGraphTraverse(t,e){for(let n=0;n<t.len();n++){e(t.node(n))}}hasNode(t){for(let e=0;e<this.nodeGraph.len();e++){if(this.nodeGraph.node(e).originData.type==t)return!0}return!1}traverseNodes(t){for(let e=0;e<this.nodeGraph.len();e++){t(this.nodeGraph.node(e))}}findNodeByName(t){for(let e=0;e<this.nodeGraph.len();e++){const n=this.nodeGraph.node(e);if(n.originData.name===t)return n}return null}get color(){return this.getStandardProp("color")}set color(t){}get opacity(){return this.getStandardProp("opacity")}set opacity(t){}connectTexture(t,e,n){let o,i,r;switch(this.profile){case"blender":o="TEX_IMAGE_BL",i="UVMAP_BL",r="vector";break;case"max":o="BITMAP_MX";break;case"maya":o="FILE_MY",i="PLACE_2D_TEXTURE_MY",r="uvCoord";break;default:return void console.error("v3d.connectTexture: Invalid material profile:",this.profile)}const s=ch(o,t.name||"Texture",{texture:t}),a=Ch(o,Object.keys(this.nodeTextures).length);this.nodeTextures[a]=t;const l=this.nodeGraph;if(l){let t=Ah(l,e);const a=ah[uh(l.node(t))][n],c=vh(l,t,a);c&&(l.disconnect(l.nodeIndex(c),!0),t=Ah(l,e)),l.addNode(s),_h(l,l.len()-1,lh[o].color,t,a),i&&(l.addNode(ch(i,s.name+"UV")),_h(l,l.len()-1,lh[i].uv,l.len()-2,ah[o][r]))}else console.error("v3d.connectTexture: Unable to connect texture to empty graph")}needsLightPathDir(){return!!(this.hasNode("LIGHT_PATH_BL")||this.hasNode("RAY_SWITCH_AR")||"USE_OSL"in this.defines)}canUseGTAO(){return(this.hasNode("DIFFUSE_BSDF_BL")||this.hasNode("BSDF_DIFFUSE_BL")||this.hasNode("SUBSURFACE_SCATTERING_BL")||this.hasNode("PHYSICAL_MX")||this.hasNode("OPENPBR_SURFACE_MX")||this.hasNode("OPENPBR_SURFACE_MY")||this.hasNode("STANDARD_SURFACE_AR")||this.hasNode("BSDF_GLASS_BL")||this.hasNode("BSDF_GLOSSY_BL")||this.hasNode("BSDF_METALLIC_BL")||this.hasNode("BSDF_PRINCIPLED_BL")||this.hasNode("EEVEE_SPECULAR_BL"))&&this.gtaoVisible}worldMaterialColor(){const t=this.nodeGraph;let e=dh(t,"OUTPUT_WORLD_BL");if(e>=0){const n=vh(t,e,0);if(!n||"BACKGROUND_BL"!=n.originData.type)return null;if(0==t.findInEdges(t.nodeIndex(n)).length)return(new tn).fromArray(n.originData.inputs[0]).multiplyScalar(n.originData.inputs[1]);if(ph(t,t.nodeIndex(n),1))return null;const o=vh(t,t.nodeIndex(n),0);if(!o||"MIX_BL"!=o.originData.type||"RGBA"!=o.originData.dataType||"MIX"!=o.originData.blendType)return null;const i=vh(t,t.nodeIndex(o),0);return i&&"LIGHT_PATH_BL"==i.originData.type?ph(t,t.nodeIndex(o),2)?null:gh(t,t.nodeIndex(i),0)?(new tn).fromArray(o.originData.inputs[2]):null:null}if(e=dh(t,"OUTPUT_MX"),e>=0&&0==t.findInEdges(e).length)return(new tn).fromArray(t.node(e).originData.inputs[0]);if(e=dh(t,"SKYDOME_LIGHT_AR"),e>=0){if(0==t.findInEdges(e).length){const n=t.node(e);return(new tn).fromArray(n.originData.inputs[0]).multiplyScalar(n.originData.inputs[1])}const n=vh(t,e,0);if(!n||"RAY_SWITCH_AR"!=n.originData.type)return null;if(0==t.findInEdges(t.nodeIndex(n)).length)return(new tn).fromArray(n.originData.inputs[0])}return null}useAddTransparency(){const t=this.nodeGraph,e=dh(t,"OUTPUT_MATERIAL_BL");if(e>=0){const n=vh(t,e,0);if(n&&"ADD_SHADER_BL"==n.originData.type){const e=vh(t,t.nodeIndex(n),0),o=vh(t,t.nodeIndex(n),1);if(e&&o&&("BSDF_TRANSPARENT_BL"==e.originData.type||"BSDF_TRANSPARENT_BL"==o.originData.type))return!0}}return!1}getMainShaderNode(){const t=this.nodeGraph;if(!t)return null;let e=dh(t,"OUTPUT_MATERIAL_BL");if(e>=0){const n=vh(t,e,ah.OUTPUT_MATERIAL_BL.surface);if(n)if(fh(n,"MIX_SHADER_BL")){let e=vh(t,n,ah.MIX_SHADER_BL.fac,"SEPARATE_COLOR_BL"),o=vh(t,n,ah.MIX_SHADER_BL.color1,["DIFFUSE_BSDF_BL","BSDF_DIFFUSE_BL"]),i=vh(t,n,ah.MIX_SHADER_BL.color2,Bh);if(e&&o&&i)return i;if(e=vh(t,n,ah.MIX_SHADER_BL.fac,"LIGHT_PATH_BL"),o=vh(t,n,ah.MIX_SHADER_BL.color1,"BSDF_TRANSPARENT_BL"),i=vh(t,n,ah.MIX_SHADER_BL.color2,"EMISSION_BL"),e&&o&&i)return i;if(e=vh(t,n,ah.MIX_SHADER_BL.fac),o=vh(t,n,ah.MIX_SHADER_BL.color1,"BSDF_TRANSPARENT_BL"),i=vh(t,n,ah.MIX_SHADER_BL.color2,Bh),!e&&o&&i)return i}else if(fh(n,Bh))return n}if(e=dh(t,"OUTPUT_MX"),e>=0){const n=vh(t,e,ah.OUTPUT_MX.color,Lh);if(n)return n}if(e=dh(t,"SHADING_ENGINE_MY"),e>=0){const n=vh(t,e,ah.SHADING_ENGINE_MY.surface,Nh);if(n)return n}return null}getInputColor(t,e){const n=vh(this.nodeGraph,t,e);if(!n)return(new tn).fromArray(t.originData.inputs[e]);if(fh(n,["RGB_BL","RGB_MX","RGB_ALPHA"])){const t=this.nodeRGB[this.nodeRGBMap[n.originData.name]];return(new tn).fromArray(t.toArray())}}getInputValue(t,e){const n=vh(this.nodeGraph,t,e);if(n){if(fh(n,["VALUE_BL","VALUE_MX","VALUE"]))return this.nodeValue[this.nodeValueMap[n.originData.name]]}else{const n=t.originData.inputs[e];if("number"==typeof n)return n;console.error(`v3d.MeshNodeMaterial: Invalid ${uh(t)} input value at index ${e}`)}}getInputTexture(t,e){const n=vh(this.nodeGraph,t,e);if(n&&fh(n,["TEX_IMAGE_BL","BITMAP_MX","FILE_MY","IMAGE_AR"]))return n.originData.texture}getStandardProp(t){var e,n;if(!(t in Dh))return void console.error(`v3d.MeshNodeMaterial: Invalid standard property: "${t}"`);const o=this.getMainShaderNode();if(!o)return Dh[t];const i=uh(o),r=hh(o),s=this.nodeGraph;let a,l,c,u,h,f,d,A,v;switch(t){case"color":if(a=Bh.includes(i)&&vh(s,o,null!=(e=ah[r].baseColor)?e:ah[r].color,"MIX_BL"),a&&"MULTIPLY"==a.originData.blendType){const t=vh(s,a,ah.MIX_BL.fac),e=vh(s,a,ah.MIX_BL.col1),n=vh(s,a,ah.MIX_BL.col2);if(!t&&(e&&!n||!e&&n)){const t=this.getInputColor(a,e?ah.MIX_BL.col2:ah.MIX_BL.col1);if(t)return t}}else{let t,e;switch(i){case"BSDF_PRINCIPLED_BL":case"EEVEE_SPECULAR_BL":t=this.getInputColor(o,ah[r].baseColor);break;case"PHYSICAL_MX":case"STANDARD_SURFACE_AR":case"LAMBERT_AR":t=this.getInputColor(o,ah[r].baseColor),t||(t=Dh.color.clone()),e=this.getInputValue(o,ah[r].base),ye(e)&&t.multiplyScalar(e);break;case"OPENPBR_SURFACE_MX":case"OPENPBR_SURFACE_MY":t=this.getInputColor(o,ah[r].baseColor),t||(t=Dh.color.clone()),e=this.getInputValue(o,ah[r].baseWeight),ye(e)&&t.multiplyScalar(e);break;default:t=this.getInputColor(o,ah[r].color)}if(t)return t}break;case"map":if(a=Bh.includes(i)&&vh(s,o,null!=(n=ah[r].baseColor)?n:ah[r].color,"MIX_BL"),a&&"MULTIPLY"==a.originData.blendType){const t=vh(s,a,ah.MIX_BL.fac),e=vh(s,a,ah.MIX_BL.col1),n=vh(s,a,ah.MIX_BL.col2);if(!t&&(e&&!n||!e&&n)){const t=this.getInputTexture(a,e?ah.MIX_BL.col1:ah.MIX_BL.col2);if(t)return t}}else if(["BSDF_PRINCIPLED_BL","EEVEE_SPECULAR_BL","PHYSICAL_MX","OPENPBR_SURFACE_MX","OPENPBR_SURFACE_MY","STANDARD_SURFACE_AR","LAMBERT_AR"].includes(i)){const t=this.getInputTexture(o,ah[r].baseColor);if(t)return t}else{const t=this.getInputTexture(o,ah[r].color);if(t)return t}break;case"opacity":if(v=dh(s,"OUTPUT_MATERIAL_BL"),v>=0){const t=vh(s,v,ah.OUTPUT_MATERIAL_BL.surface,"MIX_SHADER_BL");if(t){const e=vh(s,t,ah.MIX_SHADER_BL.fac),n=vh(s,t,ah.MIX_SHADER_BL.color1,"BSDF_TRANSPARENT_BL"),o=vh(s,t,ah.MIX_SHADER_BL.color2,Bh);if(!e&&n&&o){const e=this.getInputValue(t,ah.MIX_SHADER_BL.fac);if(ye(e))return e}}}switch(i){case"BSDF_PRINCIPLED_BL":const t=this.getInputValue(o,ah[r].alpha);if(ye(t))return t;break;case"EEVEE_SPECULAR_BL":case"PHYSICAL_MX":if(c=this.getInputValue(o,ah[r].transparency),ye(c))return 1-c;break;case"OPENPBR_SURFACE_MX":case"OPENPBR_SURFACE_MY":if(u=this.getInputValue(o,ah[r].geometryOpacity),ye(u))return u;break;case"LAMBERT_MY":case"SURFACE_SHADER_MY":if(c=this.getInputColor(o,ah[r].transparency),c)return 1-(c.r+c.g+c.b)/3;break;case"STANDARD_SURFACE_AR":case"LAMBERT_AR":if(u=this.getInputColor(o,ah[r].opacity),u)return(u.r+u.g+u.b)/3}break;case"metalness":if(this.getStandardProp("metalnessMap"))return 1;switch(i){case"BSDF_PRINCIPLED_BL":if(h=this.getInputValue(o,ah[r].metallic),ye(h))return h;break;case"PHYSICAL_MX":case"STANDARD_SURFACE_AR":if(h=this.getInputValue(o,ah[r].metalness),ye(h))return h;break;case"OPENPBR_SURFACE_MX":case"OPENPBR_SURFACE_MY":if(h=this.getInputValue(o,ah[r].baseMetalness),ye(h))return h;break;case"BSDF_DIFFUSE_BL":case"DIFFUSE_BSDF_BL":case"LAMBERT_MY":case"LAMBERT_AR":case"EMISSION_BL":case"SURFACE_SHADER_MY":case"MAP_TO_MTL_AR":return 0;case"BSDF_GLOSSY_BL":case"BSDF_METALLIC_BL":return 1;case"EEVEE_SPECULAR_BL":return.5}break;case"metalnessMap":switch(i){case"BSDF_PRINCIPLED_BL":if(l=vh(s,o,ah[r].metallic,"SEPARATE_COLOR_BL"),l&&(f=this.getInputTexture(l,ah.SEPARATE_COLOR_BL.color),f))return f;break;case"PHYSICAL_MX":case"STANDARD_SURFACE_AR":if(f=this.getInputTexture(o,ah[r].metalness),f)return f;break;case"OPENPBR_SURFACE_MX":case"OPENPBR_SURFACE_MY":if(f=this.getInputTexture(o,ah[r].baseMetalness),f)return f;break;case"BSDF_DIFFUSE_BL":case"BSDF_GLOSSY_BL":case"BSDF_METALLIC_BL":case"DIFFUSE_BSDF_BL":case"EEVEE_SPECULAR_BL":case"EMISSION_BL":case"LAMBERT_MY":case"LAMBERT_AR":case"SURFACE_SHADER_MY":case"MAP_TO_MTL_AR":return null}break;case"roughness":if(this.getStandardProp("roughnessMap"))return 1;switch(i){case"BSDF_PRINCIPLED_BL":case"BSDF_GLOSSY_BL":case"BSDF_METALLIC_BL":case"EEVEE_SPECULAR_BL":case"PHYSICAL_MX":if(d=this.getInputValue(o,ah[r].roughness),ye(d))return d;break;case"OPENPBR_SURFACE_MX":case"OPENPBR_SURFACE_MY":case"STANDARD_SURFACE_AR":if(d=this.getInputValue(o,ah[r].specularRoughness),ye(d))return d;break;case"BSDF_DIFFUSE_BL":case"DIFFUSE_BSDF_BL":case"LAMBERT_MY":case"LAMBERT_AR":return 1;case"EMISSION_BL":case"SURFACE_SHADER_MY":case"MAP_TO_MTL_AR":return.9}break;case"roughnessMap":switch(i){case"BSDF_PRINCIPLED_BL":case"BSDF_GLOSSY_BL":case"BSDF_METALLIC_BL":case"EEVEE_SPECULAR_BL":if(l=vh(s,o,ah[r].roughness,"SEPARATE_COLOR_BL"),l&&(A=this.getInputTexture(l,ah.SEPARATE_COLOR_BL.color),A))return A;break;case"PHYSICAL_MX":if(A=this.getInputTexture(o,ah[r].roughness),A)return A;break;case"OPENPBR_SURFACE_MX":case"OPENPBR_SURFACE_MY":case"STANDARD_SURFACE_AR":if(A=this.getInputTexture(o,ah[r].specularRoughness),A)return A;break;case"BSDF_DIFFUSE_BL":case"DIFFUSE_BSDF_BL":case"EMISSION_BL":case"LAMBERT_MY":case"SURFACE_SHADER_MY":case"MAP_TO_MTL_AR":return null}break;case"aoMap":if(v=dh(s,"OUTPUT_MATERIAL_BL"),v>=0){const t=vh(s,v,ah.OUTPUT_MATERIAL_BL.surface,"MIX_SHADER_BL");if(t){const e=vh(s,t,ah.MIX_SHADER_BL.fac,"SEPARATE_COLOR_BL"),n=vh(s,t,ah.MIX_SHADER_BL.color1,["DIFFUSE_BSDF_BL","BSDF_DIFFUSE_BL"]),o=vh(s,t,ah.MIX_SHADER_BL.color2,Bh);if(e&&n&&o){const t=this.getInputTexture(e,ah.SEPARATE_COLOR_BL.color);if(t)return t}}}else{let t;switch(i){case"PHYSICAL_MX":case"STANDARD_SURFACE_AR":if(t=this.getInputTexture(o,ah[r].base),t)return t;break;case"OPENPBR_SURFACE_MX":case"OPENPBR_SURFACE_MY":if(t=this.getInputTexture(o,ah[r].baseWeight),t)return t}}break;case"aoMapIntensity":break;case"normalMap":if(Bh.includes(i)){const t=ah[r].normal;if(ye(t)){const e=vh(s,o,t,"NORMAL_MAP_BL");if(e){const t=this.getInputTexture(e,ah.NORMAL_MAP_BL.normalColor);if(t)return t}}}else if(Nh.includes(i)){const t=ah[r].normal;if(ye(t)){const e=vh(s,o,t,"BUMP_2D_MY");if(e){const t=this.getInputTexture(e,ah.BUMP_2D_MY.bumpValue);if(t)return t}}}else if("PHYSICAL_MX"==i||"OPENPBR_SURFACE_MX"==i){const t=vh(s,o,ah[r].normal,"NORMAL_BUMP_MX");if(t){const e=this.getInputTexture(t,ah.NORMAL_BUMP_MX.normalColor);if(e)return e}}break;case"normalScale":if(Bh.includes(i)){const t=ah[r].normal;if(ye(t)){const e=vh(s,o,t,"NORMAL_MAP_BL");if(e){const t=this.getInputValue(e,ah.NORMAL_MAP_BL.strength);if(ye(t))return new we(t,t)}}}else if(Nh.includes(i)){const t=ah[r].normal;if(ye(t)){const e=vh(s,o,t,"BUMP_2D_MY");if(e){const t=this.getInputValue(e,ah.BUMP_2D_MY.bumpDepth);if(ye(t))return new we(t,t)}}}else if("PHYSICAL_MX"==i||"OPENPBR_SURFACE_MX"==i){const t=vh(s,o,ah[r].normal,"NORMAL_BUMP_MX");if(t){const e=this.getInputValue(t,ah.NORMAL_BUMP_MX.normalMult);if(ye(e))return new we(e,e)}}break;case"emissive":if(this.getStandardProp("emissiveMap"))return new tn(1,1,1);let t;switch(i){case"BSDF_PRINCIPLED_BL":t=this.getInputColor(o,ah[r].emission);break;case"EEVEE_SPECULAR_BL":t=this.getInputColor(o,ah[r].emissiveColor);break;case"PHYSICAL_MX":t=this.getInputColor(o,ah[r].emitColor);break;case"OPENPBR_SURFACE_MX":case"OPENPBR_SURFACE_MY":case"STANDARD_SURFACE_AR":t=this.getInputColor(o,ah[r].emissionColor)}if(t)return t;break;case"emissiveMap":let m;switch(i){case"BSDF_PRINCIPLED_BL":m=this.getInputTexture(o,ah[r].emission);break;case"EEVEE_SPECULAR_BL":m=this.getInputTexture(o,ah[r].emissiveColor);break;case"PHYSICAL_MX":m=this.getInputTexture(o,ah[r].emitColor);break;case"OPENPBR_SURFACE_MX":case"OPENPBR_SURFACE_MY":case"STANDARD_SURFACE_AR":m=this.getInputTexture(o,ah[r].emissionColor)}if(m)return m;break;case"emissiveIntensity":let p;switch(i){case"BSDF_PRINCIPLED_BL":p=this.getInputValue(o,ah[r].emissionStrength);break;case"EEVEE_SPECULAR_BL":p=1;break;case"PHYSICAL_MX":case"STANDARD_SURFACE_AR":p=this.getInputValue(o,ah[r].emission);break;case"OPENPBR_SURFACE_MX":p=this.getInputValue(o,ah[r].emissionWeight);break;case"OPENPBR_SURFACE_MY":p=this.getInputValue(o,ah[r].emissionLuminance/1e3)}if(ye(p))return p}return Dh[t]}isUnlit(){const t=this.getMainShaderNode();return!(!t||!fh(t,["EMISSION_BL","SURFACE_SHADER_MY","MAP_TO_MTL_AR"]))}copy(t){super.copy(t),this.wireframe=t.wireframe,this.wireframeLinewidth=t.wireframeLinewidth,this.flatShading=t.flatShading,this.fog=t.fog,this.envMap=t.envMap,this.envMapIntensity=t.envMapIntensity,this.envMapParallaxType=t.envMapParallaxType,this.envMapParallaxMatrix.copy(t.envMapParallaxMatrix),this.envMapParallaxMatrixInv.copy(t.envMapParallaxMatrixInv),this.materialIndex=t.materialIndex,this.profile=t.profile,this.nodeTextures=Object.assign({},t.nodeTextures),this.nodeRGB=[];for(let e=0;e<t.nodeRGB.length;e++)this.nodeRGB.push(t.nodeRGB[e].clone());this.nodeRGBMap=Object.assign({},t.nodeRGBMap),this.nodeTexCoordObject=t.nodeTexCoordObject.slice(),this.nodeTexCoordObjectMap=Object.assign({},t.nodeTexCoordObjectMap),this.nodeValue=t.nodeValue.slice(),this.nodeValueMap=Object.assign({},t.nodeValueMap),this.nodeInputs={};for(const e in t.nodeInputs)this.nodeInputs[e]=t.nodeInputs[e].slice();this.needsBoundingBox=t.needsBoundingBox,this.useFloatTex=t.useFloatTex,this.nodeGraph=wh(t.nodeGraph),this.additionalNodeGraphs={};for(const e in t.additionalNodeGraphs)this.additionalNodeGraphs[e]=wh(t.additionalNodeGraphs[e]);return this.nodeChunks=Object.assign({},t.nodeChunks),this.nodeChunksHash=t.nodeChunksHash,this.nodeVCAliases=Object.assign({},t.nodeVCAliases),this.nodeUVAliases=Object.assign({},t.nodeUVAliases),this}}const Oh={enabled:!1,files:{},add:function(t,e){!1!==this.enabled&&(this.files[t]=e)},get:function(t){if(!1!==this.enabled)return this.files[t]},remove:function(t){delete this.files[t]},clear:function(){this.files={}}};class Fh{constructor(t,e,n){const o=this;let i,r=!1,s=0,a=0;const l=[];this.onStart=void 0,this.onLoad=t,this.onProgress=e,this.onError=n,this.itemStart=function(t){a++,!1===r&&void 0!==o.onStart&&o.onStart(t,s,a),r=!0},this.itemEnd=function(t){s++,void 0!==o.onProgress&&o.onProgress(t,s,a),s===a&&(r=!1,void 0!==o.onLoad&&o.onLoad())},this.itemError=function(t){void 0!==o.onError&&o.onError(t)},this.resolveURL=function(t){return i?i(t):t},this.setURLModifier=function(t){return i=t,this},this.addHandler=function(t,e){return l.push(t,e),this},this.removeHandler=function(t){const e=l.indexOf(t);return-1!==e&&l.splice(e,2),this},this.getHandler=function(t){for(let e=0,n=l.length;e<n;e+=2){const n=l[e],o=l[e+1];if(n.global&&(n.lastIndex=0),n.test(t))return o}return null}}}const Uh=new Fh;class Vh{constructor(t){this.manager=void 0!==t?t:Uh,this.crossOrigin="anonymous",this.withCredentials=!1,this.path="",this.resourcePath="",this.requestHeader={}}load(){}loadAsync(t,e){const n=this;return new Promise(function(o,i){n.load(t,o,e,i)})}parse(){}setCrossOrigin(t){return this.crossOrigin=t,this}setWithCredentials(t){return this.withCredentials=t,this}setPath(t){return this.path=t,this}setResourcePath(t){return this.resourcePath=t,this}setRequestHeader(t){return this.requestHeader=t,this}}const Gh={};class Qh extends Error{constructor(t,e){super(t),this.response=e}}class zh extends Vh{constructor(t){super(t)}load(t,e,n,o){void 0===t&&(t=""),void 0!==this.path&&(t=this.path+t),t=this.manager.resolveURL(t);const i=Oh.get(t);if(void 0!==i)return this.manager.itemStart(t),setTimeout(()=>{e&&e(i),this.manager.itemEnd(t)},0),i;if(void 0!==Gh[t])return void Gh[t].push({onLoad:e,onProgress:n,onError:o});Gh[t]=[],Gh[t].push({onLoad:e,onProgress:n,onError:o});const r=new Request(t,{headers:new Headers(this.requestHeader),credentials:this.withCredentials?"include":"same-origin"}),s=this.mimeType,a=this.responseType;fetch(r).then(e=>{if(200===e.status||0===e.status){if(0===e.status&&console.warn("v3d.FileLoader: HTTP Status 0 received."),"undefined"==typeof ReadableStream||void 0===e.body||void 0===e.body.getReader)return e;const n=Gh[t],o=e.body.getReader(),i=e.headers.get("Content-Length")||e.headers.get("X-File-Size"),r=i?parseInt(i):0,s=0!==r;let a=0;const l=new ReadableStream({start(t){!function e(){o.read().then(({done:o,value:i})=>{if(o)t.close();else{a+=i.byteLength;const o=new ProgressEvent("progress",{lengthComputable:s,loaded:a,total:r});for(let t=0,e=n.length;t<e;t++){const e=n[t];e.onProgress&&e.onProgress(o)}t.enqueue(i),e()}})}()}});return new Response(l)}throw new Qh(`fetch for "${e.url}" responded with ${e.status}: ${e.statusText}`,e)}).then(t=>{switch(a){case"arraybuffer":return t.arrayBuffer();case"blob":return t.blob();case"document":return t.text().then(t=>(new DOMParser).parseFromString(t,s));case"json":return t.json();default:if(void 0===s)return t.text();{const e=/charset="?([^;"\s]*)"?/i.exec(s),n=e&&e[1]?e[1].toLowerCase():void 0,o=new TextDecoder(n);return t.arrayBuffer().then(t=>o.decode(t))}}}).then(e=>{Oh.add(t,e);const n=Gh[t];delete Gh[t];for(let t=0,o=n.length;t<o;t++){const o=n[t];o.onLoad&&o.onLoad(e)}}).catch(e=>{const n=Gh[t];if(void 0===n)throw this.manager.itemError(t),e;delete Gh[t];for(let t=0,o=n.length;t<o;t++){const o=n[t];o.onError&&o.onError(e)}this.manager.itemError(t)}).finally(()=>{this.manager.itemEnd(t)}),this.manager.itemStart(t)}setResponseType(t){return this.responseType=t,this}setMimeType(t){return this.mimeType=t,this}}class kh extends Vh{constructor(t){super(t)}load(t,e,n,o){void 0!==this.path&&(t=this.path+t),t=this.manager.resolveURL(t);const i=this,r=Oh.get(t);if(void 0!==r)return i.manager.itemStart(t),setTimeout(function(){e&&e(r),i.manager.itemEnd(t)},0),r;const s=be("img");function a(){c(),Oh.add(t,this),e&&e(this),i.manager.itemEnd(t)}function l(e){c(),o&&o(e),i.manager.itemError(t),i.manager.itemEnd(t)}function c(){s.removeEventListener("load",a,!1),s.removeEventListener("error",l,!1)}return s.addEventListener("load",a,!1),s.addEventListener("error",l,!1),"data:"!==t.slice(0,5)&&void 0!==this.crossOrigin&&(s.crossOrigin=this.crossOrigin),i.manager.itemStart(t),s.src=t,s}}class Hh extends Vh{constructor(t){super(t)}load(t,e,n,o){const i=this,r=new ul,s=new zh(this.manager);return s.setResponseType("arraybuffer"),s.setRequestHeader(this.requestHeader),s.setPath(this.path),s.setWithCredentials(i.withCredentials),s.load(t,function(t){const n=i.parse(t);n&&(void 0!==n.image?r.image=n.image:void 0!==n.data&&(r.image.width=n.width,r.image.height=n.height,r.image.data=n.data),r.wrapS=void 0!==n.wrapS?n.wrapS:y,r.wrapT=void 0!==n.wrapT?n.wrapT:y,r.magFilter=void 0!==n.magFilter?n.magFilter:N,r.minFilter=void 0!==n.minFilter?n.minFilter:N,r.anisotropy=void 0!==n.anisotropy?n.anisotropy:1,void 0!==n.encoding&&(r.encoding=n.encoding),void 0!==n.flipY&&(r.flipY=n.flipY),void 0!==n.format&&(r.format=n.format),void 0!==n.type&&(r.type=n.type),void 0!==n.mipmaps&&(r.mipmaps=n.mipmaps,r.minFilter=P),1===n.mipmapCount&&(r.minFilter=N),void 0!==n.generateMipmaps&&(r.generateMipmaps=n.generateMipmaps),r.needsUpdate=!0,e&&e(r,n))},n,o),r}}class Wh extends Vh{constructor(t){super(t)}load(t,e,n,o){const i=new an,r=new kh(this.manager);return r.setCrossOrigin(this.crossOrigin),r.setPath(this.path),r.load(t,function(t){i.image=t,i.needsUpdate=!0,void 0!==e&&e(i)},n,o),i}}class Yh extends Vh{constructor(t){super(t),this.isImageBitmapLoader=!0,"undefined"==typeof createImageBitmap&&console.warn("v3d.ImageBitmapLoader: createImageBitmap() not supported."),"undefined"==typeof fetch&&console.warn("v3d.ImageBitmapLoader: fetch() not supported."),this.options={premultiplyAlpha:"none"}}setOptions(t){return this.options=t,this}load(t,e,n,o){void 0===t&&(t=""),void 0!==this.path&&(t=this.path+t),t=this.manager.resolveURL(t);const i=this,r=Oh.get(t);if(void 0!==r)return i.manager.itemStart(t),setTimeout(function(){e&&e(r),i.manager.itemEnd(t)},0),r;const s={};s.credentials="anonymous"===this.crossOrigin?"same-origin":"include",s.headers=this.requestHeader,fetch(t,s).then(function(t){return t.blob()}).then(function(t){return createImageBitmap(t,Object.assign(i.options,{colorSpaceConversion:"none"}))}).then(function(n){Oh.add(t,n),e&&e(n),i.manager.itemEnd(t)}).catch(function(e){o&&o(e),i.manager.itemError(t),i.manager.itemEnd(t)}),i.manager.itemStart(t)}}class Xh{static decodeText(t){if("undefined"!=typeof TextDecoder)return(new TextDecoder).decode(t);let e="";for(let n=0,o=t.length;n<o;n++)e+=String.fromCharCode(t[n]);try{return decodeURIComponent(escape(e))}catch(t){return e}}static extractUrlBase(t){const e=t.lastIndexOf("/");return-1===e?"./":t.slice(0,e+1)}static resolveURL(t,e){return"string"!=typeof t||""===t?"":(/^https?:\/\//i.test(e)&&/^\//.test(t)&&(e=e.replace(/(^https?:\/\/[^\/]+).*/i,"$1")),/^(https?:)?\/\//i.test(t)||/^data:.*,.*$/i.test(t)||/^blob:.*$/i.test(t)?t:e+t)}}let Kh;class jh{static getContext(){return void 0===Kh&&(Kh=new(window.AudioContext||window.webkitAudioContext)),Kh}static setContext(t){Kh=t}}class Zh extends mo{constructor(t,e=1){super(),this.isLight=!0,this.type="Light",this.color=new tn(t),this.intensity=e}dispose(){}copy(t,e){return super.copy(t,e),this.color.copy(t.color),this.intensity=t.intensity,this}getWorldDirection(t){this.updateWorldMatrix(!0,!1);const e=this.matrixWorld.elements;return t.set(-e[8],-e[9],-e[10]).normalize()}}const qh=new An;class Jh extends Zh{constructor(t,e,n=0,o=Math.PI/3,i=0,r=2){super(t,e),this.isSpotLight=!0,this.type="SpotLight",this.position.copy(mo.DefaultUp),this.updateMatrix(),this.target=new mo,this.distance=n,this.angle=o,this.penumbra=i,this.decay=r,this.shadow=new wa,this.isFreeLight=!1}get power(){return 4*this.intensity*Math.PI}set power(t){this.intensity=t/(4*Math.PI)}dispose(){this.shadow.dispose()}copy(t,e){return super.copy(t,e),this.distance=t.distance,this.angle=t.angle,this.penumbra=t.penumbra,this.decay=t.decay,this.target=t.target.clone(),this.shadow=t.shadow.clone(),this.isFreeLight=t.isFreeLight,this}updateMatrixWorld(t){super.updateMatrixWorld(t),this.isFreeLight&&this.updateFreeLightTarget()}updateWorldMatrix(t,e){super.updateWorldMatrix(t,e),this.isFreeLight&&this.updateFreeLightTarget()}updateFreeLightTarget(){qh.set(0,0,-1).applyQuaternion(this.quaternion).normalize(),this.target.position.addVectors(this.position,qh),this.target.updateMatrixWorld()}}const $h=new Hn,tf=new An,ef=new An;class nf extends pa{constructor(){super(new Ei(90,1,.5,500)),this.isPointLightShadow=!0,this.Yt=new we(4,2),this.Xt=6,this.Kt=[new ln(2,1,1,1),new ln(0,1,1,1),new ln(3,1,1,1),new ln(1,1,1,1),new ln(3,0,1,1),new ln(1,0,1,1)],this.te=[new An(1,0,0),new An(-1,0,0),new An(0,0,1),new An(0,0,-1),new An(0,1,0),new An(0,-1,0)],this.ee=[new An(0,1,0),new An(0,1,0),new An(0,1,0),new An(0,1,0),new An(0,0,1),new An(0,0,-1)]}updateMatrices(t,e=0){const n=this.camera,o=this.matrix,i=t.distance||n.far;i!==n.far&&(n.far=i,n.updateProjectionMatrix()),tf.setFromMatrixPosition(t.matrixWorld),n.position.copy(tf),ef.copy(n.position),ef.add(this.te[e]),n.up.copy(this.ee[e]),n.lookAt(ef),n.updateMatrixWorld(),o.makeTranslation(-tf.x,-tf.y,-tf.z),$h.multiplyMatrices(n.projectionMatrix,n.matrixWorldInverse),this.Wt.setFromProjectionMatrix($h)}}class of extends Zh{constructor(t,e,n=0,o=2){super(t,e),this.isPointLight=!0,this.type="PointLight",this.distance=n,this.decay=o,this.shadow=new nf}get power(){return 4*this.intensity*Math.PI}set power(t){this.intensity=t/(4*Math.PI)}dispose(){this.shadow.dispose()}copy(t,e){return super.copy(t,e),this.distance=t.distance,this.decay=t.decay,this.shadow=t.shadow.clone(),this}}class rf extends nf{constructor(){super(),this.isRectAreaLightShadow=!0}}class sf extends Zh{constructor(t,e,n=10,o=10){super(t,e),this.isRectAreaLight=!0,this.type="RectAreaLight",this.width=n,this.height=o,this.shadow=new rf}get power(){return 2*this.intensity*Math.PI}set power(t){this.intensity=t/(2*Math.PI)}copy(t){return super.copy(t),this.width=t.width,this.height=t.height,this.shadow=t.shadow.clone(),this}}const af=new Hn;class lf{constructor({maxFar:t=1e5,projectionMatrix:e=null}={}){this.vertices={near:[new An,new An,new An,new An],far:[new An,new An,new An,new An]},e&&this.setFromProjectionMatrix(e,t)}setFromProjectionMatrix(t,e){const n=0===t.elements[11];return af.copy(t).invert(),this.vertices.near[0].set(1,1,-1),this.vertices.near[1].set(1,-1,-1),this.vertices.near[2].set(-1,-1,-1),this.vertices.near[3].set(-1,1,-1),this.vertices.near.forEach(function(t){t.applyMatrix4(af)}),this.vertices.far[0].set(1,1,1),this.vertices.far[1].set(1,-1,1),this.vertices.far[2].set(-1,-1,1),this.vertices.far[3].set(-1,1,1),this.vertices.far.forEach(function(t){t.applyMatrix4(af);const o=Math.abs(t.z);n?t.z*=Math.min(e/o,1):t.multiplyScalar(Math.min(e/o,1))}),this.vertices}split(t,e,n){for(;t.length>e.length;)e.push(new lf);e.length=t.length;for(let o=0;o<t.length;o++){const i=e[o];if(0===o||n)for(let t=0;t<4;t++)i.vertices.near[t].copy(this.vertices.near[t]);else for(let e=0;e<4;e++)i.vertices.near[e].lerpVectors(this.vertices.near[e],this.vertices.far[e],t[o-1]);if(o===t.length-1)for(let t=0;t<4;t++)i.vertices.far[t].copy(this.vertices.far[t]);else for(let e=0;e<4;e++)i.vertices.far[e].lerpVectors(this.vertices.near[e],this.vertices.far[e],t[o])}}toSpace(t,e){for(let n=0;n<4;n++)e.vertices.near[n].copy(this.vertices.near[n]).applyMatrix4(t),e.vertices.far[n].copy(this.vertices.far[n]).applyMatrix4(t)}}const cf=new An,uf=new An,hf=new An,ff=new Hn;new Hn;const df=new pn,Af=new lf,vf=[],mf=[];class pf extends pa{constructor(){super(new Xi(-5,5,5,-5,.5,500)),this.esmBlurRadius=0,this.pancakeDepth=!0,this.isDirectionalLightShadowCascade=!0}updateMatrices(t){const e=this.camera,n=this.matrix,o=cf.setFromMatrixPosition(e.matrixWorld),i=uf.setFromMatrixPosition(t.matrixWorld);e.position.copy(i);const r=hf.setFromMatrixPosition(t.target.matrixWorld);e.lookAt(r),e.position.copy(o),e.updateMatrixWorld();const s=ff.multiplyMatrices(e.projectionMatrix,e.matrixWorldInverse);this.Wt.setFromProjectionMatrix(s),this.pancakeDepth&&(this.Wt.planes[5].constant=1/0),n.set(.5,0,0,.5,0,.5,0,.5,0,0,.5,.5,0,0,0,1),n.multiply(s)}}class gf extends pa{constructor({numCascades:t=1,maxDistance:e=500,fade:n=0,lightMargin:o=1,noLastCascadeCutOff:i=!0,customSplitsCallback:r=null}={}){super(new Xi(-5,5,5,-5,.5,500)),this.numCascades=t,this.exponent=.5,this.customSplitsCallback=r,this.maxDistance=e,this.fade=n,this.lightMargin=o,this.noLastCascadeCutOff=i,this.cascadesFitToScene=!1,this.mainFrustum=new lf,this.Ie=[],this.Me=[],this.Ht=[],this.Se=new Hn,this.be=null,this.ye=!0,this.createCascades(),this.isDirectionalLightShadowCSM=!0}createCascades(){const t=this.Ht;for(;t.length>this.numCascades;)t.pop().dispose();for(let e=t.length;e<this.numCascades;e++){const e=new pf;e.mapSize.copy(this.mapSize),e.copy(this),t.push(e)}for(let e=0;e<t.length;e++){const n=t[e];n.mapSize.copy(this.mapSize),n.copy(this)}this.updateMapSize()}initCascades(t){t.updateProjectionMatrix(),this.mainFrustum.setFromProjectionMatrix(t.projectionMatrix,this.maxDistance),this.mainFrustum.split(this.Me,this.Ie,this.cascadesFitToScene)}updateShadowBounds(t){const e=this.Ie;for(let n=0;n<e.length;n++){const o=this.Ht[n],i=this.Ht[n].camera,r=e[n],s=r.vertices.near,a=r.vertices.far,l=a[0];let c;c=l.distanceTo(a[2])>l.distanceTo(s[2])?a[2]:s[2];let u=l.distanceTo(c);if(this.fade>0){const e=Math.min(t.far,this.maxDistance),n=t.near,o=r.vertices.far[0].z/(e-n);u+=this.fade*Math.pow(o,2)*(e-n)}i.left=-u/2,i.right=u/2,i.top=u/2,i.bottom=-u/2,i.near=0,i.far=u+this.lightMargin,i.updateProjectionMatrix(),o.bias=this.bias,o.normalBias=this.normalBias,o.esmBlurRadius=o.radius/((i.right-i.left)/2)}}getBreaks(t){const e=t.near,n=Math.min(t.far,this.maxDistance),o=this.numCascades,i=this.exponent,r=this.Me;r.length=0,this.customSplitsCallback?this.customSplitsCallback(o,e,n,r,i):function(t,e,n,o,i){vf.length=0,mf.length=0,function(t,e,n,o){for(let i=1;i<t;i++)o.push(e*(n/e)**(i/t)/n);o.push(1)}(t,e,n,mf),function(t,e,n,o){for(let i=1;i<t;i++)o.push((e+(n-e)*i/t)/n);o.push(1)}(t,e,n,vf);for(let e=1;e<t;e++)i.push(se(vf[e-1],mf[e-1],o));i.push(1)}(o,e,n,i,r)}updateCascadePositions(t){const e=this.Ie;for(let n=0;n<e.length;n++){const o=this.Ht[n],i=this.Ht[n].camera,r=(i.right-i.left)/o.mapSize.x,s=(i.top-i.bottom)/o.mapSize.y;i.updateMatrixWorld(!0);const a=ff.multiplyMatrices(i.matrixWorldInverse,t.matrixWorld);e[n].toSpace(a,Af);const l=Af.vertices.near,c=Af.vertices.far;df.makeEmpty();for(let t=0;t<4;t++)df.expandByPoint(l[t]),df.expandByPoint(c[t]);const u=df.getCenter(cf);u.z=df.max.z+this.lightMargin,u.x=Math.floor(u.x/r)*r,u.y=Math.floor(u.y/s)*s,u.applyMatrix4(i.matrixWorld),i.position.copy(u),i.updateMatrixWorld()}}update(t,e){!this.ye&&this.be===t&&this.Se.equals(t.projectionMatrix)||(this.updateFrustums(t),this.updateMatrices(e),this.be=t,this.Se.copy(t.projectionMatrix),this.ye=!1),this.updateCascadePositions(t)}getCascadeRange(t,e){const n=this.Me,o=n[e],i=n[e-1]||0;t.x=i,t.y=o,this.noLastCascadeCutOff&&e==n.length-1&&(t.y=1/0)}updateFrustums(t){this.getBreaks(t),this.initCascades(t),this.updateShadowBounds(t)}updateMatrices(t){for(let e=0;e<this.Ht.length;e++)this.Ht[e].updateMatrices(t)}updateMapSize(t){t&&this.mapSize.copy(t);const e=this.mapSize;for(let t=0;t<this.Ht.length;t++){this.Ht[t].mapSize.copy(e)}this.updateMaps()}updateMaps(){for(let t=0;t<this.Ht.length;t++){const e=this.Ht[t];e.dispose(),e.map=null,e.jt=null,e.Zt=null}}dispose(){for(let t=0;t<this.Ht.length;t++)this.Ht[t].dispose();super.dispose()}copy(t){return super.copy(t),this.numCascades=t.numCascades,this.exponent=t.exponent,this.maxDistance=t.maxDistance,this.fade=t.fade,this.lightMargin=t.lightMargin,this.noLastCascadeCutOff=t.noLastCascadeCutOff,this.createCascades(),this}clone(){return(new this.constructor).copy(this)}setCascadesFitToScene(t){this.cascadesFitToScene=t,this.ye=!0}setExponent(t){this.exponent=t,this.ye=!0}setFade(t){this.fade=t,this.ye=!0}setMaxDistance(t){this.maxDistance=t,this.ye=!0}setNoLastCascadeCutOff(t){this.noLastCascadeCutOff=t,this.ye=!0}setNumCascades(t){this.numCascades=t,this.ye=!0,this.createCascades()}setLightMargin(t){this.lightMargin=t,this.ye=!0}}const _f=new An;class Ef extends Zh{constructor(t,e){super(t,e),this.isDirectionalLight=!0,this.type="DirectionalLight",this.position.copy(mo.DefaultUp),this.updateMatrix(),this.target=new mo,this.shadow=new gf,this.isFreeLight=!1}dispose(){this.shadow.dispose()}copy(t){return super.copy(t),this.target=t.target.clone(),this.shadow=t.shadow.clone(),this.isFreeLight=t.isFreeLight,this}updateMatrixWorld(t){super.updateMatrixWorld(t),this.isFreeLight&&this.updateFreeLightTarget()}updateWorldMatrix(t,e){super.updateWorldMatrix(t,e),this.isFreeLight&&this.updateFreeLightTarget()}updateFreeLightTarget(){_f.set(0,0,-1).applyQuaternion(this.quaternion).normalize(),this.target.position.addVectors(this.position,_f),this.target.updateMatrixWorld()}}class Cf extends Zh{constructor(t,e){super(t,e),this.isAmbientLight=!0,this.type="AmbientLight"}}class wf{constructor(){this.isSphericalHarmonics3=!0,this.coefficients=[];for(let t=0;t<9;t++)this.coefficients.push(new An)}set(t){for(let e=0;e<9;e++)this.coefficients[e].copy(t[e]);return this}zero(){for(let t=0;t<9;t++)this.coefficients[t].set(0,0,0);return this}getAt(t,e){const n=t.x,o=t.y,i=t.z,r=this.coefficients;return e.copy(r[0]).multiplyScalar(.282095),e.addScaledVector(r[1],.488603*o),e.addScaledVector(r[2],.488603*i),e.addScaledVector(r[3],.488603*n),e.addScaledVector(r[4],n*o*1.092548),e.addScaledVector(r[5],o*i*1.092548),e.addScaledVector(r[6],.315392*(3*i*i-1)),e.addScaledVector(r[7],n*i*1.092548),e.addScaledVector(r[8],.546274*(n*n-o*o)),e}getIrradianceAt(t,e){const n=t.x,o=t.y,i=t.z,r=this.coefficients;return e.copy(r[0]).multiplyScalar(.886227),e.addScaledVector(r[1],1.023328*o),e.addScaledVector(r[2],1.023328*i),e.addScaledVector(r[3],1.023328*n),e.addScaledVector(r[4],.858086*n*o),e.addScaledVector(r[5],.858086*o*i),e.addScaledVector(r[6],.743125*i*i-.247708),e.addScaledVector(r[7],.858086*n*i),e.addScaledVector(r[8],.429043*(n*n-o*o)),e}add(t){for(let e=0;e<9;e++)this.coefficients[e].add(t.coefficients[e]);return this}addScaledSH(t,e){for(let n=0;n<9;n++)this.coefficients[n].addScaledVector(t.coefficients[n],e);return this}scale(t){for(let e=0;e<9;e++)this.coefficients[e].multiplyScalar(t);return this}lerp(t,e){for(let n=0;n<9;n++)this.coefficients[n].lerp(t.coefficients[n],e);return this}equals(t){for(let e=0;e<9;e++)if(!this.coefficients[e].equals(t.coefficients[e]))return!1;return!0}copy(t){return this.set(t.coefficients)}clone(){return(new this.constructor).copy(this)}fromArray(t,e=0){const n=this.coefficients;for(let o=0;o<9;o++)n[o].fromArray(t,e+3*o);return this}toArray(t=[],e=0){const n=this.coefficients;for(let o=0;o<9;o++)n[o].toArray(t,e+3*o);return t}static getBasisAt(t,e){const n=t.x,o=t.y,i=t.z;e[0]=.282095,e[1]=.488603*o,e[2]=.488603*i,e[3]=.488603*n,e[4]=1.092548*n*o,e[5]=1.092548*o*i,e[6]=.315392*(3*i*i-1),e[7]=1.092548*n*i,e[8]=.546274*(n*n-o*o)}}class xf extends Zh{constructor(t=new wf,e=1){super(void 0,e),this.isLightProbe=!0,this.type="LightProbe",this.sh=t}copy(t){return super.copy(t),this.sh.copy(t.sh),this}}class If{constructor(t=!0){this.autoStart=t,this.startTime=0,this.oldTime=0,this.elapsedTime=0,this.running=!1}start(){this.startTime=performance.now(),this.oldTime=this.startTime,this.elapsedTime=0,this.running=!0}stop(){this.getElapsedTime(),this.running=!1,this.autoStart=!1}getElapsedTime(){return this.getDelta(),this.elapsedTime}getDelta(){let t=0;if(this.autoStart&&!this.running)return this.start(),0;if(this.running){const e=performance.now();t=(e-this.oldTime)/1e3,this.oldTime=e,this.elapsedTime+=t}return t}}const Mf=new An,Sf=new dn,bf=new An,yf=new An;class Rf extends mo{constructor(){super(),this.type="AudioListener",this.context=jh.getContext(),this.gain=this.context.createGain(),this.gain.connect(this.context.destination),this.filter=null,this.timeDelta=0,this.Re=new If}getInput(){return this.gain}removeFilter(){return null!==this.filter&&(this.gain.disconnect(this.filter),this.filter.disconnect(this.context.destination),this.gain.connect(this.context.destination),this.filter=null),this}getFilter(){return this.filter}setFilter(t){return null!==this.filter?(this.gain.disconnect(this.filter),this.filter.disconnect(this.context.destination)):this.gain.disconnect(this.context.destination),this.filter=t,this.gain.connect(this.filter),this.filter.connect(this.context.destination),this}getMasterVolume(){return this.gain.gain.value}setMasterVolume(t){return this.gain.gain.setTargetAtTime(t,this.context.currentTime,.01),this}updateMatrixWorld(t){super.updateMatrixWorld(t);const e=this.context.listener,n=this.up;if(this.timeDelta=this.Re.getDelta(),this.matrixWorld.decompose(Mf,Sf,bf),yf.set(0,0,-1).applyQuaternion(Sf),e.positionX){const t=this.context.currentTime+this.timeDelta;e.positionX.linearRampToValueAtTime(Mf.x,t),e.positionY.linearRampToValueAtTime(Mf.y,t),e.positionZ.linearRampToValueAtTime(Mf.z,t),e.forwardX.linearRampToValueAtTime(yf.x,t),e.forwardY.linearRampToValueAtTime(yf.y,t),e.forwardZ.linearRampToValueAtTime(yf.z,t),e.upX.linearRampToValueAtTime(n.x,t),e.upY.linearRampToValueAtTime(n.y,t),e.upZ.linearRampToValueAtTime(n.z,t)}else e.setPosition(Mf.x,Mf.y,Mf.z),e.setOrientation(yf.x,yf.y,yf.z,n.x,n.y,n.z)}}class Tf extends mo{constructor(t){super(),this.type="Audio",this.listener=t,this.context=t.context,this.gain=this.context.createGain(),this.gain.connect(t.getInput()),this.autoplay=!1,this.buffer=null,this.detune=0,this.loop=!1,this.loopStart=0,this.loopEnd=0,this.offset=0,this.duration=void 0,this.playbackRate=1,this.isPlaying=!1,this.hasPlaybackControl=!0,this.source=null,this.sourceType="empty",this.Te=0,this.Be=0,this.Le=!1,this.filters=[]}getOutput(){return this.gain}setNodeSource(t){return this.hasPlaybackControl=!1,this.sourceType="audioNode",this.source=t,this.connect(),this}setMediaElementSource(t){return this.hasPlaybackControl=!1,this.sourceType="mediaNode",this.source=this.context.createMediaElementSource(t),this.connect(),this}setMediaStreamSource(t){return this.hasPlaybackControl=!1,this.sourceType="mediaStreamNode",this.source=this.context.createMediaStreamSource(t),this.connect(),this}setBuffer(t){return this.buffer=t,this.sourceType="buffer",this.autoplay&&this.play(),this}play(t=0){if(!0===this.isPlaying)return void console.warn("v3d.Audio: Audio is already playing.");if(!1===this.hasPlaybackControl)return void console.warn("v3d.Audio: this Audio has no playback control.");this.Te=this.context.currentTime+t;const e=this.context.createBufferSource();return e.buffer=this.buffer,e.loop=this.loop,e.loopStart=this.loopStart,e.loopEnd=this.loopEnd,e.onended=this.onEnded.bind(this),e.start(this.Te,this.Be+this.offset,this.duration),this.isPlaying=!0,this.source=e,this.setDetune(this.detune),this.setPlaybackRate(this.playbackRate),this.connect()}pause(){if(!1!==this.hasPlaybackControl)return!0===this.isPlaying&&(this.Be+=Math.max(this.context.currentTime-this.Te,0)*this.playbackRate,!0===this.loop&&(this.Be=this.Be%(this.duration||this.buffer.duration)),this.source.stop(),this.source.onended=null,this.isPlaying=!1),this;console.warn("v3d.Audio: this Audio has no playback control.")}stop(){if(!1!==this.hasPlaybackControl)return this.Be=0,this.source.stop(),this.source.onended=null,this.isPlaying=!1,this;console.warn("v3d.Audio: this Audio has no playback control.")}connect(){if(this.filters.length>0){this.source.connect(this.filters[0]);for(let t=1,e=this.filters.length;t<e;t++)this.filters[t-1].connect(this.filters[t]);this.filters[this.filters.length-1].connect(this.getOutput())}else this.source.connect(this.getOutput());return this.Le=!0,this}disconnect(){if(this.filters.length>0){this.source.disconnect(this.filters[0]);for(let t=1,e=this.filters.length;t<e;t++)this.filters[t-1].disconnect(this.filters[t]);this.filters[this.filters.length-1].disconnect(this.getOutput())}else this.source.disconnect(this.getOutput());return this.Le=!1,this}getFilters(){return this.filters}setFilters(t){return t||(t=[]),!0===this.Le?(this.disconnect(),this.filters=t.slice(),this.connect()):this.filters=t.slice(),this}setDetune(t){if(this.detune=t,void 0!==this.source.detune)return!0===this.isPlaying&&this.source.detune.setTargetAtTime(this.detune,this.context.currentTime,.01),this}getDetune(){return this.detune}getFilter(){return this.getFilters()[0]}setFilter(t){return this.setFilters(t?[t]:[])}setPlaybackRate(t){if(!1!==this.hasPlaybackControl)return this.playbackRate=t,!0===this.isPlaying&&this.source.playbackRate.setTargetAtTime(this.playbackRate,this.context.currentTime,.01),this;console.warn("v3d.Audio: this Audio has no playback control.")}getPlaybackRate(){return this.playbackRate}onEnded(){this.isPlaying=!1}getLoop(){return!1===this.hasPlaybackControl?(console.warn("v3d.Audio: this Audio has no playback control."),!1):this.loop}setLoop(t){if(!1!==this.hasPlaybackControl)return this.loop=t,!0===this.isPlaying&&(this.source.loop=this.loop),this;console.warn("v3d.Audio: this Audio has no playback control.")}setLoopStart(t){return this.loopStart=t,this}setLoopEnd(t){return this.loopEnd=t,this}getVolume(){return this.gain.gain.value}setVolume(t){return this.gain.gain.setTargetAtTime(t,this.context.currentTime,.01),this}}const Bf=new An,Lf=new dn,Nf=new An,Df=new An;class Pf extends Zc{constructor(t,e,n,o){super(t,e,n,o),this.Ne=-0,this.De=-0,this.Pe=-0,this.Oe=-0,this.DefaultSettings_={endingStart:Bt,endingEnd:Bt}}intervalChanged_(t,e,n){const o=this.parameterPositions;let i=t-2,r=t+1,s=o[i],a=o[r];if(void 0===s)switch(this.getSettings_().endingStart){case Lt:i=t,s=2*e-n;break;case Nt:i=o.length-2,s=e+o[i]-o[i+1];break;default:i=t,s=n}if(void 0===a)switch(this.getSettings_().endingEnd){case Lt:r=t,a=2*n-e;break;case Nt:r=1,a=n+o[1]-o[0];break;default:r=t-1,a=e}const l=.5*(n-e),c=this.valueSize;this.Ne=l/(e-s),this.Pe=l/(a-n),this.De=i*c,this.Oe=r*c}interpolate_(t,e,n,o){const i=this.resultBuffer,r=this.sampleValues,s=this.valueSize,a=t*s,l=a-s,c=this.De,u=this.Oe,h=this.Ne,f=this.Pe,d=(n-e)/(o-e),A=d*d,v=A*d,m=-h*v+2*h*A-h*d,p=(1+h)*v+(-1.5-2*h)*A+(-.5+h)*d+1,g=(-1-f)*v+(1.5+f)*A+.5*d,_=f*v-f*A;for(let t=0;t!==s;++t)i[t]=m*r[c+t]+p*r[l+t]+g*r[a+t]+_*r[u+t];return i}}function Of(t,e,n){return Uf(t)?new t.constructor(t.subarray(e,void 0!==n?n:t.length)):t.slice(e,n)}function Ff(t,e,n){return!t||!n&&t.constructor===e?t:"number"==typeof e.BYTES_PER_ELEMENT?new e(t):Array.prototype.slice.call(t)}function Uf(t){return ArrayBuffer.isView(t)&&!(t instanceof DataView)}function Vf(t){const e=t.length,n=new Array(e);for(let t=0;t!==e;++t)n[t]=t;return n.sort(function(e,n){return t[e]-t[n]}),n}function Gf(t,e,n){const o=t.length,i=new t.constructor(o);for(let r=0,s=0;s!==o;++r){const o=n[r]*e;for(let n=0;n!==e;++n)i[s++]=t[o+n]}return i}function Qf(t,e,n,o){let i=1,r=t[0];for(;void 0!==r&&void 0===r[o];)r=t[i++];if(void 0===r)return;let s=r[o];if(void 0!==s)if(Array.isArray(s))do{s=r[o],void 0!==s&&(e.push(r.time),n.push.apply(n,s)),r=t[i++]}while(void 0!==r);else if(void 0!==s.toArray)do{s=r[o],void 0!==s&&(e.push(r.time),s.toArray(n,n.length)),r=t[i++]}while(void 0!==r);else do{s=r[o],void 0!==s&&(e.push(r.time),n.push(s)),r=t[i++]}while(void 0!==r)}var zf=Object.freeze({__proto__:null,arraySlice:Of,convertArray:Ff,flattenJSON:Qf,getKeyframeOrder:Vf,isTypedArray:Uf,makeClipAdditive:function(t,e=0,n=t,o=30){o<=0&&(o=30);const i=n.tracks.length,r=e/o;for(let e=0;e<i;++e){const o=n.tracks[e],i=o.ValueTypeName;if("bool"===i||"string"===i)continue;const s=t.tracks.find(function(t){return t.name===o.name&&t.ValueTypeName===i});if(void 0===s)continue;let a=0;const l=o.getValueSize();o.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline&&(a=l/3);let c=0;const u=s.getValueSize();s.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline&&(c=u/3);const h=o.times.length-1;let f;if(r<=o.times[0]){const t=a,e=l-a;f=Of(o.values,t,e)}else if(r>=o.times[h]){const t=h*l+a,e=t+l-a;f=Of(o.values,t,e)}else{const t=o.createInterpolant(),e=a,n=l-a;t.evaluate(r),f=Of(t.resultBuffer,e,n)}if("quaternion"===i){(new dn).fromArray(f).normalize().conjugate().toArray(f)}const d=s.times.length;for(let t=0;t<d;++t){const e=t*u+c;if("quaternion"===i)dn.multiplyQuaternionsFlat(s.values,e,f,0,s.values,e);else{const t=u-2*c;for(let n=0;n<t;++n)s.values[e+n]-=f[n]}}}return t.blendMode=Pt,t},sortedArray:Gf,subclip:function(t,e,n,o,i=30){const r=t.clone();r.name=e;const s=[];r.tracks.forEach(t=>{if(0===t.times.length)return;const e=[Math.max(n/i,t.times[0]),Math.min(o/i,t.times[t.times.length-1])];if(e[0]>e[1])return;const r=t.times.findIndex(t=>t>=e[0]),a=t.times.findLastIndex(t=>t<=e[1]),l=t.getValueSize();let c=[],u=Uf(t.times)?t.times.subarray(r,a+1):t.times.slice(r,a+1),h=[],f=[],d=Uf(t.values)?t.values.subarray(r*l,(a+1)*l):t.values.slice(r*l,(a+1)*l),A=[];const v=r>a;let m,p;(v||e[0]<t.times[r])&&(c=[e[0]],f=t.createInterpolant().evaluate(c[0])),e[0]!==e[1]&&(v||e[1]>t.times[a])&&(h=[e[1]],A=t.createInterpolant().evaluate(h[0])),Uf(t.times)?(m=new t.times.constructor(c.length+u.length+h.length),m.set(c),m.set(u,c.length),m.set(h,c.length+u.length)):m=c.concat(u,h),Uf(t.values)?(p=new t.values.constructor(f.length+d.length+A.length),p.set(f),p.set(d,f.length),p.set(A,f.length+d.length)):p=f.concat(d,A),t.times=m,t.values=p,s.push(t)});const a=s.reduce((t,e)=>Math.min(t,e.times[0]),1/0);return s.forEach(t=>t.shift(-a)),r.tracks=s,r.resetDuration(),r}});class kf{constructor(t,e,n,o){if(void 0===t)throw new Error("v3d.KeyframeTrack: track name is undefined");if(void 0===e||0===e.length)throw new Error("v3d.KeyframeTrack: no keyframes in track named "+t);this.name=t,this.times=Ff(e,this.TimeBufferType),this.values=Ff(n,this.ValueBufferType),this.setInterpolation(o||this.DefaultInterpolation)}InterpolantFactoryMethodDiscrete(t){return new qc(this.times,this.values,this.getValueSize(),t)}InterpolantFactoryMethodLinear(t){return new cu(this.times,this.values,this.getValueSize(),t)}InterpolantFactoryMethodSmooth(t){return new Pf(this.times,this.values,this.getValueSize(),t)}setInterpolation(t){let e;switch(t){case yt:e=this.InterpolantFactoryMethodDiscrete;break;case Rt:e=this.InterpolantFactoryMethodLinear;break;case Tt:e=this.InterpolantFactoryMethodSmooth}if(void 0===e){const e="unsupported interpolation for "+this.ValueTypeName+" keyframe track named "+this.name;if(void 0===this.createInterpolant){if(t===this.DefaultInterpolation)throw new Error(e);this.setInterpolation(this.DefaultInterpolation)}return console.warn("v3d.KeyframeTrack:",e),this}return this.createInterpolant=e,this}getInterpolation(){switch(this.createInterpolant){case this.InterpolantFactoryMethodDiscrete:return yt;case this.InterpolantFactoryMethodLinear:return Rt;case this.InterpolantFactoryMethodSmooth:return Tt}}getValueSize(){return this.values.length/this.times.length}shift(t){if(0!==t){const e=this.times;for(let n=0,o=e.length;n!==o;++n)e[n]+=t}return this}scale(t){if(1!==t){const e=this.times;for(let n=0,o=e.length;n!==o;++n)e[n]*=t}return this}trim(t,e){const n=this.times,o=n.length;let i=0,r=o-1;for(;i!==o&&n[i]<t;)++i;for(;-1!==r&&n[r]>e;)--r;if(++r,0!==i||r!==o){i>=r&&(r=Math.max(r,1),i=r-1);const t=this.getValueSize();this.times=Of(n,i,r),this.values=Of(this.values,i*t,r*t)}return this}validate(){let t=!0;const e=this.getValueSize();e-Math.floor(e)!==0&&(console.error("v3d.KeyframeTrack: Invalid value size in track.",this),t=!1);const n=this.times,o=this.values,i=n.length;0===i&&(console.error("v3d.KeyframeTrack: Track is empty.",this),t=!1);let r=null;for(let e=0;e!==i;e++){const o=n[e];if("number"==typeof o&&isNaN(o)){console.error("v3d.KeyframeTrack: Time is not a valid number.",this,e,o),t=!1;break}if(null!==r&&r>o){console.error("v3d.KeyframeTrack: Out of order keys.",this,e,o,r),t=!1;break}r=o}if(void 0!==o&&Uf(o))for(let e=0,n=o.length;e!==n;++e){const n=o[e];if(isNaN(n)){console.error("v3d.KeyframeTrack: Value is not a valid number.",this,e,n),t=!1;break}}return t}optimize(){const t=Of(this.times),e=Of(this.values),n=this.getValueSize(),o=this.getInterpolation()===Tt,i=t.length-1;let r=1;for(let s=1;s<i;++s){let i=!1;const a=t[s];if(a!==t[s+1]&&(1!==s||a!==t[0]))if(o)i=!0;else{const t=s*n,o=t-n,r=t+n;for(let s=0;s!==n;++s){const n=e[t+s];if(n!==e[o+s]||n!==e[r+s]){i=!0;break}}}if(i){if(s!==r){t[r]=t[s];const o=s*n,i=r*n;for(let t=0;t!==n;++t)e[i+t]=e[o+t]}++r}}if(i>0){t[r]=t[i];for(let t=i*n,o=r*n,s=0;s!==n;++s)e[o+s]=e[t+s];++r}return r!==t.length?(this.times=Of(t,0,r),this.values=Of(e,0,r*n)):(this.times=t,this.values=e),this}clone(){const t=Of(this.times,0),e=Of(this.values,0),n=new(0,this.constructor)(this.name,t,e);return n.createInterpolant=this.createInterpolant,n}}kf.prototype.TimeBufferType=Float32Array,kf.prototype.ValueBufferType=Float32Array,kf.prototype.DefaultInterpolation=Rt;class Hf extends kf{}Hf.prototype.ValueTypeName="vector";class Wf extends kf{}Wf.prototype.ValueTypeName="string",Wf.prototype.ValueBufferType=Array,Wf.prototype.DefaultInterpolation=yt,Wf.prototype.InterpolantFactoryMethodLinear=void 0,Wf.prototype.InterpolantFactoryMethodSmooth=void 0;class Yf extends Zc{constructor(t,e,n,o){super(t,e,n,o)}interpolate_(t,e,n,o){const i=this.resultBuffer,r=this.sampleValues,s=this.valueSize,a=(n-e)/(o-e);let l=t*s;for(let t=l+s;l!==t;l+=4)dn.slerpFlat(i,0,r,l-s,r,l,a);return i}}class Xf extends kf{InterpolantFactoryMethodLinear(t){return new Yf(this.times,this.values,this.getValueSize(),t)}}Xf.prototype.ValueTypeName="quaternion",Xf.prototype.DefaultInterpolation=Rt,Xf.prototype.InterpolantFactoryMethodSmooth=void 0;class Kf extends kf{}Kf.prototype.ValueTypeName="number";class jf extends kf{}jf.prototype.ValueTypeName="color";class Zf extends kf{}Zf.prototype.ValueTypeName="bool",Zf.prototype.ValueBufferType=Array,Zf.prototype.DefaultInterpolation=yt,Zf.prototype.InterpolantFactoryMethodLinear=void 0,Zf.prototype.InterpolantFactoryMethodSmooth=void 0;class qf{constructor(t,e,n){let o,i,r;switch(this.binding=t,this.valueSize=n,e){case"quaternion":o=this.Fe,i=this.Ue,r=this.Ve,this.buffer=new Float64Array(6*n),this.Ge=5;break;case"string":case"bool":o=this.Qe,i=this.Qe,r=this.ze,this.buffer=new Array(5*n);break;default:o=this.ke,i=this.He,r=this.We,this.buffer=new Float64Array(5*n)}this.Ye=o,this.Xe=i,this.Ke=r,this.je=3,this.Ze=4,this.cumulativeWeight=0,this.cumulativeWeightAdditive=0,this.useCount=0,this.referenceCount=0}accumulate(t,e){const n=this.buffer,o=this.valueSize,i=t*o+o;let r=this.cumulativeWeight;if(0===r){for(let t=0;t!==o;++t)n[i+t]=n[t];r=e}else{r+=e;const t=e/r;this.Ye(n,i,0,t,o)}this.cumulativeWeight=r}accumulateAdditive(t){const e=this.buffer,n=this.valueSize,o=n*this.Ze;0===this.cumulativeWeightAdditive&&this.Ke(),this.Xe(e,o,0,t,n),this.cumulativeWeightAdditive+=t}apply(t){const e=this.valueSize,n=this.buffer,o=t*e+e,i=this.cumulativeWeight,r=this.cumulativeWeightAdditive,s=this.binding;if(this.cumulativeWeight=0,this.cumulativeWeightAdditive=0,i<1){const t=e*this.je;this.Ye(n,o,t,1-i,e)}r>0&&this.Xe(n,o,this.Ze*e,1,e);for(let t=e,i=e+e;t!==i;++t)if(n[t]!==n[t+e]){s.setValue(n,o);break}}saveOriginalState(){const t=this.binding,e=this.buffer,n=this.valueSize,o=n*this.je;t.getValue(e,o);for(let t=n,i=o;t!==i;++t)e[t]=e[o+t%n];this.Ke(),this.cumulativeWeight=0,this.cumulativeWeightAdditive=0}restoreOriginalState(){const t=3*this.valueSize;this.binding.setValue(this.buffer,t)}We(){const t=this.Ze*this.valueSize,e=t+this.valueSize;for(let n=t;n<e;n++)this.buffer[n]=0}Ve(){this.We(),this.buffer[this.Ze*this.valueSize+3]=1}ze(){const t=this.je*this.valueSize,e=this.Ze*this.valueSize;for(let n=0;n<this.valueSize;n++)this.buffer[e+n]=this.buffer[t+n]}Qe(t,e,n,o,i){if(o>=.5)for(let o=0;o!==i;++o)t[e+o]=t[n+o]}Fe(t,e,n,o){dn.slerpFlat(t,e,t,e,t,n,o)}Ue(t,e,n,o,i){const r=this.Ge*i;dn.multiplyQuaternionsFlat(t,r,t,e,t,n),dn.slerpFlat(t,e,t,e,t,r,o)}ke(t,e,n,o,i){const r=1-o;for(let s=0;s!==i;++s){const i=e+s;t[i]=t[i]*r+t[n+s]*o}}He(t,e,n,o,i){for(let r=0;r!==i;++r){const i=e+r;t[i]=t[i]+t[n+r]*o}}}const Jf="\\[\\]\\.",$f=new RegExp("["+Jf+"]","g"),td="[^"+Jf+"]",ed="[^"+Jf.replace("\\.","")+"]";/((?:WC+[\/:])*)/.source.replace("WC",td);const nd=/(WCOD+)?/.source.replace("WCOD",ed),od=/(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC",td),id=/\.(WC+)(?:\[(.+)\])?/.source.replace("WC",td),rd=new RegExp("^"+nd+od+id+"$"),sd=["material","materials","bones","map"];class ad{constructor(t,e,n){this.path=e,this.parsedPath=n||ad.parseTrackName(e),this.node=ad.findNode(t,this.parsedPath.nodeName)||t,this.rootNode=t,this.getValue=this.qe,this.setValue=this.Je}static create(t,e,n){return t&&t.isAnimationObjectGroup?new ad.Composite(t,e,n):new ad(t,e,n)}static sanitizeNodeName(t){return t.replace(/\s/g,"_").replace($f,"")}static parseTrackName(t){const e=rd.exec(t);if(null===e)throw new Error("PropertyBinding: Cannot parse trackName: "+t);const n={nodeName:e[1],objectName:e[2],objectIndex:e[3],propertyName:e[4],propertyIndex:e[5]},o=n.nodeName&&n.nodeName.lastIndexOf(".");if(void 0!==o&&-1!==o){const t=n.nodeName.substring(o+1);-1!==sd.indexOf(t)&&(n.nodeName=n.nodeName.substring(0,o),n.objectName=t)}if(null===n.propertyName||0===n.propertyName.length)throw new Error("PropertyBinding: can not parse propertyName from trackName: "+t);return n}static findNode(t,e){if(void 0===e||""===e||"."===e||-1===e||e===t.name||e===t.uuid)return t;if(t.skeleton){const n=t.skeleton.getBoneByName(e);if(void 0!==n)return n}if(t.children){const n=function(t){for(let o=0;o<t.length;o++){const i=t[o];if(i.name===e||i.uuid===e)return i;const r=n(i.children);if(r)return r}return null},o=n(t.children);if(o)return o}return null}$e(){}tn(){}en(t,e){t[e]=this.targetObject[this.propertyName]}nn(t,e){const n=this.resolvedProperty;for(let o=0,i=n.length;o!==i;++o)t[e++]=n[o]}rn(t,e){t[e]=this.resolvedProperty[this.propertyIndex]}sn(t,e){this.resolvedProperty.toArray(t,e)}an(t,e){this.targetObject[this.propertyName]=t[e]}ln(t,e){this.targetObject[this.propertyName]=t[e],this.targetObject.needsUpdate=!0}cn(t,e){this.targetObject[this.propertyName]=t[e],this.targetObject.matrixWorldNeedsUpdate=!0}un(t,e){const n=this.resolvedProperty;for(let o=0,i=n.length;o!==i;++o)n[o]=t[e++]}hn(t,e){const n=this.resolvedProperty;for(let o=0,i=n.length;o!==i;++o)n[o]=t[e++];this.targetObject.needsUpdate=!0}fn(t,e){const n=this.resolvedProperty;for(let o=0,i=n.length;o!==i;++o)n[o]=t[e++];if(this.targetObject.matrixWorldNeedsUpdate=!0,"morphTargetInfluences"===this.propertyName){const t=this.targetObject.getAuxClippingMeshes();for(let e=0;e<t.length;e++){const n=t[e];if(n.morphTargetInfluences){const t=this.targetObject.morphTargetInfluences;for(let e=0;e<t.length;e++){const o=t[e];n.morphTargetInfluences[e]=o}}}}}dn(t,e){this.resolvedProperty[this.propertyIndex]=t[e]}An(t,e){this.resolvedProperty[this.propertyIndex]=t[e],this.targetObject.needsUpdate=!0}vn(t,e){this.resolvedProperty[this.propertyIndex]=t[e],this.targetObject.matrixWorldNeedsUpdate=!0}mn(t,e){this.resolvedProperty.fromArray(t,e)}pn(t,e){this.resolvedProperty.fromArray(t,e),this.targetObject.needsUpdate=!0}gn(t,e){this.resolvedProperty.fromArray(t,e),this.targetObject.matrixWorldNeedsUpdate=!0}qe(t,e){this.bind(),this.getValue(t,e)}Je(t,e){this.bind(),this.setValue(t,e)}bind(){let t=this.node;const e=this.parsedPath,n=e.objectName,o=e.propertyName;let i=e.propertyIndex;if(t||(t=ad.findNode(this.rootNode,e.nodeName)||this.rootNode,this.node=t),this.getValue=this.$e,this.setValue=this.tn,!t)return void console.error("v3d.PropertyBinding: Trying to update node for track: "+this.path+" but it wasn't found.");if(n){let o=e.objectIndex;switch(n){case"materials":if(!t.material)return void console.error("v3d.PropertyBinding: Can not bind to material as node does not have a material.",this);if(!t.material.materials)return void console.error("v3d.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.",this);t=t.material.materials;break;case"bones":if(!t.skeleton)return void console.error("v3d.PropertyBinding: Can not bind to bones as node does not have a skeleton.",this);t=t.skeleton.bones;for(let e=0;e<t.length;e++)if(t[e].name===o){o=e;break}break;case"map":if("map"in t){t=t.map;break}if(!t.material)return void console.error("v3d.PropertyBinding: Can not bind to material as node does not have a material.",this);if(!t.material.map)return void console.error("v3d.PropertyBinding: Can not bind to material.map as node.material does not have a map.",this);t=t.material.map;break;case"constraints":if(void 0===t.constraints)return void console.error("v3d.PropertyBinding: Can not bind to constraints of node undefined.",this);t=t.constraints,o=o.replace(/"/g,"");for(let e=0;e<t.length;e++)if(t[e].name===o){o=e;break}break;default:if(void 0===t[n])return void console.error("v3d.PropertyBinding: Can not bind to objectName of node undefined.",this);t=t[n]}if(void 0!==o){if(void 0===t[o])return void console.error("v3d.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.",this,t);t=t[o]}}let r=t[o];if(void 0===r){const n=e.nodeName;return void console.error("v3d.PropertyBinding: Trying to update property for track: "+n+"."+o+" but it wasn't found.",t)}let s=this.Versioning.None;this.targetObject=t,t.isMeshNodeMaterial||void 0===t.needsUpdate?void 0!==t.matrixWorldNeedsUpdate&&(s=this.Versioning.MatrixWorldNeedsUpdate):s=this.Versioning.NeedsUpdate;let a=this.BindingType.Direct;if(void 0!==i){if("morphTargetInfluences"===o){if(!t.geometry)return void console.error("v3d.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.",this);if(!t.geometry.morphAttributes)return void console.error("v3d.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.",this);void 0!==t.morphTargetDictionary[i]&&(i=t.morphTargetDictionary[i]),this.propertyName=o}else if("nodeValue"==o){if(i=i.replace(/"/g,""),!t.nodeValueMap)return void console.error("v3d.PropertyBinding: Trying to animate nodes in non-node material",this);if(i=t.nodeValueMap[i],void 0===i)return void console.error("v3d.PropertyBinding: Animated node not found ",this)}if(a=this.BindingType.ArrayElement,"nodeRGB"==o){if(i=i.replace(/"/g,""),!t.nodeRGBMap)return void console.error("v3d.PropertyBinding: Trying to animate nodes in non-node material",this);if(i=t.nodeRGBMap[i],void 0===i)return void console.error("v3d.PropertyBinding: Animated node not found ",this);a=this.BindingType.HasFromToArray,r=t.nodeRGB[i]}this.resolvedProperty=r,this.propertyIndex=i}else void 0!==r.fromArray&&void 0!==r.toArray?(a=this.BindingType.HasFromToArray,this.resolvedProperty=r):Array.isArray(r)?(a=this.BindingType.EntireArray,this.resolvedProperty=r,"morphTargetInfluences"===o&&(this.propertyName=o)):this.propertyName=o;this.getValue=this.GetterByBindingType[a],this.setValue=this.SetterByBindingTypeAndVersioning[a][s]}unbind(){this.node=null,this.getValue=this.qe,this.setValue=this.Je}}ad.Composite=class{constructor(t,e,n){const o=n||ad.parseTrackName(e);this._n=t,this.En=t.subscribe_(e,o)}getValue(t,e){this.bind();const n=this._n.nCachedObjects_,o=this.En[n];void 0!==o&&o.getValue(t,e)}setValue(t,e){const n=this.En;for(let o=this._n.nCachedObjects_,i=n.length;o!==i;++o)n[o].setValue(t,e)}bind(){const t=this.En;for(let e=this._n.nCachedObjects_,n=t.length;e!==n;++e)t[e].bind()}unbind(){const t=this.En;for(let e=this._n.nCachedObjects_,n=t.length;e!==n;++e)t[e].unbind()}},ad.prototype.BindingType={Direct:0,EntireArray:1,ArrayElement:2,HasFromToArray:3},ad.prototype.Versioning={None:0,NeedsUpdate:1,MatrixWorldNeedsUpdate:2},ad.prototype.GetterByBindingType=[ad.prototype.en,ad.prototype.nn,ad.prototype.rn,ad.prototype.sn],ad.prototype.SetterByBindingTypeAndVersioning=[[ad.prototype.an,ad.prototype.ln,ad.prototype.cn],[ad.prototype.un,ad.prototype.hn,ad.prototype.fn],[ad.prototype.dn,ad.prototype.An,ad.prototype.vn],[ad.prototype.mn,ad.prototype.pn,ad.prototype.gn]];class ld{constructor(t,e,n=null,o=e.blendMode){this.Cn=t,this.wn=e,this.xn=n,this.blendMode=o;const i=e.tracks,r=i.length,s=new Array(r),a={endingStart:Bt,endingEnd:Bt};for(let t=0;t!==r;++t){const e=i[t].createInterpolant(null);s[t]=e,e.settings=a}this.In=a,this.Mn=s,this.Sn=new Array(r),this.bn=null,this.yn=null,this.Rn=null,this.Tn=null,this.loop=St,this.Bn=-1,this.Ln=!0,this.Nn=null,this.time=0,this.timeStart=0,this.timeScale=1,this.Dn=1,this.weight=1,this.Pn=1,this.repetitions=1/0,this.paused=!1,this.enabled=!0,this.clampWhenFinished=!0,this.zeroSlopeAtStart=!0,this.zeroSlopeAtEnd=!0,this.autoParams={loop:St,repetitions:1/0}}play(){return this.Cn.On(this),this}stop(){return this.Cn.Fn(this),this.reset()}reset(){return this.paused=!1,this.enabled=!0,this.time=0,this.Bn=-1,this.Nn=null,this.Ln=!0,this.stopFading().stopWarping()}isRunning(){return this.enabled&&!this.paused&&0!==this.timeScale&&null===this.Nn&&this.Cn.Un(this)}isScheduled(){return this.Cn.Un(this)}startAt(t){return this.Nn=t,this}setLoop(t,e,n=!1){return this.loop=t,this.repetitions=e,n&&(this.autoParams.loop=t,this.autoParams.repetitions=e),this}setEffectiveWeight(t){return this.weight=t,this.Pn=this.enabled?t:0,this.stopFading()}getEffectiveWeight(){return this.Pn}fadeIn(t){return this.Vn(t,0,1)}fadeOut(t){return this.Vn(t,1,0)}crossFadeFrom(t,e,n){if(t.fadeOut(e),this.fadeIn(e),n){const n=this.wn.duration,o=t.wn.duration,i=o/n,r=n/o;t.warp(1,i,e),this.warp(r,1,e)}return this}crossFadeTo(t,e,n){return t.crossFadeFrom(this,e,n)}stopFading(){const t=this.Tn;return null!==t&&(this.Tn=null,this.Cn.Gn(t)),this}setEffectiveTimeScale(t){return this.timeScale=t,this.Dn=this.paused?0:t,this.stopWarping()}getEffectiveTimeScale(){return this.Dn}setDuration(t){return this.timeScale=this.wn.duration/t,this.stopWarping()}syncWith(t){return this.time=t.time,this.timeScale=t.timeScale,this.stopWarping()}halt(t){return this.warp(this.Dn,0,t)}warp(t,e,n){const o=this.Cn,i=o.time,r=this.timeScale;let s=this.Rn;null===s&&(s=o.Qn(),this.Rn=s);const a=s.parameterPositions,l=s.sampleValues;return a[0]=i,a[1]=i+n,l[0]=t/r,l[1]=e/r,this}stopWarping(){const t=this.Rn;return null!==t&&(this.Rn=null,this.Cn.Gn(t)),this}getMixer(){return this.Cn}getClip(){return this.wn}getRoot(){return this.xn||this.Cn.zn}kn(t,e,n,o){if(!this.enabled)return void this.Hn(t);const i=this.Nn;if(null!==i){const o=(t-i)*n;if(o<0||0===n)return;this.Nn=null,e=n*o}e*=this.Wn(t);const r=this.Yn(e),s=this.Hn(t);if(s>0){const t=this.Mn,e=this.Sn;if(this.blendMode===Pt)for(let n=0,o=t.length;n!==o;++n)t[n].evaluate(r),e[n].accumulateAdditive(s);else for(let n=0,i=t.length;n!==i;++n)t[n].evaluate(r),e[n].accumulate(o,s)}}Hn(t){let e=0;if(this.enabled){e=this.weight;const n=this.Tn;if(null!==n){const o=n.evaluate(t)[0];e*=o,t>n.parameterPositions[1]&&(this.stopFading(),0===o&&(this.enabled=!1))}}return this.Pn=e,e}Wn(t){let e=0;if(!this.paused){e=this.timeScale;const n=this.Rn;if(null!==n){e*=n.evaluate(t)[0],t>n.parameterPositions[1]&&(this.stopWarping(),0===e?this.paused=!0:this.timeScale=e)}}return this.Dn=e,e}Xn(t){if(this.loop!==bt)return!0;if(-1==t)return!0;return!(1&t)===this.Ln}Yn(t){if(0===t)return this.time;if(this.loop!==Mt&&this.repetitions<=0)return this.clampWhenFinished?this.paused=!0:this.enabled=!1,this.Cn.dispatchEvent({type:"finished",action:this,direction:t<0?-1:1}),this.time;var e=this.timeStart,n=Math.max(e,this.wn.duration),o=n-e;if(this.loop===Mt)return this.time+=t,-1===this.Bn&&(this.Bn=0,this.Kn(!0,!0,!1)),(this.time<e||this.time>n)&&(this.clampWhenFinished?this.paused=!0:this.enabled=!1,this.time=ie(this.time,e,n),this.Cn.dispatchEvent({type:"finished",action:this,direction:t<0?-1:1})),this.time;var i=this.loop===bt,r=this.Xn(this.Bn)?1:-1;this.time+=r*t;var s=this.time<e||this.time>n,a=!1;if(-1===this.Bn&&(a=s,this.Bn=a?-1:0,this.Ln=!a,t>=0?this.Kn(!0,0===this.repetitions,i):this.Kn(0===this.repetitions,!0,i)),s){var l=Math.floor((this.time-e)/o);this.Bn+=Math.abs(l);var c=this.repetitions-this.Bn;if(c<=0)this.clampWhenFinished?this.paused=!0:this.enabled=!1,this.time=ie(this.time,e,n),this.Cn.dispatchEvent({type:"finished",action:this,direction:t<0?-1:1});else{if(1==c){var u=t<0;this.Kn(u,!u,i)}else this.Kn(!1,!1,i);var h=(this.time-e)%o;h<0&&(h+=o),this.time=i?n-h:h+e,a||this.Cn.dispatchEvent({type:"loop",action:this,loopDelta:l})}}return this.time}Kn(t,e,n){const o=this.In;n?(o.endingStart=Lt,o.endingEnd=Lt):(o.endingStart=t?this.zeroSlopeAtStart?Lt:Bt:Nt,o.endingEnd=e?this.zeroSlopeAtEnd?Lt:Bt:Nt)}Vn(t,e,n){const o=this.Cn,i=o.time;let r=this.Tn;null===r&&(r=o.Qn(),this.Tn=r);const s=r.parameterPositions,a=r.sampleValues;return s[0]=i,a[0]=e,s[1]=i+t,a[1]=n,this}}class cd{constructor(t,e=-1,n,o=2500){this.name=t,this.tracks=n,this.duration=e,this.blendMode=o,this.uuid=ne(),this.objectUUID="",this.duration<0&&this.resetDuration()}static parse(t){const e=[],n=t.tracks,o=1/(t.fps||1);for(let t=0,i=n.length;t!==i;++t)e.push(ud(n[t]).scale(o));const i=new this(t.name,t.duration,e,t.blendMode);return i.uuid=t.uuid,i}static CreateFromMorphTargetSequence(t,e,n,o){const i=e.length,r=[];for(let t=0;t<i;t++){let s=[],a=[];s.push((t+i-1)%i,t,(t+1)%i),a.push(0,1,0);const l=Vf(s);s=Gf(s,1,l),a=Gf(a,1,l),o||0!==s[0]||(s.push(i),a.push(a[0])),r.push(new Kf(".morphTargetInfluences["+e[t].name+"]",s,a).scale(1/n))}return new this(t,-1,r)}static findByName(t,e){let n=t;if(!Array.isArray(t)){const e=t;n=e.geometry&&e.geometry.animations||e.animations}for(let t=0;t<n.length;t++)if(n[t].name===e)return n[t];return null}static CreateClipsFromMorphTargetSequences(t,e,n){const o={},i=/^([\w-]*?)([\d]+)$/;for(let e=0,n=t.length;e<n;e++){const n=t[e],r=n.name.match(i);if(r&&r.length>1){const t=r[1];let e=o[t];e||(o[t]=e=[]),e.push(n)}}const r=[];for(const t in o)r.push(this.CreateFromMorphTargetSequence(t,o[t],e,n));return r}resetDuration(){let t=0;for(let e=0,n=this.tracks.length;e!==n;++e){const n=this.tracks[e];t=Math.max(t,n.times[n.times.length-1])}return this.duration=t,this}trim(){for(let t=0;t<this.tracks.length;t++)this.tracks[t].trim(0,this.duration);return this}validate(){let t=!0;for(let e=0;e<this.tracks.length;e++)t=t&&this.tracks[e].validate();return t}optimize(){for(let t=0;t<this.tracks.length;t++)this.tracks[t].optimize();return this}clone(){const t=[];for(let e=0;e<this.tracks.length;e++)t.push(this.tracks[e].clone());return new this.constructor(this.name,this.duration,t,this.blendMode)}}function ud(t){if(void 0===t.type)throw new Error("v3d.KeyframeTrack: track type undefined, can not parse");const e=function(t){switch(t.toLowerCase()){case"scalar":case"double":case"float":case"number":case"integer":return Kf;case"vector":case"vector2":case"vector3":case"vector4":return Hf;case"color":return jf;case"quaternion":return Xf;case"bool":case"boolean":return Zf;case"string":return Wf}throw new Error("v3d.KeyframeTrack: Unsupported typeName: "+t)}(t.type);if(void 0===t.times){const e=[],n=[];Qf(t.keys,e,n,"value"),t.times=e,t.values=n}return void 0!==e.parse?e.parse(t):new e(t.name,t.times,t.values,t.interpolation)}const hd=new Float32Array(1);class fd extends Zt{constructor(t){super(),this.zn=t,this.jn(),this.Zn=0,this.time=0,this.timeScale=1}qn(t,e){const n=t.xn||this.zn,o=t.wn.tracks,i=o.length,r=t.Sn,s=t.Mn,a=n.uuid,l=this.Jn;let c=l[a];void 0===c&&(c={},l[a]=c);for(let t=0;t!==i;++t){const i=o[t],l=i.name;let u=c[l];if(void 0!==u)++u.referenceCount,r[t]=u;else{if(u=r[t],void 0!==u){null===u.bn&&(++u.referenceCount,this.$n(u,a,l));continue}const o=e&&e.Sn[t].binding.parsedPath;u=new qf(ad.create(n,l,o),i.ValueTypeName,i.getValueSize()),++u.referenceCount,this.$n(u,a,l),r[t]=u}s[t].resultBuffer=u.buffer}}On(t){if(!this.Un(t)){if(null===t.bn){const e=(t.xn||this.zn).uuid,n=t.wn.uuid,o=this.eo[n];this.qn(t,o&&o.knownActions[0]),this.no(t,n,e)}const e=t.Sn;for(let t=0,n=e.length;t!==n;++t){const n=e[t];0===n.useCount++&&(this.oo(n),n.saveOriginalState())}this.io(t)}}Fn(t){if(this.Un(t)){const e=t.Sn;for(let t=0,n=e.length;t!==n;++t){const n=e[t];0===--n.useCount&&(n.restoreOriginalState(),this.ro(n))}this.so(t)}}jn(){this.ao=[],this.lo=0,this.eo={},this.En=[],this.co=0,this.Jn={},this.uo=[],this.ho=0;const t=this;this.stats={actions:{get total(){return t.ao.length},get inUse(){return t.lo}},bindings:{get total(){return t.En.length},get inUse(){return t.co}},controlInterpolants:{get total(){return t.uo.length},get inUse(){return t.ho}}}}Un(t){const e=t.bn;return null!==e&&e<this.lo}no(t,e,n){const o=this.ao,i=this.eo;let r=i[e];if(void 0===r)r={knownActions:[t],actionByRoot:{}},t.yn=0,i[e]=r;else{const e=r.knownActions;t.yn=e.length,e.push(t)}t.bn=o.length,o.push(t),r.actionByRoot[n]=t}fo(t){const e=this.ao,n=e[e.length-1],o=t.bn;n.bn=o,e[o]=n,e.pop(),t.bn=null;const i=t.wn.uuid,r=this.eo,s=r[i],a=s.knownActions,l=a[a.length-1],c=t.yn;l.yn=c,a[c]=l,a.pop(),t.yn=null;delete s.actionByRoot[(t.xn||this.zn).uuid],0===a.length&&delete r[i],this.do(t)}do(t){const e=t.Sn;for(let t=0,n=e.length;t!==n;++t){const n=e[t];0===--n.referenceCount&&this.Ao(n)}}io(t){const e=this.ao,n=t.bn,o=this.lo++,i=e[o];t.bn=o,e[o]=t,i.bn=n,e[n]=i}so(t){const e=this.ao,n=t.bn,o=--this.lo,i=e[o];t.bn=o,e[o]=t,i.bn=n,e[n]=i}$n(t,e,n){const o=this.Jn,i=this.En;let r=o[e];void 0===r&&(r={},o[e]=r),r[n]=t,t.bn=i.length,i.push(t)}Ao(t){const e=this.En,n=t.binding,o=n.rootNode.uuid,i=n.path,r=this.Jn,s=r[o],a=e[e.length-1],l=t.bn;a.bn=l,e[l]=a,e.pop(),delete s[i],0===Object.keys(s).length&&delete r[o]}oo(t){const e=this.En,n=t.bn,o=this.co++,i=e[o];t.bn=o,e[o]=t,i.bn=n,e[n]=i}ro(t){const e=this.En,n=t.bn,o=--this.co,i=e[o];t.bn=o,e[o]=t,i.bn=n,e[n]=i}Qn(){const t=this.uo,e=this.ho++;let n=t[e];return void 0===n&&(n=new cu(new Float32Array(2),new Float32Array(2),1,hd),n.vo=e,t[e]=n),n}Gn(t){const e=this.uo,n=t.vo,o=--this.ho,i=e[o];t.vo=o,e[o]=t,i.vo=n,e[n]=i}clipAction(t,e,n){const o=e||this.zn,i=o.uuid;let r="string"==typeof t?cd.findByName(o,t):t;const s=null!==r?r.uuid:t,a=this.eo[s];let l=null;if(void 0===n&&(n=null!==r?r.blendMode:Dt),void 0!==a){const t=a.actionByRoot[i];if(void 0!==t&&t.blendMode===n)return t;l=a.knownActions[0],null===r&&(r=l.wn)}if(null===r)return null;const c=new ld(this,r,e,n);return this.qn(c,l),this.no(c,s,i),c}existingAction(t,e){const n=e||this.zn,o=n.uuid,i="string"==typeof t?cd.findByName(n,t):t,r=i?i.uuid:t,s=this.eo[r];return void 0!==s&&s.actionByRoot[o]||null}stopAllAction(){const t=this.ao;for(let e=this.lo-1;e>=0;--e)t[e].stop();return this}update(t){t*=this.timeScale;const e=this.ao,n=this.lo,o=this.time+=t,i=Math.sign(t),r=this.Zn^=1;for(let s=0;s!==n;++s){e[s].kn(o,t,i,r)}const s=this.En,a=this.co;for(let t=0;t!==a;++t)s[t].apply(r);return this}setTime(t){this.time=0;for(let t=0;t<this.ao.length;t++)this.ao[t].time=0;return this.update(t)}getRoot(){return this.zn}uncacheClip(t){const e=this.ao,n=t.uuid,o=this.eo,i=o[n];if(void 0!==i){const t=i.knownActions;for(let n=0,o=t.length;n!==o;++n){const o=t[n];this.Fn(o);const i=o.bn,r=e[e.length-1];o.bn=null,o.yn=null,r.bn=i,e[i]=r,e.pop(),this.do(o)}delete o[n]}}uncacheRoot(t){const e=t.uuid,n=this.eo;for(const t in n){const o=n[t].actionByRoot[e];void 0!==o&&(this.Fn(o),this.fo(o))}const o=this.Jn[e];if(void 0!==o)for(const t in o){const e=o[t];e.restoreOriginalState(),this.Ao(e)}}uncacheAction(t,e){const n=this.existingAction(t,e);null!==n&&(this.Fn(n),this.fo(n))}}class dd{constructor(t){this.value=t}clone(){return new dd(void 0===this.value.clone?this.value:this.value.clone())}}let Ad=0;const vd=new we;const md=new An,pd=new An;class gd{constructor(t=new An,e=new An){this.start=t,this.end=e}set(t,e){return this.start.copy(t),this.end.copy(e),this}copy(t){return this.start.copy(t.start),this.end.copy(t.end),this}getCenter(t){return t.addVectors(this.start,this.end).multiplyScalar(.5)}delta(t){return t.subVectors(this.end,this.start)}distanceSq(){return this.start.distanceToSquared(this.end)}distance(){return this.start.distanceTo(this.end)}at(t,e){return this.delta(e).multiplyScalar(t).add(this.start)}closestPointToPointParameter(t,e){md.subVectors(t,this.start),pd.subVectors(this.end,this.start);const n=pd.dot(pd);let o=pd.dot(md)/n;return e&&(o=ie(o,0,1)),o}closestPointToPoint(t,e,n){const o=this.closestPointToPointParameter(t,e);return this.delta(n).multiplyScalar(o).add(this.start)}applyMatrix4(t){return this.start.applyMatrix4(t),this.end.applyMatrix4(t),this}equals(t){return t.start.equals(this.start)&&t.end.equals(this.end)}clone(){return(new this.constructor).copy(this)}}const _d=new An;class Ed extends mo{constructor(t,e){super(),this.light=t,this.matrixAutoUpdate=!1,this.color=e,this.type="SpotLightHelper";const n=new Xo,o=[0,0,0,0,0,1,0,0,0,1,0,1,0,0,0,-1,0,1,0,0,0,0,1,1,0,0,0,0,-1,1];for(let t=0,e=1,n=32;t<n;t++,e++){const i=t/n*Math.PI*2,r=e/n*Math.PI*2;o.push(Math.cos(i),Math.sin(i),1,Math.cos(r),Math.sin(r),1)}n.setAttribute("position",new Vo(o,3));const i=new El({fog:!1,toneMapped:!1});this.cone=new Rl(n,i),this.add(this.cone),this.update()}dispose(){this.cone.geometry.dispose(),this.cone.material.dispose()}update(){this.light.updateWorldMatrix(!0,!1),this.light.target.updateWorldMatrix(!0,!1),this.parent?(this.parent.updateWorldMatrix(!0),this.matrix.copy(this.parent.matrixWorld).invert().multiply(this.light.matrixWorld)):this.matrix.copy(this.light.matrixWorld),this.matrixWorld.copy(this.light.matrixWorld);const t=this.light.distance?this.light.distance:1e3,e=t*Math.tan(this.light.angle);this.cone.scale.set(e,e,t),_d.setFromMatrixPosition(this.light.target.matrixWorld),this.cone.lookAt(_d),void 0!==this.color?this.cone.material.color.set(this.color):this.cone.material.color.copy(this.light.color)}}const Cd=new An,wd=new Hn,xd=new Hn;class Id extends Rl{constructor(t){const e=Md(t),n=new Xo,o=[],i=[],r=new tn(0,0,1),s=new tn(0,1,0);for(let t=0;t<e.length;t++){const n=e[t];n.parent&&n.parent.isBone&&(o.push(0,0,0),o.push(0,0,0),i.push(r.r,r.g,r.b),i.push(s.r,s.g,s.b))}n.setAttribute("position",new Vo(o,3)),n.setAttribute("color",new Vo(i,3));super(n,new El({vertexColors:!0,depthTest:!1,depthWrite:!1,toneMapped:!1,transparent:!0})),this.isSkeletonHelper=!0,this.type="SkeletonHelper",this.root=t,this.bones=e,this.matrixAutoUpdate=!1}updateMatrixWorld(t){this.parent?this.matrix.copy(this.parent.matrixWorld).invert().multiply(this.root.matrixWorld):this.matrix.copy(this.root.matrixWorld);const e=this.bones,n=this.geometry,o=n.getAttribute("position");xd.copy(this.root.matrixWorld).invert();for(let t=0,n=0;t<e.length;t++){const i=e[t];i.parent&&i.parent.isBone&&(wd.multiplyMatrices(xd,i.matrixWorld),Cd.setFromMatrixPosition(wd),o.setXYZ(n,Cd.x,Cd.y,Cd.z),wd.multiplyMatrices(xd,i.parent.matrixWorld),Cd.setFromMatrixPosition(wd),o.setXYZ(n+1,Cd.x,Cd.y,Cd.z),n+=2)}n.getAttribute("position").needsUpdate=!0,super.updateMatrixWorld(t)}dispose(){this.geometry.dispose(),this.material.dispose()}}function Md(t){const e=[];!0===t.isBone&&e.push(t);for(let n=0;n<t.children.length;n++)e.push.apply(e,Md(t.children[n]));return e}class Sd extends hi{constructor(t,e,n){super(new Qc(e,4,3),new No({wireframe:!0,fog:!1,toneMapped:!1})),this.light=t,this.color=n,this.type="PointLightHelper",this.matrixAutoUpdate=!1,this.update()}dispose(){this.geometry.dispose(),this.material.dispose()}update(){this.light.updateWorldMatrix(!0,!1),this.parent?(this.parent.updateWorldMatrix(!0),this.matrix.copy(this.parent.matrixWorld).invert().multiply(this.light.matrixWorld)):this.matrix.copy(this.light.matrixWorld),void 0!==this.color?this.material.color.set(this.color):this.material.color.copy(this.light.color)}}class bd extends Rl{constructor(t,e=16776960){const n=new Uint16Array([0,1,1,2,2,3,3,0,4,5,5,6,6,7,7,4,0,4,1,5,2,6,3,7]),o=new Xo;o.setIndex(new Oo(n,1)),o.setAttribute("position",new Vo([1,1,1,-1,1,1,-1,-1,1,1,-1,1,1,1,-1,-1,1,-1,-1,-1,-1,1,-1,-1],3)),super(o,new El({color:e,toneMapped:!1})),this.box=t,this.type="Box3Helper",this.geometry.computeBoundingSphere()}updateMatrixWorld(t){const e=this.box;e.isEmpty()||(e.getCenter(this.position),e.getSize(this.scale),this.scale.multiplyScalar(.5),super.updateMatrixWorld(t))}dispose(){this.geometry.dispose(),this.material.dispose()}}const yd=new An,Rd=new An,Td=new An;class Bd extends mo{constructor(t,e,n){super(),this.light=t,this.matrixAutoUpdate=!1,this.color=n,this.type="DirectionalLightHelper",void 0===e&&(e=1);let o=new Xo;o.setAttribute("position",new Vo([-e,e,0,e,e,0,e,-e,0,-e,-e,0,-e,e,0],3));const i=new El({fog:!1,toneMapped:!1});this.lightPlane=new Sl(o,i),this.add(this.lightPlane),o=new Xo,o.setAttribute("position",new Vo([0,0,0,0,0,1],3)),this.targetLine=new Sl(o,i),this.add(this.targetLine),this.update()}dispose(){this.lightPlane.geometry.dispose(),this.lightPlane.material.dispose(),this.targetLine.geometry.dispose(),this.targetLine.material.dispose()}update(){this.light.updateWorldMatrix(!0,!1),this.light.target.updateWorldMatrix(!0,!1),this.parent?(this.parent.updateWorldMatrix(!0),this.matrix.copy(this.parent.matrixWorld).invert().multiply(this.light.matrixWorld)):this.matrix.copy(this.light.matrixWorld),yd.setFromMatrixPosition(this.light.matrixWorld),Rd.setFromMatrixPosition(this.light.target.matrixWorld),Td.subVectors(Rd,yd),this.lightPlane.lookAt(Rd),void 0!==this.color?(this.lightPlane.material.color.set(this.color),this.targetLine.material.color.set(this.color)):(this.lightPlane.material.color.copy(this.light.color),this.targetLine.material.color.copy(this.light.color)),this.targetLine.lookAt(Rd),this.targetLine.scale.z=Td.length()}}const Ld=new An,Nd=new _i;function Dd(t,e,n,o,i,r,s){Ld.set(i,r,s).unproject(o);const a=e[t];if(void 0!==a){const t=n.getAttribute("position");for(let e=0,n=a.length;e<n;e++)t.setXYZ(a[e],Ld.x,Ld.y,Ld.z)}}const Pd=new pn;const Od=new An;let Fd,Ud;class Vd{constructor(){this.type="ShapePath",this.color=new tn,this.subPaths=[],this.currentPath=null}moveTo(t,e){return this.currentPath=new nc,this.subPaths.push(this.currentPath),this.currentPath.moveTo(t,e),this}lineTo(t,e){return this.currentPath.lineTo(t,e),this}quadraticCurveTo(t,e,n,o){return this.currentPath.quadraticCurveTo(t,e,n,o),this}bezierCurveTo(t,e,n,o,i,r){return this.currentPath.bezierCurveTo(t,e,n,o,i,r),this}splineThru(t){return this.currentPath.splineThru(t),this}toShapes(t){function e(t,e){const n=e.length;let o=!1;for(let i=n-1,r=0;r<n;i=r++){let n=e[i],s=e[r],a=s.x-n.x,l=s.y-n.y;if(Math.abs(l)>Number.EPSILON){if(l<0&&(n=e[r],a=-a,s=e[i],l=-l),t.y<n.y||t.y>s.y)continue;if(t.y===n.y){if(t.x===n.x)return!0}else{const e=l*(t.x-n.x)-a*(t.y-n.y);if(0===e)return!0;if(e<0)continue;o=!o}}else{if(t.y!==n.y)continue;if(s.x<=t.x&&t.x<=n.x||n.x<=t.x&&t.x<=s.x)return!0}}return o}const n=Pc.isClockWise,o=this.subPaths;if(0===o.length)return[];let i,r,s;const a=[];if(1===o.length)return r=o[0],s=new cc,s.curves=r.curves,a.push(s),a;let l=!n(o[0].getPoints());l=t?!l:l;const c=[],u=[];let h,f,d=[],A=0;u[A]=void 0,d[A]=[];for(let e=0,s=o.length;e<s;e++)r=o[e],h=r.getPoints(),i=n(h),i=t?!i:i,i?(!l&&u[A]&&A++,u[A]={s:new cc,p:h},u[A].s.curves=r.curves,l&&A++,d[A]=[]):d[A].push({h:r,p:h[0]});if(!u[0])return function(t){const e=[];for(let n=0,o=t.length;n<o;n++){const o=t[n],i=new cc;i.curves=o.curves,e.push(i)}return e}(o);if(u.length>1){let t=!1,n=0;for(let t=0,e=u.length;t<e;t++)c[t]=[];for(let o=0,i=u.length;o<i;o++){const i=d[o];for(let r=0;r<i.length;r++){const s=i[r];let a=!0;for(let i=0;i<u.length;i++)e(s.p,u[i].p)&&(o!==i&&n++,a?(a=!1,c[i].push(s)):t=!0);a&&c[o].push(s)}}n>0&&!1===t&&(d=c)}for(let t=0,e=u.length;t<e;t++){s=u[t].s,a.push(s),f=d[t];for(let t=0,e=f.length;t<e;t++)s.holes.push(f[t].h)}return a}}const Gd=function(){const t=new ArrayBuffer(4),e=new Float32Array(t),n=new Uint32Array(t),o=new Uint32Array(512),i=new Uint32Array(512);for(let t=0;t<256;++t){const e=t-127;e<-27?(o[t]=0,o[256|t]=32768,i[t]=24,i[256|t]=24):e<-14?(o[t]=1024>>-e-14,o[256|t]=1024>>-e-14|32768,i[t]=-e-1,i[256|t]=-e-1):e<=15?(o[t]=e+15<<10,o[256|t]=e+15<<10|32768,i[t]=13,i[256|t]=13):e<128?(o[t]=31744,o[256|t]=64512,i[t]=24,i[256|t]=24):(o[t]=31744,o[256|t]=64512,i[t]=13,i[256|t]=13)}const r=new Uint32Array(2048),s=new Uint32Array(64),a=new Uint32Array(64);for(let t=1;t<1024;++t){let e=t<<13,n=0;for(;!(8388608&e);)e<<=1,n-=8388608;e&=-8388609,n+=947912704,r[t]=e|n}for(let t=1024;t<2048;++t)r[t]=939524096+(t-1024<<13);for(let t=1;t<31;++t)s[t]=t<<23;s[31]=1199570944,s[32]=2147483648;for(let t=33;t<63;++t)s[t]=2147483648+(t-32<<23);s[63]=3347054592;for(let t=1;t<64;++t)32!==t&&(a[t]=1024);return{floatView:e,uint32View:n,baseTable:o,shiftTable:i,mantissaTable:r,exponentTable:s,offsetTable:a}}();function Qd(t){Math.abs(t)>65504&&console.warn("v3d.DataUtils.toHalfFloat(): Value out of range."),t=ie(t,-65504,65504),Gd.floatView[0]=t;const e=Gd.uint32View[0],n=e>>23&511;return Gd.baseTable[n]+((8388607&e)>>Gd.shiftTable[n])}function zd(t){const e=t>>10;return Gd.uint32View[0]=Gd.mantissaTable[Gd.offsetTable[e]+(1023&t)]+Gd.exponentTable[e],Gd.floatView[0]}var kd=Object.freeze({__proto__:null,fromHalfFloat:zd,toHalfFloat:Qd});class Hd extends Cr{constructor(t,e,n){super(),this.damp=e,this.shader=Vi.afterimage,this.uniforms=pi.clone(this.shader.uniforms),this.uniforms.damp.value=this.damp,this.textureComp=new cn(t.x,t.y,n),this.textureComp.texture.name="AfterImage.comp",this.textureOld=new cn(t.x,t.y,n),this.textureOld.texture.name="AfterImage.old",this.shaderMaterial=new gi({type:"AfterImage",uniforms:this.uniforms,vertexShader:this.shader.vertexShader,fragmentShader:this.shader.fragmentShader}),this.compFsQuad=new Ir(this.shaderMaterial);const o=new No;this.copyFsQuad=new Ir(o)}dispose(){this.textureComp.dispose(),this.textureOld.dispose()}render(t,e,n){this.uniforms.tOld.value=this.textureOld.texture,this.uniforms.tNew.value=n.texture,this.uniforms.damp.value=this.damp,t.setRenderTarget(this.textureComp),this.compFsQuad.render(t),this.copyFsQuad.material.map=this.textureComp.texture,this.renderToScreen?(t.setRenderTarget(null),this.copyFsQuad.render(t)):(t.setRenderTarget(e),this.clear&&t.clear(),this.copyFsQuad.render(t));const o=this.textureOld;this.textureOld=this.textureComp,this.textureComp=o}setSize(t,e){this.textureComp.setSize(t,e),this.textureOld.setSize(t,e)}}class Wd extends Cr{constructor(t,e,n,o,i){super(),this.strength=void 0!==e?e:1,this.radius=ie(n),this.threshold=o,this.resolution=void 0!==t?new we(t.x,t.y):new we(256,256),i=i||{minFilter:N,magFilter:N,format:W},this.clearColor=new tn(0,0,0),this.renderTargetsHorizontal=[],this.renderTargetsVertical=[],this.nMips=5;let r=Math.round(this.resolution.x/2),s=Math.round(this.resolution.y/2);this.renderTargetBright=new cn(r,s,i),this.renderTargetBright.texture.name="BloomPass.bright",this.renderTargetBright.texture.generateMipmaps=!1;for(let t=0;t<this.nMips;t++){const e=new cn(r,s,i);e.texture.name="BloomPass.h"+t,e.texture.generateMipmaps=!1,this.renderTargetsHorizontal.push(e);const n=new cn(r,s,i);n.texture.name="BloomPass.v"+t,n.texture.generateMipmaps=!1,this.renderTargetsVertical.push(n),r=Math.round(r/2),s=Math.round(s/2)}const l=Vi.bloomLumHighPass;this.highPassUniforms=pi.clone(l.uniforms),this.highPassUniforms.luminosityThreshold.value=o,this.highPassUniforms.smoothWidth.value=.01,this.materialHighPassFilter=new gi({type:"BloomHighPass",uniforms:this.highPassUniforms,vertexShader:l.vertexShader,fragmentShader:l.fragmentShader,defines:{}}),this.separableBlurMaterials=[];const c=[3,5,7,9,11];r=Math.round(this.resolution.x/2),s=Math.round(this.resolution.y/2);for(let t=0;t<this.nMips;t++)this.separableBlurMaterials.push(this.getSeparableBlurMaterial(c[t],c[t]/3)),this.separableBlurMaterials[t].uniforms.texSize.value=new we(r,s),r=Math.round(r/2),s=Math.round(s/2);this.compositeMaterial=this.getCompositeMaterial(this.nMips),this.compositeMaterial.uniforms.blurTexture1.value=this.renderTargetsVertical[0].texture,this.compositeMaterial.uniforms.blurTexture2.value=this.renderTargetsVertical[1].texture,this.compositeMaterial.uniforms.blurTexture3.value=this.renderTargetsVertical[2].texture,this.compositeMaterial.uniforms.blurTexture4.value=this.renderTargetsVertical[3].texture,this.compositeMaterial.uniforms.blurTexture5.value=this.renderTargetsVertical[4].texture,this.compositeMaterial.uniforms.bloomStrength.value=e,this.compositeMaterial.uniforms.bloomRadius.value=.1,this.compositeMaterial.needsUpdate=!0;this.compositeMaterial.uniforms.bloomFactors.value=[1,.8,.6,.4,.2],this.bloomTintColors=[new An(1,1,1),new An(1,1,1),new An(1,1,1),new An(1,1,1),new An(1,1,1)],this.compositeMaterial.uniforms.bloomTintColors.value=this.bloomTintColors;const f=Vi.copy;this.copyUniforms=pi.clone(f.uniforms),this.copyUniforms.opacity.value=1,this.materialCopy=new gi({type:"BloomCopy",defines:Object.assign({},f.defines),uniforms:this.copyUniforms,vertexShader:f.vertexShader,fragmentShader:f.fragmentShader,blending:5,blendEquation:a,blendEquationAlpha:a,blendSrc:A,blendDst:h,blendSrcAlpha:u,blendDstAlpha:h,depthTest:!1,depthWrite:!1,transparent:!0}),this.enabled=!0,this.needsSwap=!1,this.mo=new tn,this.oldClearAlpha=1,this.basic=new No,this.fsQuad=new Ir(null)}dispose(){for(let t=0;t<this.renderTargetsHorizontal.length;t++)this.renderTargetsHorizontal[t].dispose();for(let t=0;t<this.renderTargetsVertical.length;t++)this.renderTargetsVertical[t].dispose();this.renderTargetBright.dispose()}setSize(t,e){let n=Math.round(t/2),o=Math.round(e/2);this.renderTargetBright.setSize(n,o);for(let t=0;t<this.nMips;t++)this.renderTargetsHorizontal[t].setSize(n,o),this.renderTargetsVertical[t].setSize(n,o),this.separableBlurMaterials[t].uniforms.texSize.value=new we(n,o),n=Math.round(n/2),o=Math.round(o/2)}render(t,e,n,o,i){t.getClearColor(this.mo),this.oldClearAlpha=t.getClearAlpha();const r=t.autoClear;t.autoClear=!1,t.setClearColor(this.clearColor,0),i&&t.state.buffers.stencil.setTest(!1),this.renderToScreen&&(this.fsQuad.material=this.basic,this.basic.map=n.texture,t.setRenderTarget(null),t.clear(),this.fsQuad.render(t)),this.highPassUniforms.tDiffuse.value=n.texture,this.highPassUniforms.luminosityThreshold.value=this.threshold,this.fsQuad.material=this.materialHighPassFilter,t.setRenderTarget(this.renderTargetBright),t.clear(),this.fsQuad.render(t);let s=this.renderTargetBright;for(let e=0;e<this.nMips;e++)this.fsQuad.material=this.separableBlurMaterials[e],this.separableBlurMaterials[e].uniforms.colorTexture.value=s.texture,this.separableBlurMaterials[e].uniforms.direction.value=Wd.BlurDirectionX,t.setRenderTarget(this.renderTargetsHorizontal[e]),t.clear(),this.fsQuad.render(t),this.separableBlurMaterials[e].uniforms.colorTexture.value=this.renderTargetsHorizontal[e].texture,this.separableBlurMaterials[e].uniforms.direction.value=Wd.BlurDirectionY,t.setRenderTarget(this.renderTargetsVertical[e]),t.clear(),this.fsQuad.render(t),s=this.renderTargetsVertical[e];this.fsQuad.material=this.compositeMaterial,this.compositeMaterial.uniforms.bloomStrength.value=this.strength,this.compositeMaterial.uniforms.bloomRadius.value=ie(this.radius),this.compositeMaterial.uniforms.bloomTintColors.value=this.bloomTintColors,t.setRenderTarget(this.renderTargetsHorizontal[0]),t.clear(),this.fsQuad.render(t),this.fsQuad.material=this.materialCopy,this.copyUniforms.tDiffuse.value=this.renderTargetsHorizontal[0].texture,i&&t.state.buffers.stencil.setTest(!0),this.renderToScreen?(t.setRenderTarget(null),this.fsQuad.render(t)):(t.setRenderTarget(n),this.fsQuad.render(t)),t.setClearColor(this.mo,this.oldClearAlpha),t.autoClear=r}getSeparableBlurMaterial(t,e){return new gi({type:"BloomSeparableBlur",uniforms:{colorTexture:{value:null},texSize:{value:new we(.5,.5)},direction:{value:new we(.5,.5)},kernelRadius:{value:t},sigma:{value:e}},vertexShader:Fi.pp_plane_vert,fragmentShader:Fi.pp_bloom_separable_blur_frag})}getCompositeMaterial(t){return new gi({type:"BloomComposite",defines:{NUM_MIPS:t},uniforms:{blurTexture1:{value:null},blurTexture2:{value:null},blurTexture3:{value:null},blurTexture4:{value:null},blurTexture5:{value:null},dirtTexture:{value:null},bloomStrength:{value:1},bloomFactors:{value:null},bloomTintColors:{value:null},bloomRadius:{value:0}},vertexShader:Fi.pp_plane_vert,fragmentShader:Fi.pp_bloom_composite_frag})}}Wd.BlurDirectionX=new we(1,0),Wd.BlurDirectionY=new we(0,1);class Yd extends Cr{constructor(t,e,n){super(),this.scene=t,this.camera=e;const o=n.width||window.innerWidth||1,i=n.height||window.innerHeight||1,r=new cn(o,i,{minFilter:N,magFilter:N,format:W});this.renderTargetDepth=r.clone(),this.renderTargetDepth.texture.name="BokehPass.depth",this.materialDepth=new fa,this.materialDepth.depthPacking=Ut,this.materialDepth.blending=0;const s=Vi.bokeh,a=pi.clone(s.uniforms);a.tDepth.value=this.renderTargetDepth.texture,a.focus.value=ye(n.focus)?n.focus:1,a.aperture.value=ye(n.aperture)?n.aperture:1,a.maxblur.value=ye(n.maxblur)?n.maxblur:1,a.depthLeakThreshold.value=ye(n.depthLeakThreshold)?n.depthLeakThreshold:.2,a.nearClip.value=e.near,a.farClip.value=e.far,a.aspect.value=e.aspect,Object.defineProperties(this,{focus:{get:function(){return this.uniforms.focus.value},set:function(t){this.uniforms.focus.value=t}},aperture:{get:function(){return this.uniforms.aperture.value},set:function(t){this.uniforms.aperture.value=t}},maxblur:{get:function(){return this.uniforms.maxblur.value},set:function(t){this.uniforms.maxblur.value=t}},depthLeakThreshold:{get:function(){return this.uniforms.depthLeakThreshold.value},set:function(t){this.uniforms.depthLeakThreshold.value=t}}}),this.materialBokeh=new gi({type:"Bokeh",defines:Object.assign({},s.defines),uniforms:a,vertexShader:s.vertexShader,fragmentShader:s.fragmentShader}),this.uniforms=a,this.camera2=new Xi(-1,1,1,-1,0,1),this.scene2=new Ni,this.quad2=new hi(new Oi(2,2),null),this.quad2.frustumCulled=!1,this.scene2.add(this.quad2),this.oldClearColor=new tn,this.oldClearAlpha=1}render(t,e,n,o,i){this.quad2.material=this.materialBokeh,this.scene.overrideMaterial=this.materialDepth,t.getClearColor(this.oldClearColor),this.oldClearAlpha=t.getClearAlpha(),t.autoClear,t.autoClear=!1,t.setClearColor(16777215),t.setClearAlpha(1),t.setRenderTarget(this.renderTargetDepth),t.clear(),t.render(this.scene,this.camera),this.uniforms.tColor.value=n.texture,this.uniforms.nearClip.value=this.camera.near,this.uniforms.farClip.value=this.camera.far,this.uniforms.aspect.value=this.camera.aspect,this.renderToScreen?(t.setRenderTarget(null),t.render(this.scene2,this.camera2)):(t.setRenderTarget(e),t.clear(),t.render(this.scene2,this.camera2)),this.scene.overrideMaterial=null,t.setClearColor(this.oldClearColor),t.setClearAlpha(this.oldClearAlpha),t.autoClear=this.oldAutoClear}setCamera(t){this.camera=t}setSize(t,e){this.renderTargetDepth.setSize(t,e)}dispose(){this.renderTargetDepth.dispose()}}class Xd extends Cr{constructor(t,e){super(),this.textureID=void 0!==e?e:"tDiffuse",t instanceof gi?(this.uniforms=t.uniforms,this.material=t):t&&(this.uniforms=pi.clone(t.uniforms),this.material=new gi({type:"ShaderPass",defines:Object.assign({},t.defines),uniforms:this.uniforms,vertexShader:t.vertexShader,fragmentShader:t.fragmentShader})),this.fsQuad=new Ir(this.material)}render(t,e,n){this.uniforms[this.textureID]&&(this.uniforms[this.textureID].value=n.texture),this.fsQuad.material=this.material,this.renderToScreen?(t.setRenderTarget(null),this.fsQuad.render(t)):(t.setRenderTarget(e),this.clear&&t.clear(t.autoClearColor,t.autoClearDepth,t.autoClearStencil),this.fsQuad.render(t))}dispose(){this.material.dispose()}}class Kd extends Xd{constructor(){super(Vi.brightness_contrast),this.material.type="Grayscale"}get brightness(){return this.uniforms.brightness.value}set brightness(t){this.uniforms.brightness.value=t}get contrast(){return this.uniforms.contrast.value}set contrast(t){this.uniforms.contrast.value=t}}class jd extends Xd{constructor(t,e,n,o){super(Vi.fxaa),this.material.type="FXAA",this.width=void 0!==n?n:512,this.height=void 0!==o?o:256,this.needsSwap=!1}setSize(t,e){this.width=t,this.height=e,this.uniforms.resolution.value.set(1/t,1/e)}}class Zd extends Xd{constructor(){super(Vi.grayscale),this.material.type="Grayscale"}}let qd,Jd,$d,tA;function eA(t,e=1/0,n=null){Jd||(Jd=new Oi(2,2,1,1)),$d||($d=new gi({uniforms:{blitTexture:new dd(t)},vertexShader:"\n            varying vec2 vUv;\n            void main(){\n                vUv = uv;\n                gl_Position = vec4(position.xy * 1.0,0.,.999999);\n            }",fragmentShader:"\n            uniform sampler2D blitTexture;\n            varying vec2 vUv;\n\n            void main(){\n                gl_FragColor = vec4(vUv.xy, 0, 1);\n\n                #ifdef IS_SRGB\n                gl_FragColor = LinearTosRGB(texture2D(blitTexture, vUv));\n                #else\n                gl_FragColor = texture2D(blitTexture, vUv);\n                #endif\n            }"})),$d.uniforms.blitTexture.value=t,$d.defines.IS_SRGB=t.encoding==Ft,$d.needsUpdate=!0,tA||(tA=new hi(Jd,$d),tA.frustumCulled=!1);const o=new Ei,i=new Ni;i.add(tA),null===n&&(n=qd=new Oa({antialias:!1}));const r=Math.min(t.image.width,e),s=Math.min(t.image.height,e);n.setSize(r,s),n.clear(),n.render(i,o);const a=document.createElement("canvas"),l=a.getContext("2d");a.width=r,a.height=s,l.drawImage(n.domElement,0,0,r,s);const c=new Vl(a);return c.minFilter=t.minFilter,c.magFilter=t.magFilter,c.wrapS=t.wrapS,c.wrapT=t.wrapT,c.name=t.name,qd&&(qd.forceContextLoss(),qd.dispose(),qd=null),c}class nA{constructor(){this.pluginCallbacks=[],this.register(function(t){return new BA(t)})}register(t){return-1===this.pluginCallbacks.indexOf(t)&&this.pluginCallbacks.push(t),this}unregister(t){return-1!==this.pluginCallbacks.indexOf(t)&&this.pluginCallbacks.splice(this.pluginCallbacks.indexOf(t),1),this}parse(t,e,n,o){const i=new TA,r=[];for(let t=0,e=this.pluginCallbacks.length;t<e;t++)r.push(this.pluginCallbacks[t](i));i.setPlugins(r),i.write(t,e,o).catch(n)}parseAsync(t,e){const n=this;return new Promise(function(o,i){n.parse(t,o,i,e)})}}const oA=0,iA=1,rA=2,sA=3,aA=4,lA=5121,cA=5123,uA=5126,hA=5125,fA=34962,dA=34963,AA=9728,vA=9729,mA=9984,pA=9985,gA=9986,_A=9987,EA=33071,CA=33648,wA=10497,xA={};xA[1003]=AA,xA[1004]=mA,xA[1005]=gA,xA[1006]=vA,xA[1007]=pA,xA[1008]=_A,xA[1001]=EA,xA[1e3]=wA,xA[1002]=CA;const IA={scale:"scale",position:"translation",quaternion:"rotation",morphTargetInfluences:"weights"};function MA(t,e){return t.length===e.length&&t.every(function(t,n){return t===e[n]})}function SA(t){return 4*Math.ceil(t/4)}function bA(t,e=0){const n=SA(t.byteLength);if(n!==t.byteLength){const o=new Uint8Array(n);if(o.set(new Uint8Array(t)),0!==e)for(let i=t.byteLength;i<n;i++)o[i]=e;return o.buffer}return t}function yA(){return"undefined"==typeof document&&"undefined"!=typeof OffscreenCanvas?new OffscreenCanvas(1,1):document.createElement("canvas")}function RA(t,e){if(void 0!==t.toBlob)return new Promise(n=>t.toBlob(n,e));let n;return"image/jpeg"===e?n=.92:"image/webp"===e&&(n=.8),t.convertToBlob({type:e,quality:n})}class TA{constructor(){this.plugins=[],this.options={},this.pending=[],this.buffers=[],this.byteOffset=0,this.buffers=[],this.nodeMap=new Map,this.skins=[],this.extensionsUsed={},this.uids=new Map,this.uid=0,this.json={asset:{version:"2.0",generator:"Verge3D"}},this.cache={meshes:new Map,attributes:new Map,attributesNormalized:new Map,materials:new Map,textures:new Map,images:new Map}}setPlugins(t){this.plugins=t}async write(t,e,n={}){this.options=Object.assign({binary:!1,trs:!1,onlyVisible:!0,maxTextureSize:1/0,animations:[],includeCustomExtensions:!1},n),this.options.animations.length>0&&(this.options.trs=!0),this.processInput(t),await Promise.all(this.pending);const o=this,i=o.buffers,r=o.json;n=o.options;const s=o.extensionsUsed,a=new Blob(i,{type:"application/octet-stream"}),l=Object.keys(s);if(l.length>0&&(r.extensionsUsed=l),r.buffers&&r.buffers.length>0&&(r.buffers[0].byteLength=a.size),!0===n.binary){const t=new FileReader;t.readAsArrayBuffer(a),t.onloadend=function(){const n=bA(t.result),o=new DataView(new ArrayBuffer(8));o.setUint32(0,n.byteLength,!0),o.setUint32(4,5130562,!0);const i=bA((s=JSON.stringify(r),(new TextEncoder).encode(s).buffer),32);var s;const a=new DataView(new ArrayBuffer(8));a.setUint32(0,i.byteLength,!0),a.setUint32(4,1313821514,!0);const l=new ArrayBuffer(12),c=new DataView(l);c.setUint32(0,1179937895,!0),c.setUint32(4,2,!0);const u=12+a.byteLength+i.byteLength+o.byteLength+n.byteLength;c.setUint32(8,u,!0);const h=new Blob([l,a,i,o,n],{type:"application/octet-stream"}),f=new FileReader;f.readAsArrayBuffer(h),f.onloadend=function(){e(f.result)}}}else if(r.buffers&&r.buffers.length>0){const t=new FileReader;t.readAsDataURL(a),t.onloadend=function(){const n=t.result;r.buffers[0].uri=n,e(r)}}else e(r)}serializeUserData(t,e){if(0===Object.keys(t.userData).length)return;const n=this.options,o=this.extensionsUsed;try{const i=JSON.parse(JSON.stringify(t.userData));if(n.includeCustomExtensions&&i.gltfExtensions){void 0===e.extensions&&(e.extensions={});for(const t in i.gltfExtensions)e.extensions[t]=i.gltfExtensions[t],o[t]=!0;delete i.gltfExtensions}Object.keys(i).length>0&&(e.extras=i)}catch(e){console.warn("v3d.GLTFExporter: userData of '"+t.name+"' won't be serialized because of JSON.stringify error - "+e.message)}}getUID(t,e=!1){if(!1===this.uids.has(t)){const e=new Map;e.set(!0,this.uid++),e.set(!1,this.uid++),this.uids.set(t,e)}return this.uids.get(t).get(e)}isNormalizedNormalAttribute(t){if(this.cache.attributesNormalized.has(t))return!1;const e=new An;for(let n=0,o=t.count;n<o;n++)if(Math.abs(e.fromBufferAttribute(t,n).length()-1)>5e-4)return!1;return!0}createNormalizedNormalAttribute(t){const e=this.cache;if(e.attributesNormalized.has(t))return e.attributesNormalized.get(t);const n=t.clone(),o=new An;for(let t=0,e=n.count;t<e;t++)o.fromBufferAttribute(n,t),0===o.x&&0===o.y&&0===o.z?o.setX(1):o.normalize(),n.setXYZ(t,o.x,o.y,o.z);return e.attributesNormalized.set(t,n),n}buildMetalRoughTexture(t,e){var n,o;if(t===e)return t;function i(t){return t.encoding===Ft?function(t){return t<.04045?.0773993808*t:Math.pow(.9478672986*t+.0521327014,2.4)}:function(t){return t}}console.warn("v3d.GLTFExporter: Merged metalnessMap and roughnessMap textures."),t instanceof Ul&&(t=eA(t)),e instanceof Ul&&(e=eA(e));const r=null==(n=t)?void 0:n.image,s=null==(o=e)?void 0:o.image,a=Math.max((null==r?void 0:r.width)||0,(null==s?void 0:s.width)||0),l=Math.max((null==r?void 0:r.height)||0,(null==s?void 0:s.height)||0),c=yA();c.width=a,c.height=l;const u=c.getContext("2d");u.fillStyle="#00ffff",u.fillRect(0,0,a,l);const h=u.getImageData(0,0,a,l);if(r){u.drawImage(r,0,0,a,l);const e=i(t),n=u.getImageData(0,0,a,l).data;for(let t=2;t<n.length;t+=4)h.data[t]=256*e(n[t]/256)}if(s){u.drawImage(s,0,0,a,l);const t=i(e),n=u.getImageData(0,0,a,l).data;for(let e=1;e<n.length;e+=4)h.data[e]=256*t(n[e]/256)}u.putImageData(h,0,0);const f=(t||e).clone();return f.source=new rn(c),f.encoding=Ot,f}processBuffer(t){const e=this.json,n=this.buffers;return e.buffers||(e.buffers=[{byteLength:0}]),n.push(t),0}processBufferView(t,e,n,o,i){const r=this.json;let s;r.bufferViews||(r.bufferViews=[]),s=e===lA?1:e===cA?2:4;const a=SA(o*t.itemSize*s),l=new DataView(new ArrayBuffer(a));let c=0;for(let i=n;i<n+o;i++)for(let n=0;n<t.itemSize;n++){let o;t.itemSize>4?o=t.array[i*t.itemSize+n]:(0===n?o=t.getX(i):1===n?o=t.getY(i):2===n?o=t.getZ(i):3===n&&(o=t.getW(i)),!0===t.normalized&&(o=Ae(o,t.array))),e===uA?l.setFloat32(c,o,!0):e===hA?l.setUint32(c,o,!0):e===cA?l.setUint16(c,o,!0):e===lA&&l.setUint8(c,o),c+=s}const u={buffer:this.processBuffer(l.buffer),byteOffset:this.byteOffset,byteLength:a};void 0!==i&&(u.target=i),i===fA&&(u.byteStride=t.itemSize*s),this.byteOffset+=a,r.bufferViews.push(u);return{id:r.bufferViews.length-1,byteLength:0}}processBufferViewImage(t){const e=this,n=e.json;return n.bufferViews||(n.bufferViews=[]),new Promise(function(o){const i=new FileReader;i.readAsArrayBuffer(t),i.onloadend=function(){const t=bA(i.result),r={buffer:e.processBuffer(t),byteOffset:e.byteOffset,byteLength:t.byteLength};e.byteOffset+=t.byteLength,o(n.bufferViews.push(r)-1)}})}processAccessor(t,e,n,o){const i=this.json;let r;if(t.array.constructor===Float32Array)r=uA;else if(t.array.constructor===Uint32Array)r=hA;else if(t.array.constructor===Uint16Array)r=cA;else{if(t.array.constructor!==Uint8Array)throw new Error("v3d.GLTFExporter: Unsupported bufferAttribute component type.");r=lA}if(void 0===n&&(n=0),void 0===o&&(o=t.count),0===o)return null;const s=function(t,e,n){const o={min:new Array(t.itemSize).fill(Number.POSITIVE_INFINITY),max:new Array(t.itemSize).fill(Number.NEGATIVE_INFINITY)};for(let i=e;i<e+n;i++)for(let e=0;e<t.itemSize;e++){let n;t.itemSize>4?n=t.array[i*t.itemSize+e]:(0===e?n=t.getX(i):1===e?n=t.getY(i):2===e?n=t.getZ(i):3===e&&(n=t.getW(i)),!0===t.normalized&&(n=Ae(n,t.array))),o.min[e]=Math.min(o.min[e],n),o.max[e]=Math.max(o.max[e],n)}return o}(t,n,o);let a;void 0!==e&&(a=t===e.index?dA:fA);const l=this.processBufferView(t,r,n,o,a),c={bufferView:l.id,byteOffset:l.byteOffset,componentType:r,count:o,max:s.max,min:s.min,type:{1:"SCALAR",2:"VEC2",3:"VEC3",4:"VEC4",16:"MAT4"}[t.itemSize]};return!0===t.normalized&&(c.normalized=!0),i.accessors||(i.accessors=[]),i.accessors.push(c)-1}processImage(t,e,n,o="image/png"){if(null!==t){const i=this,r=i.cache,s=i.json,a=i.options,l=i.pending;r.images.has(t)||r.images.set(t,{});const c=r.images.get(t),u=o+":flipY/"+n.toString();if(void 0!==c[u])return c[u];s.images||(s.images=[]);const h={mimeType:o},f=yA();f.width=Math.min(t.width,a.maxTextureSize),f.height=Math.min(t.height,a.maxTextureSize);const d=f.getContext("2d");if(!0===n&&(d.translate(0,f.height),d.scale(1,-1)),void 0!==t.data){e!==W&&console.error("GLTFExporter: Only RGBAFormat is supported."),(t.width>a.maxTextureSize||t.height>a.maxTextureSize)&&console.warn("GLTFExporter: Image size is bigger than maxTextureSize",t);const n=new Uint8ClampedArray(t.height*t.width*4);for(let e=0;e<n.length;e+=4)n[e+0]=t.data[e+0],n[e+1]=t.data[e+1],n[e+2]=t.data[e+2],n[e+3]=t.data[e+3];d.putImageData(new ImageData(n,t.width,t.height),0,0)}else d.drawImage(t,0,0,f.width,f.height);!0===a.binary?l.push(RA(f,o).then(t=>i.processBufferViewImage(t)).then(t=>{h.bufferView=t})):void 0!==f.toDataURL?h.uri=f.toDataURL(o):l.push(RA(f,o).then(t=>(new FileReader).readAsDataURL(t)).then(t=>{h.uri=t}));const A=s.images.push(h)-1;return c[u]=A,A}throw new Error("v3d.GLTFExporter: No valid image data found. Unable to process texture.")}processSampler(t){const e=this.json;e.samplers||(e.samplers=[]);const n={magFilter:xA[t.magFilter],minFilter:xA[t.minFilter],wrapS:xA[t.wrapS],wrapT:xA[t.wrapT]};return e.samplers.push(n)-1}processTexture(t){const e=this.options,n=this.cache,o=this.json;if(n.textures.has(t))return n.textures.get(t);o.textures||(o.textures=[]),t instanceof Ul&&(t=eA(t,e.maxTextureSize));let i=t.userData.mimeType;"image/webp"===i&&(i="image/png");const r={sampler:this.processSampler(t),source:this.processImage(t.image,t.format,t.flipY,i)};t.name&&(r.name=t.name),this.po(function(e){e.writeTexture&&e.writeTexture(t,r)});const s=o.textures.push(r)-1;return n.textures.set(t,s),s}processMaterial(t){const e=this.cache,n=this.json;if(e.materials.has(t))return e.materials.get(t);if(t.isShaderMaterial)return console.warn("GLTFExporter: v3d.ShaderMaterial not supported."),null;n.materials||(n.materials=[]);const o={pbrMetallicRoughness:{}};!0!==t.isMeshNodeMaterial&&!0!==t.isMeshStandardMaterial&&!0!==t.isMeshBasicMaterial&&console.warn("GLTFExporter: Use MeshNodeMaterial, MeshStandardMaterial, or MeshBasicMaterial for best results.");const i=t.color.toArray().concat([t.opacity]);MA(i,[1,1,1,1])||(o.pbrMetallicRoughness.baseColorFactor=i),t.isMeshNodeMaterial?(o.pbrMetallicRoughness.metallicFactor=t.getStandardProp("metalness"),o.pbrMetallicRoughness.roughnessFactor=t.getStandardProp("roughness")):t.isMeshStandardMaterial?(o.pbrMetallicRoughness.metallicFactor=t.metalness,o.pbrMetallicRoughness.roughnessFactor=t.roughness):(o.pbrMetallicRoughness.metallicFactor=.5,o.pbrMetallicRoughness.roughnessFactor=.5);const r=t.isMeshNodeMaterial?t.getStandardProp("metalnessMap"):t.metalnessMap,s=t.isMeshNodeMaterial?t.getStandardProp("roughnessMap"):t.roughnessMap;if(r||s){const t=this.buildMetalRoughTexture(r,s),e={index:this.processTexture(t)};o.pbrMetallicRoughness.metallicRoughnessTexture=e}const a=t.isMeshNodeMaterial?t.getStandardProp("map"):t.map;if(a){const t={index:this.processTexture(a)};o.pbrMetallicRoughness.baseColorTexture=t}let l=t.isMeshNodeMaterial?t.getStandardProp("emissive"):t.emissive;if(l){const e=t.isMeshNodeMaterial?t.getStandardProp("emissiveIntensity"):t.emissiveIntensity;l=l.clone().multiplyScalar(e);const n=Math.max(l.r,l.g,l.b);n>1&&(l.multiplyScalar(1/n),console.warn("v3d.GLTFExporter: Some emissive components exceed 1; emissive has been limited")),n>0&&(o.emissiveFactor=l.toArray());const i=t.isMeshNodeMaterial?t.getStandardProp("emissiveMap"):t.emissiveMap;if(i){const t={index:this.processTexture(i)};o.emissiveTexture=t}}const c=t.isMeshNodeMaterial?t.getStandardProp("normalMap"):t.normalMap;if(c){const e={index:this.processTexture(c)},n=t.isMeshNodeMaterial?t.getStandardProp("normalScale"):t.normalScale;n&&1!==n.x&&(e.scale=n.x),o.normalTexture=e}const u=t.isMeshNodeMaterial?t.getStandardProp("aoMap"):t.aoMap;if(u){const e={index:this.processTexture(u),texCoord:1},n=t.isMeshNodeMaterial?t.getStandardProp("aoMapIntensity"):t.aoMapIntensity;1!==n&&(e.strength=n),o.occlusionTexture=e}t.transparent?o.alphaMode="BLEND":t.alphaTest>0&&(o.alphaMode="MASK",o.alphaCutoff=t.alphaTest),2===t.side&&(o.doubleSided=!0),""!==t.name&&(o.name=t.name),this.serializeUserData(t,o),this.po(function(e){e.writeMaterial&&e.writeMaterial(t,o)});const h=n.materials.push(o)-1;return e.materials.set(t,h),h}processMesh(t){const e=this.cache,n=this.json,o=[t.geometry.uuid];if(Array.isArray(t.material))for(let e=0,n=t.material.length;e<n;e++)o.push(t.material[e].uuid);else o.push(t.material.uuid);const i=o.join(":");if(e.meshes.has(i))return e.meshes.get(i);const r=t.geometry;let s;s=t.isLineSegments?iA:t.isLineLoop?rA:t.isLine?sA:t.isPoints?oA:t.material.wireframe?iA:aA;const a={},l={},c=[],u=[],h={uv:"TEXCOORD_0",uv2:"TEXCOORD_1",color:"COLOR_0",skinWeight:"WEIGHTS_0",skinIndex:"JOINTS_0"},f=r.getAttribute("normal");void 0===f||this.isNormalizedNormalAttribute(f)||(console.warn("v3d.GLTFExporter: Creating normalized normal attribute from the non-normalized one."),r.setAttribute("normal",this.createNormalizedNormalAttribute(f)));let d=null;for(let t in r.attributes){if("morph"===t.slice(0,5))continue;const n=r.attributes[t];t=h[t]||t.toUpperCase();if(/^(POSITION|NORMAL|TANGENT|TEXCOORD_\d+|COLOR_\d+|JOINTS_\d+|WEIGHTS_\d+)$/.test(t)||(t="_"+t),e.attributes.has(this.getUID(n))){l[t]=e.attributes.get(this.getUID(n));continue}d=null;const o=n.array;"JOINTS_0"!==t||o instanceof Uint16Array||o instanceof Uint8Array||(console.warn('GLTFExporter: Attribute "skinIndex" converted to type UNSIGNED_SHORT.'),d=new Oo(new Uint16Array(o),n.itemSize,n.normalized));const i=this.processAccessor(d||n,r);null!==i&&(l[t]=i,e.attributes.set(this.getUID(n),i))}if(void 0!==f&&r.setAttribute("normal",f),0===Object.keys(l).length)return null;if(void 0!==t.morphTargetInfluences&&t.morphTargetInfluences.length>0){const n=[],o=[],i={};if(void 0!==t.morphTargetDictionary)for(const e in t.morphTargetDictionary)i[t.morphTargetDictionary[e]]=e;for(let s=0;s<t.morphTargetInfluences.length;++s){const a={};let l=!1;for(const t in r.morphAttributes){if("position"!==t&&"normal"!==t){l||(console.warn("GLTFExporter: Only POSITION and NORMAL morph are supported."),l=!0);continue}const n=r.morphAttributes[t][s],o=t.toUpperCase(),i=r.attributes[t];if(e.attributes.has(this.getUID(n,!0))){a[o]=e.attributes.get(this.getUID(n,!0));continue}const c=n.clone();if(!r.morphTargetsRelative)for(let t=0,e=n.count;t<e;t++)for(let e=0;e<n.itemSize;e++)0===e&&c.setX(t,n.getX(t)-i.getX(t)),1===e&&c.setY(t,n.getY(t)-i.getY(t)),2===e&&c.setZ(t,n.getZ(t)-i.getZ(t)),3===e&&c.setW(t,n.getW(t)-i.getW(t));a[o]=this.processAccessor(c,r),e.attributes.set(this.getUID(i,!0),a[o])}u.push(a),n.push(t.morphTargetInfluences[s]),void 0!==t.morphTargetDictionary&&o.push(i[s])}a.weights=n,o.length>0&&(a.extras={},a.extras.targetNames=o)}const A=Array.isArray(t.material);if(A&&0===r.groups.length)return null;const v=A?t.material:[t.material],m=A?r.groups:[{materialIndex:0,start:void 0,count:void 0}];for(let t=0,n=m.length;t<n;t++){const n={mode:s,attributes:l};if(this.serializeUserData(r,n),u.length>0&&(n.targets=u),null!==r.index){let o=this.getUID(r.index);void 0===m[t].start&&void 0===m[t].count||(o+=":"+m[t].start+":"+m[t].count),e.attributes.has(o)?n.indices=e.attributes.get(o):(n.indices=this.processAccessor(r.index,r,m[t].start,m[t].count),e.attributes.set(o,n.indices)),null===n.indices&&delete n.indices}const o=this.processMaterial(v[m[t].materialIndex]);null!==o&&(n.material=o),c.push(n)}a.primitives=c,n.meshes||(n.meshes=[]),this.po(function(e){e.writeMesh&&e.writeMesh(t,a)});const p=n.meshes.push(a)-1;return e.meshes.set(i,p),p}processCamera(t){const e=this.json;e.cameras||(e.cameras=[]);const n=t.isOrthographicCamera,o={type:n?"orthographic":"perspective"};return n?o.orthographic={xmag:2*t.right,ymag:2*t.top,zfar:t.far<=0?.001:t.far,znear:t.near<0?0:t.near}:o.perspective={aspectRatio:t.aspect,yfov:le(t.fov),zfar:t.far<=0?.001:t.far,znear:t.near<0?0:t.near},""!==t.name&&(o.name=t.type),e.cameras.push(o)-1}processAnimation(t,e){const n=this.json,o=this.nodeMap;n.animations||(n.animations=[]);const i=(t=nA.Utils.mergeMorphTargetTracks(t.clone(),e)).tracks,r=[],s=[];for(let t=0;t<i.length;++t){const n=i[t],a=ad.parseTrackName(n.name);let l=ad.findNode(e,a.nodeName);const c=IA[a.propertyName];if("bones"===a.objectName&&(l=!0===l.isSkinnedMesh?l.skeleton.getBoneByName(a.objectIndex):void 0),!l||!c)return console.warn('v3d.GLTFExporter: Could not export animation track "%s".',n.name),null;const u=1;let h,f=n.values.length/n.times.length;c===IA.morphTargetInfluences&&(f/=l.morphTargetInfluences.length),!0===n.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline?(h="CUBICSPLINE",f/=3):h=n.getInterpolation()===yt?"STEP":"LINEAR",s.push({input:this.processAccessor(new Oo(n.times,u)),output:this.processAccessor(new Oo(n.values,f)),interpolation:h}),r.push({sampler:s.length-1,target:{node:o.get(l),path:c}})}return n.animations.push({name:t.name||"clip_"+n.animations.length,samplers:s,channels:r}),n.animations.length-1}processSkin(t){const e=this.json,n=this.nodeMap,o=e.nodes[n.get(t)],i=t.skeleton;if(void 0===i)return null;const r=t.skeleton.bones[0];if(void 0===r)return null;const s=[],a=new Float32Array(16*i.bones.length),l=new Hn;for(let e=0;e<i.bones.length;++e)s.push(n.get(i.bones[e])),l.copy(i.boneInverses[e]),l.multiply(t.bindMatrix).toArray(a,16*e);void 0===e.skins&&(e.skins=[]),e.skins.push({inverseBindMatrices:this.processAccessor(new Oo(a,16)),joints:s,skeleton:n.get(r)});return o.skin=e.skins.length-1}processNode(t){const e=this.json,n=this.options,o=this.nodeMap;if(t.isAuxClippingMesh)return null;let i=!1;if(n.onlyVisible&&!t.visible&&(t.traverse(function(t){t.visible&&(i=!0)}),!i))return null;e.nodes||(e.nodes=[]);const r={};if(n.trs){const e=t.quaternion.toArray(),n=t.position.toArray(),o=t.scale.toArray();MA(e,[0,0,0,1])||(r.rotation=e),MA(n,[0,0,0])||(r.translation=n),MA(o,[1,1,1])||(r.scale=o)}else t.matrixAutoUpdate&&t.updateMatrix(),!1===MA(t.matrix.elements,[1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1])&&(r.matrix=t.matrix.elements);if(""!==t.name&&(r.name=String(t.name)),this.serializeUserData(t,r),(t.isMesh||t.isLine||t.isPoints)&&!i){const e=this.processMesh(t);null!==e&&(r.mesh=e)}else t.isCamera&&!i&&(r.camera=this.processCamera(t));if(t.isSkinnedMesh&&!i&&this.skins.push(t),t.children.length>0){const e=[];for(let n=0,o=t.children.length;n<o;n++){const o=t.children[n],i=this.processNode(o);null!==i&&e.push(i)}e.length>0&&(r.children=e)}this.po(function(e){e.writeNode&&e.writeNode(t,r)});const s=e.nodes.push(r)-1;return o.set(t,s),s}processScene(t){const e=this.json,n=this.options;e.scenes||(e.scenes=[],e.scene=0);const o={};""!==t.name&&(o.name=t.name),e.scenes.push(o);const i=[];for(let e=0,o=t.children.length;e<o;e++){const o=t.children[e];if(o.visible||!1===n.onlyVisible){const t=this.processNode(o);null!==t&&i.push(t)}}i.length>0&&(o.nodes=i),this.serializeUserData(t,o)}processObjects(t){const e=new Ni;e.name="AuxScene";for(let n=0;n<t.length;n++)e.children.push(t[n]);this.processScene(e)}processInput(t){const e=this.options;t=t instanceof Array?t:[t],this.po(function(e){e.beforeParse&&e.beforeParse(t)});const n=[];for(let e=0;e<t.length;e++)t[e]instanceof Ni?this.processScene(t[e]):n.push(t[e]);n.length>0&&this.processObjects(n);for(let t=0;t<this.skins.length;++t)this.processSkin(this.skins[t]);for(let n=0;n<e.animations.length;++n)this.processAnimation(e.animations[n],t[0]);this.po(function(e){e.afterParse&&e.afterParse(t)})}po(t){for(let e=0,n=this.plugins.length;e<n;e++)t(this.plugins[e])}}let BA=class{constructor(t){this.writer=t,this.name="KHR_materials_unlit"}writeMaterial(t,e){if(!(t.isMeshBasicMaterial||t.isMeshNodeMaterial&&t.isUnlit()))return;const n=this.writer.extensionsUsed;e.extensions=e.extensions||{},e.extensions[this.name]={},n[this.name]=!0,e.pbrMetallicRoughness.metallicFactor=0,e.pbrMetallicRoughness.roughnessFactor=.9}};nA.Utils={insertKeyframe:function(t,e){const n=.001,o=t.getValueSize(),i=new t.TimeBufferType(t.times.length+1),r=new t.ValueBufferType(t.values.length+o),s=t.createInterpolant(new t.ValueBufferType(o));let a;if(0===t.times.length){i[0]=e;for(let t=0;t<o;t++)r[t]=0;a=0}else if(e<t.times[0]){if(Math.abs(t.times[0]-e)<n)return 0;i[0]=e,i.set(t.times,1),r.set(s.evaluate(e),0),r.set(t.values,o),a=0}else if(e>t.times[t.times.length-1]){if(Math.abs(t.times[t.times.length-1]-e)<n)return t.times.length-1;i[i.length-1]=e,i.set(t.times,0),r.set(t.values,0),r.set(s.evaluate(e),t.values.length),a=i.length-1}else for(let l=0;l<t.times.length;l++){if(Math.abs(t.times[l]-e)<n)return l;if(t.times[l]<e&&t.times[l+1]>e){i.set(t.times.slice(0,l+1),0),i[l+1]=e,i.set(t.times.slice(l+1),l+2),r.set(t.values.slice(0,(l+1)*o),0),r.set(s.evaluate(e),(l+1)*o),r.set(t.values.slice((l+1)*o),(l+2)*o),a=l+1;break}}return t.times=i,t.values=r,a},mergeMorphTargetTracks:function(t,e){const n=[],o={},i=t.tracks;for(let t=0;t<i.length;++t){let r=i[t];const s=ad.parseTrackName(r.name),a=ad.findNode(e,s.nodeName);if("morphTargetInfluences"!==s.propertyName||void 0===s.propertyIndex){n.push(r);continue}if(r.createInterpolant!==r.InterpolantFactoryMethodDiscrete&&r.createInterpolant!==r.InterpolantFactoryMethodLinear){if(r.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline)throw new Error("v3d.GLTFExporter: Cannot merge tracks with glTF CUBICSPLINE interpolation.");console.warn("v3d.GLTFExporter: Morph target interpolation mode not yet supported. Using LINEAR instead."),r=r.clone(),r.setInterpolation(Rt)}const l=a.morphTargetInfluences.length,c=a.morphTargetDictionary[s.propertyIndex];if(void 0===c)throw new Error("v3d.GLTFExporter: Morph target name not found: "+s.propertyIndex);let u;if(void 0===o[a.uuid]){u=r.clone();const t=new u.ValueBufferType(l*u.times.length);for(let e=0;e<u.times.length;e++)t[e*l+c]=u.values[e];u.name=(s.nodeName||"")+".morphTargetInfluences",u.values=t,o[a.uuid]=u,n.push(u);continue}const h=r.createInterpolant(new r.ValueBufferType(1));u=o[a.uuid];for(let t=0;t<u.times.length;t++)u.values[t*l+c]=h.evaluate(u.times[t]);for(let t=0;t<r.times.length;t++){const e=this.insertKeyframe(u,r.times[t]);u.values[e*l+c]=r.values[t]}}return t.tracks=n,t}};class LA extends Cr{constructor(t,e){super(),this.scene=t,this.camera=e,this.clear=!0,this.needsSwap=!1,this.inverse=!1}render(t,e,n){const o=t.getContext(),i=t.state;let r,s;i.buffers.color.setMask(!1),i.buffers.depth.setMask(!1),i.buffers.color.setLocked(!0),i.buffers.depth.setLocked(!0),this.inverse?(r=0,s=1):(r=1,s=0),i.buffers.stencil.setTest(!0),i.buffers.stencil.setOp(o.REPLACE,o.REPLACE,o.REPLACE),i.buffers.stencil.setFunc(o.ALWAYS,r,4294967295),i.buffers.stencil.setClear(s),i.buffers.stencil.setLocked(!0),t.setRenderTarget(n),this.clear&&t.clear(),t.render(this.scene,this.camera),t.setRenderTarget(e),this.clear&&t.clear(),t.render(this.scene,this.camera),i.buffers.color.setLocked(!1),i.buffers.depth.setLocked(!1),i.buffers.stencil.setLocked(!1),i.buffers.stencil.setFunc(o.EQUAL,1,4294967295),i.buffers.stencil.setOp(o.KEEP,o.KEEP,o.KEEP),i.buffers.stencil.setLocked(!0)}setCamera(t){this.camera=t}}class NA extends Cr{constructor(){super(),this.needsSwap=!1}render(t){t.state.buffers.stencil.setLocked(!1),t.state.buffers.stencil.setTest(!1)}}function DA(t,e,n,o,i){if(t=t.subarray||t.slice?t:t.buffer,n=n.subarray||n.slice?n:n.buffer,t=e?t.subarray?t.subarray(e,i&&e+i):t.slice(e,i&&e+i):t,n.set)n.set(t,o);else for(let e=0;e<t.length;e++)n[e+o]=t[e];return n}class PA{constructor(){this.positions=[],this.previous=[],this.next=[],this.side=[],this.width=[],this.indices_array=[],this.uvs=[],this.counters=[],this.geometry=new Xo,this.widthCallback=null}setGeometry(t,e){if(this.widthCallback=e,this.positions=[],this.counters=[],t instanceof Float32Array||t instanceof Array)for(let e=0;e<t.length;e+=3){const n=e/t.length;this.positions.push(t[e],t[e+1],t[e+2]),this.positions.push(t[e],t[e+1],t[e+2]),this.counters.push(n),this.counters.push(n)}this.process()}compareV3(t,e){const n=6*t,o=6*e;return this.positions[n]===this.positions[o]&&this.positions[n+1]===this.positions[o+1]&&this.positions[n+2]===this.positions[o+2]}copyV3(t){const e=6*t;return[this.positions[e],this.positions[e+1],this.positions[e+2]]}process(){const t=this.positions.length/6;this.previous=[],this.next=[],this.side=[],this.width=[],this.indices_array=[],this.uvs=[];for(let e=0;e<t;e++)this.side.push(1),this.side.push(-1);let e,n;for(let n=0;n<t;n++)e=this.widthCallback?this.widthCallback(n/(t-1)):1,this.width.push(e),this.width.push(e);for(let e=0;e<t;e++)this.uvs.push(e/(t-1),0),this.uvs.push(e/(t-1),1);n=this.compareV3(0,t-1)?this.copyV3(t-2):this.copyV3(0),this.previous.push(n[0],n[1],n[2]),this.previous.push(n[0],n[1],n[2]);for(let e=0;e<t-1;e++)n=this.copyV3(e),this.previous.push(n[0],n[1],n[2]),this.previous.push(n[0],n[1],n[2]);for(let e=1;e<t;e++)n=this.copyV3(e),this.next.push(n[0],n[1],n[2]),this.next.push(n[0],n[1],n[2]);n=this.compareV3(t-1,0)?this.copyV3(1):this.copyV3(t-1),this.next.push(n[0],n[1],n[2]),this.next.push(n[0],n[1],n[2]);for(let e=0;e<t-1;e++){const t=2*e;this.indices_array.push(t,t+1,t+2),this.indices_array.push(t+2,t+1,t+3)}this.attributes?(this.attributes.position.copyArray(new Float32Array(this.positions)),this.attributes.position.needsUpdate=!0,this.attributes.previous.copyArray(new Float32Array(this.previous)),this.attributes.previous.needsUpdate=!0,this.attributes.next.copyArray(new Float32Array(this.next)),this.attributes.next.needsUpdate=!0,this.attributes.side.copyArray(new Float32Array(this.side)),this.attributes.side.needsUpdate=!0,this.attributes.width.copyArray(new Float32Array(this.width)),this.attributes.width.needsUpdate=!0,this.attributes.uv.copyArray(new Float32Array(this.uvs)),this.attributes.uv.needsUpdate=!0,this.attributes.counters.copyArray(new Float32Array(this.counters)),this.attributes.counters.needsUpdate=!0,this.attributes.index.copyArray(new Uint16Array(this.indices_array)),this.attributes.index.needsUpdate=!0):this.attributes={position:new Oo(new Float32Array(this.positions),3),previous:new Oo(new Float32Array(this.previous),3),next:new Oo(new Float32Array(this.next),3),side:new Oo(new Float32Array(this.side),1),width:new Oo(new Float32Array(this.width),1),uv:new Oo(new Float32Array(this.uvs),2),counters:new Oo(new Float32Array(this.counters),1),index:new Oo(new Uint16Array(this.indices_array),1)},this.geometry.setAttribute("position",this.attributes.position),this.geometry.setAttribute("previous",this.attributes.previous),this.geometry.setAttribute("next",this.attributes.next),this.geometry.setAttribute("side",this.attributes.side),this.geometry.setAttribute("width",this.attributes.width),this.geometry.setAttribute("uv",this.attributes.uv),this.geometry.setAttribute("counters",this.attributes.counters),this.geometry.setIndex(this.attributes.index)}advance(t){const e=this.attributes.position.array,n=this.attributes.previous.array,o=this.attributes.next.array,i=e.length;DA(e,0,n,0,i),DA(e,6,e,0,i-6),e[i-6]=t.x,e[i-5]=t.y,e[i-4]=t.z,e[i-3]=t.x,e[i-2]=t.y,e[i-1]=t.z,DA(e,6,o,0,i-6),o[i-6]=t.x,o[i-5]=t.y,o[i-4]=t.z,o[i-3]=t.x,o[i-2]=t.y,o[i-1]=t.z,this.attributes.position.needsUpdate=!0,this.attributes.previous.needsUpdate=!0,this.attributes.next.needsUpdate=!0}static updateAttributes(t){const e=t.attributes.position.array;t.attributes.previous.array,t.attributes.next.array;const n=new PA;n.positions=e,n.process(),t.attributes.previous=n.attributes.previous,t.attributes.previous.needsUpdate=!0,t.attributes.next=n.attributes.next,t.attributes.next.needsUpdate=!0}}class OA{constructor(t){this.headEdge=this.tailEdge=t,this.headIndex=t.index0,this.tailIndex=t.index1,this.indexCount=2}mergeStrip(t){const e=this.headIndex,n=t.headIndex,o=this.tailIndex,i=t.tailIndex;e==n?(this.headEdge.linkToEdge(t.headEdge),t.headEdge.linkToEdge(this.headEdge),this.headEdge=t.tailEdge,this.headIndex=t.tailIndex,this.indexCount+=t.indexCount-1):e==i?(this.headEdge.linkToEdge(t.tailEdge),t.tailEdge.linkToEdge(this.headEdge),this.headEdge=t.headEdge,this.headIndex=t.headIndex,this.indexCount+=t.indexCount-1):o==n?(this.tailEdge.linkToEdge(t.headEdge),t.headEdge.linkToEdge(this.tailEdge),this.tailEdge=t.tailEdge,this.tailIndex=t.tailIndex,this.indexCount+=t.indexCount-1):o==i&&(this.tailEdge.linkToEdge(t.tailEdge),t.tailEdge.linkToEdge(this.tailEdge),this.tailEdge=t.headEdge,this.tailIndex=t.headIndex,this.indexCount+=t.indexCount-1)}getIndicesFlat(){const t=new Float32Array(this.indexCount);let e=0,n=null,o=this.headEdge,i=t[e++]=this.headIndex;for(;null!==o;){i=o.index0==i?o.index1:o.index0,t[e++]=i;let r=o.edge0;r!=n&&null!==r||(r=o.edge1),r==n&&(r=null),n=o,o=r}return t}}class FA{constructor(t,e){this.index0=t,this.index1=e,this.edge0=null,this.edge1=null}linkToEdge(t){null===this.edge0?this.edge0=t:null===this.edge1&&(this.edge1=t)}}function UA(t,e,n){const o=t.headIndex,i=t.tailIndex;return e[o][0]||e[i][0]||n[o][0]||n[i][0]||null}class VA{constructor(){this.geometry=new Xo}fromBufferGeometry(t){const e=t.getAttribute("position"),n=t.getIndex();if(void 0===e)return;const o=[];if(null!==n){const t=function(t){const e=t.length%2?t.length-1:t.length,n={},o={};for(let i=0;i<e;i+=2){const e=new OA(new FA(t[i],t[i+1])),r=e.headIndex,s=e.tailIndex;n[r]=n[r]||[],n[s]=n[s]||[],o[r]=o[r]||[],o[s]=o[s]||[],n[r].push(e),o[s].push(e)}const i=new eu;for(const t in n)n[t].length&&i.push(new tu(n[t]),t);const r=[];let s=i.first&&i.first.value[0];for(;s;){let t=s.headIndex;n[t].splice(n[t].indexOf(s),1);let e=s.tailIndex;o[e].splice(o[e].indexOf(s),1),0==n[t].length&&i.removeNodeByKey(t);let a=UA(s,n,o);for(;null!==a;)t=a.headIndex,n[t].splice(n[t].indexOf(a),1),e=a.tailIndex,o[e].splice(o[e].indexOf(a),1),0==n[t].length&&i.removeNodeByKey(t),s.mergeStrip(a),a=UA(s,n,o);r.push(s),s=i.first&&i.first.value[0]}return r}(n.array);t.forEach(function(t){const n=new PA,i=new Float32Array(3*t.indexCount);t.getIndicesFlat().forEach(function(t,n){i.set(e.array.subarray(3*t,3*t+3),3*n)}),n.setGeometry(i),o.push(n)})}else{const t=new PA;t.setGeometry(e.array),o.push(t)}let i=[],r=[],s=[],a=[],l=[],c=[],u=[],h=[],f=0;o.forEach(function(t){i=i.concat(t.positions),r=r.concat(t.previous),s=s.concat(t.next),a=a.concat(t.side),l=l.concat(t.width),c=c.concat(t.uvs),u=u.concat(t.counters);const e=t.indices_array.map(function(t){return t+f});h=h.concat(e),f+=t.positions.length/3}),this.geometry.setAttribute("position",new Oo(new Float32Array(i),3)),this.geometry.setAttribute("previous",new Oo(new Float32Array(r),3)),this.geometry.setAttribute("next",new Oo(new Float32Array(s),3)),this.geometry.setAttribute("side",new Oo(new Float32Array(a),1)),this.geometry.setAttribute("width",new Oo(new Float32Array(l),1)),this.geometry.setAttribute("uv",new Oo(new Float32Array(c),2)),this.geometry.setAttribute("counters",new Oo(new Float32Array(u),1));const d=Me(h)>65535?Uint32Array:Uint16Array;this.geometry.setIndex(new Oo(new d(h),1))}}class GA extends Cr{constructor(t,e,n,o){super(),this.renderScene=e,this.renderCamera=n,this.selectedObjects=void 0!==o?o:[],this.visibleEdgeColor=new ln(1,1,1,1),this.hiddenEdgeColor=new ln(.1,.04,.02,1),this.edgeGlow=0,this.usePatternTexture=!1,this.edgeThickness=1,this.edgeStrength=3,this.downSampleRatio=2,this.pulsePeriod=0,this.renderToScreen=!1,this.resolution=void 0!==t?new we(t.x,t.y):new we(256,256);const i=Math.round(this.resolution.x/this.downSampleRatio),r=Math.round(this.resolution.y/this.downSampleRatio);this.renderTargetMaskBuffer=new cn(this.resolution.x,this.resolution.y),this.renderTargetMaskBuffer.texture.name="OutlinePass.mask",this.renderTargetMaskBuffer.texture.generateMipmaps=!1,this.renderTargetDepthBuffer=new cn(this.resolution.x,this.resolution.y),this.renderTargetDepthBuffer.texture.name="OutlinePass.depth",this.renderTargetDepthBuffer.texture.generateMipmaps=!1,this.renderTargetMaskDownSampleBuffer=new cn(i,r),this.renderTargetMaskDownSampleBuffer.texture.name="OutlinePass.depthDownSample",this.renderTargetMaskDownSampleBuffer.texture.generateMipmaps=!1,this.renderTargetBlurBuffer1=new cn(i,r),this.renderTargetBlurBuffer1.texture.name="OutlinePass.blur1",this.renderTargetBlurBuffer1.texture.generateMipmaps=!1,this.renderTargetBlurBuffer2=new cn(Math.round(i/2),Math.round(r/2)),this.renderTargetBlurBuffer2.texture.name="OutlinePass.blur2",this.renderTargetBlurBuffer2.texture.generateMipmaps=!1,this.edgeDetectionMaterial=this.getEdgeDetectionMaterial(),this.renderTargetEdgeBuffer1=new cn(i,r),this.renderTargetEdgeBuffer1.texture.name="OutlinePass.edge1",this.renderTargetEdgeBuffer1.texture.generateMipmaps=!1,this.renderTargetEdgeBuffer2=new cn(Math.round(i/2),Math.round(r/2)),this.renderTargetEdgeBuffer2.texture.name="OutlinePass.edge2",this.renderTargetEdgeBuffer2.texture.generateMipmaps=!1;this.separableBlurMaterial1=this.getSeparableBlurMaterial(4),this.separableBlurMaterial1.uniforms.texSize.value=new we(i,r),this.separableBlurMaterial1.uniforms.kernelRadius.value=1,this.separableBlurMaterial2=this.getSeparableBlurMaterial(4),this.separableBlurMaterial2.uniforms.texSize.value=new we(Math.round(i/2),Math.round(r/2)),this.separableBlurMaterial2.uniforms.kernelRadius.value=4,this.overlayMaterial=this.getOverlayMaterial();const s=Vi.copy;this.copyUniforms=pi.clone(s.uniforms),this.copyUniforms.opacity.value=1,this.materialCopy=new gi({defines:Object.assign({},s.defines),uniforms:this.copyUniforms,vertexShader:s.vertexShader,fragmentShader:s.fragmentShader,blending:0,depthTest:!1,depthWrite:!1,transparent:!0}),this.enabled=!0,this.needsSwap=!1,this.oldClearColor=new tn,this.oldClearAlpha=1,this.basic=new No({toneMapped:!1}),this.fsQuad=new Ir(null),this.camera=new Xi(-1,1,1,-1,0,1),this.tempPulseColor1=new ln,this.tempPulseColor2=new ln,this.textureMatrix=new Hn,this.visibilityState=new WeakMap,this._o=new fa({blending:0,depthPacking:Ut,side:2}),this.Eo=new jc({side:2})}dispose(){this.renderTargetMaskBuffer.dispose(),this.renderTargetDepthBuffer.dispose(),this.renderTargetMaskDownSampleBuffer.dispose(),this.renderTargetBlurBuffer1.dispose(),this.renderTargetBlurBuffer2.dispose(),this.renderTargetEdgeBuffer1.dispose(),this.renderTargetEdgeBuffer2.dispose()}setSize(t,e){this.renderTargetMaskBuffer.setSize(t,e);let n=Math.round(t/this.downSampleRatio),o=Math.round(e/this.downSampleRatio);this.renderTargetMaskDownSampleBuffer.setSize(n,o),this.renderTargetBlurBuffer1.setSize(n,o),this.renderTargetEdgeBuffer1.setSize(n,o),this.separableBlurMaterial1.uniforms.texSize.value=new we(n,o),n=Math.round(n/2),o=Math.round(o/2),this.renderTargetBlurBuffer2.setSize(n,o),this.renderTargetEdgeBuffer2.setSize(n,o),this.separableBlurMaterial2.uniforms.texSize.value=new we(n,o)}saveVisibilityState(){const t=this;t.renderScene.traverse(function(e){(e.isMesh||e.isSprite||e.isPoints||e.isLine)&&t.visibilityState.set(e,e.visible)})}restoreVisibilityState(){const t=this;t.renderScene.traverse(function(e){(e.isMesh||e.isSprite||e.isPoints||e.isLine)&&(e.visible=t.visibilityState.get(e))})}changeVisibilityOfSelectedObjects(t){const e=this;function n(n){(n.isMesh||n.isSprite||n.isPoints||n.isLine)&&e.visibilityState.get(n)&&(n.visible=t)}for(let t=0;t<e.selectedObjects.length;t++){const o=e.selectedObjects[t];n(o);const i=o.children;for(let t=0;t<i.length;t++){const e=i[t];e.isMesh&&e.isMaterialGeneratedMesh&&n(e)}}}changeVisibilityOfNonSelectedObjects(t){const e=this,n=[];function o(t){(t.isMesh||t.isSprite||t.isPoints||t.isLine)&&e.visibilityState.get(t)&&n.push(t)}for(let t=0;t<e.selectedObjects.length;t++){const n=e.selectedObjects[t];o(n);const i=n.children;for(let t=0;t<i.length;t++){const e=i[t];e.isMesh&&e.isMaterialGeneratedMesh&&o(e)}}e.renderScene.traverse(function(o){if((o.isMesh||o.isSprite||o.isPoints||o.isLine)&&e.visibilityState.get(o)){let e=!1;for(let t=0;t<n.length;t++){if(n[t].id===o.id){e=!0;break}}e||(o.visible=t)}})}updateTextureMatrix(){this.textureMatrix.set(.5,0,0,.5,0,.5,0,.5,0,0,.5,.5,0,0,0,1),this.textureMatrix.multiply(this.renderCamera.projectionMatrix),this.textureMatrix.multiply(this.renderCamera.matrixWorldInverse)}render(t,e,n,o,i){if(this.renderToScreen&&(this.fsQuad.material=this.basic,this.basic.map=n.texture,t.setRenderTarget(null),t.clear(),this.fsQuad.render(t)),0===this.selectedObjects.length)return;t.getClearColor(this.oldClearColor),this.oldClearAlpha=t.getClearAlpha();const r=t.autoClear;t.autoClear=!1,i&&t.context.disable(t.context.STENCIL_TEST),t.setClearColor(16777215,1);const s=this.renderScene.background;if(this.renderScene.background=null,this.renderScene.traverse(function(t){t.isAnnotationControl&&(t.Co=t.doUpdate,t.doUpdate=!1)}),this.saveVisibilityState(),t.setRenderTarget(this.renderTargetDepthBuffer),t.clear(),this.changeVisibilityOfSelectedObjects(!1),this.changeVisibilityOfNonSelectedObjects(!0),this.renderScene.overrideMaterial=this._o,t.render(this.renderScene,this.renderCamera),this.updateTextureMatrix(),t.setRenderTarget(this.renderTargetMaskBuffer),t.clear(),this.changeVisibilityOfSelectedObjects(!0),this.changeVisibilityOfNonSelectedObjects(!1),this.renderScene.overrideMaterial=this.Eo,this.renderScene.overrideMaterial.cameraNearFar=new we(this.renderCamera.near,this.renderCamera.far),this.renderScene.overrideMaterial.depthTexture=this.renderTargetDepthBuffer.texture,this.renderScene.overrideMaterial.textureMatrix=this.textureMatrix,t.render(this.renderScene,this.renderCamera),this.renderScene.overrideMaterial=null,this.restoreVisibilityState(),this.renderScene.background=s,this.fsQuad.material=this.materialCopy,this.copyUniforms.tDiffuse.value=this.renderTargetMaskBuffer.texture,t.setRenderTarget(this.renderTargetMaskDownSampleBuffer),t.clear(),this.fsQuad.render(t),this.tempPulseColor1.copy(this.visibleEdgeColor),this.tempPulseColor2.copy(this.hiddenEdgeColor),this.pulsePeriod>0){const t=.625+.75*Math.cos(.01*performance.now()/this.pulsePeriod)/2;this.tempPulseColor1.multiplyScalar(t),this.tempPulseColor2.multiplyScalar(t)}this.fsQuad.material=this.edgeDetectionMaterial,this.edgeDetectionMaterial.uniforms.maskTexture.value=this.renderTargetMaskDownSampleBuffer.texture,this.edgeDetectionMaterial.uniforms.texSize.value=new we(this.renderTargetMaskDownSampleBuffer.width,this.renderTargetMaskDownSampleBuffer.height),this.edgeDetectionMaterial.uniforms.visibleEdgeColor.value=this.tempPulseColor1,this.edgeDetectionMaterial.uniforms.hiddenEdgeColor.value=this.tempPulseColor2,t.setRenderTarget(this.renderTargetEdgeBuffer1),t.clear(),this.fsQuad.render(t),this.fsQuad.material=this.separableBlurMaterial1,this.separableBlurMaterial1.uniforms.colorTexture.value=this.renderTargetEdgeBuffer1.texture,this.separableBlurMaterial1.uniforms.direction.value=GA.BlurDirectionX,this.separableBlurMaterial1.uniforms.kernelRadius.value=this.edgeThickness,t.setRenderTarget(this.renderTargetBlurBuffer1),t.clear(),this.fsQuad.render(t),this.separableBlurMaterial1.uniforms.colorTexture.value=this.renderTargetBlurBuffer1.texture,this.separableBlurMaterial1.uniforms.direction.value=GA.BlurDirectionY,t.setRenderTarget(this.renderTargetEdgeBuffer1),t.clear(),this.fsQuad.render(t),this.fsQuad.material=this.separableBlurMaterial2,this.separableBlurMaterial2.uniforms.colorTexture.value=this.renderTargetEdgeBuffer1.texture,this.separableBlurMaterial2.uniforms.direction.value=GA.BlurDirectionX,t.setRenderTarget(this.renderTargetBlurBuffer2),t.clear(),this.fsQuad.render(t),this.separableBlurMaterial2.uniforms.colorTexture.value=this.renderTargetBlurBuffer2.texture,this.separableBlurMaterial2.uniforms.direction.value=GA.BlurDirectionY,t.setRenderTarget(this.renderTargetEdgeBuffer2),t.clear(),this.fsQuad.render(t),this.fsQuad.material=this.overlayMaterial,this.overlayMaterial.uniforms.maskTexture.value=this.renderTargetMaskBuffer.texture,this.overlayMaterial.uniforms.edgeTexture1.value=this.renderTargetEdgeBuffer1.texture,this.overlayMaterial.uniforms.edgeTexture2.value=this.renderTargetEdgeBuffer2.texture,this.overlayMaterial.uniforms.patternTexture.value=this.patternTexture,this.overlayMaterial.uniforms.edgeStrength.value=this.edgeStrength,this.overlayMaterial.uniforms.edgeGlow.value=this.edgeGlow,this.overlayMaterial.uniforms.usePatternTexture.value=this.usePatternTexture,i&&t.context.enable(t.context.STENCIL_TEST),this.renderToScreen?t.setRenderTarget(null):t.setRenderTarget(n),this.fsQuad.render(t),t.setClearColor(this.oldClearColor,this.oldClearAlpha),t.autoClear=r,this.renderScene.traverse(function(t){t.isAnnotationControl&&(t.doUpdate=t.Co)})}getEdgeDetectionMaterial(){return new gi({type:"OutlineEdgeDetection",defines:{HIDDEN_EDGE_ALPHA:1},uniforms:{maskTexture:{value:null},texSize:{value:new we(.5,.5)},visibleEdgeColor:{value:new ln(1,1,1,1)},hiddenEdgeColor:{value:new ln(1,1,1,1)}},vertexShader:Fi.pp_plane_vert,fragmentShader:Fi.pp_outline_edge_frag})}getSeparableBlurMaterial(t){return new gi({type:"OutlineSeparableBlur",defines:{MAX_RADIUS:t},uniforms:{colorTexture:{value:null},texSize:{value:new we(.5,.5)},direction:{value:new we(.5,.5)},kernelRadius:{value:1}},vertexShader:Fi.pp_plane_vert,fragmentShader:Fi.pp_outline_blur_frag})}getOverlayMaterial(){return new gi({type:"OutlineOverlay",uniforms:{maskTexture:{value:null},edgeTexture1:{value:null},edgeTexture2:{value:null},patternTexture:{value:null},edgeStrength:{value:1},edgeGlow:{value:1},usePatternTexture:{value:0}},vertexShader:Fi.pp_plane_vert,fragmentShader:Fi.pp_outline_overlay_frag,blending:5,blendEquation:a,blendEquationAlpha:a,blendSrc:A,blendDst:v,blendSrcAlpha:h,blendDstAlpha:h,depthTest:!1,depthWrite:!1,transparent:!0})}setCamera(t){this.renderCamera=t}}GA.BlurDirectionX=new we(1,0),GA.BlurDirectionY=new we(0,1);class QA extends Cr{constructor(t,e,n,o,i){super(),this.scene=t,this.camera=e,this.overrideMaterial=n,this.clearColor=o,this.clearAlpha=void 0!==i?i:0,this.clear=!0,this.clearDepth=!1,this.needsSwap=!1,this.mo=new tn}render(t,e,n){const o=t.autoClear;let i,r;t.autoClear=!1,void 0!==this.overrideMaterial&&(r=this.scene.overrideMaterial,this.scene.overrideMaterial=this.overrideMaterial),this.clearColor&&(t.getClearColor(this.mo),i=t.getClearAlpha(),t.setClearColor(this.clearColor,this.clearAlpha)),this.clearDepth&&t.clearDepth(),t.setRenderTarget(this.renderToScreen?null:n),this.clear&&t.clear(t.autoClearColor,t.autoClearDepth,t.autoClearStencil),t.render(this.scene,this.camera),this.clearColor&&t.setClearColor(this.mo,i),void 0!==this.overrideMaterial&&(this.scene.overrideMaterial=r),t.autoClear=o}setCamera(t){this.camera=t}}class zA{constructor(t,e,n,o,i){this.wo=t,this.xo=Array.isArray(e)?e:[e],this.Io=n,this.Mo=o,this.So=i,this.bo=0,this.yo=0,this.Ro=function(t){this.xo.includes(t.code)&&(this.bo||(this.bo=window.setTimeout(function(){this.yo=0,this.bo=null}.bind(this),1e3*i)),++this.yo>=o&&(this.bo&&(window.clearTimeout(this.bo),this.bo=null),this.yo=0,this.Io()))}.bind(this),this.wo.addEventListener("keydown",this.Ro,!1)}dispose(){this.wo.removeEventListener("keydown",this.Ro,!1),this.bo&&window.clearTimeout(this.bo)}}class kA extends Cr{constructor(t,e,n,o){super(),this.scene=t,this.camera=e,this.sampleLevel=4,this.unbiased=!0,this.clearColor=void 0!==n?n:0,this.clearAlpha=void 0!==o?o:0,this.mo=new tn;const i=Vi.copy;this.copyUniformsAccum=pi.clone(i.uniforms),this.copyMaterialAccum=new gi({type:"SSAACopyAccum",defines:Object.assign({},i.defines),uniforms:this.copyUniformsAccum,vertexShader:i.vertexShader,fragmentShader:i.fragmentShader,premultipliedAlpha:!0,transparent:!0,blending:2,depthTest:!1,depthWrite:!1}),this.fsQuadAccum=new Ir(this.copyMaterialAccum),this.copyUniformsFinal=pi.clone(i.uniforms),this.copyMaterialFinal=new gi({type:"SSAACopyFinal",defines:Object.assign({},i.defines),uniforms:this.copyUniformsFinal,vertexShader:i.vertexShader,fragmentShader:i.fragmentShader,premultipliedAlpha:!1,transparent:!1,blending:0,depthTest:!1,depthWrite:!1}),this.fsQuadFinal=new Ir(this.copyMaterialFinal),this.iterative=!1,this.iterativeFrame=0}To(){return HA[Math.max(0,Math.min(this.sampleLevel,5))]}Bo(){const t=this.To();return this.iterativeFrame==t.length-1}dispose(){this.sampleRenderTarget&&(this.sampleRenderTarget.dispose(),this.sampleRenderTarget=null,this.accumRenderTarget.dispose(),this.accumRenderTarget=null)}setSize(t,e){this.sampleRenderTarget&&(this.sampleRenderTarget.setSize(t,e),this.accumRenderTarget.setSize(t,e))}render(t,e,n){this.sampleRenderTarget||(this.sampleRenderTarget=n.clone(),this.sampleRenderTarget.texture.name="SSAARenderPass.sample",this.accumRenderTarget=n.clone(),this.accumRenderTarget.texture.name="SSAARenderPass.accum");const o=this.To(),i=t.autoClear;t.autoClear=!1,t.getClearColor(this.mo);const r=t.getClearAlpha(),s=1/o.length;this.copyUniformsAccum.tDiffuse.value=this.sampleRenderTarget.texture;const a=n.width,l=n.height,c=this.camera.view?this.camera.view.offsetX:0,u=this.camera.view?this.camera.view.offsetY:0;let h,f;this.iterative?(h=this.iterativeFrame,f=performance.now()):h=0;const d=o.length;for(let n=h;n<d;n++){this.dispatchEvent({type:"iteration",frame:n});const i=o[n];this.camera.setViewOffset&&this.camera.setViewOffset(a,l,c+.0625*i[0],u+.0625*i[1],a,l);let r=s;if(this.unbiased){r+=.03125*((n+.5)/o.length-.5)}if(this.copyUniformsAccum.opacity.value=r,t.setClearColor(this.clearColor,this.clearAlpha),t.setRenderTarget(this.sampleRenderTarget),t.clear(),t.render(this.scene,this.camera),this.iterative?t.setRenderTarget(this.accumRenderTarget):t.setRenderTarget(this.renderToScreen?null:e),0===n&&(t.setClearColor(0,0),t.clear()),this.fsQuadAccum.render(t),this.iterativeFrame=n,this.iterative&&performance.now()-f>4)break}this.iterative&&(this.Bo()?(this.copyUniformsFinal.tDiffuse.value=this.accumRenderTarget.texture,t.setRenderTarget(this.renderToScreen?null:e),this.fsQuadFinal.render(t),this.iterativeFrame=0):this.iterativeFrame++),this.camera.setViewOffset&&this.camera.setViewOffset(a,l,c,u,a,l),t.autoClear=i,t.setClearColor(this.mo,r)}setCamera(t){this.camera=t}}const HA=[[[0,0]],[[4,4],[-4,-4]],[[-2,-6],[6,-2],[-6,2],[2,6]],[[1,-3],[-1,3],[5,1],[-3,-5],[-5,5],[-7,-1],[3,7],[7,-7]],[[1,1],[-1,-3],[-3,2],[4,-1],[-5,-2],[2,5],[5,3],[3,-5],[-2,6],[0,-7],[-4,-6],[-6,4],[-8,0],[7,-4],[6,7],[-7,-8]],[[-4,-7],[-7,-5],[-3,-5],[-5,-4],[-1,-4],[-2,-2],[-6,-1],[-4,0],[-7,1],[-1,2],[-6,3],[-3,3],[-7,6],[-3,6],[-5,7],[-1,7],[5,-7],[1,-6],[6,-5],[4,-4],[2,-3],[7,-2],[1,-1],[4,-1],[2,1],[6,2],[0,4],[4,4],[2,5],[7,5],[5,6],[3,7]]];class WA extends Cr{constructor(t,e,n){var o,i,r,s,a,l,c,u,h,f;super(),this.enabled=!0,this.needsSwap=!1,n=n||{},this.objects=null!=(o=n.objects)?o:[],this.steps=null!=(i=n.steps)?i:100,this.stride=null!=(r=n.stride)?r:10,this.binarySearchSteps=null!=(s=n.binarySearchSteps)?s:4,this.renderTargetScale=null!=(a=n.renderTargetScale)?a:.5,this.maxDistance=null!=(l=n.maxDistance)?l:100,this.jitter=null!=(c=n.jitter)?c:1,this.useRefract=null!=(u=n.useRefract)&&u,this.renderAfter=null!=(h=n.renderAfter)?h:[],this.simpleRefraction=null!=(f=n.simpleRefraction)&&f,this.scene=t,this.camera=e,this.Lo=new tn,this.No=new cn(256,256,{minFilter:T,magFilter:T,format:K,type:Q}),this.No.texture.name="SSRPass.Depth",this.No.texture.generateMipmaps=!1,this._o=new fa,this._o.depthPacking=Vt,this.Do=this.No.clone(),this.Do.texture.name="SSRPass.Depth",this.Po=new fa,this.Po.depthPacking=Vt,this.Po.side=1,this.basic=new No,this.fsQuad=new Ir(null)}Oo(t,e){t.layers.set(e);for(let n=0;n<t.children.length;n++){const o=t.children[n];o.isMesh&&o.isMaterialGeneratedMesh&&o.layers.set(e)}t.isMesh&&t.isMaterialGeneratedMesh&&t.parent.layers.enable(e)}dispose(){this.No.dispose(),this.Do.dispose();for(let t=0;t<this.objects.length;t++){const e=this.objects[t],n=e.material;n&&(this.Oo(e,0),delete n.defines.USE_SSR,delete n.defines.USE_SSR_REFRACT,delete n.defines.SSR_SIMPLE_REFRACT,delete n.defines.MAX_STEPS,delete n.defines.BINARY_SEARCH_ITERATIONS,n.ssrParams=null,n.needsUpdate=!0)}this.objects.splice(0);for(let t=0;t<this.renderAfter.length;t++){const e=this.renderAfter[t];this.Oo(e,0)}this.renderAfter.splice(0)}setCamera(t){this.camera=t}setSize(t,e){t*=this.renderTargetScale,e*=this.renderTargetScale,this.No.setSize(t,e),this.Do.setSize(t,e)}Fo(t,e){t.ssrParams=t.ssrParams||{};const n=t.ssrParams;n.invProjectionMatrix=n.invProjectionMatrix||new Hn,n.invProjectionMatrix.copy(this.camera.projectionMatrix).invert(),n.sourceBuffer=e,n.depthBuffer=this.No,n.backfaceDepthBuffer=this.Do,n.stride=this.stride,n.maxDistance=this.maxDistance,n.jitter=this.jitter}render(t,e,n,o,i){t.getClearColor(this.Lo);const r=t.getClearAlpha(),s=t.autoClear;t.autoClear=!0,t.setClearColor(0,0);const a=this.scene.background;this.scene.background=null;const l=this.camera.layers.mask,c=this.camera.ignoreShadowLayers,u=this.scene.overrideMaterial;this.fsQuad.material=this.basic,this.basic.map=n.texture,t.setRenderTarget(e),t.clear(),this.fsQuad.render(t),this.camera.layers.enable(this.useRefract?3:5),this.useRefract&&this.simpleRefraction||(this.scene.overrideMaterial=this._o,t.setRenderTarget(this.No),t.clear(),t.render(this.scene,this.camera)),this.useRefract||(this.scene.overrideMaterial=this.Po,t.setRenderTarget(this.Do),t.clear(),t.render(this.scene,this.camera)),this.scene.overrideMaterial=u,this.scene.traverse(t=>{t.isLight&&(t.userData.oldLayersMask=t.layers.mask,t.layers.enable(this.useRefract?5:3),this.renderAfter.length&&t.layers.enable(this.useRefract?6:4))});for(let t=0;t<this.objects.length;t++){const n=this.objects[t],o=n.material;o&&o.isMeshNodeMaterial&&(this.Oo(n,this.useRefract?5:3),ye(o.defines.USE_SSR)||(o.defines.USE_SSR="",o.needsUpdate=!0),this.useRefract&&(ye(o.defines.USE_SSR_REFRACT)||(o.defines.USE_SSR_REFRACT="",o.needsUpdate=!0),this.simpleRefraction&&(ye(o.defines.SSR_SIMPLE_REFRACT)||(o.defines.SSR_SIMPLE_REFRACT="",o.needsUpdate=!0))),o.defines.MAX_STEPS!==this.steps&&(o.defines.MAX_STEPS=Math.floor(this.steps),o.needsUpdate=!0),o.defines.BINARY_SEARCH_ITERATIONS!==this.binarySearchSteps&&(o.defines.BINARY_SEARCH_ITERATIONS=Math.floor(this.binarySearchSteps),o.needsUpdate=!0),this.Fo(o,e))}for(let t=0;t<this.renderAfter.length;t++){const e=this.renderAfter[t];this.Oo(e,this.useRefract?6:4)}this.camera.layers.set(this.useRefract?5:3),this.camera.ignoreShadowLayers=!0,t.autoClear=!1,t.setRenderTarget(n),t.render(this.scene,this.camera),this.renderAfter.length&&(this.camera.layers.set(this.useRefract?6:4),t.render(this.scene,this.camera)),this.scene.background=a,this.camera.layers.mask=l,this.camera.ignoreShadowLayers=c,this.scene.traverse(t=>{t.isLight&&"oldLayersMask"in t.userData&&(t.layers.mask=t.userData.oldLayersMask,delete t.userData.oldLayersMask)}),this.renderToScreen&&(this.fsQuad.material=this.basic,this.basic.map=n.texture,t.setRenderTarget(null),t.clear(),this.fsQuad.render(t)),t.setClearColor(this.Lo,r),t.autoClear=s}}class YA extends Xd{constructor(){super(Vi.tonemap),this.material.type="ToneMap"}}var XA=function(t){return URL.createObjectURL(new Blob([t],{type:"text/javascript"}))};try{URL.revokeObjectURL(XA(""))}catch(t){XA=function(t){return"data:application/javascript;charset=UTF-8,"+encodeURI(t)}}var KA=Uint8Array,jA=Uint16Array,ZA=Uint32Array,qA=new KA([0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0,0,0,0]),JA=new KA([0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13,0,0]),$A=new KA([16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15]),tv=function(t,e){for(var n=new jA(31),o=0;o<31;++o)n[o]=e+=1<<t[o-1];var i=new ZA(n[30]);for(o=1;o<30;++o)for(var r=n[o];r<n[o+1];++r)i[r]=r-n[o]<<5|o;return[n,i]},ev=tv(qA,2),nv=ev[0],ov=ev[1];nv[28]=258,ov[258]=28;for(var iv=tv(JA,0)[1],rv=new jA(32768),sv=0;sv<32768;++sv){var av=(43690&sv)>>>1|(21845&sv)<<1;av=(61680&(av=(52428&av)>>>2|(13107&av)<<2))>>>4|(3855&av)<<4,rv[sv]=((65280&av)>>>8|(255&av)<<8)>>>1}var lv=function(t,e,n){for(var o=t.length,i=0,r=new jA(e);i<o;++i)++r[t[i]-1];var s,a=new jA(e);for(i=0;i<e;++i)a[i]=a[i-1]+r[i-1]<<1;if(n){s=new jA(1<<e);var l=15-e;for(i=0;i<o;++i)if(t[i])for(var c=i<<4|t[i],u=e-t[i],h=a[t[i]-1]++<<u,f=h|(1<<u)-1;h<=f;++h)s[rv[h]>>>l]=c}else for(s=new jA(o),i=0;i<o;++i)t[i]&&(s[i]=rv[a[t[i]-1]++]>>>15-t[i]);return s},cv=new KA(288);for(sv=0;sv<144;++sv)cv[sv]=8;for(sv=144;sv<256;++sv)cv[sv]=9;for(sv=256;sv<280;++sv)cv[sv]=7;for(sv=280;sv<288;++sv)cv[sv]=8;var uv=new KA(32);for(sv=0;sv<32;++sv)uv[sv]=5;var hv=lv(cv,9,0),fv=lv(uv,5,0),dv=function(t){return(t/8|0)+(7&t&&1)},Av=function(t,e,n){(null==n||n>t.length)&&(n=t.length);var o=new(t instanceof jA?jA:t instanceof ZA?ZA:KA)(n-e);return o.set(t.subarray(e,n)),o},vv=function(t,e,n){n<<=7&e;var o=e/8|0;t[o]|=n,t[o+1]|=n>>>8},mv=function(t,e,n){n<<=7&e;var o=e/8|0;t[o]|=n,t[o+1]|=n>>>8,t[o+2]|=n>>>16},pv=function(t,e){for(var n=[],o=0;o<t.length;++o)t[o]&&n.push({s:o,f:t[o]});var i=n.length,r=n.slice();if(!i)return[Iv,0];if(1==i){var s=new KA(n[0].s+1);return s[n[0].s]=1,[s,1]}n.sort(function(t,e){return t.f-e.f}),n.push({s:-1,f:25001});var a=n[0],l=n[1],c=0,u=1,h=2;for(n[0]={s:-1,f:a.f+l.f,l:a,r:l};u!=i-1;)a=n[n[c].f<n[h].f?c++:h++],l=n[c!=u&&n[c].f<n[h].f?c++:h++],n[u++]={s:-1,f:a.f+l.f,l:a,r:l};var f=r[0].s;for(o=1;o<i;++o)r[o].s>f&&(f=r[o].s);var d=new jA(f+1),A=gv(n[u-1],d,0);if(A>e){o=0;var v=0,m=A-e,p=1<<m;for(r.sort(function(t,e){return d[e.s]-d[t.s]||t.f-e.f});o<i;++o){var g=r[o].s;if(!(d[g]>e))break;v+=p-(1<<A-d[g]),d[g]=e}for(v>>>=m;v>0;){var _=r[o].s;d[_]<e?v-=1<<e-d[_]++-1:++o}for(;o>=0&&v;--o){var E=r[o].s;d[E]==e&&(--d[E],++v)}A=e}return[new KA(d),A]},gv=function(t,e,n){return-1==t.s?Math.max(gv(t.l,e,n+1),gv(t.r,e,n+1)):e[t.s]=n},_v=function(t){for(var e=t.length;e&&!t[--e];);for(var n=new jA(++e),o=0,i=t[0],r=1,s=function(t){n[o++]=t},a=1;a<=e;++a)if(t[a]==i&&a!=e)++r;else{if(!i&&r>2){for(;r>138;r-=138)s(32754);r>2&&(s(r>10?r-11<<5|28690:r-3<<5|12305),r=0)}else if(r>3){for(s(i),--r;r>6;r-=6)s(8304);r>2&&(s(r-3<<5|8208),r=0)}for(;r--;)s(i);r=1,i=t[a]}return[n.subarray(0,o),e]},Ev=function(t,e){for(var n=0,o=0;o<e.length;++o)n+=t[o]*e[o];return n},Cv=function(t,e,n){var o=n.length,i=dv(e+2);t[i]=255&o,t[i+1]=o>>>8,t[i+2]=255^t[i],t[i+3]=255^t[i+1];for(var r=0;r<o;++r)t[i+r+4]=n[r];return 8*(i+4+o)},wv=function(t,e,n,o,i,r,s,a,l,c,u){vv(e,u++,n),++i[256];for(var h=pv(i,15),f=h[0],d=h[1],A=pv(r,15),v=A[0],m=A[1],p=_v(f),g=p[0],_=p[1],E=_v(v),C=E[0],w=E[1],x=new jA(19),I=0;I<g.length;++I)x[31&g[I]]++;for(I=0;I<C.length;++I)x[31&C[I]]++;for(var M=pv(x,7),S=M[0],b=M[1],y=19;y>4&&!S[$A[y-1]];--y);var R,T,B,L,N=c+5<<3,D=Ev(i,cv)+Ev(r,uv)+s,P=Ev(i,f)+Ev(r,v)+s+14+3*y+Ev(x,S)+(2*x[16]+3*x[17]+7*x[18]);if(N<=D&&N<=P)return Cv(e,u,t.subarray(l,l+c));if(vv(e,u,1+(P<D)),u+=2,P<D){R=lv(f,d,0),T=f,B=lv(v,m,0),L=v;var O=lv(S,b,0);vv(e,u,_-257),vv(e,u+5,w-1),vv(e,u+10,y-4),u+=14;for(I=0;I<y;++I)vv(e,u+3*I,S[$A[I]]);u+=3*y;for(var F=[g,C],U=0;U<2;++U){var V=F[U];for(I=0;I<V.length;++I){var G=31&V[I];vv(e,u,O[G]),u+=S[G],G>15&&(vv(e,u,V[I]>>>5&127),u+=V[I]>>>12)}}}else R=hv,T=cv,B=fv,L=uv;for(I=0;I<a;++I)if(o[I]>255){G=o[I]>>>18&31;mv(e,u,R[G+257]),u+=T[G+257],G>7&&(vv(e,u,o[I]>>>23&31),u+=qA[G]);var Q=31&o[I];mv(e,u,B[Q]),u+=L[Q],Q>3&&(mv(e,u,o[I]>>>5&8191),u+=JA[Q])}else mv(e,u,R[o[I]]),u+=T[o[I]];return mv(e,u,R[256]),u+T[256]},xv=new ZA([65540,131080,131088,131104,262176,1048704,1048832,2114560,2117632]),Iv=new KA(0),Mv=function(){for(var t=new ZA(256),e=0;e<256;++e){for(var n=e,o=9;--o;)n=(1&n&&3988292384)^n>>>1;t[e]=n}return t}(),Sv=function(){var t=-1;return{p:function(e){for(var n=t,o=0;o<e.length;++o)n=Mv[255&n^e[o]]^n>>>8;t=n},d:function(){return~t}}},bv=function(t,e,n,o,i){return function(t,e,n,o,i,r){var s=t.length,a=new KA(o+s+5*(1+Math.ceil(s/7e3))+i),l=a.subarray(o,a.length-i),c=0;if(!e||s<8)for(var u=0;u<=s;u+=65535){var h=u+65535;h<s?c=Cv(l,c,t.subarray(u,h)):(l[u]=r,c=Cv(l,c,t.subarray(u,s)))}else{for(var f=xv[e-1],d=f>>>13,A=8191&f,v=(1<<n)-1,m=new jA(32768),p=new jA(v+1),g=Math.ceil(n/3),_=2*g,E=function(e){return(t[e]^t[e+1]<<g^t[e+2]<<_)&v},C=new ZA(25e3),w=new jA(288),x=new jA(32),I=0,M=0,S=(u=0,0),b=0,y=0;u<s;++u){var R=E(u),T=32767&u,B=p[R];if(m[T]=B,p[R]=T,b<=u){var L=s-u;if((I>7e3||S>24576)&&L>423){c=wv(t,l,0,C,w,x,M,S,y,u-y,c),S=I=M=0,y=u;for(var N=0;N<286;++N)w[N]=0;for(N=0;N<30;++N)x[N]=0}var D=2,P=0,O=A,F=T-B&32767;if(L>2&&R==E(u-F))for(var U=Math.min(d,L)-1,V=Math.min(32767,u),G=Math.min(258,L);F<=V&&--O&&T!=B;){if(t[u+D]==t[u+D-F]){for(var Q=0;Q<G&&t[u+Q]==t[u+Q-F];++Q);if(Q>D){if(D=Q,P=F,Q>U)break;var z=Math.min(F,Q-2),k=0;for(N=0;N<z;++N){var H=u-F+N+32768&32767,W=H-m[H]+32768&32767;W>k&&(k=W,B=H)}}}F+=(T=B)-(B=m[T])+32768&32767}if(P){C[S++]=268435456|ov[D]<<18|iv[P];var Y=31&ov[D],X=31&iv[P];M+=qA[Y]+JA[X],++w[257+Y],++x[X],b=u+D,++I}else C[S++]=t[u],++w[t[u]]}}c=wv(t,l,r,C,w,x,M,S,y,u-y,c)}return Av(a,0,o+dv(c)+i)}(t,null==e.level?6:e.level,null==e.mem?Math.ceil(1.5*Math.max(8,Math.min(13,Math.log(t.length)))):12+e.mem,n,o,!0)},yv=function(t,e){var n={};for(var o in t)n[o]=t[o];for(var o in e)n[o]=e[o];return n},Rv=function(t,e,n){for(;n;++e)t[e]=n,n>>>=8};function Tv(t,e){return bv(t,e||{},0,0)}var Bv=function(t,e,n,o){for(var i in t){var r=t[i],s=e+i;r instanceof KA?n[s]=[r,o]:Array.isArray(r)?n[s]=[r[0],yv(o,r[1])]:Bv(r,s+"/",n,o)}},Lv="undefined"!=typeof TextEncoder&&new TextEncoder,Nv="undefined"!=typeof TextDecoder&&new TextDecoder;try{Nv.decode(Iv,{stream:!0})}catch(t){}function Dv(t,e){if(Lv)return Lv.encode(t);for(var n=t.length,o=new KA(t.length+(t.length>>1)),i=0,r=function(t){o[i++]=t},s=0;s<n;++s){if(i+5>o.length){var a=new KA(i+8+(n-s<<1));a.set(o),o=a}var l=t.charCodeAt(s);l<128||e?r(l):l<2048?(r(192|l>>6),r(128|63&l)):l>55295&&l<57344?(r(240|(l=65536+(1047552&l)|1023&t.charCodeAt(++s))>>18),r(128|l>>12&63),r(128|l>>6&63),r(128|63&l)):(r(224|l>>12),r(128|l>>6&63),r(128|63&l))}return Av(o,0,i)}var Pv=function(t){var e=0;if(t)for(var n in t){var o=t[n].length;if(o>65535)throw"extra field too long";e+=o+4}return e},Ov=function(t,e,n,o,i,r,s,a){var l=o.length,c=n.extra,u=a&&a.length,h=Pv(c);Rv(t,e,null!=s?33639248:67324752),e+=4,null!=s&&(t[e++]=20,t[e++]=n.os),t[e]=20,e+=2,t[e++]=n.flag<<1|(null==r&&8),t[e++]=i&&8,t[e++]=255&n.compression,t[e++]=n.compression>>8;var f=new Date(null==n.mtime?Date.now():n.mtime),d=f.getFullYear()-1980;if(d<0||d>119)throw"date not in range 1980-2099";if(Rv(t,e,d<<25|f.getMonth()+1<<21|f.getDate()<<16|f.getHours()<<11|f.getMinutes()<<5|f.getSeconds()>>>1),e+=4,null!=r&&(Rv(t,e,n.crc),Rv(t,e+4,r),Rv(t,e+8,n.size)),Rv(t,e+12,l),Rv(t,e+14,h),e+=16,null!=s&&(Rv(t,e,u),Rv(t,e+6,n.attrs),Rv(t,e+10,s),e+=14),t.set(o,e),e+=l,h)for(var A in c){var v=c[A],m=v.length;Rv(t,e,+A),Rv(t,e+2,m),t.set(v,e+4),e+=4+m}return u&&(t.set(a,e),e+=u),e};function Fv(t,e){e||(e={});var n={},o=[];Bv(t,"",n,e);var i=0,r=0;for(var s in n){var a=n[s],l=a[0],c=a[1],u=0==c.level?0:8,h=(x=Dv(s)).length,f=c.comment,d=f&&Dv(f),A=d&&d.length,v=Pv(c.extra);if(h>65535)throw"filename too long";var m=u?Tv(l,c):l,p=m.length,g=Sv();g.p(l),o.push(yv(c,{size:l.length,crc:g.d(),c:m,f:x,m:d,u:h!=s.length||d&&f.length!=A,o:i,compression:u})),i+=30+h+v+p,r+=76+2*(h+v)+(A||0)+p}for(var _=new KA(r+22),E=i,C=r-i,w=0;w<o.length;++w){var x=o[w];Ov(_,x.o,x,x.f,x.u,x.c.length);var I=30+x.f.length+Pv(x.extra);_.set(x.c,x.o+I),Ov(_,i,x,x.f,x.u,x.c.length,x.o,x.m),i+=16+I+(x.m?x.m.length:0)}return function(t,e,n,o,i){Rv(t,e,101010256),Rv(t,e+8,n),Rv(t,e+10,n),Rv(t,e+12,o),Rv(t,e+16,i)}(_,i,o.length,C,E),_}function Uv(t,e,n){if("undefined"!=typeof HTMLImageElement&&t instanceof HTMLImageElement||"undefined"!=typeof HTMLCanvasElement&&t instanceof HTMLCanvasElement||"undefined"!=typeof OffscreenCanvas&&t instanceof OffscreenCanvas||"undefined"!=typeof ImageBitmap&&t instanceof ImageBitmap){const o=n/Math.max(t.width,t.height),i=document.createElement("canvas");i.width=t.width*Math.min(1,o),i.height=t.height*Math.min(1,o);const r=i.getContext("2d");return!0===e&&(r.translate(0,i.height),r.scale(1,-1)),r.drawImage(t,0,0,i.width,i.height),i}throw new Error("v3d.USDZExporter: No valid image data found. Unable to process texture.")}const Vv=7;function Gv(){return'#usda 1.0\n(\n    customLayerData = {\n        string creator = "Verge3D"\n    }\n    defaultPrim = "Root"\n    metersPerUnit = 1\n    upAxis = "Y"\n)\n\n'}function Qv(t){const e=t.elements;return`(${zv(e,0)}, ${zv(e,4)}, ${zv(e,8)}, ${zv(e,12)})`}function zv(t,e){return`(${t[e+0]}, ${t[e+1]}, ${t[e+2]}, ${t[e+3]})`}function kv(t,e){if(void 0===t)return console.warn("USDZExporter: Normals missing."),Array(e).fill("(0, 0, 0)").join(", ");const n=[];for(let e=0;e<t.count;e++){const o=t.getX(e),i=t.getY(e),r=t.getZ(e);n.push(`(${o.toPrecision(Vv)}, ${i.toPrecision(Vv)}, ${r.toPrecision(Vv)})`)}return n.join(", ")}function Hv(t){const e=[];for(let n=0;n<t.count;n++){const o=t.getX(n),i=t.getY(n);e.push(`(${o.toPrecision(Vv)}, ${1-i.toPrecision(Vv)})`)}return e.join(", ")}function Wv(t,e,n=!1){const o="            ",i=[],r=[];function s(o,i,r){const s=o.source.id+(o.flipY?"_flipped":"");e[s]=o;const a={1e3:"repeat",1001:"clamp",1002:"mirror"},l=o.repeat.clone(),c=o.offset.clone(),u=o.rotation,h=Math.sin(u),f=Math.cos(u);return c.y=1-c.y-l.y,n?(c.x=c.x/l.x,c.y=c.y/l.y,c.x+=h/l.x,c.y+=f-1):(c.x+=h*l.x,c.y+=(1-f)*l.y),`\n        def Shader "PrimvarReader_${i}"\n        {\n            uniform token info:id = "UsdPrimvarReader_float2"\n            float2 inputs:fallback = (0.0, 0.0)\n            token inputs:varname = "st"\n            float2 outputs:result\n        }\n\n        def Shader "Transform2d_${i}"\n        {\n            uniform token info:id = "UsdTransform2d"\n            token inputs:in.connect = </Materials/Material_${t.id}/PrimvarReader_${i}.outputs:result>\n            float inputs:rotation = ${(u*(180/Math.PI)).toFixed(Vv)}\n            float2 inputs:scale = ${Xv(l)}\n            float2 inputs:translation = ${Xv(c)}\n            float2 outputs:result\n        }\n\n        def Shader "Texture_${o.id}_${i}"\n        {\n            uniform token info:id = "UsdUVTexture"\n            asset inputs:file = @textures/Texture_${s}.png@\n            float2 inputs:st.connect = </Materials/Material_${t.id}/Transform2d_${i}.outputs:result>\n            ${void 0!==r?"float4 inputs:scale = "+function(t){return`(${t.r}, ${t.g}, ${t.b}, 1.0)`}(r):""}\n            token inputs:sourceColorSpace = "${o.encoding===Ot?"raw":"sRGB"}"\n            token inputs:wrapS = "${a[o.wrapS]}"\n            token inputs:wrapT = "${a[o.wrapT]}"\n            float outputs:r\n            float outputs:g\n            float outputs:b\n            float3 outputs:rgb\n            ${t.transparent||t.alphaTest>0?"float outputs:a":""}\n        }`}2===t.side&&console.warn("v3d.USDZExporter: USDZ does not support double sided materials",t);const a=t.isMeshNodeMaterial?t.getStandardProp("map"):t.map,l=t.isMeshNodeMaterial?t.getStandardProp("color"):t.color;null!==a?(i.push(`${o}color3f inputs:diffuseColor.connect = </Materials/Material_${t.id}/Texture_${a.id}_diffuse.outputs:rgb>`),t.transparent?i.push(`${o}float inputs:opacity.connect = </Materials/Material_${t.id}/Texture_${a.id}_diffuse.outputs:a>`):t.alphaTest>0&&(i.push(`${o}float inputs:opacity.connect = </Materials/Material_${t.id}/Texture_${a.id}_diffuse.outputs:a>`),i.push(`${o}float inputs:opacityThreshold = ${t.alphaTest}`)),r.push(s(a,"diffuse",l))):i.push(`${o}color3f inputs:diffuseColor = ${Yv(l)}`);const c=t.isMeshNodeMaterial?t.getStandardProp("emissiveMap"):t.emissiveMap,u=t.isMeshNodeMaterial?t.getStandardProp("emissiveIntensity"):t.emissiveIntensity;let h=t.isMeshNodeMaterial?t.getStandardProp("emissive"):t.emissive;h=h.clone().multiplyScalar(u),null!==c?(i.push(`${o}color3f inputs:emissiveColor.connect = </Materials/Material_${t.id}/Texture_${c.id}_emissive.outputs:rgb>`),r.push(s(c,"emissive"))):h.getHex()>0&&i.push(`${o}color3f inputs:emissiveColor = ${Yv(h)}`);const f=t.isMeshNodeMaterial?t.getStandardProp("normalMap"):t.normalMap;null!==f&&(i.push(`${o}normal3f inputs:normal.connect = </Materials/Material_${t.id}/Texture_${f.id}_normal.outputs:rgb>`),r.push(s(f,"normal")));const d=t.isMeshNodeMaterial?t.getStandardProp("aoMap"):t.aoMap;null!==d&&(i.push(`${o}float inputs:occlusion.connect = </Materials/Material_${t.id}/Texture_${d.id}_occlusion.outputs:r>`),r.push(s(d,"occlusion")));const A=t.isMeshNodeMaterial?t.getStandardProp("roughnessMap"):t.roughnessMap,v=t.isMeshNodeMaterial?t.getStandardProp("roughness"):t.roughness;null!==A&&1===v?(i.push(`${o}float inputs:roughness.connect = </Materials/Material_${t.id}/Texture_${A.id}_roughness.outputs:g>`),r.push(s(A,"roughness"))):i.push(`${o}float inputs:roughness = ${v}`);const m=t.isMeshNodeMaterial?t.getStandardProp("metalnessMap"):t.metalnessMap,p=t.isMeshNodeMaterial?t.getStandardProp("metalness"):t.metalness;null!==m&&1===p?(i.push(`${o}float inputs:metallic.connect = </Materials/Material_${t.id}/Texture_${m.id}_metallic.outputs:b>`),r.push(s(m,"metallic"))):i.push(`${o}float inputs:metallic = ${p}`);const g=t.isMeshNodeMaterial?t.getStandardProp("alphaMap"):t.alphaMap,_=t.isMeshNodeMaterial?t.getStandardProp("opacity"):t.opacity;return null!==g?(i.push(`${o}float inputs:opacity.connect = </Materials/Material_${t.id}/Texture_${g.id}_opacity.outputs:r>`),i.push(`${o}float inputs:opacityThreshold = 0.0001`),r.push(s(g,"opacity"))):i.push(`${o}float inputs:opacity = ${_}`),`\n    def Material "Material_${t.id}"\n    {\n        def Shader "PreviewSurface"\n        {\n            uniform token info:id = "UsdPreviewSurface"\n${i.join("\n")}\n            int inputs:useSpecularWorkflow = 0\n            token outputs:surface\n        }\n\n        token outputs:surface.connect = </Materials/Material_${t.id}/PreviewSurface.outputs:surface>\n\n${r.join("\n")}\n\n    }\n`}function Yv(t){return`(${t.r}, ${t.g}, ${t.b})`}function Xv(t){return`(${t.x}, ${t.y})`}class Kv extends Zt{constructor(t,e){super(),this.object=t,this.domElement=void 0!==e?e:document,this.enabled=!0,this.allowMouseOverIframes=!1,this.iframePointerEventsStatus=new WeakMap}lockIframeEvents(){const t=document.getElementsByTagName("iframe");for(let e=0;e<t.length;e++){const n=t[e];this.iframePointerEventsStatus.set(n,n.style.pointerEvents),n.style.pointerEvents="none"}}unlockIframeEvents(){const t=document.getElementsByTagName("iframe");for(let e=0;e<t.length;e++){const n=t[e],o=this.iframePointerEventsStatus.get(n)||"auto";n.style.pointerEvents=o}}}var jv={BACKSPACE:8,TAB:9,ENTER:13,SHIFT:16,CTRL:17,ALT:18,PAUSE_BREAK:19,CAPS_LOCK:20,ESCAPE:27,PAGE_UP:33,PAGE_DOWN:34,END:35,HOME:36,LEFT_ARROW:37,UP_ARROW:38,RIGHT_ARROW:39,DOWN_ARROW:40,INSERT:45,DELETE:46,0:48,1:49,2:50,3:51,4:52,5:53,6:54,7:55,8:56,9:57,A:65,B:66,C:67,D:68,E:69,F:70,G:71,H:72,I:73,J:74,K:75,L:76,M:77,N:78,O:79,P:80,Q:81,R:82,S:83,T:84,U:85,V:86,W:87,X:88,Y:89,Z:90,LEFT_WINDOW_KEY:91,RIGHT_WINDOW_KEY:92,SELECT_KEY:93,NUMPAD_0:96,NUMPAD_1:97,NUMPAD_2:98,NUMPAD_3:99,NUMPAD_4:100,NUMPAD_5:101,NUMPAD_6:102,NUMPAD_7:103,NUMPAD_8:104,NUMPAD_9:105,MULTIPLY:106,ADD:107,SUBTRACT:109,DECIMAL_POINT:110,DIVIDE:111,F1:112,F2:113,F3:114,F4:115,F5:116,F6:117,F7:118,F8:119,F9:120,F10:121,F11:122,F12:123,NUM_LOCK:144,SCROLL_LOCK:145,SEMI_COLON:186,EQUAL_SIGN:187,COMMA:188,DASH:189,PERIOD:190,FORWARD_SLASH:191,GRAVE_ACCENT:192,OPEN_BRACKET:219,BACK_SLASH:220,CLOSE_BRAKET:221,SINGLE_QUOTE:222};class Zv{constructor(t,e=null){this.isKeyDown={};for(const t in jv)this.isKeyDown[jv[t]]=!1;if(this.onKeyDown=null,this.onKeyUp=null,this.wo=t,this.Ro=function(t){this.isKeyDown[t.keyCode]=!0,this.onKeyDown&&this.onKeyDown(t)}.bind(this),this.Uo=function(t){this.isKeyDown[t.keyCode]=!1,this.onKeyUp&&this.onKeyUp(t)}.bind(this),this.Vo=function(t){this.Ro({keyCode:jv.W})}.bind(this),this.Go=function(t){this.Uo({keyCode:jv.W})}.bind(this),this.wo.addEventListener("keydown",this.Ro,!1),this.wo.addEventListener("keyup",this.Uo,!1),e&&Mi.isTouchDevice()){const t=document.createElement("div");t.className="v3d-mobile-forward",e.appendChild(t),t.addEventListener("touchstart",this.Vo),t.addEventListener("touchend",this.Go),this.Qo=t}}dispose(){this.wo.removeEventListener("keydown",this.Ro,!1),this.wo.removeEventListener("keyup",this.Uo,!1),this.Qo&&(this.Qo.removeEventListener("touchstart",this.Vo),this.Qo.removeEventListener("touchend",this.Go),this.Qo.remove())}}const qv=new An,Jv=new An,$v=new An;class tm{constructor(){this.posFrom=new An,this.targetFrom=new An,this.posTo=new An,this.targetTo=new An,this.sphericalFrom=new uu,this.sphericalTo=new uu,this.finishCb=function(){},this.movementType=0,this.active=!1,this.duration=0,this.clock=new If}setup({posFrom:t=new An,targetFrom:e=new An,posTo:n=new An,targetTo:o=new An,finishCb:i=function(){},movementType:r=0}){if(this.posFrom.copy(t),this.targetFrom.copy(e),this.posTo.copy(n),this.targetTo.copy(o),this.finishCb=i,this.movementType=r,1===this.movementType){qv.copy(this.posFrom).sub(this.targetFrom),this.sphericalFrom.setFromVector3(qv),qv.copy(this.posTo).sub(this.targetTo),this.sphericalTo.setFromVector3(qv);const t=ge(this.sphericalFrom.theta);let e=ge(this.sphericalTo.theta);const n=Math.abs(t-e);n>Math.PI&&(e=t+Math.sign(t-e)*(2*Math.PI-n)),this.sphericalFrom.theta=t,this.sphericalTo.theta=e}return this}start(t){this.active=!0,this.duration=t,this.clock.start()}update(t=function(t,e,n){}){let e=this.clock.getElapsedTime()/this.duration;if(e=ae(e,0,1),$v.lerpVectors(this.targetFrom,this.targetTo,e),0===this.movementType)Jv.lerpVectors(this.posFrom,this.posTo,e);else if(1===this.movementType){const t=se(this.sphericalFrom.radius,this.sphericalTo.radius,e),n=se(this.sphericalFrom.phi,this.sphericalTo.phi,e),o=se(this.sphericalFrom.theta,this.sphericalTo.theta,e);Jv.setFromSphericalCoords(t,n,o),Jv.add($v)}t(e,Jv,$v),e>=1&&(this.active=!1,this.finishCb())}}const em=new An;class nm{constructor(){this.posFrom=new An,this.targetFrom=new An,this.posTo=new An,this.targetTo=new An,this.zoomFrom=0,this.zoomTo=0,this.finishCb=function(){},this.active=!1,this.duration=0,this.clock=new If}setup({posFrom:t=new An,targetFrom:e=new An,posTo:n=new An,targetTo:o=new An,zoomFrom:i=0,zoomTo:r=0,finishCb:s=function(){}}){return this.posFrom.copy(t),this.targetFrom.copy(e),this.posTo.copy(n),this.targetTo.copy(o),this.zoomFrom=i,this.zoomTo=r,this.finishCb=s,this}start(t){this.active=!0,this.duration=t,this.clock.start()}update(t=function(t,e,n){}){let e=this.clock.getElapsedTime()/this.duration;e=ae(e,0,1),em.lerpVectors(this.targetFrom,this.targetTo,e);let n=se(this.zoomFrom,this.zoomTo,e);t(e,em,n),e>=1&&(this.active=!1,this.finishCb())}}const om={minDistance:0,maxDistance:1/0,minZoom:0,maxZoom:1/0,minPolarAngle:0,maxPolarAngle:Math.PI,minAzimuthAngle:-1/0,maxAzimuthAngle:1/0,autoRotate:!1,autoRotateSpeed:2,enablePan:!0,panInertia:.05,panSpeed:1.3,panSpeedKey:15,screenSpacePanning:!0,enableRotate:!0,rotateInertia:.05,rotateInertiaTouch:.05,rotateSpeed:1.2,rotateSpeedTouch:.7,enableZoom:!0,enableCtrlZoom:!1,zoomInertia:.05,zoomInertiaTouch:.05,zoomSpeed:5,zoomSpeedTouch:1,enableDamping:!0,enableTurnover:!1,enableKeys:!0},im=.1,rm=.1,sm=new An(0,1,0),am=(new dn).setFromAxisAngle(new An(0,0,1),Math.PI),lm=-1,cm=0,um=1,hm=2,fm=3,dm=4,Am=1e-6,vm=new An,mm=new An,pm=new dn,gm=new dn,_m={type:"change"},Em={type:"start"},Cm={type:"end"};class wm extends Kv{constructor(t,e){super(t,e),this.domElement.style.touchAction="none",this.targetObj=new mo,this.minDistance=om.minDistance,this.maxDistance=om.maxDistance,this.minZoom=om.minZoom,this.maxZoom=om.maxZoom,this.minPolarAngle=om.minPolarAngle,this.maxPolarAngle=om.maxPolarAngle,this.minAzimuthAngle=om.minAzimuthAngle,this.maxAzimuthAngle=om.maxAzimuthAngle,this.enableDamping=om.enableDamping,this.enableZoom=om.enableZoom,this.enableCtrlZoom=om.enableCtrlZoom,this.zoomSpeed=om.zoomSpeed,this.zoomSpeedTouch=om.zoomSpeedTouch,this.zoomInertia=om.zoomInertia,this.zoomInertiaTouch=om.zoomInertiaTouch,this.enableRotate=om.enableRotate,this.rotateSpeed=om.rotateSpeed,this.rotateSpeedTouch=om.rotateSpeedTouch,this.rotateInertia=om.rotateInertia,this.rotateInertiaTouch=om.rotateInertiaTouch,this.enablePan=om.enablePan,this.panSpeed=om.panSpeed,this.screenSpacePanning=om.screenSpacePanning,this.panSpeedKey=om.panSpeedKey,this.panInertia=om.panInertia,this.autoRotate=om.autoRotate,this.autoRotateSpeed=om.autoRotateSpeed,this.enableTurnover=om.enableTurnover,this.enableKeys=om.enableKeys,this.mouseButtons={ROTATE:s.LEFT,ZOOM:s.MIDDLE,PAN:s.RIGHT},this.target0=this.targetObj.position.clone(),this.position0=this.object.position.clone(),this.zoom0=this.object.zoom,Object.defineProperty(this,"inTween",{get:()=>R.active||T.active,set(t){R.active=t}}),this.getPolarAngle=function(){return i.phi},this.getAzimuthalAngle=function(){return i.theta},this.getDistance=function(){return this.object.position.distanceTo(this.targetObj.position)},this.saveState=function(){n.targetObj.updateWorldMatrix(!0,!1),n.target0.setFromMatrixPosition(n.targetObj.matrixWorld),n.position0.copy(n.object.position),n.zoom0=n.object.zoom},this.forceMouseUp=function(){Q()},this.reset=function(){n.targetObj.updateWorldMatrix(!0,!1);const t=vm.copy(n.target0);n.targetObj.worldToLocal(t),n.targetObj.position.add(t),n.object.position.copy(n.position0),n.object.zoom=n.zoom0,n.object.updateProjectionMatrix(),n.dispatchEvent(_m),n.update(),o=lm},this.update=function(){const t=new An,e=new An,s=new An,f=new dn;let d=!1,g=!1;return function(){const _=n.object.position;if(n.targetObj.updateWorldMatrix(!0,!1),R.active)R.update(function(e,o,i){if(_.copy(o),t.copy(i),n.object.lookAt(t),e>=1){r.set(0,0,0),l.set(0,0,0),a=1,C.set(0,0);for(let t in u)u[t]=0;v.set(0,0),y.getDelta()}});else if(T.active)T.update(function(e,o,i){if(t.copy(o),n.object.lookAt(t),n.object.zoom=i,n.object.updateProjectionMatrix(),e>=1){r.set(0,0,0),l.set(0,0,0),a=1,C.set(0,0);for(let t in u)u[t]=0;v.set(0,0),y.getDelta()}});else{t.setFromMatrixPosition(n.targetObj.matrixWorld),e.copy(_).sub(t);const s=pm.setFromUnitVectors(n.object.up,sm),c=gm.copy(s).invert();if(e.applyQuaternion(s),i.setFromVector3(e),n.autoRotate&&o===lm&&L(2*Math.PI/60/60*n.autoRotateSpeed),i.theta+=r.theta,i.phi+=r.phi,n.enableTurnover){d&&(i.phi-=2*r.phi),g!=d&&o==lm&&(g=d),g&&(i.theta-=2*r.theta);const t=i.phi;(t<=0||t>=Math.PI)&&(d=!d,i.theta+=Math.PI,i.phi=t>0?2*Math.PI-t:Math.abs(t))}else isFinite(n.minAzimuthAngle)&&isFinite(n.maxAzimuthAngle)&&(i.theta=Ee(i.theta,n.minAzimuthAngle,n.maxAzimuthAngle)),i.phi=Math.max(n.minPolarAngle,Math.min(n.maxPolarAngle,i.phi));i.makeSafe(),n.object.isPerspectiveCamera?(i.radius*=a,i.radius=Math.max(n.minDistance,Math.min(n.maxDistance,i.radius))):n.object.isOrthographicCamera&&(n.object.zoom/=a,n.object.zoom=Math.max(n.minZoom,Math.min(n.maxZoom,n.object.zoom)),n.object.updateProjectionMatrix()),t.add(l),e.setFromSpherical(i),e.applyQuaternion(c),_.copy(t).add(e),n.object.lookAt(t),d&&(n.enableTurnover?n.object.quaternion.multiply(am):d=!1),r.set(0,0,0),l.set(0,0,0),function(){const t=y.getDelta();let e,o;A.copy(v),v.x=n.enableDamping?pe(v.x,0,t,p,im):0,v.y=n.enableDamping?pe(v.y,0,t,p,im):0,A.sub(v),function(){const t=n.domElement===document?n.domElement.body:n.domElement,e=t.clientWidth,o=t.clientHeight;if(!e||!o)return;L(2*Math.PI*A.x/e*m),i=2*Math.PI*A.y/o*m,r.phi-=i;var i}(),E.copy(C),C.x=n.enableDamping?pe(C.x,0,t,n.panInertia,rm):0,C.y=n.enableDamping?pe(C.y,0,t,n.panInertia,rm):0,E.sub(C),E.multiplyScalar(n.panSpeed);for(let i in u)h.isKeyDown[i]?e=u[i]=1:(o=u[i],u[i]=pe(u[i],0,t,n.panInertia,rm),e=o-u[i]),n.enabled&&n.enableKeys&&n.enablePan&&(e*=60*t*n.panSpeedKey,i==jv.A||i==jv.LEFT_ARROW?E.x+=e:i==jv.D||i==jv.RIGHT_ARROW?E.x-=e:i==jv.W||i==jv.UP_ARROW?E.y+=e:i!=jv.S&&i!=jv.DOWN_ARROW||(E.y-=e));(function(t,e){const o=n.domElement===document?n.domElement.body:n.domElement,i=o.clientWidth,r=o.clientHeight;if(!i||!r)return;if(n.object.isPerspectiveCamera){n.targetObj.updateWorldMatrix(!0,!1);const o=vm.setFromMatrixPosition(n.targetObj.matrixWorld),i=n.object.position;let s=mm.copy(i).sub(o).length();s*=Math.tan(n.object.fov/2*Jt),D(2*t*s/r,n.object.matrix),P(2*e*s/r,n.object.matrix)}else n.object.isOrthographicCamera?(D(t*(n.object.right-n.object.left)/n.object.zoom/i,n.object.matrix),P(e*(n.object.top-n.object.bottom)/n.object.zoom/r,n.object.matrix)):(console.warn("WARNING: OrbitControls.js encountered an unknown camera type - pan disabled."),n.enablePan=!1)})(E.x,E.y),a=M,M=n.enableDamping?pe(M,1,t,b,.001):1,a/=M}()}return n.targetObj.position.copy(t),!!(c||s.distanceToSquared(n.object.position)>Am||8*(1-f.dot(n.object.quaternion))>Am)&&(n.dispatchEvent(_m),s.copy(n.object.position),f.copy(n.object.quaternion),c=!1,!0)}}(),this.dispose=function(){n.domElement.removeEventListener("contextmenu",Y),n.domElement.removeEventListener("mousedown",V),n.domElement.removeEventListener("wheel",z),n.domElement.removeEventListener("touchstart",k),n.domElement.removeEventListener("touchend",W),n.domElement.removeEventListener("touchmove",H),document.removeEventListener("mousemove",G),document.removeEventListener("mouseup",Q),document.removeEventListener("mouseleave",Q),h.dispose(),n.allowMouseOverIframes&&n.unlockIframeEvents()},this.tween=function(){const t=1e-5;return function(e,o,i,r,s){n.targetObj.updateWorldMatrix(!0,!1);const a=vm.setFromMatrixPosition(n.targetObj.matrixWorld);n.object.parent&&(e=mm.copy(e),n.object.parent.worldToLocal(e)),e.manhattanDistanceTo(n.object.position)<t&&o.manhattanDistanceTo(a)<t?void 0!==r&&r():R.setup({posFrom:n.object.position,targetFrom:a,posTo:e,targetTo:o,finishCb:r,movementType:s}).start(i)}}(),this.tweenZoomTo=function(t,e,o,i){if(!n.object.isOrthographicCamera)return void console.warn("v3d.OrbitControls: .tweenZoomTo() works only for orthographic camera");n.targetObj.updateWorldMatrix(!0,!1);const r=vm.setFromMatrixPosition(n.targetObj.matrixWorld);T.setup({zoomFrom:n.object.zoom,targetFrom:r,zoomTo:e,targetTo:t,finishCb:i}).start(o)};const n=this;let o=lm;const i=new uu,r=new uu;let a=1;const l=new An;let c=!1;const u={};u[jv.W]=u[jv.S]=u[jv.A]=u[jv.D]=u[jv.UP_ARROW]=u[jv.DOWN_ARROW]=u[jv.LEFT_ARROW]=u[jv.RIGHT_ARROW]=0;const h=new Zv(window);h.onKeyDown=function(t){n.enableKeys?t.keyCode in u&&(u[t.keyCode]=1):h.isKeyDown[t.keyCode]=!1};const f=new we,d=new we,A=new we,v=new we;let m=1,p=1;const g=new we,_=new we,E=new we,C=new we,w=new we,x=new we,I=new we;let M=1,S=1,b=1;const y=new If,R=new tm,T=new nm;function B(t=1){return Math.pow(.95,S*t)}function L(t){r.theta-=t}function N(t,e){d.set(t,e),v.add(d).sub(f),f.copy(d)}function D(t,e){vm.setFromMatrixColumn(e,0),vm.multiplyScalar(-t),l.add(vm)}function P(t,e){!0===n.screenSpacePanning?vm.setFromMatrixColumn(e,1):(vm.setFromMatrixColumn(e,0),vm.crossVectors(n.object.up,vm)),vm.multiplyScalar(t),l.add(vm)}function O(t){n.object.isPerspectiveCamera?M/=t:n.object.isOrthographicCamera?(M/=t,c=!0):(console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."),n.enableZoom=!1)}function F(t){n.object.isPerspectiveCamera?M*=t:n.object.isOrthographicCamera?(M*=t,c=!0):(console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."),n.enableZoom=!1)}function U(t){!function(t,e){_.set(t,e),C.add(_).sub(g),g.copy(_)}(t.clientX,t.clientY)}function V(t){if(!1!==n.enabled){switch(t.preventDefault(),t.button){case n.mouseButtons.ROTATE:if(!1===n.enableRotate)return;!function(t){f.set(t.clientX,t.clientY)}(t),o=cm;break;case n.mouseButtons.ZOOM:case n.mouseButtons.PAN:if(!1===n.enablePan)return;!function(t){g.set(t.clientX,t.clientY)}(t),o=hm}o!==lm&&(document.addEventListener("mousemove",G),document.addEventListener("mouseup",Q),document.addEventListener("mouseleave",Q),n.allowMouseOverIframes&&n.lockIframeEvents(),n.dispatchEvent(Em))}}function G(t){if(!1!==n.enabled)switch(t.preventDefault(),o){case cm:if(!1===n.enableRotate)return;!function(t){N(t.clientX,t.clientY),m=n.rotateSpeed,p=n.rotateInertia}(t);break;case um:if(!1===n.enableZoom)return;!function(t){x.set(t.clientX,t.clientY),I.subVectors(x,w),I.y>0?O(B()):I.y<0&&F(B()),w.copy(x),n.update()}(t);break;case hm:if(!1===n.enablePan)return;U(t)}}function Q(t){!1!==n.enabled&&(document.removeEventListener("mousemove",G),document.removeEventListener("mouseup",Q),document.removeEventListener("mouseleave",Q),n.allowMouseOverIframes&&n.unlockIframeEvents(),n.dispatchEvent(Cm),o=lm)}function z(t){!1===n.enabled||!1===n.enableZoom||o!==lm&&o!==cm||n.enableCtrlZoom&&!t.ctrlKey||(t.preventDefault(),t.stopPropagation(),n.dispatchEvent(Em),function(t){S=n.zoomSpeed,b=n.zoomInertia,t.deltaY<0?F(B(Math.abs(t.deltaY)/100)):t.deltaY>0&&O(B(Math.abs(t.deltaY)/100)),n.update()}(t),n.dispatchEvent(Cm))}function k(t){if(!1!==n.enabled){switch(t.touches.length){case 1:if(!1===n.enableRotate)return;!function(t){f.set(t.touches[0].pageX,t.touches[0].pageY)}(t),o=fm;break;case 2:if(!1===n.enableZoom&&!1===n.enablePan)return;!function(t){if(n.enableZoom){S=n.zoomSpeedTouch,b=n.zoomInertiaTouch;let e=t.touches[0].pageX-t.touches[1].pageX,o=t.touches[0].pageY-t.touches[1].pageY,i=Math.sqrt(e*e+o*o);w.set(0,i)}if(n.enablePan){let e=.5*(t.touches[0].pageX+t.touches[1].pageX),n=.5*(t.touches[0].pageY+t.touches[1].pageY);g.set(e,n)}n.update()}(t),o=dm;break;default:o=lm}o!==lm&&n.dispatchEvent(Em)}}function H(t){if(!1!==n.enabled)switch(t.preventDefault(),t.touches.length){case 1:if(!1===n.enableRotate)return;if(o!==fm)return;!function(t){N(t.touches[0].pageX,t.touches[0].pageY),m=n.rotateSpeedTouch,p=n.rotateInertiaTouch}(t);break;case 2:if(!1===n.enableZoom&&!1===n.enablePan)return;if(o!==dm)return;!function(t){let e=t.touches[0].pageX-t.touches[1].pageX,o=t.touches[0].pageY-t.touches[1].pageY,i=Math.sqrt(e*e+o*o);x.set(0,i),I.subVectors(x,w),w.copy(x);let r=.5*(t.touches[0].pageX+t.touches[1].pageX),s=.5*(t.touches[0].pageY+t.touches[1].pageY);_.set(r,s),E.subVectors(_,g),g.copy(_),n.enableZoom&&Math.abs(I.length())>Math.abs(E.length())&&(I.y>0?F(B()):I.y<0&&O(B())),n.enablePan&&Math.abs(I.length())<Math.abs(E.length())&&C.add(E),n.update()}(t);break;default:o=lm}}function W(t){!1!==n.enabled&&(n.dispatchEvent(Cm),o=lm)}function Y(t){!1!==n.enabled&&t.preventDefault()}n.domElement.addEventListener("contextmenu",Y),n.domElement.addEventListener("mousedown",V),n.domElement.addEventListener("wheel",z,{passive:!1}),n.domElement.addEventListener("touchstart",k,{passive:!0}),n.domElement.addEventListener("touchend",W),n.domElement.addEventListener("touchmove",H,{passive:!1}),this.update()}}const xm={enableCollisions:!0,gazeLevel:1.8,enablePan:!0,panInertia:.05,panSpeedKey:.15,enableRotate:!0,rotateInertia:.05,rotateInertiaTouch:.05,rotateSpeed:.9,rotateSpeedTouch:.75,storyHeight:3,enableZoom:!0,enableCtrlZoom:!1,zoomInertia:.05,zoomSpeed:30,zoomSpeedKey:.2,enableDamping:!0,enableKeys:!0},Im=.001,Mm=new we,Sm=new An,bm=new An,ym=new An;class Rm extends Kv{constructor(t,e){super(t,e),this.zo=new La(new An,new An(0,-1,0)),this.ko=!1,this.Ho=new An,this.Wo=xm.enableCollisions,this.Yo=new An,this.Xo=new An,this.Ko=new Hn,this.jo={point:new An,distance:0,faceIndex:0};const n=this;this.screen={left:0,top:0,width:0,height:0},this.enableDamping=xm.enableDamping,this.enableRotate=xm.enableRotate,this.rotateSpeed=xm.rotateSpeed,this.rotateSpeedTouch=xm.rotateSpeedTouch,this.rotateInertia=xm.rotateInertia,this.rotateInertiaTouch=xm.rotateInertiaTouch,this.enableZoom=xm.enableZoom,this.enableCtrlZoom=xm.enableCtrlZoom,this.zoomSpeed=xm.zoomSpeed,this.zoomSpeedKey=xm.zoomSpeedKey,this.zoomInertia=xm.zoomInertia,this.enablePan=xm.enablePan,this.panSpeedKey=xm.panSpeedKey,this.panInertia=xm.panInertia,this.enableKeys=xm.enableKeys,this.gazeLevel=xm.gazeLevel,this.storyHeight=xm.storyHeight,this.collisionMeshes=[],this.zo.params.checkVisibility=!1;let o=!1;Object.defineProperty(this,"enablePointerLock",{get:()=>o,set(t){o!==t&&(o=t,W())}}),Object.defineProperty(this,"inTween",{get:()=>b.active||y.active});const i=new If,r=1e-6,s=new An,a=new An,l=new An,c=new dn,u=new An,h={};let f;h[jv.W]=h[jv.S]=h[jv.A]=h[jv.D]=h[jv.UP_ARROW]=h[jv.DOWN_ARROW]=h[jv.LEFT_ARROW]=h[jv.RIGHT_ARROW]=0;let d=!1;const A=new uu,v=new uu,m=new we;let p=1,g=1;const _=new we,E=new we;let C=0,w=0,x=1,I=1;const M=new we,S=new we;const b=new tm,y=new nm,R={type:"change"},T={type:"start"},B={type:"end"};this.handleResize=function(){if(this.domElement===document)this.screen.left=0,this.screen.top=0,this.screen.width=window.innerWidth,this.screen.height=window.innerHeight;else{const t=this.domElement.getBoundingClientRect(),e=this.domElement.ownerDocument.documentElement;this.screen.left=t.left+window.pageXOffset-e.clientLeft,this.screen.top=t.top+window.pageYOffset-e.clientTop,this.screen.width=t.width,this.screen.height=t.height}},this.handleEvent=function(t){"function"==typeof this[t.type]&&this[t.type](t)};const L=function(t,e){return Mm.set((t-.5*n.screen.width-n.screen.left)/(.5*n.screen.width),(n.screen.height+2*(n.screen.top-e))/n.screen.width)};function N(t){!1!==n.enabled&&(t.preventDefault(),!1!==n.enableRotate&&(E.copy(L(t.pageX,t.pageY).negate()),_.copy(E),d=!0,document.addEventListener("mousemove",D),document.addEventListener("mouseup",P),document.addEventListener("mouseleave",P),n.allowMouseOverIframes&&n.lockIframeEvents(),n.dispatchEvent(T)))}function D(t){if(!1!==n.enabled&&(t.preventDefault(),d)){if(!1===n.enableRotate)return;E.copy(L(t.pageX,t.pageY).negate()),m.add(E).sub(_),_.copy(E),p=n.rotateSpeed,g=n.rotateInertia}}function P(t){!1!==n.enabled&&(t.preventDefault(),d=!1,document.removeEventListener("mousemove",D),document.removeEventListener("mouseup",P),document.removeEventListener("mouseleave",P),n.allowMouseOverIframes&&n.unlockIframeEvents(),n.dispatchEvent(B))}function O(t){if(!1!==n.enabled&&!1!==n.enableZoom&&(!n.enableCtrlZoom||t.ctrlKey)){switch(t.preventDefault(),t.stopPropagation(),t.deltaMode){case 2:w-=.025*t.deltaY,x=n.zoomSpeed,I=n.zoomInertia;break;case 1:w-=.01*t.deltaY,x=n.zoomSpeed,I=n.zoomInertia;break;default:w-=25e-5*t.deltaY,x=n.zoomSpeed,I=n.zoomInertia}n.dispatchEvent(T),n.dispatchEvent(B)}}function F(t){if(!1===n.enabled)return;const e=t.targetTouches[0];d=!0,E.copy(L(e.pageX,e.pageY).negate()),_.copy(E),n.dispatchEvent(T)}function U(t){if(!1===n.enabled)return;t.preventDefault();const e=t.targetTouches[0];!1!==n.enableRotate&&(E.copy(L(e.pageX,e.pageY).negate()),m.add(E).sub(_),_.copy(E),p=n.rotateSpeedTouch,g=n.rotateInertiaTouch)}function V(t){if(!1!==n.enabled){if(0===t.targetTouches.length)d=!1;else{if(!1===n.enableRotate)return;d=!0,E.copy(L(t.targetTouches[0].pageX,t.targetTouches[0].pageY).negate()),_.copy(E)}n.dispatchEvent(B)}}function G(t){!1!==n.enabled&&t.preventDefault()}function Q(t){n.domElement.requestPointerLock()}function z(t){document.pointerLockElement===n.domElement?(n.dispatchEvent(T),document.addEventListener("mousemove",H)):(n.dispatchEvent(B),document.removeEventListener("mousemove",H))}function k(t){console.error("Pointer lock failed")}function H(t){var e,o;(t.preventDefault(),n.enabled&&n.enableRotate)&&(m.add((e=t.movementX,o=t.movementY,Mm.set(e,-o).multiplyScalar(2/n.screen.width)).negate()),p=n.rotateSpeed,g=n.rotateInertia)}function W(){Y(),n.domElement.addEventListener("contextmenu",G),n.enablePointerLock?(n.domElement.addEventListener("click",Q),document.addEventListener("pointerlockchange",z),document.addEventListener("pointerlockerror",k)):n.domElement.addEventListener("mousedown",N),n.domElement.addEventListener("wheel",O,{passive:!1}),n.domElement.addEventListener("touchstart",F,{passive:!0}),n.domElement.addEventListener("touchend",V),n.domElement.addEventListener("touchmove",U,{passive:!1}),f=new Zv(window,n.domElement.parentElement),f.onKeyDown=function(t){n.enableKeys?t.keyCode in h&&(h[t.keyCode]=1):f.isKeyDown[t.keyCode]=!1}}function Y(){n.domElement.removeEventListener("contextmenu",G),n.domElement.removeEventListener("click",Q),document.removeEventListener("pointerlockchange",z),document.removeEventListener("pointerlockerror",k),document.removeEventListener("mousemove",H),n.domElement.removeEventListener("mousedown",N),n.domElement.removeEventListener("wheel",O),n.domElement.removeEventListener("touchstart",F),n.domElement.removeEventListener("touchend",V),n.domElement.removeEventListener("touchmove",U),document.removeEventListener("mousemove",D),document.removeEventListener("mouseup",P),document.removeEventListener("mouseleave",P),f&&f.dispose()}this.update=function(){b.active?b.update(function(t,e,o){if(n.object.position.copy(e),n.object.lookAt(o),t>=1){v.set(0,0,0),m.set(0,0),C=0,w=0,M.set(0,0),S.set(0,0);for(const t in h)h[t]=0;i.getDelta()}}):y.active?y.update(function(t,e,o){if(n.object.lookAt(e),n.object.zoom=o,n.object.updateProjectionMatrix(),t>=1){v.set(0,0,0),m.set(0,0),C=0,w=0,M.set(0,0),S.set(0,0);for(let t in h)h[t]=0;i.getDelta()}}):(n.object.matrixAutoUpdate&&n.object.updateMatrix(),n.object.getLocalDirection(u),A.setFromVector3(u),A.theta+=v.theta*p,A.phi+=v.phi*p,A.makeSafe(),u.setFromSpherical(A),s.copy(u).add(n.object.position),n.object.lookAtLocal(s),n.object.isPerspectiveCamera?n.object.position.addScaledVector(u,C):n.object.isOrthographicCamera&&(n.object.zoom*=1+.15*C,n.object.updateProjectionMatrix()),a.copy(u).cross(n.object.up).setLength(-M.x),a.add(l.copy(n.object.up).setLength(M.y)),n.object.position.add(a),function(){const t=i.getDelta();v.set(v.radius,m.y,m.x),m.x=n.enableDamping?pe(m.x,0,t,g,.001):0,m.y=n.enableDamping?pe(m.y,0,t,g,.001):0,v.set(v.radius,v.phi-m.y,v.theta-m.x),M.copy(S),S.x=n.enableDamping?pe(S.x,0,t,1,Im):0,S.y=n.enableDamping?pe(S.y,0,t,1,Im):0,M.sub(S),M.multiplyScalar(1),C=w,w=n.enableDamping?pe(w,0,t,I,.001):0,C-=w,C*=x;for(const e in h){const o=e==jv.A||e==jv.LEFT_ARROW||e==jv.D||e==jv.RIGHT_ARROW,i=e==jv.W||e==jv.UP_ARROW||e==jv.S||e==jv.DOWN_ARROW,r=o?n.panInertia:n.zoomInertia,s=o?n.panSpeedKey:n.zoomSpeedKey,a=o?Im:.001;let l;if(f.isKeyDown[e])l=h[e]=1;else{const n=h[e];h[e]=pe(h[e],0,t,r,a),l=n-h[e]}n.enabled&&n.enableKeys&&(o&&!n.enablePan||i&&!n.enableZoom||(l*=60*t*s,e==jv.A||e==jv.LEFT_ARROW?M.x+=l:e==jv.D||e==jv.RIGHT_ARROW?M.x-=l:e==jv.W||e==jv.UP_ARROW?C+=l:e!=jv.S&&e!=jv.DOWN_ARROW||(C-=l)))}}()),this.Zo();let t=!1;this.Ho.distanceToSquared(n.object.position)>r&&(this.Ho.copy(n.object.position),t=!0),c.dot(n.object.quaternion)<1-r&&(c.copy(n.object.quaternion),t=!0),t&&n.dispatchEvent(R)},this.forceMouseUp=function(){P({preventDefault:function(){}})},this.dispose=function(){Y(),n.allowMouseOverIframes&&n.unlockIframeEvents()},this.releaseFromCollision=function(){this.ko=!1},this.tween=function(t,e,o,i,r){n.object.parent&&(t=Sm.copy(t),n.object.parent.worldToLocal(t));const s=n.object.getWorldPosition(bm),a=ym.subVectors(e,s).length(),l=n.object.getWorldDirection(ym).multiplyScalar(a).add(s),c=1e-5;t.manhattanDistanceTo(n.object.position)<c&&e.manhattanDistanceTo(l)<c?void 0!==i&&i():b.setup({posFrom:n.object.position,targetFrom:l,posTo:t,targetTo:e,finishCb:i,movementType:r}).start(o)},this.tweenZoomTo=function(t,e,o,i){if(!n.object.isOrthographicCamera)return void console.warn("v3d.FirstPersonControls: .tweenZoomTo() works only for orthographic camera");const r=n.object.getWorldPosition(Sm),s=bm.subVectors(t,r).length(),a=n.object.getWorldDirection(bm).multiplyScalar(s).add(r);y.setup({zoomFrom:n.object.zoom,targetFrom:a,zoomTo:e,targetTo:t,finishCb:i}).start(o)},W(),this.handleResize(),this.update()}set enableCollisions(t){this.Wo=t,t||this.releaseFromCollision()}get enableCollisions(){return this.Wo}Zo(){if(!this.Wo||0==this.collisionMeshes.length)return;this.zo.ray.origin.copy(this.object.position),this.zo.far=this.storyHeight;const t=this.zo.intersectObjects(this.collisionMeshes,!1);if(t.length>0){const e=t[0];this.object.position.y=e.point.y+this.gazeLevel,this.ko=!0}else if(this.ko){let t=1/0;for(const e of this.collisionMeshes){if(!e.geometry.boundsTree){console.warn("v3d.FirstPersonControls: no bounding tree found on "+e.name);continue}this.Ko.copy(e.matrixWorld).invert(),this.Xo.copy(this.object.position),this.Xo.y-=this.gazeLevel,this.Xo.applyMatrix4(this.Ko);const n=this.jo;e.geometry.boundsTree.closestPointToPoint(this.Xo,n),n.distance<t&&(this.Yo.copy(n.point),this.Yo.applyMatrix4(e.matrixWorld),t=n.distance)}isFinite(t)?(this.object.position.copy(this.Yo),this.object.position.y+=this.gazeLevel):this.object.position.copy(this.Ho)}}}const Tm={panInertia:.05,panInertiaTouch:.05,panSpeed:20,panSpeedKey:.4,panSpeedTouch:15,rotateInertia:.05,rotateInertiaTouch:.05,rotateSpeed:.9,rotateSpeedTouch:.75,zoomInertia:.05,zoomInertiaTouch:.05,zoomSpeed:150,zoomSpeedKey:.5,zoomSpeedTouch:20,enableDamping:!0,enableRotate:!0,enableZoom:!0,enableCtrlZoom:!1,enablePan:!0,enableKeys:!0,minAzimuthAngle:-1/0,maxAzimuthAngle:1/0,minPolarAngle:0,maxPolarAngle:Math.PI},Bm=.001;class Lm extends Kv{constructor(t,e){super(t,e);var n=this,o=-1,i=0,r=1,a=2,l=3,c=4;this.screen={left:0,top:0,width:0,height:0},this.enableDamping=Tm.enableDamping,this.enableRotate=Tm.enableRotate,this.rotateSpeed=Tm.rotateSpeed,this.rotateSpeedTouch=Tm.rotateSpeedTouch,this.rotateInertia=Tm.rotateInertia,this.rotateInertiaTouch=Tm.rotateInertiaTouch,this.enableZoom=Tm.enableZoom,this.enableCtrlZoom=Tm.enableCtrlZoom,this.zoomSpeed=Tm.zoomSpeed,this.zoomSpeedKey=Tm.zoomSpeedKey,this.zoomSpeedTouch=Tm.zoomSpeedTouch,this.zoomInertia=Tm.zoomInertia,this.zoomInertiaTouch=Tm.zoomInertiaTouch,this.enablePan=Tm.enablePan,this.panSpeed=Tm.panSpeed,this.panSpeedKey=Tm.panSpeedKey,this.panSpeedTouch=Tm.panSpeedTouch,this.panInertia=Tm.panInertia,this.panInertiaTouch=Tm.panInertiaTouch,this.enableKeys=Tm.enableKeys,this.minAzimuthAngle=Tm.minAzimuthAngle,this.maxAzimuthAngle=Tm.maxAzimuthAngle,this.minPolarAngle=Tm.minPolarAngle,this.maxPolarAngle=Tm.maxPolarAngle,this.mouseButtons={ROTATE:s.LEFT,ZOOM:s.MIDDLE,PAN:s.RIGHT},Object.defineProperty(this,"inTween",{get:()=>Q.active||z.active});var u=new If,h=1e-6,f=new An,d=new An,A=new An,v=new we,m=new An,p=new dn,g=o,_=new An,E={};E[jv.W]=E[jv.S]=E[jv.A]=E[jv.D]=E[jv.UP_ARROW]=E[jv.DOWN_ARROW]=E[jv.LEFT_ARROW]=E[jv.RIGHT_ARROW]=0;var C=new Zv(window);C.onKeyDown=function(t){n.enableKeys?t.keyCode in E&&(E[t.keyCode]=1):C.isKeyDown[t.keyCode]=!1};var w=new uu,x=new uu,I=new we,M=1,S=1,b=new we,y=new we,R=0,T=0,B=1,L=1,N=0,D=0,P=new we,O=new we,F=1,U=1,V=new we,G=new we,Q=new tm;const z=new nm;var k={type:"change"},H={type:"start"},W={type:"end"};this.handleResize=function(){if(this.domElement===document)this.screen.left=0,this.screen.top=0,this.screen.width=window.innerWidth,this.screen.height=window.innerHeight;else{var t=this.domElement.getBoundingClientRect(),e=this.domElement.ownerDocument.documentElement;this.screen.left=t.left+window.pageXOffset-e.clientLeft,this.screen.top=t.top+window.pageYOffset-e.clientTop,this.screen.width=t.width,this.screen.height=t.height}},this.handleEvent=function(t){"function"==typeof this[t.type]&&this[t.type](t)};var Y,X,K,j,Z=(Y=new we,function(t,e){return Y.set((t-n.screen.left)/n.screen.width,(e-n.screen.top)/n.screen.height),Y}),q=function(){var t=new we;return function(e,o){return t.set((e-.5*n.screen.width-n.screen.left)/(.5*n.screen.width),(n.screen.height+2*(n.screen.top-o))/n.screen.width),t}}();function J(t){if(!1!==n.enabled){switch(t.preventDefault(),t.button){case n.mouseButtons.ROTATE:if(!1===n.enableRotate)return;y.copy(q(t.pageX,t.pageY).negate()),b.copy(y),g=i;break;case n.mouseButtons.ZOOM:case n.mouseButtons.PAN:if(!1===n.enablePan)return;V.copy(Z(t.pageX,t.pageY)),G.copy(V),g=t.button==n.mouseButtons.PAN?a:r}document.addEventListener("mousemove",$),document.addEventListener("mouseup",tt),document.addEventListener("mouseleave",tt),n.allowMouseOverIframes&&n.lockIframeEvents(),n.dispatchEvent(H)}}function $(t){if(!1!==n.enabled)if(t.preventDefault(),g===i){if(!1===n.enableRotate)return;y.copy(q(t.pageX,t.pageY).negate()),I.add(y).sub(b),b.copy(y),M=n.rotateSpeed,S=n.rotateInertia}else if(g===a||g===r){if(!1===n.enablePan)return;G.copy(Z(t.pageX,t.pageY)),O.add(G).sub(V),V.copy(G),F=n.panSpeed,U=n.panInertia}}function tt(t){!1!==n.enabled&&(t.preventDefault(),g=o,document.removeEventListener("mousemove",$),document.removeEventListener("mouseup",tt),document.removeEventListener("mouseleave",tt),n.allowMouseOverIframes&&n.unlockIframeEvents(),n.dispatchEvent(W))}function et(t){if(!1!==n.enabled&&!1!==n.enableZoom&&(!n.enableCtrlZoom||t.ctrlKey)){switch(t.preventDefault(),t.stopPropagation(),t.deltaMode){case 2:T-=.025*t.deltaY,B=n.zoomSpeed,L=n.zoomInertia;break;case 1:T-=.01*t.deltaY,B=n.zoomSpeed,L=n.zoomInertia;break;default:T-=25e-5*t.deltaY,B=n.zoomSpeed,L=n.zoomInertia}n.dispatchEvent(H),n.dispatchEvent(W)}}function nt(t){if(!1!==n.enabled){var e=t.touches[0],o=t.touches[1];if(1===t.touches.length){if(!1===n.enableRotate)return;g=l,y.copy(q(e.pageX,e.pageY).negate()),b.copy(y)}else{if(!1===n.enableZoom&&!1===n.enablePan)return;if(g=c,n.enableZoom){var i=Z(e.pageX-o.pageX,e.pageY-o.pageY);N=D=i.length()}if(n.enablePan){var r=Z((e.pageX+o.pageX)/2,(e.pageY+o.pageY)/2);V.copy(r),G.copy(V)}}n.dispatchEvent(H)}}function ot(t){if(!1!==n.enabled){t.preventDefault();var e=t.touches[0],o=t.touches[1];if(1===t.touches.length){if(!1===n.enableRotate)return;y.copy(q(e.pageX,e.pageY).negate()),I.add(y).sub(b),b.copy(y),M=n.rotateSpeedTouch,S=n.rotateInertiaTouch}else{if(!1===n.enableZoom&&!1===n.enablePan)return;var i=Z(e.pageX-o.pageX,e.pageY-o.pageY),r=(D=i.length())-N;N=D;var s=Z((e.pageX+o.pageX)/2,(e.pageY+o.pageY)/2);G.copy(s);var a=v.subVectors(G,V),l=a.length();V.copy(G),n.enableZoom&&Math.abs(r)>Math.abs(l)&&(T+=r,B=n.zoomSpeedTouch,L=n.zoomInertiaTouch),n.enablePan&&Math.abs(r)<=Math.abs(l)&&(O.add(a),F=n.panSpeedTouch,U=n.panInertiaTouch)}}}function it(t){if(!1!==n.enabled){switch(t.touches.length){case 0:g=o;break;case 1:if(!1===n.enableRotate)return;g=l,y.copy(q(t.touches[0].pageX,t.touches[0].pageY).negate()),b.copy(y)}n.dispatchEvent(W)}}function rt(t){!1!==n.enabled&&t.preventDefault()}this.update=(new An,function(){Q.active?Q.update(function(t,e,o){if(n.object.position.copy(e),n.object.lookAt(o),t>=1){for(var i in x.set(0,0,0),I.set(0,0),R=0,T=0,P.set(0,0),O.set(0,0),E)E[i]=0;u.getDelta()}}):z.active?z.update(function(t,e,o){if(n.object.lookAt(e),n.object.zoom=o,n.object.updateProjectionMatrix(),t>=1){x.set(0,0,0),I.set(0,0),R=0,T=0,P.set(0,0),O.set(0,0);for(let t in E)E[t]=0;u.getDelta()}}):(n.object.getLocalDirection(_),w.setFromVector3(_),w.theta+=x.theta*M,w.phi+=x.phi*M,w.theta=Math.max(n.minAzimuthAngle,Math.min(n.maxAzimuthAngle,w.theta)),w.phi=Math.max(n.minPolarAngle,Math.min(n.maxPolarAngle,w.phi)),w.makeSafe(),_.setFromSpherical(w),f.copy(_).add(n.object.position),n.object.lookAtLocal(f),n.object.isPerspectiveCamera?n.object.position.addScaledVector(_,R):n.object.isOrthographicCamera&&(n.object.zoom*=1+.15*R,n.object.updateProjectionMatrix()),d.copy(_).cross(n.object.up).setLength(-P.x),d.add(A.copy(n.object.up).setLength(P.y)),n.object.position.add(d),function(){var t=u.getDelta();for(var e in x.set(x.radius,I.y,I.x),I.x=n.enableDamping?pe(I.x,0,t,S,.001):0,I.y=n.enableDamping?pe(I.y,0,t,S,.001):0,x.set(x.radius,x.phi-I.y,x.theta-I.x),P.copy(O),O.x=n.enableDamping?pe(O.x,0,t,U,Bm):0,O.y=n.enableDamping?pe(O.y,0,t,U,Bm):0,P.sub(O),P.multiplyScalar(F),R=T,T=n.enableDamping?pe(T,0,t,L,.001):0,R-=T,R*=B,E){var o=e==jv.A||e==jv.LEFT_ARROW||e==jv.D||e==jv.RIGHT_ARROW,i=e==jv.W||e==jv.UP_ARROW||e==jv.S||e==jv.DOWN_ARROW,r=o?n.panInertia:n.zoomInertia,s=o?n.panSpeedKey:n.zoomSpeedKey,a=o?Bm:.001;if(C.isKeyDown[e])var l=E[e]=1;else{var c=E[e];E[e]=pe(E[e],0,t,r,a),l=c-E[e]}n.enabled&&n.enableKeys&&(o&&!n.enablePan||i&&!n.enableZoom||(l*=60*t*s,e==jv.A||e==jv.LEFT_ARROW?P.x+=l:e==jv.D||e==jv.RIGHT_ARROW?P.x-=l:e==jv.W||e==jv.UP_ARROW?R+=l:e!=jv.S&&e!=jv.DOWN_ARROW||(R-=l)))}}());var t=!1;m.distanceToSquared(n.object.position)>h&&(m.copy(n.object.position),t=!0),p.dot(n.object.quaternion)<1-h&&(p.copy(n.object.quaternion),t=!0),t&&n.dispatchEvent(k)}),this.forceMouseUp=function(){tt({preventDefault:function(){}})},this.dispose=function(){this.domElement.removeEventListener("contextmenu",rt),this.domElement.removeEventListener("mousedown",J),this.domElement.removeEventListener("wheel",et),this.domElement.removeEventListener("touchstart",nt),this.domElement.removeEventListener("touchend",it),this.domElement.removeEventListener("touchmove",ot),document.removeEventListener("mousemove",$),document.removeEventListener("mouseup",tt),document.removeEventListener("mouseleave",tt),C.dispose(),this.allowMouseOverIframes&&this.unlockIframeEvents()},this.tween=(X=new An,K=new An,j=new An,function(t,e,o,i,r){n.object.parent&&(t=X.copy(t),n.object.parent.worldToLocal(t));var s=n.object.getWorldPosition(K),a=j.subVectors(e,s).length(),l=n.object.getWorldDirection(j).multiplyScalar(a).add(s),c=1e-5;t.manhattanDistanceTo(n.object.position)<c&&e.manhattanDistanceTo(l)<c?void 0!==i&&i():Q.setup({posFrom:n.object.position,targetFrom:l,posTo:t,targetTo:e,finishCb:i,movementType:r}).start(o)}),this.tweenZoomTo=function(){const t=new An,e=new An;return function(o,i,r,s){if(!n.object.isOrthographicCamera)return void console.warn("v3d.FlyingControls: .tweenZoomTo() works only for orthographic camera");const a=n.object.getWorldPosition(t);let l=e.subVectors(o,a).length();const c=n.object.getWorldDirection(e).multiplyScalar(l).add(a);z.setup({zoomFrom:n.object.zoom,targetFrom:c,zoomTo:i,targetTo:o,finishCb:s}).start(r)}}(),this.domElement.addEventListener("contextmenu",rt),this.domElement.addEventListener("mousedown",J),this.domElement.addEventListener("wheel",et,{passive:!1}),this.domElement.addEventListener("touchstart",nt,{passive:!0}),this.domElement.addEventListener("touchend",it),this.domElement.addEventListener("touchmove",ot,{passive:!1}),this.handleResize(),this.update()}}const Nm={ORBIT:om,FIRST_PERSON:xm,FLYING:Tm};class Dm{constructor(t="ORBIT",e=!0,n=1,o=1){this.type=t,this.enablePan=e,this.enableZoom=!0,this.enableCtrlZoom=!1,this.enableKeys=!0,this.rotateSpeed=n,this.moveSpeed=o,this.orbitMinDistance=om.minDistance,this.orbitMaxDistance=om.maxDistance,this.orbitMinZoom=om.minZoom,this.orbitMaxZoom=om.maxZoom,this.orbitMinPolarAngle=om.minPolarAngle,this.orbitMaxPolarAngle=om.maxPolarAngle,this.orbitMinAzimuthAngle=om.minAzimuthAngle,this.orbitMaxAzimuthAngle=om.maxAzimuthAngle,this.orbitEnableTurnover=om.enableTurnover,this.orbitTarget=new mo,this.screenSpacePanning=om.screenSpacePanning,this.enableCollisions=xm.enableCollisions,this.collisionMaterial=null,this.gazeLevel=xm.gazeLevel,this.storyHeight=xm.storyHeight,this.enablePointerLock=!1}copy(t){return this.type=t.type,this.enablePan=t.enablePan,this.enableZoom=t.enableZoom,this.enableCtrlZoom=t.enableCtrlZoom,this.enableKeys=t.enableKeys,this.rotateSpeed=t.rotateSpeed,this.moveSpeed=t.moveSpeed,this.orbitMinDistance=t.orbitMinDistance,this.orbitMaxDistance=t.orbitMaxDistance,this.orbitMinZoom=t.orbitMinZoom,this.orbitMaxZoom=t.orbitMaxZoom,this.orbitMinPolarAngle=t.orbitMinPolarAngle,this.orbitMaxPolarAngle=t.orbitMaxPolarAngle,this.orbitMinAzimuthAngle=t.orbitMinAzimuthAngle,this.orbitMaxAzimuthAngle=t.orbitMaxAzimuthAngle,this.orbitEnableTurnover=t.orbitEnableTurnover,this.orbitTarget=t.orbitTarget,this.screenSpacePanning=t.screenSpacePanning,this.enableCollisions=t.enableCollisions,this.collisionMaterial=t.collisionMaterial,this.gazeLevel=t.gazeLevel,this.storyHeight=t.storyHeight,this.enablePointerLock=t.enablePointerLock,this}clone(){return(new this.constructor).copy(this)}assignToControls(t,e){const n=Nm[this.type];switch(this.type){case"ORBIT":t.targetObj=this.orbitTarget,t.minDistance=this.orbitMinDistance,t.maxDistance=this.orbitMaxDistance,t.minZoom=this.orbitMinZoom,t.maxZoom=this.orbitMaxZoom,t.minPolarAngle=this.orbitMinPolarAngle,t.maxPolarAngle=this.orbitMaxPolarAngle,t.minAzimuthAngle=this.orbitMinAzimuthAngle,t.maxAzimuthAngle=this.orbitMaxAzimuthAngle,t.enableTurnover=this.orbitEnableTurnover,t.screenSpacePanning=this.screenSpacePanning;break;case"FLYING":t.panSpeedTouch=n.panSpeedTouch*this.moveSpeed,t.zoomSpeedKey=n.zoomSpeedKey*this.moveSpeed;break;case"FIRST_PERSON":t.enableCollisions=this.enableCollisions,t.gazeLevel=this.gazeLevel,t.storyHeight=this.storyHeight,t.zoomSpeedKey=n.zoomSpeedKey*this.moveSpeed,t.enablePointerLock=this.enablePointerLock;const o=this;t.collisionMeshes=[],e.traverse(function(e){const n=e.material;n&&o.collisionMaterial&&n.name==o.collisionMaterial.name&&t.collisionMeshes.push(e)});break;default:return void console.error("ControlSettings: unsupported control type")}t.enablePan=this.enablePan,t.enableZoom=this.enableZoom,t.enableCtrlZoom=this.enableCtrlZoom,t.enableKeys=this.enableKeys,t.rotateSpeed=n.rotateSpeed*this.rotateSpeed,t.rotateSpeedTouch=n.rotateSpeedTouch*this.rotateSpeed,t.panSpeed=n.panSpeed*this.moveSpeed,t.panSpeedKey=n.panSpeedKey*this.moveSpeed,t.zoomSpeed=n.zoomSpeed*this.moveSpeed,t.zoomSpeedTouch=n.zoomSpeedTouch*this.moveSpeed}}function Pm(t,e=!1){const n=null!==t[0].index,o=new Set(Object.keys(t[0].attributes)),i=new Set(Object.keys(t[0].morphAttributes)),r={},s={},a=t[0].morphTargetsRelative,l=new Xo;let c=0;for(let u=0;u<t.length;++u){const h=t[u];let f=0;if(n!==(null!==h.index))return console.error("v3d.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index "+u+". All geometries must have compatible attributes; make sure index attribute exists among all geometries, or in none of them."),null;for(const t in h.attributes){if(!o.has(t))return console.error("v3d.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index "+u+'. All geometries must have compatible attributes; make sure "'+t+'" attribute exists among all geometries, or in none of them.'),null;void 0===r[t]&&(r[t]=[]),r[t].push(h.attributes[t]),f++}if(f!==o.size)return console.error("v3d.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index "+u+". Make sure all geometries have the same number of attributes."),null;if(a!==h.morphTargetsRelative)return console.error("v3d.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index "+u+". .morphTargetsRelative must be consistent throughout all geometries."),null;for(const t in h.morphAttributes){if(!i.has(t))return console.error("v3d.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index "+u+".  .morphAttributes must be consistent throughout all geometries."),null;void 0===s[t]&&(s[t]=[]),s[t].push(h.morphAttributes[t])}if(e){let t;if(n)t=h.index.count;else{if(void 0===h.attributes.position)return console.error("v3d.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index "+u+". The geometry must have either an index or a position attribute"),null;t=h.attributes.position.count}l.addGroup(c,t,u),c+=t}}if(n){let e=0;const n=[];for(let o=0;o<t.length;++o){const i=t[o].index;for(let t=0;t<i.count;++t)n.push(i.getX(t)+e);e+=t[o].attributes.position.count}l.setIndex(n)}for(const t in r){const e=Om(r[t]);if(!e)return console.error("v3d.BufferGeometryUtils: .mergeBufferGeometries() failed while trying to merge the "+t+" attribute."),null;l.setAttribute(t,e)}for(const t in s){const e=s[t][0].length;if(0===e)break;l.morphAttributes=l.morphAttributes||{},l.morphAttributes[t]=[];for(let n=0;n<e;++n){const e=[];for(let o=0;o<s[t].length;++o)e.push(s[t][o][n]);const o=Om(e);if(!o)return console.error("v3d.BufferGeometryUtils: .mergeBufferGeometries() failed while trying to merge the "+t+" morphAttribute."),null;l.morphAttributes[t].push(o)}}return l.morphTargetsRelative=a,l}function Om(t){let e,n,o,i=-1,r=0;for(let s=0;s<t.length;++s){const a=t[s];if(void 0===e&&(e=a.array.constructor),e!==a.array.constructor)return console.error("v3d.BufferGeometryUtils: .mergeBufferAttributes() failed. BufferAttribute.array must be of consistent array types across matching attributes."),null;if(void 0===n&&(n=a.itemSize),n!==a.itemSize)return console.error("v3d.BufferGeometryUtils: .mergeBufferAttributes() failed. BufferAttribute.itemSize must be consistent across matching attributes."),null;if(void 0===o&&(o=a.normalized),o!==a.normalized)return console.error("v3d.BufferGeometryUtils: .mergeBufferAttributes() failed. BufferAttribute.normalized must be consistent across matching attributes."),null;if(-1===i&&(i=a.gpuType),i!==a.gpuType)return console.error("v3d.BufferGeometryUtils: .mergeBufferAttributes() failed. BufferAttribute.gpuType must be consistent across matching attributes."),null;r+=a.array.length}const s=new e(r),a=new Oo(s,n,o);let l=0;for(let e=0;e<t.length;++e)s.set(t[e].array,l),l+=t[e].array.length;return void 0!==i&&(a.gpuType=i),a}function Fm(t){return t.isInstancedBufferAttribute?(new InstancedBufferAttribute).copy(t):(new Oo).copy(t)}function Um(t,e){if(0===e)return console.warn("v3d.BufferGeometryUtils.toTrianglesDrawMode(): Geometry already defined as triangles."),t;if(2===e||1===e){let n=t.getIndex();if(null===n){const e=[],o=t.getAttribute("position");if(void 0===o)return console.error("v3d.BufferGeometryUtils.toTrianglesDrawMode(): Undefined position attribute. Processing not possible."),t;for(let t=0;t<o.count;t++)e.push(t);t.setIndex(e),n=t.getIndex()}const o=n.count-2,i=[];if(2===e)for(let t=1;t<=o;t++)i.push(n.getX(0)),i.push(n.getX(t)),i.push(n.getX(t+1));else for(let t=0;t<o;t++)t%2==0?(i.push(n.getX(t)),i.push(n.getX(t+1)),i.push(n.getX(t+2))):(i.push(n.getX(t+2)),i.push(n.getX(t+1)),i.push(n.getX(t)));i.length/3!==o&&console.error("v3d.BufferGeometryUtils.toTrianglesDrawMode(): Unable to generate correct amount of triangles.");const r=t.clone();return r.setIndex(i),r.clearGroups(),r}return console.error("v3d.BufferGeometryUtils.toTrianglesDrawMode(): Unknown draw mode:",e),t}function Vm(t){if(0===t.groups.length)return console.warn("v3d.BufferGeometryUtils.mergeGroups(): No groups are defined. Nothing to merge."),t;let e=t.groups;if(e=e.sort((t,e)=>t.materialIndex!==e.materialIndex?t.materialIndex-e.materialIndex:t.start-e.start),null===t.getIndex()){const e=t.getAttribute("position"),n=[];for(let t=0;t<e.count;t+=3)n.push(t,t+1,t+2);t.setIndex(n)}const n=t.getIndex(),o=[];for(let t=0;t<e.length;t++){const i=e[t],r=i.start,s=r+i.count;for(let t=r;t<s;t++)o.push(n.getX(t))}t.dispose(),t.setIndex(o);let i=0;for(let t=0;t<e.length;t++){const n=e[t];n.start=i,i+=n.count}let r=e[0];t.groups=[r];for(let n=1;n<e.length;n++){const o=e[n];r.materialIndex===o.materialIndex?r.count+=o.count:(r=o,t.groups.push(r))}return t}var Gm=Object.freeze({__proto__:null,batchMeshes:function(t,e){const n={};for(let e=0;e<t.length;e++){const o=t[e],i=o.geometry,r=o.material;let s=[];s.push(r.name),s.push(o.visible),s.push(o.disableChildRendering),s.push(o.castShadow),s.push(o.receiveShadow),s.push(o.renderOrder),s=s.concat(o.groupNames);const a=Object.keys(i.attributes);s=s.concat(a);const l=Object.keys(i.morphAttributes);s=s.concat(l),s=s.join(),n[s]=n[s]||[],-1==n[s].indexOf(o)&&n[s].push(o)}for(let t in n){const o=n[t];if(o.length<2)continue;const i=[];let r=!0;for(let t=0;t<o.length;t++){const e=o[t],n=e.geometry;e.updateWorldMatrix(!0,!1),i.push(n.clone().applyMatrix4(e.matrixWorld)),n.boundsTree||(r=!1)}const s=o[0],a=s.material,l=`${a.name}_x${o.length}_batch`,c=Pm(i);if(c){const t=new hi(c,a);t.name=l,t.visible=s.visible,t.disableChildRendering=s.disableChildRendering,t.castShadow=s.castShadow,t.receiveShadow=s.receiveShadow,t.renderOrder=s.renderOrder,t.groupNames=s.groupNames;for(let t=0;t<o.length;t++){const e=o[t];e.parent.remove(e)}r&&c.computeBoundsTree({verbose:!1}),console.log("Adding batch object:",l),e.add(t)}else console.warn("Failed to create batch object:",l)}},computeMikkTSpaceTangents:function(t,e,n=!0){console.error("v3d.BufferGeometryUtils.computeMikkTSpaceTangents has been removed in Verge3D 4.11")},computeMorphedAttributes:function(t){if(!0!==t.geometry.isBufferGeometry)return console.error("v3d.BufferGeometryUtils: Geometry is not of type BufferGeometry."),null;const e=new An,n=new An,o=new An,i=new An,r=new An,s=new An,a=new An,l=new An,c=new An;function u(t,u,h,f,d,A,v,m){e.fromBufferAttribute(u,d),n.fromBufferAttribute(u,A),o.fromBufferAttribute(u,v);const p=t.morphTargetInfluences;if(h&&p){a.set(0,0,0),l.set(0,0,0),c.set(0,0,0);for(let t=0,u=h.length;t<u;t++){const u=p[t],m=h[t];0!==u&&(i.fromBufferAttribute(m,d),r.fromBufferAttribute(m,A),s.fromBufferAttribute(m,v),f?(a.addScaledVector(i,u),l.addScaledVector(r,u),c.addScaledVector(s,u)):(a.addScaledVector(i.sub(e),u),l.addScaledVector(r.sub(n),u),c.addScaledVector(s.sub(o),u)))}e.add(a),n.add(l),o.add(c)}t.isSkinnedMesh&&(t.boneTransform(d,e),t.boneTransform(A,n),t.boneTransform(v,o)),m[3*d+0]=e.x,m[3*d+1]=e.y,m[3*d+2]=e.z,m[3*A+0]=n.x,m[3*A+1]=n.y,m[3*A+2]=n.z,m[3*v+0]=o.x,m[3*v+1]=o.y,m[3*v+2]=o.z}const h=t.geometry,f=t.material;let d,A,v;const m=h.index,p=h.attributes.position,g=h.morphAttributes.position,_=h.morphTargetsRelative,E=h.attributes.normal,C=h.morphAttributes.normal,w=h.groups,x=h.drawRange;let I,M,S,b,y,R,T;const B=new Float32Array(p.count*p.itemSize),L=new Float32Array(E.count*E.itemSize);if(null!==m)if(Array.isArray(f))for(I=0,S=w.length;I<S;I++)for(y=w[I],R=Math.max(y.start,x.start),T=Math.min(y.start+y.count,x.start+x.count),M=R,b=T;M<b;M+=3)d=m.getX(M),A=m.getX(M+1),v=m.getX(M+2),u(t,p,g,_,d,A,v,B),u(t,E,C,_,d,A,v,L);else for(R=Math.max(0,x.start),T=Math.min(m.count,x.start+x.count),I=R,S=T;I<S;I+=3)d=m.getX(I),A=m.getX(I+1),v=m.getX(I+2),u(t,p,g,_,d,A,v,B),u(t,E,C,_,d,A,v,L);else if(Array.isArray(f))for(I=0,S=w.length;I<S;I++)for(y=w[I],R=Math.max(y.start,x.start),T=Math.min(y.start+y.count,x.start+x.count),M=R,b=T;M<b;M+=3)d=M,A=M+1,v=M+2,u(t,p,g,_,d,A,v,B),u(t,E,C,_,d,A,v,L);else for(R=Math.max(0,x.start),T=Math.min(p.count,x.start+x.count),I=R,S=T;I<S;I+=3)d=I,A=I+1,v=I+2,u(t,p,g,_,d,A,v,B),u(t,E,C,_,d,A,v,L);return{positionAttribute:p,normalAttribute:E,morphedPositionAttribute:new Vo(B,3),morphedNormalAttribute:new Vo(L,3)}},deepCloneAttribute:Fm,deinterleaveAttribute:function(){console.error("v3d.BufferGeometryUtils.deinterleaveAttribute has been removed in Verge3D 4.10")},deinterleaveGeometry:function(){console.error("v3d.BufferGeometryUtils.deinterleaveGeometry has been removed in Verge3D 4.10")},estimateBytesUsed:function(t){let e=0;for(const n in t.attributes){const o=t.getAttribute(n);e+=o.count*o.itemSize*o.array.BYTES_PER_ELEMENT}const n=t.getIndex();return e+=n?n.count*n.itemSize*n.array.BYTES_PER_ELEMENT:0,e},interleaveAttributes:function(){console.error("v3d.BufferGeometryUtils.interleaveAttributes has been removed in Verge3D 4.10")},mergeBufferAttributes:Om,mergeBufferGeometries:Pm,mergeGroups:Vm,mergeVertices:function(t,e=1e-4){e=Math.max(e,Number.EPSILON);const n={},o=t.getIndex(),i=t.getAttribute("position"),r=o?o.count:i.count;let s=0;const a=Object.keys(t.attributes),l={},c={},u=[],h=["getX","getY","getZ","getW"],f=["setX","setY","setZ","setW"];for(let e=0,n=a.length;e<n;e++){const n=a[e],o=t.attributes[n];l[n]=new Oo(new o.array.constructor(o.count*o.itemSize),o.itemSize,o.normalized);const i=t.morphAttributes[n];i&&(c[n]=new Oo(new i.array.constructor(i.count*i.itemSize),i.itemSize,i.normalized))}const d=Math.log10(1/e),A=Math.pow(10,d);for(let e=0;e<r;e++){const i=o?o.getX(e):e;let r="";for(let e=0,n=a.length;e<n;e++){const n=a[e],o=t.getAttribute(n),s=o.itemSize;for(let t=0;t<s;t++)r+=~~(o[h[t]](i)*A)+","}if(r in n)u.push(n[r]);else{for(let e=0,n=a.length;e<n;e++){const n=a[e],o=t.getAttribute(n),r=t.morphAttributes[n],u=o.itemSize,d=l[n],A=c[n];for(let t=0;t<u;t++){const e=h[t],n=f[t];if(d[n](s,o[e](i)),r)for(let t=0,o=r.length;t<o;t++)A[t][n](s,r[t][e](i))}}n[r]=s,u.push(s),s++}}const v=t.clone();for(const e in t.attributes){const t=l[e];if(v.setAttribute(e,new Oo(t.array.slice(0,s*t.itemSize),t.itemSize,t.normalized)),e in c)for(let t=0;t<c[e].length;t++){const n=c[e][t];v.morphAttributes[e][t]=new Oo(n.array.slice(0,s*n.itemSize),n.itemSize,n.normalized)}}return v.setIndex(u),v},toCreasedNormals:function(t,e=Math.PI/3){const n=Math.cos(e),o=100*(1+1e-10),i=[new An,new An,new An],r=new An,s=new An,a=new An,l=new An;function c(t){return`${~~(t.x*o)},${~~(t.y*o)},${~~(t.z*o)}`}const u=t.toNonIndexed(),h=u.attributes.position,f={};for(let t=0,e=h.count/3;t<e;t++){const e=3*t,n=i[0].fromBufferAttribute(h,e+0),o=i[1].fromBufferAttribute(h,e+1),a=i[2].fromBufferAttribute(h,e+2);r.subVectors(a,o),s.subVectors(n,o);const l=(new An).crossVectors(r,s).normalize();for(let t=0;t<3;t++){const e=c(i[t]);e in f||(f[e]=[]),f[e].push(l)}}const d=new Float32Array(3*h.count),A=new Oo(d,3,!1);for(let t=0,e=h.count/3;t<e;t++){const e=3*t,o=i[0].fromBufferAttribute(h,e+0),u=i[1].fromBufferAttribute(h,e+1),d=i[2].fromBufferAttribute(h,e+2);r.subVectors(d,u),s.subVectors(o,u),a.crossVectors(r,s).normalize();for(let t=0;t<3;t++){const o=f[c(i[t])];l.set(0,0,0);for(let t=0,e=o.length;t<e;t++){const e=o[t];a.dot(e)>n&&l.add(e)}l.normalize(),A.setXYZ(e+t,l.x,l.y,l.z)}}return u.setAttribute("normal",A),u},toTrianglesDrawMode:Um});const Qm=["alphaMap","aoMap","bumpMap","displacementMap","emissiveMap","envMap","lightMap","map","metalnessMap","normalMap","roughnessMap"];function zm(t){if(Qm.forEach(function(e){t[e]&&t[e].isTexture&&t[e].dispose()}),"MeshNodeMaterial"==t.type)for(const e in t.nodeTextures)t.nodeTextures[e]&&t.nodeTextures[e].dispose()}function km(t,e,n){const o=new nu,i={};if(o.addNode(ch("LIGHT_PATH_BL","Light Path")),o.addNode(ch("TEX_ENVIRONMENT_BL","Lighting Texture",{texture:e})),i[Ch("TEX_ENVIRONMENT_BL",0)]=e,n instanceof tn){const t=n.toArray([0,0,0,1]);o.addNode(ch("RGB_BL","Background Color",{outputs:[t]}))}else o.addNode(ch("TEX_ENVIRONMENT_BL","Background  Texture",{texture:n})),i[Ch("TEX_ENVIRONMENT_BL",1)]=n;return o.addNode(ch("MIX_BL","Mix")),_h(o,0,lh.LIGHT_PATH_BL.isCameraRay,3,ah.MIX_BL.fac),_h(o,1,lh.TEX_ENVIRONMENT_BL.color,3,ah.MIX_BL.col1),_h(o,2,lh[uh(o.node(2))].color,3,ah.MIX_BL.col2),o.addNode(ch("BACKGROUND_BL","Background")),_h(o,3,lh.MIX_BL.col,4,ah.BACKGROUND_BL.color),o.addNode(ch("OUTPUT_WORLD_BL","Output")),_h(o,4,lh.BACKGROUND_BL.color,5,ah.OUTPUT_WORLD_BL.surface),new Ph({name:t,nodeGraph:o,nodeTextures:i})}function Hm(t,e,n,o="blender"){let i=new nu;switch(o){case"blender":if(n<1){i.addNode(ch("BSDF_TRANSPARENT_BL","Transparent"));const t=ch("DIFFUSE_BSDF_BL","Diffuse");e.toArray(t.originData.inputs[ah.DIFFUSE_BSDF_BL.color]),i.addNode(t);const o=ch("MIX_SHADER_BL","Mix");o.originData.inputs[ah.MIX_SHADER_BL.fac]=n,i.addNode(o),_h(i,0,lh.BSDF_TRANSPARENT_BL.color,2,ah.MIX_SHADER_BL.color1),_h(i,1,lh.DIFFUSE_BSDF_BL.color,2,ah.MIX_SHADER_BL.color2)}else{const t=ch("DIFFUSE_BSDF_BL","Diffuse");e.toArray(t.originData.inputs[ah.DIFFUSE_BSDF_BL.color]),i.addNode(t)}i.addNode(ch("OUTPUT_MATERIAL_BL","Output")),_h(i,i.len()-2,lh[uh(i.node(i.len()-2))].color,i.len()-1,ah.OUTPUT_MATERIAL_BL.surface);break;case"max":const t=ch("LAMBERT_AR","Diffuse");t.originData.inputs[ah.LAMBERT_AR.base]=1,e.toArray(t.originData.inputs[ah.LAMBERT_AR.baseColor]),t.originData.inputs[ah.LAMBERT_AR.opacity][0]=n,t.originData.inputs[ah.LAMBERT_AR.opacity][1]=n,t.originData.inputs[ah.LAMBERT_AR.opacity][2]=n,i.addNode(t),i.addNode(ch("OUTPUT_MX","Output")),_h(i,0,lh.LAMBERT_AR.color,1,ah.OUTPUT_MX.color);break;case"maya":const r=ch("LAMBERT_MY","Diffuse");e.toArray(r.originData.inputs[ah.LAMBERT_MY.color]),r.originData.inputs[ah.LAMBERT_MY.diffuse]=1,r.originData.inputs[ah.LAMBERT_MY.transparency][0]=1-n,r.originData.inputs[ah.LAMBERT_MY.transparency][1]=1-n,r.originData.inputs[ah.LAMBERT_MY.transparency][2]=1-n,i.addNode(r),i.addNode(ch("SHADING_ENGINE_MY","Output")),_h(i,0,lh.LAMBERT_MY.color,1,ah.SHADING_ENGINE_MY.surface);break;default:console.error("createDiffuseMaterial: Incorrect material profile - "+o),i=null}return new Ph({name:t,nodeGraph:i,profile:o})}var Wm=Object.freeze({__proto__:null,createDiffuseMaterial:Hm,createEnvironmentMaterial:km,createStandardPBRMaterial:function(t="blender",e={}){var n,o,i,r,s,a,l;let c=new nu,u=null!=(n=e.color)?n:"white",h=null!=(o=e.emissive)?o:"black";const f=null!=(i=e.opacity)?i:1,d=null!=(r=e.metalness)?r:0,A=null!=(s=e.roughness)?s:1,v=null!=(a=e.emissiveIntensity)?a:1;let m,p;switch(u instanceof tn||(u=new tn(u)),h instanceof tn||(h=new tn(h)),t){case"blender":m=ch("RGB_BL","color"),u.toArray(m.originData.outputs[lh.RGB_BL.color]),c.addNode(m),p=ch("RGB_BL","emissive"),h.toArray(p.originData.outputs[lh.RGB_BL.color]),c.addNode(p),c.addNode(ch("VALUE_BL","opacity",{outputs:[f]})),c.addNode(ch("VALUE_BL","metalness",{outputs:[d]})),c.addNode(ch("VALUE_BL","roughness",{outputs:[A]})),c.addNode(ch("VALUE_BL","emissiveIntensity",{outputs:[v]})),c.addNode(ch("BSDF_PRINCIPLED_BL","Shader")),_h(c,0,lh.RGB_BL.color,6,ah.BSDF_PRINCIPLED_BL.baseColor),_h(c,1,lh.RGB_BL.color,6,ah.BSDF_PRINCIPLED_BL.emission),_h(c,2,lh.VALUE_BL.value,6,ah.BSDF_PRINCIPLED_BL.alpha),_h(c,3,lh.VALUE_BL.value,6,ah.BSDF_PRINCIPLED_BL.metallic),_h(c,4,lh.VALUE_BL.value,6,ah.BSDF_PRINCIPLED_BL.roughness),_h(c,5,lh.VALUE_BL.value,6,ah.BSDF_PRINCIPLED_BL.emissionStrength),c.addNode(ch("OUTPUT_MATERIAL_BL","Output")),_h(c,6,lh.BSDF_PRINCIPLED_BL.color,7,ah.OUTPUT_MATERIAL_BL.surface);break;case"max":m=ch("RGB_MX","color"),u.toArray(m.originData.outputs[lh.RGB_MX.color]),c.addNode(m),p=ch("RGB_MX","emissive"),h.toArray(p.originData.outputs[lh.RGB_BL.color]),c.addNode(p),c.addNode(ch("VALUE_MX","opacity",{outputs:[f]})),c.addNode(ch("VALUE_MX","metalness",{outputs:[d]})),c.addNode(ch("VALUE_MX","roughness",{outputs:[A]})),c.addNode(ch("VALUE_MX","emissiveIntensity",{outputs:[v]})),c.addNode(ch("PHYSICAL_MX","Shader")),_h(c,0,lh.RGB_MX.color,6,ah.PHYSICAL_MX.baseColor),_h(c,1,lh.RGB_MX.color,6,ah.PHYSICAL_MX.emitColor),_h(c,2,lh.VALUE_BL.value,6,ah.PHYSICAL_MX.opacity),_h(c,3,lh.VALUE_MX.value,6,ah.PHYSICAL_MX.metalness),_h(c,4,lh.VALUE_MX.value,6,ah.PHYSICAL_MX.roughness),_h(c,5,lh.VALUE_MX.value,6,ah.PHYSICAL_MX.emission),c.addNode(ch("OUTPUT_MX","Output")),_h(c,6,lh.PHYSICAL_MX.color,7,ah.OUTPUT_MX.color);break;case"maya":m=ch("COLOR_CONSTANT_MY","color"),u.toArray(m.originData.inputs[ah.COLOR_CONSTANT_MY.color]),u.toArray(m.originData.outputs[ah.COLOR_CONSTANT_MY.color]),c.addNode(m),p=ch("COLOR_CONSTANT_MY","emissive"),h.toArray(p.originData.inputs[ah.COLOR_CONSTANT_MY.color]),h.toArray(p.originData.outputs[ah.COLOR_CONSTANT_MY.color]),c.addNode(p),c.addNode(ch("FLOAT_CONSTANT_MY","opacity",{outputs:[f]})),c.addNode(ch("FLOAT_CONSTANT_MY","metalness",{outputs:[d]})),c.addNode(ch("FLOAT_CONSTANT_MY","roughness",{outputs:[A]})),c.addNode(ch("FLOAT_CONSTANT_MY","emissiveIntensity",{outputs:[v]})),c.addNode(ch("STANDARD_SURFACE_AR","Shader")),_h(c,0,lh.COLOR_CONSTANT_MY.color,6,ah.STANDARD_SURFACE_AR.baseColor),_h(c,1,lh.COLOR_CONSTANT_MY.color,6,ah.STANDARD_SURFACE_AR.emissionColor),_h(c,2,lh.FLOAT_CONSTANT_MY.value,6,ah.STANDARD_SURFACE_AR.opacity),_h(c,3,lh.FLOAT_CONSTANT_MY.value,6,ah.STANDARD_SURFACE_AR.metalness),_h(c,4,lh.FLOAT_CONSTANT_MY.value,6,ah.STANDARD_SURFACE_AR.specularRoughness),_h(c,5,lh.FLOAT_CONSTANT_MY.value,6,ah.STANDARD_SURFACE_AR.emission),c.addNode(ch("SHADING_ENGINE_MY","Output")),_h(c,6,lh.STANDARD_SURFACE_AR.color,7,ah.SHADING_ENGINE_MY.surface);break;default:console.error("createStandardPBRMaterial: Incorrect material profile - "+t),c=null}return new Ph({name:null!=(l=name)?l:"",nodeGraph:c,profile:t})},disposeTextures:zm,replaceTexture:function(t,e,n){switch(t.type){case"MeshNodeMaterial":t.traverseNodes(t=>{t.originData.texture===e&&(t.originData.texture=n)});for(const o in t.nodeTextures)t.nodeTextures[o]===e&&(t.nodeTextures[o]=n);break;case"MeshStandardMaterial":Qm.forEach(o=>{t[o]===e&&(t[o]=n)});break;default:return void console.error("replaceTexture: Unsupported material type "+t.type)}n.encoding=e.encoding,n.wrapS=e.wrapS,n.wrapT=e.wrapT}});const Ym=new tn,Xm=new Hn;function Km(t,e){let n=null;if(null!==t.scene){t.scene.traverse(t=>{t.material&&t.material.uuid===e&&(n=t.material)});const o=t.scene.worldMaterial;null!==o&&o.uuid===e&&(n=o)}return n}function jm(t){const e=[];if(null!==t.scene){t.scene.traverse(t=>{t.material&&!e.includes(t.material)&&e.push(t.material)});const n=t.scene.worldMaterial;null===n||e.includes(n)||e.push(n)}return e}function Zm(t,e){return Boolean(e.Sn.find(function(e){const n=e.binding.node;return n&&n.findRoot()===t}))}function qm(t){const e=new pn;return e.expandByObject(t),e}function Jm(t,e){const n=new An,o=2*t.getSize(n).length(),i=new Ei(45,e,o/1e4,o);return i.position.copy(t.max).multiplyScalar(2),i.lookAt(t.getCenter(n)),i}function $m(t,e){const n=new mo;e.getCenter(n.position),t.controlSettings=new Dm,t.controlSettings.orbitMinDistance=t.near,t.controlSettings.orbitMaxDistance=t.far,t.controlSettings.orbitTarget=n}var tp=Object.freeze({__proto__:null,assignDefaultControls:$m,calcSceneBox:qm,checkActionIsUsed:Zm,createDefaultCamera:Jm,createEnvironmentMaterial:km,createMeshesFromInstancedMesh:function(t){const e=new Ra,n=t.count,o=t.geometry,i=t.material;for(let r=0;r<n;r++){const n=new hi(o,i);t.getMatrixAt(r,n.matrix),n.matrix.decompose(n.position,n.quaternion,n.scale),e.add(n)}return e.copy(t),e.updateWorldMatrix(!1,!0),e},createMeshesFromMultiMaterialMesh:function(t){if(!1===Array.isArray(t.material))return console.warn("v3d.SceneUtils.createMeshesFromMultiMaterialMesh(): The given mesh has no multiple materials."),t;const e=new Ra;e.copy(t);const n=Vm(t.geometry),o=n.index,i=n.groups,r=Object.keys(n.attributes);for(let s=0;s<i.length;s++){const a=i[s],l=a.start,c=l+a.count,u=new Xo,h=t.material[a.materialIndex];for(let t=0;t<r.length;t++){const e=r[t],i=n.attributes[e],s=i.itemSize,h=a.count*s,f=new(0,i.array.constructor)(h),d=new Oo(f,s);for(let t=l,e=0;t<c;t++,e++){const n=o.getX(t);s>=1&&d.setX(e,i.getX(n)),s>=2&&d.setY(e,i.getY(n)),s>=3&&d.setZ(e,i.getZ(n)),s>=4&&d.setW(e,i.getW(n))}u.setAttribute(e,d)}const f=new hi(u,h);f.isMaterialGeneratedMesh=!0,f.name=e.name+"MatMesh"+s,e.add(f)}return e},createMultiMaterialMesh:function(t){const e=[],n=[];let o=null;for(let i=0;i<t.children.length;i++){const r=t.children[i];r.isMesh&&r.isMaterialGeneratedMesh&&(e.push(r.geometry),n.push(r.material),o||(o=r))}if(0==e.length)return t;const i=Pm(e,!0),r=new(o.isSkinnedMesh?ll:hi)(i,n);mo.prototype.copy.call(r,t);for(let t=r.children.length-1;t>=0;t--){const e=r.children[t];e.isMesh&&e.isMaterialGeneratedMesh&&r.remove(e)}return o.morphTargetInfluences&&(r.morphTargetInfluences=o.morphTargetInfluences.slice()),o.morphTargetDictionary&&(r.morphTargetDictionary=Object.assign({},o.morphTargetDictionary)),o.isSkinnedMesh&&(r.bindMode=o.bindMode,r.bindMatrix.copy(o.bindMatrix),r.bindMatrixInverse.copy(o.bindMatrixInverse),r.skeleton=o.skeleton),r},createMultiMaterialObject:function(t,e){const n=new Ra;for(let o=0,i=e.length;o<i;o++){new hi(t,e[o]).isMaterialGeneratedMesh=!0,n.add()}return n},getAllMaterials:jm,getAnimationActionByName:function(t,e){const n=oe(e);for(let o=0;o<t.actions.length;o++){const i=t.actions[o],r=i.getClip();if((n?r.uuid:r.name)==e)return i}return null},getAnimationActionByObjectUUID:function(t,e){for(let n=0;n<t.actions.length;n++){const o=t.actions[n];if(o.getClip().objectUUID==e)return o}return null},getAnimationActionsByName:function(t,e){const n=oe(e),o=[];for(let i=0;i<t.actions.length;i++){const r=t.actions[i],s=r.getClip();(n?s.uuid:s.name)==e&&o.push(r)}return o},getMaterialByName:function(t,e){if(oe(e))return Km(t,e);const n=this.getMaterialsByName(t,e);return n.length?n[0]:null},getMaterialByUUID:Km,getMaterialsByName:function(t,e){if(oe(e)){const n=Km(t,e);return n?[n]:[]}const n=[];if(null!==t.scene){t.scene.traverse(function(t){t.material&&t.material.name===e&&-1===n.indexOf(t.material)&&n.push(t.material)});const o=t.scene.worldMaterial;null!==o&&o.name===e&&-1===n.indexOf(o)&&n.push(o)}return n},reduceVertices:function(t,e,n){let o=n;const i=new An;return t.updateWorldMatrix(!0,!0),t.traverseVisible(t=>{const{geometry:n}=t;if(void 0!==n){const{position:r}=n.attributes;if(void 0!==r)for(let n=0,s=r.count;n<s;n++)t.isMesh?t.getVertexPosition(n,i):i.fromBufferAttribute(r,n),t.isSkinnedMesh||i.applyMatrix4(t.matrixWorld),o=e(o,i)}}),o},removeClipPlanesFromMats:function(t,e){e.traverse(e=>{if(!e.material)return;const n=Array.isArray(e.material)?e.material:[e.material];for(let e=0;e<n.length;e++){const o=n[e];if(o.clippingPlanes)for(let e=o.clippingPlanes.length-1;e>=0;e--)o.clippingPlanes[e]===t.plane&&o.clippingPlanes.splice(e,1)}})},sortInstancedMesh:function(t,e){const n=Fm(t.instanceMatrix),o=t.instanceColor?Fm(t.instanceColor):null,i=new Map;for(const e in t.geometry.attributes){const n=t.geometry.attributes[e];n.isInstancedBufferAttribute&&i.set(n,Fm(n))}const r=[];for(let e=0;e<t.count;e++)r.push(e);r.sort(e);for(let e=0;e<r.length;e++){const s=r[e];Xm.fromArray(n.array,s*t.instanceMatrix.itemSize),Xm.toArray(t.instanceMatrix.array,e*t.instanceMatrix.itemSize),t.instanceColor&&(Ym.fromArray(o.array,s*t.instanceColor.itemSize),Ym.toArray(t.instanceColor.array,e*t.instanceColor.itemSize));for(const n in t.geometry.attributes){const o=t.geometry.attributes[n];if(o.isInstancedBufferAttribute){const t=i.get(o);o.setX(e,t.getX(s)),o.itemSize>1&&o.setY(e,t.getY(s)),o.itemSize>2&&o.setZ(e,t.getZ(s)),o.itemSize>3&&o.setW(e,t.getW(s))}}}}});const ep={Afterimage:Hd,Bloom:Wd,Bokeh:Yd,"Brightness/Contrast":Kd,FXAA:jd,Grayscale:Zd,Mask:LA,Outline:GA,Render:QA,SSAA:kA,SSR:WA,ToneMapping:YA,"Copy/Other":Xd},np={[Z]:"RG",[W]:"RGBA",[Y]:"DEPTH",[It]:"RGBA_BPTC",[ut]:"RGBA_ASTC_4x4",[$]:"RGB_S3TC_DXT1",[nt]:"RGBA_S3TC_DXT5",[ot]:"RGB_PVRTC_4BPPV1",[rt]:"RGBA_PVRTC_4BPPV1",[at]:"RGB_ETC1",[lt]:"RGB_ETC2",[ct]:"RGB_ETC2_EAC"};class op{static getPageParams(t){let e=(t=t||window).location.href.toString();const n={};if(-1==e.indexOf("?"))return n;const o=e.split("#")[0].split("?")[1].split("&");for(let t=0;t<o.length;t++){const e=o[t].split("="),i=decodeURIComponent(e[0]);1==e.length?n[i]="":n[i]=decodeURIComponent(e[1])}return n}static updatePageParam(t,e,n){let o,i,r=null,s="",a=t.split("?"),l=a[0],c=a[1],u="";if(c){o=c.split("#"),i=o[0],r=o[1],r&&(c=i),a=c.split("&");for(let t=0;t<a.length;t++)a[t].split("=")[0]!=e&&(s+=u+a[t],u="&")}else o=l.split("#"),i=o[0],r=o[1],i&&(l=i);r&&(n+="#"+r);return l+"?"+s+(u+""+e+"="+n)}static loadScript(t,e,n,o){function i(t){s.removeEventListener("load",i,!1),s.removeEventListener("error",r,!1),e.removeChild(s),n(t)}function r(t){s.removeEventListener("load",i,!1),s.removeEventListener("error",r,!1),e.removeChild(s),o(t)}const s=document.createElement("script");s.addEventListener("load",i,!1),s.addEventListener("error",r,!1),e.appendChild(s),s.src=t}static drawWatermark(t){setTimeout(function(){ke("register",{revision:n,v3dl:r})},0);const e=t.container;if(3483952072!=ve(r))return;const o=["color: #fff;","opacity: 0.5;","font-size: 18px;","font-family: sans-serif;","text-align: center;","text-decoration: none;","position: absolute;","bottom: 1%;","right: 1%;","user-select: none;","z-index: 9999;","text-shadow: 1px 1px #000;"].join("\n"),i=document.createElement("div");i.innerHTML=`<a href="https://www.soft8soft.com/verge3d-trial/" target="_blank" style="${o}">MADE WITH VERGE3D TRIAL</a>`,e.appendChild(i),setTimeout(function(){e.contains(i)&&890310108==ve(i.textContent)||t.dispose()},1e3)}static isXML(t){return null!==t.match(/.*\.xml$/)}static isJS(t){return null!==t.match(/.*\.js$/)}static addToAppList(t){const e=Fe();e.v3d&&(e.v3d.apps=e.v3d.apps||[],-1==e.v3d.apps.indexOf(t)&&e.v3d.apps.push(t))}static removeFromAppList(t){const e=Fe();if(e.v3d&&e.v3d.apps){const n=e.v3d.apps.indexOf(t);n>-1&&e.v3d.apps.splice(n,1)}}static printPerformanceInfo(t,e){e=e||1;const n=t.renderer.info;n.reset();const o=t.frame;for(let t=0;t<n.programs.length;t++)n.programs[t].profile.calcRenderTime=!0;let i;function r(t,e){i==t&&(t+=" "),i=t,e?console.log("%c"+t,"color:red"):console.log(t)}setTimeout(function(){if(r("--- Verge3D Performance Profile ("+e+"s) ---"),!t.scene)return void r("Scene not loaded");const i=t.frame-o,s=Math.round(t.qo);r(`Scene Loading Time: ${s}ms`,s>1e4);const a=-1!=t.Jo.indexOf(".xz",t.Jo.length-3);r("Asset Compression: "+(a?"yes":"no"),0==a);const l=Math.round(n.numShaderCompiles);r(`Shader Compilations: ${l}`,l>100);const c=i/e;r("FPS: "+c,c<30);const u=Math.round(n.render.calls/i);r("Render Calls: "+u,u>1e3);const h=Math.round(n.render.triangles/i);r("Triangles Rendered: "+h,h>1e6),r("Geometry Buffers: "+n.memory.geometries,n.memory.geometries>200),r("HDR Rendering: "+(t.useHDR?"yes":"no")),r("Order-Independent Transparency: "+(t.renderer.useOIT?"yes":"no"));const f=t.renderer.getDrawingBufferSize(new we);r("Viewport Resolution: "+f.x+"x"+f.y),r(`Pixel Ratio: ${t.renderer.getPixelRatio()} (current) / ${window.devicePixelRatio} (device)`);let d="N/A";switch(t.$o){case 0:d="PMREM",d+=` ${t.ti} px`;break;case 1:d="Light Probe",d+=` ${t.ti} px`}r(`Image-Based Lighting: ${d}`);let A=0,v=0,m=0,p=0,g=0,_=0;t.scene.traverse(function(t){t.isLight&&(A++,t.castShadow&&t.shadow&&(p++,g=t.shadow.mapSize.width,_=t.shadow.mapSize.height)),t.isCubeReflectionProbe&&v++,t.isPlaneReflectionProbe&&m++}),r("Lights: "+A,A>10),r(`Reflection Probes: ${v} (cube) / ${m} (plane) `,v>3||m>1);const E=[];if(t.postprocessing){t.postprocessing.gtaoGenerator&&E.push("GTAO");t.postprocessing.composer.passes.forEach(function(t){for(let e in ep)if(t instanceof ep[e])return void E.push(e);E.push("Undefined")})}r(`Post-Processing: ${E.length?E.join(","):"N/A"}`);let C="N/A";if(p&&t.renderer.shadowMap&&t.renderer.shadowMap.enabled){switch(t.renderer.shadowMap.type){case 0:C="Basic";break;case 1:C="Bilinear";break;case 2:C="PCF";break;case 3:C="ESM";break;default:C="Unknown"}C+=` ${g}x${_}x${p}`}r("Shadow Map: "+C,p>4||g>2048||_>2048);const w=n.programs.slice(0);r("Materials and Shaders: "+w.length,w>100),w.sort(function(t,e){return e.profile.renderTime-t.profile.renderTime});let x=0;for(let t=0;t<w.length;t++){const e=w[t];e.profile.calcRenderTime=!1;const n=e.profile.materials,o=e.profile.renderTime/i;let s;s=o>=.1?String(Math.round(10*o)/10)+"ms":o>0&&o<.1?String(Math.round(1e3*o)/1e3)+"ms":"N/R",r("    "+(0==n.size?"System Material":Array.from(n).join(","))+" - "+e.name+" - "+s,o>16),x+=o,e.profile.renderTime=0}r("Total Render Time: "+String(Math.round(10*x)/10)+"ms",x>16),r("Textures & Render Buffers: "+n.memory.textures,n.memory.textures>100);const I=Array.from(n.memory.textureSpecs.values());I.sort(function(t,e){return t.type<e.type?1:t.type>e.type?-1:t.width!=e.width?e.width-t.width:e.height-t.height});for(let t=0;t<I.length;t++){const e=I[t],n="Texture"==e.type?"- "+np[e.format]:"",o=e.isCube?"x6":"";r(`    ${e.name||"N/A"} - ${e.type} - ${e.width}x${e.height}${o} ${n}`,e.width>=4096||e.height>=4096)}if(n.render.customCounter){const t=n.render.customCounter/i;r(`Custom Counter: ${Math.round(10*t)/10} iter/frame`)}},1e3*e)}static printMaterialsStats(t){const e=jm(t).filter(t=>"MeshNodeMaterial"==t.type),n=new Map;e.forEach(t=>{t.traverseNodes(t=>{const e=t.originData.type;n.has(e)||n.set(e,0),n.set(e,n.get(e)+1)})});const o=Array.from(n);o.sort((t,e)=>e[1]-t[1]),console.log("Total Node Materials:",e.length);const i=t.renderer.info.programs.filter(t=>"MeshNodeMaterial"==t.name);console.log("Total Node Shaders:",i.length),console.log("Node Stats:"),o.forEach(t=>{console.log(`    ${t[0]} - ${t[1]}`)})}static registerServiceKeys(t){op.unregisterServiceKeys(t),t.ei=t.ei||[];const e=t.ei;e.push(new zA(window,"KeyP",function(){op.printPerformanceInfo(t,1)},3,1)),e.push(new zA(window,"KeyF",function(){t.stats?t.hideFPS():t.showFPS()},3,1)),e.push(new zA(window,"KeyH",function(){t.enableRender?t.disableRendering():t.enableRendering()},3,1)),e.push(new zA(window,["Backquote","IntlBackslash"],()=>{let e;op.showServiceKeysHelp(t),t.controls&&(e=t.controls.enableKeys,t.controls.enableKeys=!1);const n=o=>{switch(o.code){case"KeyW":t.hasDebugMode("wireframes")?t.disableDebugMode("wireframes"):t.enableDebugMode("wireframes");break;case"KeyL":t.hasDebugMode("lights")?t.disableDebugMode("lights"):t.enableDebugMode("lights");break;case"KeyS":t.hasDebugMode("skeletons")?t.disableDebugMode("skeletons"):t.enableDebugMode("skeletons");break;case"KeyP":op.printPerformanceInfo(t,1);break;case"KeyF":t.stats?t.hideFPS():t.showFPS();break;case"KeyH":t.enableRender?t.disableRendering():t.enableRendering();break;case"KeyN":t.hasDebugMode("normals")?t.disableDebugMode("normals"):t.enableDebugMode("normals")}window.removeEventListener("keydown",n),op.hideServiceKeysHelp(t),t.controls&&(t.controls.enableKeys=e)};window.addEventListener("keydown",n)},3,1))}static unregisterServiceKeys(t){Array.isArray(t.ei)&&(t.ei.forEach(t=>t.dispose()),t.ei.length=0)}static showServiceKeysHelp(t){const e=t.container,n=["color: #fff;","font-size: 14px;","font-family: monospace;","text-decoration: none;","position: absolute;",`top: ${t.stats?60:10}px;`,"left: 10px;","user-select: none;","z-index: 9999;","text-shadow: 1px 1px #000;"].join("\n"),o=document.createElement("div");o.id="v3d-debug-info-help",o.style=n,o.innerHTML="Service Tools:<br>[F] FPS counter<br>[P] performance profile<br>[H] halt/resume render<br>[W] wireframes<br>[L] lights<br>[S] skeletons<br>[N] normals",e.appendChild(o)}static hideServiceKeysHelp(t){t.container.querySelector("#v3d-debug-info-help").remove()}}const ip={prepareRenderer:function(t){Mi.getGPUVendor(t),Mi.getGPUModel(t);const e=Mi.checkAndroid();t.compatSettings.gtaoDisableBkgFix=e}},rp=new An,sp=new dn,ap=new An;const lp=new Hn,cp=new Hn;class up{constructor(t){const e=this;let n,o,i,r;const s={camera:{style:""},objects:new WeakMap};this.domElement=t;const a=document.createElement("div");a.id="v3d-css-render-view",a.style.transformOrigin="0 0",a.style.pointerEvents="none",a.style.position="absolute",a.style.zIndex="-2",t.appendChild(a),this.viewElement=a;const l=document.createElement("div");function c(t){return Math.abs(t)<1e-10?0:t}function u(t){const e=t.elements;return"matrix3d("+c(e[0])+","+c(-e[1])+","+c(e[2])+","+c(e[3])+","+c(e[4])+","+c(-e[5])+","+c(e[6])+","+c(e[7])+","+c(e[8])+","+c(-e[9])+","+c(e[10])+","+c(e[11])+","+c(e[12])+","+c(-e[13])+","+c(e[14])+","+c(e[15])+")"}function h(t){const e=t.elements;return"translate(-50%,-50%)"+("matrix3d("+c(e[0])+","+c(e[1])+","+c(e[2])+","+c(e[3])+","+c(-e[4])+","+c(-e[5])+","+c(-e[6])+","+c(-e[7])+","+c(e[8])+","+c(e[9])+","+c(e[10])+","+c(e[11])+","+c(e[12])+","+c(e[13])+","+c(e[14])+","+c(e[15])+")")}function f(t){t.isCSS3DObject&&(t.element.style.display="none");for(let e=0,n=t.children.length;e<n;e++)f(t.children[e])}function d(t,n,o,i){if(!1!==t.visible){if(t.isCSS3DObject){const i=!0===t.layers.test(o.layers),r=t.element;if(r.style.display=!0===i?"":"none",!0===i){let i;t.onBeforeRender(e,n,o),t.isCSS3DSprite?(lp.copy(o.matrixWorldInverse),lp.transpose(),0!==t.rotation2D&&lp.multiply(cp.makeRotationZ(t.rotation2D)),t.matrixWorld.decompose(rp,sp,ap),lp.setPosition(rp),lp.scale(ap),lp.elements[3]=0,lp.elements[7]=0,lp.elements[11]=0,lp.elements[15]=1,i=h(lp)):i=h(t.matrixWorld);const a=s.objects.get(t);if(void 0===a||a.style!==i){r.style.transform=i;const e={style:i};s.objects.set(t,e)}r.parentNode!==l&&l.appendChild(r),t.onAfterRender(e,n,o)}}for(let e=0,i=t.children.length;e<i;e++)d(t.children[e],n,o)}else f(t)}l.id="v3d-css-render-camera",l.style.transformStyle="preserve-3d",a.appendChild(l),this.getSize=function(){return{width:n,height:o}},this.render=function(t,e){const h=e.projectionMatrix.elements[5]*r;let f,A;e.view&&e.view.enabled?(a.style.transform=`translate(${-e.view.offsetX*(n/e.view.width)}px, ${-e.view.offsetY*(o/e.view.height)}px)`,a.style.transform+=`scale(${e.view.fullWidth/e.view.width}, ${e.view.fullHeight/e.view.height})`):a.style.transform="",!0===t.matrixWorldAutoUpdate&&t.updateMatrixWorld(),null===e.parent&&!0===e.matrixWorldAutoUpdate&&e.updateMatrixWorld(),e.isOrthographicCamera&&(f=-(e.right+e.left)/2,A=(e.top+e.bottom)/2);const v=e.view&&e.view.enabled?e.view.height/e.view.fullHeight:1,m=e.isOrthographicCamera?`scale(${v})scale(`+h+")translate("+c(f)+"px,"+c(A)+"px)"+u(e.matrixWorldInverse):`scale(${v})translateZ(`+h+"px)"+u(e.matrixWorldInverse),p=(e.isPerspectiveCamera?"perspective("+h+"px) ":"")+m+"translate("+i+"px,"+r+"px)";s.camera.style!==p&&(l.style.transform=p,s.camera.style=p),d(t,t,e)},this.setSize=function(t,e){n=t,o=e,i=n/2,r=o/2,a.style.width=t+"px",a.style.height=e+"px",l.style.width=t+"px",l.style.height=e+"px"}}}class hp{constructor(t){this.sourceTexture=t,this.camera=new Xi(-1,1,1,-1,0,1),this.shader=new gi({type:"CubeCopy",uniforms:{faceIdx:{value:0},cubemap:{value:null}},vertexShader:"\n            uniform int faceIdx;\n\n            varying vec3 vCubeDirection;\n\n            vec3 uvToCubeDirection(vec2 uv, int face) {\n                vec3 dir;\n                uv = 2.0 * uv - 1.0;\n\n                if (face == 0) {\n                    dir = vec3(1.0, -uv.y, -uv.x);\n                } else if (face == 1) {\n                    dir = vec3(-1.0, -uv.y, uv.x);\n                } else if (face == 2) {\n                    dir = vec3(uv.x, 1.0, uv.y);\n                } else if (face == 3) {\n                    dir = vec3(uv.x, -1.0, -uv.y);\n                } else if (face == 4) {\n                    dir = vec3(uv.x, -uv.y, 1.0);\n                } else if (face == 5) {\n                    dir = vec3(-uv.x, -uv.y, -1.0);\n                }\n                return dir;\n            }\n\n            void main() {\n                vCubeDirection = uvToCubeDirection(uv, faceIdx);\n                gl_Position = vec4(position, 1.0);\n            }\n            ",fragmentShader:"\n            uniform samplerCube cubemap;\n\n            varying vec3 vCubeDirection;\n\n            void main() {\n                gl_FragColor = textureCube(cubemap, vCubeDirection);\n\n                #include <tonemapping_fragment>\n\n                gl_FragColor = linearToOutputTexel(gl_FragColor);\n            }\n            "}),this.shader.map=t,this.shader.uniforms.cubemap.value=t,this.planeMesh=new hi(new Oi(2,2),this.shader),this.scene=new Ni,this.scene.add(this.camera),this.scene.add(this.planeMesh)}render(t,e,n=1){const o=t.toneMapping,i=t.toneMappingExposure,r=t.getRenderTarget();t.toneMapping=1,t.toneMappingExposure=n;for(var s=0;s<6;s++)t.setRenderTarget(e,s),this.shader.uniforms.faceIdx.value=s,t.render(this.scene,this.camera);t.toneMapping=o,t.toneMappingExposure=i,t.setRenderTarget(r)}dispose(){this.planeMesh.geometry.dispose(),this.planeMesh.material.dispose()}}function fp(t,e,n,{camPos:o=new An,clipStart:i=.1,clipEnd:r=100}={}){Mi.checkHalfFloatTex(e,!0)||(console.warn("v3d.RenderUtils: disabling half float cubemaps"),n.texture.type=O);const s=new wi(i,r,n);s.position.copy(o);let a=t.worldMaterial;if(null!==a&&a.isMeshNodeMaterial){const o=new hi(new di(1,1,1),a);o.material.side=1,o.material.defines.WORLD_NODES=1,new wi(.1,10,n).update(e,o),o.geometry.disposeBoundsTree&&o.geometry.disposeBoundsTree(),o.geometry.dispose();const i=t.background;t.background=null;const r=e.autoClearColor;e.autoClearColor=!1,s.update(e,t),e.autoClearColor=r,t.background=i}else s.update(e,t);return s.renderTarget}function dp(t,e,n,o){e.isMeshNodeMaterial||console.error("v3d.RenderUtils.renderWorldNodeMatToCubemap(): material is not an instance of MeshNodeMaterial.");const i=new Ni;i.worldMaterial=e;const r=new Ii(n,o);return r.texture.name="WorldNodesCubemap",fp(i,t,r)}var Ap=Object.freeze({__proto__:null,assignAllLayersMask:function(t){const e=t.layers.mask;return t.layers.set(0),t.isArrayCamera&&(t.layers.enable(1),t.layers.enable(2)),t.layers.enable(3),t.layers.enable(4),t.layers.enable(5),t.layers.enable(6),t.layers.enable(7),e},renderSceneToCubemap:fp,renderWorldNodeMatToCubemap:dp});const vp=new pn,mp=new Pn,pp=new Hn,gp=new An,_p=new An;class Ep extends mo{constructor(t=256){super(),this.isCubeReflectionProbe=!0,this.type="CubeReflectionProbe",this.influenceType=1,this.influenceDistance=1,this.parallaxType=1,this.parallaxDistance=1,this.probeClipStart=.1,this.probeClipEnd=100,this.probeIntensity=1,this.visibilityGroup=null,this.visibilityGroupInv=!1,this.influenceGroup=null,this.influenceGroupInv=!1,this.ni=new Ii(t,{encoding:Ft,format:W,generateMipmaps:!0,minFilter:P,type:Q}),this.ni.texture.name="CubeReflectionProbe.ini",this.oi=this.ni.clone(),this.ni.texture.name="CubeReflectionProbe.exp",this.renderTarget=null,this.matrixWorldInverse=new Hn}setSize(t){this.ni.setSize(t,t),this.oi.setSize(t,t)}setEncoding(t){this.ni.texture.encoding=t,this.oi.texture.encoding=t}intersectsMesh(t){let e=!1;const n=t.geometry,o=n.boundsTree,i=pp;switch(i.copy(t.matrixWorld).invert(),i.multiply(this.matrixWorld),this.influenceType){case 0:e=!0;break;case 1:mp.center.setScalar(0),mp.radius=this.influenceDistance,mp.applyMatrix4(i),o?e=o.intersectsSphere(mp):(null===n.boundingBox&&n.computeBoundingBox(),e=n.boundingBox.intersectsSphere(mp));break;case 2:const t=gp.setScalar(0),r=_p.setScalar(2*this.influenceDistance);vp.setFromCenterAndSize(t,r),o?e=o.intersectsBox(vp,i):(vp.applyMatrix4(i),null===n.boundingBox&&n.computeBoundingBox(),e=n.boundingBox.intersectsBox(vp))}return e}update(t,e){const n={};t.traverse(t=>{!t.isCubeReflectionProbe&&this.ii(t)||(n[t.id]=t.layers.mask,t.layers.disableAll())});const o=t.worldMaterial,i=null!==o&&o.isMeshNodeMaterial&&o.needsLightPathDir();let r;i&&(r=o.defines.LIGHT_PATH_IS_CAM_RAY,o.defines.LIGHT_PATH_IS_CAM_RAY=0),fp(t,e,this.ni,{camPos:this.position,clipStart:this.probeClipStart,clipEnd:this.probeClipEnd}),this.oi.texture.type=this.ni.texture.type;const s=new hp(this.ni.texture);s.render(e,this.oi,this.probeIntensity),s.dispose(),this.renderTarget=this.onUpdate(this.oi),i&&(o.defines.LIGHT_PATH_IS_CAM_RAY=r),t.traverse(t=>{!t.isCubeReflectionProbe&&this.ii(t)||(t.layers.mask=n[t.id])})}onUpdate(t){return t}updateMatrixWorld(t){super.updateMatrixWorld(t),this.matrixWorldInverse.copy(this.matrixWorld).invert()}updateWorldMatrix(t,e){super.updateWorldMatrix(t,e),this.matrixWorldInverse.copy(this.matrixWorld).invert()}clone(){return(new this.constructor).copy(this)}copy(t){return super.copy(t),this.influenceType=t.influenceType,this.influenceDistance=t.influenceDistance,this.parallaxType=t.parallaxType,this.parallaxDistance=t.parallaxDistance,this.probeClipStart=t.probeClipStart,this.probeClipEnd=t.probeClipEnd,this.probeIntensity=t.probeIntensity,this.visibilityGroup=t.visibilityGroup,this.visibilityGroupInv=t.visibilityGroupInv,this.influenceGroup=t.influenceGroup,this.influenceGroupInv=t.influenceGroupInv,this.setSize(t.ni.width),this.matrixWorldInverse.copy(t.matrixWorldInverse),this}dispose(){null!==this.ni&&this.ni.dispose(),null!==this.oi&&this.oi.dispose(),null!==this.renderTarget&&(this.renderTarget.dispose(),this.renderTarget=null),this.dispatchEvent({type:"dispose"})}ii(t){if(null===this.visibilityGroup)return!0;if(!t.isMesh)return!0;return-1!==t.groupNames.indexOf(this.visibilityGroup)^this.visibilityGroupInv}}class Cp{constructor(t,e){if(this.renderer=t,void 0===e){const n=t.getSize(new we);this.ri=t.getPixelRatio(),this.si=n.width,this.ai=n.height,(e=new cn(Math.floor(this.si*this.ri),Math.floor(this.ai*this.ri))).texture.name="EffectComposer.rt1"}else this.ri=1,this.si=e.width,this.ai=e.height;this.renderTarget1=e,this.renderTarget2=e.clone(),this.renderTarget2.texture.name="EffectComposer.rt2",this.writeBuffer=this.renderTarget1,this.readBuffer=this.renderTarget2,this.renderToScreen=!0,this.passes=[],this.copyPass=new Xd(Vi.copy),this.clock=new If}swapBuffers(){const t=this.readBuffer;this.readBuffer=this.writeBuffer,this.writeBuffer=t}addPass(t){this.passes.push(t),t.setSize(Math.floor(this.si*this.ri),Math.floor(this.ai*this.ri))}insertPass(t,e){this.passes.splice(e,0,t),t.setSize(Math.floor(this.si*this.ri),Math.floor(this.ai*this.ri))}removePass(t){const e=this.passes.indexOf(t);-1!==e&&this.passes.splice(e,1)}isLastEnabledPass(t){for(let e=t+1;e<this.passes.length;e++)if(this.passes[e].enabled)return!1;return!0}render(t){void 0===t&&(t=this.clock.getDelta());const e=this.renderer.getRenderTarget();let n=!1;for(let e=0,o=this.passes.length;e<o;e++){const o=this.passes[e];if(!1!==o.enabled){if(o.renderToScreen=this.renderToScreen&&this.isLastEnabledPass(e),o.render(this.renderer,this.writeBuffer,this.readBuffer,t,n),o.needsSwap){if(n){const e=this.renderer.getContext(),n=this.renderer.state.buffers.stencil;n.setFunc(e.NOTEQUAL,1,4294967295),this.copyPass.render(this.renderer,this.writeBuffer,this.readBuffer,t),n.setFunc(e.EQUAL,1,4294967295)}this.swapBuffers()}o instanceof LA?n=!0:o instanceof NA&&(n=!1)}}this.renderer.setRenderTarget(e)}reset(t){if(void 0===t){const e=this.renderer.getSize(new we);this.ri=this.renderer.getPixelRatio(),this.si=e.width,this.ai=e.height,(t=this.renderTarget1.clone()).setSize(Math.floor(this.si*this.ri),Math.floor(this.ai*this.ri))}this.renderTarget1.dispose(),this.renderTarget2.dispose(),this.renderTarget1=t,this.renderTarget2=t.clone(),this.writeBuffer=this.renderTarget1,this.readBuffer=this.renderTarget2}setSize(t,e){this.si=t,this.ai=e;const n=Math.floor(this.si*this.ri),o=Math.floor(this.ai*this.ri);this.renderTarget1.setSize(n,o),this.renderTarget2.setSize(n,o);for(let t=0;t<this.passes.length;t++)this.passes[t].setSize(n,o)}setPixelRatio(t){this.ri=t,this.setSize(this.si,this.ai)}getPixelRatio(){return this.ri}dispose(){this.renderTarget1.dispose(),this.renderTarget2.dispose(),this.copyPass.dispose()}getActiveSSAAPass(){return this.passes[0]instanceof kA?this.passes[0]:null}insertPassAfter(t,e){let n=0;for(let t=0;t<this.passes.length;t++)e.indexOf(this.passes[t])>-1&&(n=t+1);this.insertPass(t,n)}enableAllPasses(){for(let t=0;t<this.passes.length;t++)this.passes[t].enabled=!0}disableAllPasses(){for(let t=0;t<this.passes.length;t++)this.passes[t].enabled=!1}setStencil(t){this.renderTarget1.stencilBuffer=t,this.renderTarget1.dispose(),this.renderTarget2.stencilBuffer=t,this.renderTarget2.dispose()}}var wp,xp=(wp="undefined"==typeof document&&"undefined"==typeof location?require("url").pathToFileURL(__filename).href:"undefined"==typeof document?location.href:e&&"SCRIPT"===e.tagName.toUpperCase()&&e.src||new URL("v3d.js",document.baseURI).href,function(t){t=void 0!==(t=t||{})?t:{};var e,n,o=Object.assign;t.ready=new Promise(function(t,o){e=t,n=o});var i,r,s,a,l,c,u=o({},t),h="object"==typeof window,f="function"==typeof importScripts,d="object"==typeof process&&"object"==typeof process.versions&&"string"==typeof process.versions.node,A="";d?(A=f?require("path").dirname(A)+"/":__dirname+"/",c=()=>{l||(a=require("fs"),l=require("path"))},i=function(t,e){var n=X(t);return n?e?n:n.toString():(c(),t=l.normalize(t),a.readFileSync(t,e?null:"utf8"))},s=t=>{var e=i(t,!0);return e.buffer||(e=new Uint8Array(e)),e},r=(t,e,n)=>{var o=X(t);o&&e(o),c(),t=l.normalize(t),a.readFile(t,function(t,o){t?n(t):e(o.buffer)})},process.argv.length>1&&process.argv[1].replace(/\\/g,"/"),process.argv.slice(2),process.on("uncaughtException",function(t){if(!(t instanceof $))throw t}),process.on("unhandledRejection",function(t){throw t}),t.inspect=function(){return"[Emscripten Module object]"}):(h||f)&&(f?A=self.location.href:"undefined"!=typeof document&&document.currentScript&&(A=document.currentScript.src),wp&&(A=wp),A=0!==A.indexOf("blob:")?A.substr(0,A.replace(/[?#].*/,"").lastIndexOf("/")+1):"",i=t=>{try{var e=new XMLHttpRequest;return e.open("GET",t,!1),e.send(null),e.responseText}catch(e){var n=X(t);if(n)return function(t){for(var e=[],n=0;n<t.length;n++){var o=t[n];o>255&&(o&=255),e.push(String.fromCharCode(o))}return e.join("")}(n);throw e}},f&&(s=t=>{try{var e=new XMLHttpRequest;return e.open("GET",t,!1),e.responseType="arraybuffer",e.send(null),new Uint8Array(e.response)}catch(e){var n=X(t);if(n)return n;throw e}}),r=(t,e,n)=>{var o=new XMLHttpRequest;o.open("GET",t,!0),o.responseType="arraybuffer",o.onload=()=>{if(200==o.status||0==o.status&&o.response)e(o.response);else{var i=X(t);i?e(i.buffer):n()}},o.onerror=n,o.send(null)}),t.print||console.log.bind(console);var v,m,p=t.printErr||console.warn.bind(console);o(t,u),u=null,t.arguments&&t.arguments,t.thisProgram&&t.thisProgram,t.quit&&t.quit,t.wasmBinary&&(v=t.wasmBinary),t.noExitRuntime,"object"!=typeof WebAssembly&&P("no native wasm support detected");var g=!1;function _(e){return t["_"+e]}function E(t,e,n,o,i){var r={string:function(t){var e=0;if(null!=t&&0!==t){var n=1+(t.length<<2);!function(t,e,n){!function(t,e,n,o){if(!(o>0))return 0;for(var i=n+o-1,r=0;r<t.length;++r){var s=t.charCodeAt(r);if(s>=55296&&s<=57343&&(s=65536+((1023&s)<<10)|1023&t.charCodeAt(++r)),s<=127){if(n>=i)break;e[n++]=s}else if(s<=2047){if(n+1>=i)break;e[n++]=192|s>>6,e[n++]=128|63&s}else if(s<=65535){if(n+2>=i)break;e[n++]=224|s>>12,e[n++]=128|s>>6&63,e[n++]=128|63&s}else{if(n+3>=i)break;e[n++]=240|s>>18,e[n++]=128|s>>12&63,e[n++]=128|s>>6&63,e[n++]=128|63&s}}e[n]=0}(t,x,e,n)}(t,e=J(n),n)}return e},array:function(t){var e=J(t.length);return function(t,e){w.set(t,e)}(t,e),e}};function s(t){return"string"===e?(n=t)?function(t,e,n){for(var o=e+n,i=e;t[i]&&!(i>=o);)++i;if(i-e>16&&t.subarray&&M)return M.decode(t.subarray(e,i));for(var r="";e<i;){var s=t[e++];if(128&s){var a=63&t[e++];if(192!=(224&s)){var l=63&t[e++];if((s=224==(240&s)?(15&s)<<12|a<<6|l:(7&s)<<18|a<<12|l<<6|63&t[e++])<65536)r+=String.fromCharCode(s);else{var c=s-65536;r+=String.fromCharCode(55296|c>>10,56320|1023&c)}}else r+=String.fromCharCode((31&s)<<6|a)}else r+=String.fromCharCode(s)}return r}(x,n,o):"":"boolean"===e?Boolean(t):t;var n,o}var a=_(t),l=[],c=0;if(o)for(var u=0;u<o.length;u++){var h=r[n[u]];h?(0===c&&(c=Z()),l[u]=h(o[u])):l[u]=o[u]}var f=a.apply(null,l);return f=function(t){return 0!==c&&q(c),s(t)}(f)}var C,w,x,I,M="undefined"!=typeof TextDecoder?new TextDecoder("utf8"):void 0;function S(t,e){return t%e>0&&(t+=e-t%e),t}function b(e){C=e,t.HEAP8=w=new Int8Array(e),t.HEAP16=new Int16Array(e),t.HEAP32=new Int32Array(e),t.HEAPU8=x=new Uint8Array(e),t.HEAPU16=new Uint16Array(e),t.HEAPU32=new Uint32Array(e),t.HEAPF32=new Float32Array(e),t.HEAPF64=new Float64Array(e)}t.INITIAL_MEMORY;var y=[],R=[],T=[];function B(t){y.unshift(t)}function L(t){T.unshift(t)}var N=0,D=null;function P(e){t.onAbort&&t.onAbort(e),p(e="Aborted("+e+")"),g=!0,e+=". Build with -s ASSERTIONS=1 for more info.";var o=new WebAssembly.RuntimeError(e);throw n(o),o}t.preloadedImages={},t.preloadedAudios={};var O,F,U="data:application/octet-stream;base64,";function V(t){return t.startsWith(U)}function G(t){return t.startsWith("file://")}function Q(t){try{if(t==O&&v)return new Uint8Array(v);var e=X(t);if(e)return e;if(s)return s(t);throw"both async and sync fetching of the wasm failed"}catch(t){P(t)}}function z(e){for(;e.length>0;){var n=e.shift();if("function"!=typeof n){var o=n.func;"number"==typeof o?void 0===n.arg?H(o)():H(o)(n.arg):o(void 0===n.arg?null:n.arg)}else n(t)}}V(O="data:application/octet-stream;base64,AGFzbQEAAAABIwdgAX8AYAABf2ABfwF/YAN/f38Bf2ADf39/AGACf38AYAAAAg0CAWEBYQACAWEBYgADAxoZBAMCAAIFBgQCAAQDAQEBAQIAAQEBAAAAAAQFAXABAQEFBwEBgAKAgAIGCQF/AUHQpIADCwdBEAFjAgABZAAIAWUAEQFmABABZwAPAWgADgFpABoBagAZAWsAGAFsABcBbQAWAW4AFQFvAQABcAAUAXEAEwFyABIKl6QBGf0DAQJ/IAJBgARPBEAgACABIAIQARoPCyAAIAJqIQMCQCAAIAFzQQNxRQRAAkAgAEEDcUUEQCAAIQIMAQsgAkUEQCAAIQIMAQsgACECA0AgAiABLQAAOgAAIAFBAWohASACQQFqIgJBA3FFDQEgAiADSQ0ACwsCQCADQXxxIgBBwABJDQAgAiAAQUBqIgRLDQADQCACIAEoAgA2AgAgAiABKAIENgIEIAIgASgCCDYCCCACIAEoAgw2AgwgAiABKAIQNgIQIAIgASgCFDYCFCACIAEoAhg2AhggAiABKAIcNgIcIAIgASgCIDYCICACIAEoAiQ2AiQgAiABKAIoNgIoIAIgASgCLDYCLCACIAEoAjA2AjAgAiABKAI0NgI0IAIgASgCODYCOCACIAEoAjw2AjwgAUFAayEBIAJBQGsiAiAETQ0ACwsgACACTQ0BA0AgAiABKAIANgIAIAFBBGohASACQQRqIgIgAEkNAAsMAQsgA0EESQRAIAAhAgwBCyAAIANBBGsiBEsEQCAAIQIMAQsgACECA0AgAiABLQAAOgAAIAIgAS0AAToAASACIAEtAAI6AAIgAiABLQADOgADIAFBBGohASACQQRqIgIgBE0NAAsLIAIgA0kEQANAIAIgAS0AADoAACABQQFqIQEgAkEBaiICIANHDQALCwujAQEBfyACQX9zIQICQCABRQ0AIAFBAXEEfyAALQAAIAJB/wFxc0ECdEGwCGooAgAgAkEIdnMhAiAAQQFqIQAgAUEBawUgAQshAyABQQFGDQADQCAALQABIAAtAAAgAkH/AXFzQQJ0QbAIaigCACACQQh2cyIBQf8BcXNBAnRBsAhqKAIAIAFBCHZzIQIgAEECaiEAIANBAmsiAw0ACwsgAkF/cwtRAQJ/QaAIKAIAIgEgAEEDakF8cSICaiEAAkAgAkEAIAAgAU0bDQAgAD8AQRB0SwRAIAAQAEUNAQtBoAggADYCACABDwtB1KDAAEEwNgIAQX8L8QwBB38CQCAARQ0AIABBCGsiAyAAQQRrKAIAIgFBeHEiAGohBQJAIAFBAXENACABQQNxRQ0BIAMgAygCACIBayIDQeigwAAoAgBJDQEgACABaiEAIANB7KDAACgCAEcEQCABQf8BTQRAIAMoAggiAiABQQN2IgRBA3RBgKHAAGpGGiACIAMoAgwiAUYEQEHYoMAAQdigwAAoAgBBfiAEd3E2AgAMAwsgAiABNgIMIAEgAjYCCAwCCyADKAIYIQYCQCADIAMoAgwiAUcEQCADKAIIIgIgATYCDCABIAI2AggMAQsCQCADQRRqIgIoAgAiBA0AIANBEGoiAigCACIEDQBBACEBDAELA0AgAiEHIAQiAUEUaiICKAIAIgQNACABQRBqIQIgASgCECIEDQALIAdBADYCAAsgBkUNAQJAIAMgAygCHCICQQJ0QYijwABqIgQoAgBGBEAgBCABNgIAIAENAUHcoMAAQdygwAAoAgBBfiACd3E2AgAMAwsgBkEQQRQgBigCECADRhtqIAE2AgAgAUUNAgsgASAGNgIYIAMoAhAiAgRAIAEgAjYCECACIAE2AhgLIAMoAhQiAkUNASABIAI2AhQgAiABNgIYDAELIAUoAgQiAUEDcUEDRw0AQeCgwAAgADYCACAFIAFBfnE2AgQgAyAAQQFyNgIEIAAgA2ogADYCAA8LIAMgBU8NACAFKAIEIgFBAXFFDQACQCABQQJxRQRAIAVB8KDAACgCAEYEQEHwoMAAIAM2AgBB5KDAAEHkoMAAKAIAIABqIgA2AgAgAyAAQQFyNgIEIANB7KDAACgCAEcNA0HgoMAAQQA2AgBB7KDAAEEANgIADwsgBUHsoMAAKAIARgRAQeygwAAgAzYCAEHgoMAAQeCgwAAoAgAgAGoiADYCACADIABBAXI2AgQgACADaiAANgIADwsgAUF4cSAAaiEAAkAgAUH/AU0EQCAFKAIIIgIgAUEDdiIEQQN0QYChwABqRhogAiAFKAIMIgFGBEBB2KDAAEHYoMAAKAIAQX4gBHdxNgIADAILIAIgATYCDCABIAI2AggMAQsgBSgCGCEGAkAgBSAFKAIMIgFHBEAgBSgCCCICQeigwAAoAgBJGiACIAE2AgwgASACNgIIDAELAkAgBUEUaiICKAIAIgQNACAFQRBqIgIoAgAiBA0AQQAhAQwBCwNAIAIhByAEIgFBFGoiAigCACIEDQAgAUEQaiECIAEoAhAiBA0ACyAHQQA2AgALIAZFDQACQCAFIAUoAhwiAkECdEGIo8AAaiIEKAIARgRAIAQgATYCACABDQFB3KDAAEHcoMAAKAIAQX4gAndxNgIADAILIAZBEEEUIAYoAhAgBUYbaiABNgIAIAFFDQELIAEgBjYCGCAFKAIQIgIEQCABIAI2AhAgAiABNgIYCyAFKAIUIgJFDQAgASACNgIUIAIgATYCGAsgAyAAQQFyNgIEIAAgA2ogADYCACADQeygwAAoAgBHDQFB4KDAACAANgIADwsgBSABQX5xNgIEIAMgAEEBcjYCBCAAIANqIAA2AgALIABB/wFNBEAgAEEDdiIBQQN0QYChwABqIQACf0HYoMAAKAIAIgJBASABdCIBcUUEQEHYoMAAIAEgAnI2AgAgAAwBCyAAKAIICyECIAAgAzYCCCACIAM2AgwgAyAANgIMIAMgAjYCCA8LQR8hAiADQgA3AhAgAEH///8HTQRAIABBCHYiASABQYD+P2pBEHZBCHEiAXQiAiACQYDgH2pBEHZBBHEiAnQiBCAEQYCAD2pBEHZBAnEiBHRBD3YgASACciAEcmsiAUEBdCAAIAFBFWp2QQFxckEcaiECCyADIAI2AhwgAkECdEGIo8AAaiEBAkACQAJAQdygwAAoAgAiBEEBIAJ0IgdxRQRAQdygwAAgBCAHcjYCACABIAM2AgAgAyABNgIYDAELIABBAEEZIAJBAXZrIAJBH0YbdCECIAEoAgAhAQNAIAEiBCgCBEF4cSAARg0CIAJBHXYhASACQQF0IQIgBCABQQRxaiIHQRBqKAIAIgENAAsgByADNgIQIAMgBDYCGAsgAyADNgIMIAMgAzYCCAwBCyAEKAIIIgAgAzYCDCAEIAM2AgggA0EANgIYIAMgBDYCDCADIAA2AggLQfigwABB+KDAACgCAEEBayIAQX8gABs2AgALC5IvAQt/IwBBEGsiCyQAAkACQAJAAkACQAJAAkACQAJAAkACQCAAQfQBTQRAQdigwAAoAgAiBkEQIABBC2pBeHEgAEELSRsiB0EDdiICdiIBQQNxBEAgAUF/c0EBcSACaiIDQQN0IgFBiKHAAGooAgAiBEEIaiEAAkAgBCgCCCICIAFBgKHAAGoiAUYEQEHYoMAAIAZBfiADd3E2AgAMAQsgAiABNgIMIAEgAjYCCAsgBCADQQN0IgFBA3I2AgQgASAEaiIBIAEoAgRBAXI2AgQMDAsgB0HgoMAAKAIAIgpNDQEgAQRAAkBBAiACdCIAQQAgAGtyIAEgAnRxIgBBACAAa3FBAWsiACAAQQx2QRBxIgJ2IgFBBXZBCHEiACACciABIAB2IgFBAnZBBHEiAHIgASAAdiIBQQF2QQJxIgByIAEgAHYiAUEBdkEBcSIAciABIAB2aiIDQQN0IgBBiKHAAGooAgAiBCgCCCIBIABBgKHAAGoiAEYEQEHYoMAAIAZBfiADd3EiBjYCAAwBCyABIAA2AgwgACABNgIICyAEQQhqIQAgBCAHQQNyNgIEIAQgB2oiAiADQQN0IgEgB2siA0EBcjYCBCABIARqIAM2AgAgCgRAIApBA3YiAUEDdEGAocAAaiEFQeygwAAoAgAhBAJ/IAZBASABdCIBcUUEQEHYoMAAIAEgBnI2AgAgBQwBCyAFKAIICyEBIAUgBDYCCCABIAQ2AgwgBCAFNgIMIAQgATYCCAtB7KDAACACNgIAQeCgwAAgAzYCAAwMC0HcoMAAKAIAIglFDQEgCUEAIAlrcUEBayIAIABBDHZBEHEiAnYiAUEFdkEIcSIAIAJyIAEgAHYiAUECdkEEcSIAciABIAB2IgFBAXZBAnEiAHIgASAAdiIBQQF2QQFxIgByIAEgAHZqQQJ0QYijwABqKAIAIgEoAgRBeHEgB2shAyABIQIDQAJAIAIoAhAiAEUEQCACKAIUIgBFDQELIAAoAgRBeHEgB2siAiADIAIgA0kiAhshAyAAIAEgAhshASAAIQIMAQsLIAEoAhghCCABIAEoAgwiBEcEQCABKAIIIgBB6KDAACgCAEkaIAAgBDYCDCAEIAA2AggMCwsgAUEUaiICKAIAIgBFBEAgASgCECIARQ0DIAFBEGohAgsDQCACIQUgACIEQRRqIgIoAgAiAA0AIARBEGohAiAEKAIQIgANAAsgBUEANgIADAoLQX8hByAAQb9/Sw0AIABBC2oiAEF4cSEHQdygwAAoAgAiCUUNAEEAIAdrIQMCQAJAAkACf0EAIAdBgAJJDQAaQR8gB0H///8HSw0AGiAAQQh2IgAgAEGA/j9qQRB2QQhxIgJ0IgAgAEGA4B9qQRB2QQRxIgF0IgAgAEGAgA9qQRB2QQJxIgB0QQ92IAEgAnIgAHJrIgBBAXQgByAAQRVqdkEBcXJBHGoLIgZBAnRBiKPAAGooAgAiAkUEQEEAIQAMAQtBACEAIAdBAEEZIAZBAXZrIAZBH0YbdCEBA0ACQCACKAIEQXhxIAdrIgUgA08NACACIQQgBSIDDQBBACEDIAIhAAwDCyAAIAIoAhQiBSAFIAIgAUEddkEEcWooAhAiAkYbIAAgBRshACABQQF0IQEgAg0ACwsgACAEckUEQEEAIQRBAiAGdCIAQQAgAGtyIAlxIgBFDQMgAEEAIABrcUEBayIAIABBDHZBEHEiAnYiAUEFdkEIcSIAIAJyIAEgAHYiAUECdkEEcSIAciABIAB2IgFBAXZBAnEiAHIgASAAdiIBQQF2QQFxIgByIAEgAHZqQQJ0QYijwABqKAIAIQALIABFDQELA0AgACgCBEF4cSAHayIBIANJIQIgASADIAIbIQMgACAEIAIbIQQgACgCECIBBH8gAQUgACgCFAsiAA0ACwsgBEUNACADQeCgwAAoAgAgB2tPDQAgBCgCGCEGIAQgBCgCDCIBRwRAIAQoAggiAEHooMAAKAIASRogACABNgIMIAEgADYCCAwJCyAEQRRqIgIoAgAiAEUEQCAEKAIQIgBFDQMgBEEQaiECCwNAIAIhBSAAIgFBFGoiAigCACIADQAgAUEQaiECIAEoAhAiAA0ACyAFQQA2AgAMCAsgB0HgoMAAKAIAIgJNBEBB7KDAACgCACEDAkAgAiAHayIBQRBPBEBB4KDAACABNgIAQeygwAAgAyAHaiIANgIAIAAgAUEBcjYCBCACIANqIAE2AgAgAyAHQQNyNgIEDAELQeygwABBADYCAEHgoMAAQQA2AgAgAyACQQNyNgIEIAIgA2oiACAAKAIEQQFyNgIECyADQQhqIQAMCgsgB0HkoMAAKAIAIghJBEBB5KDAACAIIAdrIgE2AgBB8KDAAEHwoMAAKAIAIgIgB2oiADYCACAAIAFBAXI2AgQgAiAHQQNyNgIEIAJBCGohAAwKC0EAIQAgB0EvaiIJAn9BsKTAACgCAARAQbikwAAoAgAMAQtBvKTAAEJ/NwIAQbSkwABCgKCAgICABDcCAEGwpMAAIAtBDGpBcHFB2KrVqgVzNgIAQcSkwABBADYCAEGUpMAAQQA2AgBBgCALIgFqIgZBACABayIFcSICIAdNDQlBkKTAACgCACIEBEBBiKTAACgCACIDIAJqIgEgA00NCiABIARLDQoLQZSkwAAtAABBBHENBAJAAkBB8KDAACgCACIDBEBBmKTAACEAA0AgAyAAKAIAIgFPBEAgASAAKAIEaiADSw0DCyAAKAIIIgANAAsLQQAQBCIBQX9GDQUgAiEGQbSkwAAoAgAiA0EBayIAIAFxBEAgAiABayAAIAFqQQAgA2txaiEGCyAGIAdNDQUgBkH+////B0sNBUGQpMAAKAIAIgQEQEGIpMAAKAIAIgMgBmoiACADTQ0GIAAgBEsNBgsgBhAEIgAgAUcNAQwHCyAGIAhrIAVxIgZB/v///wdLDQQgBhAEIgEgACgCACAAKAIEakYNAyABIQALAkAgAEF/Rg0AIAdBMGogBk0NAEG4pMAAKAIAIgEgCSAGa2pBACABa3EiAUH+////B0sEQCAAIQEMBwsgARAEQX9HBEAgASAGaiEGIAAhAQwHC0EAIAZrEAQaDAQLIAAiAUF/Rw0FDAMLQQAhBAwHC0EAIQEMBQsgAUF/Rw0CC0GUpMAAQZSkwAAoAgBBBHI2AgALIAJB/v///wdLDQEgAhAEIQFBABAEIQAgAUF/Rg0BIABBf0YNASAAIAFNDQEgACABayIGIAdBKGpNDQELQYikwABBiKTAACgCACAGaiIANgIAQYykwAAoAgAgAEkEQEGMpMAAIAA2AgALAkACQAJAQfCgwAAoAgAiBQRAQZikwAAhAANAIAEgACgCACIDIAAoAgQiAmpGDQIgACgCCCIADQALDAILQeigwAAoAgAiAEEAIAAgAU0bRQRAQeigwAAgATYCAAtBACEAQZykwAAgBjYCAEGYpMAAIAE2AgBB+KDAAEF/NgIAQfygwABBsKTAACgCADYCAEGkpMAAQQA2AgADQCAAQQN0IgNBiKHAAGogA0GAocAAaiICNgIAIANBjKHAAGogAjYCACAAQQFqIgBBIEcNAAtB5KDAACAGQShrIgNBeCABa0EHcUEAIAFBCGpBB3EbIgBrIgI2AgBB8KDAACAAIAFqIgA2AgAgACACQQFyNgIEIAEgA2pBKDYCBEH0oMAAQcCkwAAoAgA2AgAMAgsgAC0ADEEIcQ0AIAMgBUsNACABIAVNDQAgACACIAZqNgIEQfCgwAAgBUF4IAVrQQdxQQAgBUEIakEHcRsiAGoiAjYCAEHkoMAAQeSgwAAoAgAgBmoiASAAayIANgIAIAIgAEEBcjYCBCABIAVqQSg2AgRB9KDAAEHApMAAKAIANgIADAELQeigwAAoAgAgAUsEQEHooMAAIAE2AgALIAEgBmohAkGYpMAAIQACQAJAAkACQAJAAkADQCACIAAoAgBHBEAgACgCCCIADQEMAgsLIAAtAAxBCHFFDQELQZikwAAhAANAIAUgACgCACICTwRAIAIgACgCBGoiBCAFSw0DCyAAKAIIIQAMAAsACyAAIAE2AgAgACAAKAIEIAZqNgIEIAFBeCABa0EHcUEAIAFBCGpBB3EbaiIJIAdBA3I2AgQgAkF4IAJrQQdxQQAgAkEIakEHcRtqIgYgByAJaiIIayECIAUgBkYEQEHwoMAAIAg2AgBB5KDAAEHkoMAAKAIAIAJqIgA2AgAgCCAAQQFyNgIEDAMLIAZB7KDAACgCAEYEQEHsoMAAIAg2AgBB4KDAAEHgoMAAKAIAIAJqIgA2AgAgCCAAQQFyNgIEIAAgCGogADYCAAwDCyAGKAIEIgBBA3FBAUYEQCAAQXhxIQUCQCAAQf8BTQRAIAYoAggiAyAAQQN2IgBBA3RBgKHAAGpGGiADIAYoAgwiAUYEQEHYoMAAQdigwAAoAgBBfiAAd3E2AgAMAgsgAyABNgIMIAEgAzYCCAwBCyAGKAIYIQcCQCAGIAYoAgwiAUcEQCAGKAIIIgAgATYCDCABIAA2AggMAQsCQCAGQRRqIgAoAgAiAw0AIAZBEGoiACgCACIDDQBBACEBDAELA0AgACEEIAMiAUEUaiIAKAIAIgMNACABQRBqIQAgASgCECIDDQALIARBADYCAAsgB0UNAAJAIAYgBigCHCIDQQJ0QYijwABqIgAoAgBGBEAgACABNgIAIAENAUHcoMAAQdygwAAoAgBBfiADd3E2AgAMAgsgB0EQQRQgBygCECAGRhtqIAE2AgAgAUUNAQsgASAHNgIYIAYoAhAiAARAIAEgADYCECAAIAE2AhgLIAYoAhQiAEUNACABIAA2AhQgACABNgIYCyAFIAZqIQYgAiAFaiECCyAGIAYoAgRBfnE2AgQgCCACQQFyNgIEIAIgCGogAjYCACACQf8BTQRAIAJBA3YiAEEDdEGAocAAaiECAn9B2KDAACgCACIBQQEgAHQiAHFFBEBB2KDAACAAIAFyNgIAIAIMAQsgAigCCAshACACIAg2AgggACAINgIMIAggAjYCDCAIIAA2AggMAwtBHyEAIAJB////B00EQCACQQh2IgAgAEGA/j9qQRB2QQhxIgN0IgAgAEGA4B9qQRB2QQRxIgF0IgAgAEGAgA9qQRB2QQJxIgB0QQ92IAEgA3IgAHJrIgBBAXQgAiAAQRVqdkEBcXJBHGohAAsgCCAANgIcIAhCADcCECAAQQJ0QYijwABqIQQCQEHcoMAAKAIAIgNBASAAdCIBcUUEQEHcoMAAIAEgA3I2AgAgBCAINgIAIAggBDYCGAwBCyACQQBBGSAAQQF2ayAAQR9GG3QhACAEKAIAIQEDQCABIgMoAgRBeHEgAkYNAyAAQR12IQEgAEEBdCEAIAMgAUEEcWoiBCgCECIBDQALIAQgCDYCECAIIAM2AhgLIAggCDYCDCAIIAg2AggMAgtB5KDAACAGQShrIgNBeCABa0EHcUEAIAFBCGpBB3EbIgBrIgI2AgBB8KDAACAAIAFqIgA2AgAgACACQQFyNgIEIAEgA2pBKDYCBEH0oMAAQcCkwAAoAgA2AgAgBSAEQScgBGtBB3FBACAEQSdrQQdxG2pBL2siACAAIAVBEGpJGyICQRs2AgQgAkGgpMAAKQIANwIQIAJBmKTAACkCADcCCEGgpMAAIAJBCGo2AgBBnKTAACAGNgIAQZikwAAgATYCAEGkpMAAQQA2AgAgAkEYaiEAA0AgAEEHNgIEIABBCGohASAAQQRqIQAgASAESQ0ACyACIAVGDQMgAiACKAIEQX5xNgIEIAUgAiAFayIEQQFyNgIEIAIgBDYCACAEQf8BTQRAIARBA3YiAEEDdEGAocAAaiECAn9B2KDAACgCACIBQQEgAHQiAHFFBEBB2KDAACAAIAFyNgIAIAIMAQsgAigCCAshACACIAU2AgggACAFNgIMIAUgAjYCDCAFIAA2AggMBAtBHyEAIAVCADcCECAEQf///wdNBEAgBEEIdiIAIABBgP4/akEQdkEIcSICdCIAIABBgOAfakEQdkEEcSIBdCIAIABBgIAPakEQdkECcSIAdEEPdiABIAJyIAByayIAQQF0IAQgAEEVanZBAXFyQRxqIQALIAUgADYCHCAAQQJ0QYijwABqIQMCQEHcoMAAKAIAIgJBASAAdCIBcUUEQEHcoMAAIAEgAnI2AgAgAyAFNgIAIAUgAzYCGAwBCyAEQQBBGSAAQQF2ayAAQR9GG3QhACADKAIAIQEDQCABIgIoAgRBeHEgBEYNBCAAQR12IQEgAEEBdCEAIAIgAUEEcWoiAygCECIBDQALIAMgBTYCECAFIAI2AhgLIAUgBTYCDCAFIAU2AggMAwsgAygCCCIAIAg2AgwgAyAINgIIIAhBADYCGCAIIAM2AgwgCCAANgIICyAJQQhqIQAMBQsgAigCCCIAIAU2AgwgAiAFNgIIIAVBADYCGCAFIAI2AgwgBSAANgIIC0HkoMAAKAIAIgAgB00NAEHkoMAAIAAgB2siATYCAEHwoMAAQfCgwAAoAgAiAiAHaiIANgIAIAAgAUEBcjYCBCACIAdBA3I2AgQgAkEIaiEADAMLQdSgwABBMDYCAEEAIQAMAgsCQCAGRQ0AAkAgBCgCHCICQQJ0QYijwABqIgAoAgAgBEYEQCAAIAE2AgAgAQ0BQdygwAAgCUF+IAJ3cSIJNgIADAILIAZBEEEUIAYoAhAgBEYbaiABNgIAIAFFDQELIAEgBjYCGCAEKAIQIgAEQCABIAA2AhAgACABNgIYCyAEKAIUIgBFDQAgASAANgIUIAAgATYCGAsCQCADQQ9NBEAgBCADIAdqIgBBA3I2AgQgACAEaiIAIAAoAgRBAXI2AgQMAQsgBCAHQQNyNgIEIAQgB2oiBSADQQFyNgIEIAMgBWogAzYCACADQf8BTQRAIANBA3YiAEEDdEGAocAAaiECAn9B2KDAACgCACIBQQEgAHQiAHFFBEBB2KDAACAAIAFyNgIAIAIMAQsgAigCCAshACACIAU2AgggACAFNgIMIAUgAjYCDCAFIAA2AggMAQtBHyEAIANB////B00EQCADQQh2IgAgAEGA/j9qQRB2QQhxIgJ0IgAgAEGA4B9qQRB2QQRxIgF0IgAgAEGAgA9qQRB2QQJxIgB0QQ92IAEgAnIgAHJrIgBBAXQgAyAAQRVqdkEBcXJBHGohAAsgBSAANgIcIAVCADcCECAAQQJ0QYijwABqIQECQAJAIAlBASAAdCICcUUEQEHcoMAAIAIgCXI2AgAgASAFNgIADAELIANBAEEZIABBAXZrIABBH0YbdCEAIAEoAgAhBwNAIAciASgCBEF4cSADRg0CIABBHXYhAiAAQQF0IQAgASACQQRxaiICKAIQIgcNAAsgAiAFNgIQCyAFIAE2AhggBSAFNgIMIAUgBTYCCAwBCyABKAIIIgAgBTYCDCABIAU2AgggBUEANgIYIAUgATYCDCAFIAA2AggLIARBCGohAAwBCwJAIAhFDQACQCABKAIcIgJBAnRBiKPAAGoiACgCACABRgRAIAAgBDYCACAEDQFB3KDAACAJQX4gAndxNgIADAILIAhBEEEUIAgoAhAgAUYbaiAENgIAIARFDQELIAQgCDYCGCABKAIQIgAEQCAEIAA2AhAgACAENgIYCyABKAIUIgBFDQAgBCAANgIUIAAgBDYCGAsCQCADQQ9NBEAgASADIAdqIgBBA3I2AgQgACABaiIAIAAoAgRBAXI2AgQMAQsgASAHQQNyNgIEIAEgB2oiAiADQQFyNgIEIAIgA2ogAzYCACAKBEAgCkEDdiIAQQN0QYChwABqIQVB7KDAACgCACEEAn9BASAAdCIAIAZxRQRAQdigwAAgACAGcjYCACAFDAELIAUoAggLIQAgBSAENgIIIAAgBDYCDCAEIAU2AgwgBCAANgIIC0HsoMAAIAI2AgBB4KDAACADNgIACyABQQhqIQALIAtBEGokACAAC9YCAQF/AkAgAUUNACAAQQA6AAAgACABaiICQQFrQQA6AAAgAUEDSQ0AIABBADoAAiAAQQA6AAEgAkEDa0EAOgAAIAJBAmtBADoAACABQQdJDQAgAEEAOgADIAJBBGtBADoAACABQQlJDQAgAEEAIABrQQNxIgJqIgBBADYCACAAIAEgAmtBfHEiAmoiAUEEa0EANgIAIAJBCUkNACAAQQA2AgggAEEANgIEIAFBCGtBADYCACABQQxrQQA2AgAgAkEZSQ0AIABBADYCGCAAQQA2AhQgAEEANgIQIABBADYCDCABQRBrQQA2AgAgAUEUa0EANgIAIAFBGGtBADYCACABQRxrQQA2AgAgAiAAQQRxQRhyIgJrIgFBIEkNACAAIAJqIQADQCAAQgA3AxggAEIANwMQIABCADcDCCAAQgA3AwAgAEEgaiEAIAFBIGsiAUEfSw0ACwsLAwABC7AEAQd/AkAgACgCACIGQYCAgAhPBEAgACgCBCEEDAELIAAgBkEIdCIGNgIAIAAgACgCECIDQQFqNgIQIAAgAyAAKAIMai0AACAAKAIEQQh0ciIENgIECwJ/IAEvAQAiBSAGQQt2bCIDIARLBEAgASAFQYAQIAVrQQV2ajsBACABIAJBBHRqQQRqIQhBAiEFQQgMAQsgACAEIANrIgQ2AgQgASAFIAVBBXZrOwEAIAYgA2siBkH///8HTQRAIAAgBkEIdCIGNgIAIAAgACgCECIDQQFqNgIQIAAgAyAAKAIMai0AACAEQQh0ciIENgIECyABLwECIgUgBkELdmwiAyAESwRAIAEgBUGAECAFa0EFdmo7AQIgASACQQR0akGEAmohCEEKIQVBCAwBCyAAIAQgA2siBDYCBCABIAUgBUEFdms7AQIgAUGEBGohCCAGIANrIQNBEiEFQYACCyEGIAAgBTYCaEEBIQEDQCAIIAFBAXQiAWohCQJAIANB////B0sEQCADIQIMAQsgACADQQh0IgI2AgAgACAAKAIQIgNBAWo2AhAgACADIAAoAgxqLQAAIARBCHRyIgQ2AgQLAkAgCS8BACIHIAJBC3ZsIgMgBE0EQCAAIAQgA2siBDYCBCAAIAIgA2siAzYCACAJIAcgB0EFdms7AQAgAUEBciEBDAELIAAgAzYCACAJIAdBgBAgB2tBBXZqOwEACyABIAZJDQALIAAgASAGayAFajYCaAvIHwEQfwJAIAAoAigiASAAKAIgIglNDQAgACgCaCICRQ0AIAAoAlQiAyAAKAIkTw0AIAAoAjAgA00NACAAIAIgASAJayIBIAIgASACSRsiBms2AmggCSADQX9zaiEEIAMgCU8EQCAAKAIsIARqIQQLIAAoAhgiAyAEai0AACEBIAAgCUEBajYCICADIAlqIAE6AAACQCAGQQFrIgdFDQAgB0EBcQRAIAAoAhgiAkEAIARBAWoiASABIAAoAixGGyIEai0AACEDIAAgACgCICIBQQFqNgIgIAEgAmogAzoAACAGQQJrIQcLIAZBAkYNAANAIAAoAhgiAkEAIARBAWoiASABIAAoAixGGyIGai0AACEDIAAgACgCICIBQQFqNgIgIAEgAmogAzoAACAAKAIYIgJBACAGQQFqIgEgASAAKAIsRhsiBGotAAAhAyAAIAAoAiAiAUEBajYCICABIAJqIAM6AAAgB0ECayIHDQALCyAAKAIgIgkgACgCJE0NACAAIAk2AiQLAkACQCAJIAAoAihPDQAgAEHcDWohDiAAQeAVaiEPIABB1ABqIRADQCAAKAIQIgMgACgCFEsNASAAIAAoAmQiCkEFdGogACgCdCAJcSIIQQF0aiIMIQYCQCAAKAIAIgVBgICACE8EQCAAKAIEIQQMAQsgACAFQQh0IgU2AgAgACADQQFqIgE2AhAgACAAKAIMIANqLQAAIAAoAgRBCHRyIgQ2AgQgASEDCwJAIAYvAXgiASAFQQt2bCICIARLBEAgACACNgIAIAYgAUGAECABa0EFdmo7AXggCUEBayEFIAlFBEAgACgCLCAFaiEFCyAAKAJwIAlxIAAoAmwiAXQgACgCJCIGBH8gACgCGCAFai0AAAVBAAtBCCABa3ZqIQ1BASEFAkAgCkEGTQRAA0AgBUEBdCIFIAAgDUGADGxqakHkHWohBgJAIAJB////B0sEQCACIQEMAQsgACACQQh0IgE2AgAgACADQQFqIgI2AhAgACAAKAIMIANqLQAAIARBCHRyIgQ2AgQgAiEDCwJAIAYvAQAiCCABQQt2bCICIARNBEAgACAEIAJrIgQ2AgQgACABIAJrIgI2AgAgBiAIIAhBBXZrOwEAIAVBAXIhBQwBCyAAIAI2AgAgBiAIQYAQIAhrQQV2ajsBAAsgBUGAAkkNAAwCCwALIAkgACgCVCIBQX9zaiEFIAEgCU8EQCAAKAIsIAVqIQULIAYEfyAAKAIYIAVqLQAABUEACyEGQQEhBUGAAiEHA0AgACANQYAMbGogBkEBdCIGIAdxIgwgB2ogBWpBAXRqQeQdaiELAkAgAkH///8HSwRAIAIhCAwBCyAAIAJBCHQiCDYCACAAIANBAWoiATYCECAAIAAoAgwgA2otAAAgBEEIdHIiBDYCBCABIQMLIAsCfyAEIAsvAQAiASAIQQt2bCICTyIKRQRAIAAgAjYCACABQYAQIAFrQQV2agwBCyAAIAQgAmsiBDYCBCAAIAggAmsiAjYCAEEAIQcgASABQQV2aws7AQAgByAMcyEHIAVBAXQgCnIiBUGAAkkNAAsLIAAgCUEBajYCICAAKAIYIAlqIAU6AAAgACgCICIJIAAoAiRLBEAgACAJNgIkC0EAIQIgACAAKAJkIgFBBE8EfyABQQlNBEAgACABQQNrNgJkDAMLIAFBBmsFQQALNgJkDAELIAAgBCACayIENgIEIAAgBSACayICNgIAIAYgASABQQV2azsBeCAAIApBAXRqIgshBgJAIAJB////B0sEQCADIQEMAQsgACACQQh0IgI2AgAgACADQQFqIgE2AhAgACAAKAIMIANqLQAAIARBCHRyIgQ2AgQLAkAgBi8B+AMiCiACQQt2bCIDIARNBEAgACAEIANrIgQ2AgQgACACIANrIgI2AgAgBiAKIApBBXZrOwH4AwJAIAJB////B0sEQCABIQYMAQsgACACQQh0IgI2AgAgACABQQFqIgY2AhAgACAAKAIMIAFqLQAAIARBCHRyIgQ2AgQLAkAgCy8BkAQiASACQQt2bCIFIARLBEAgCyABQYAQIAFrQQV2ajsBkAQgBUH///8HTQRAIAAgBUEIdCIFNgIAIAAgBkEBajYCECAAIAAoAgwgBmotAAAgBEEIdHIiBDYCBAsgDC8B2AQiAyAFQQt2bCIBIARNBEAgACAEIAFrNgIEIAAgBSABazYCACAMIAMgA0EFdms7AdgEDAILIAAgATYCACAMIANBgBAgA2tBBXZqOwHYBCAAQQE2AmggAEEJQQsgACgCZEEHSRs2AmQMAwsgACAEIAVrIgQ2AgQgCyABIAFBBXZrOwGQBAJAIAIgBWsiAkH///8HSwRAIAYhAQwBCyAAIAJBCHQiAjYCACAAIAZBAWoiATYCECAAIAAoAgwgBmotAAAgBEEIdHIiBDYCBAsCQCALLwGoBCIGIAJBC3ZsIgMgBEsEQCAAIAM2AgAgCyAGQYAQIAZrQQV2ajsBqAQgACgCWCECDAELIAAgBCADayIENgIEIAsgBiAGQQV2azsBqAQgAiADayICQf///wdNBEAgACACQQh0IgI2AgAgACABQQFqNgIQIAAgACgCDCABai0AACAEQQh0ciIENgIECwJAIAsvAcAEIgMgAkELdmwiASAESwRAIAAgATYCACALIANBgBAgA2tBBXZqOwHABCAAKAJcIQIMAQsgACAEIAFrNgIEIAAgAiABazYCACALIAMgA0EFdms7AcAEIAAoAmAhAiAAIAAoAlw2AmALIAAgACgCWDYCXAsgACAAKAJUNgJYIAAgAjYCVAsgAEEIQQsgACgCZEEHSRs2AmQgACAPIAgQCQwBCyAAIAM2AgAgBiAKQYAQIAprQQV2ajsB+AMgACAAKAJcNgJgIAAgACkCVDcCWCAAQQdBCiAAKAJkQQdJGzYCZCAAIA4gCBAJIAAoAmgiAUECa0EDIAFBBkkbIQMgACgCACECQQEhBANAIARBAXQiBCAAIANBB3RqaiEGAkAgAkGAgIAITwRAIAAoAgQhBQwBCyAAIAJBCHQiAjYCACAAIAAoAhAiAUEBajYCECAAIAEgACgCDGotAAAgACgCBEEIdHIiBTYCBAsCQCAGLwHYByIIIAJBC3ZsIgEgBU0EQCAAIAUgAWsiBTYCBCAAIAIgAWsiAjYCACAGIAggCEEFdms7AdgHIARBAXIhBAwBCyAAIAE2AgAgBiAIQYAQIAhrQQV2ajsB2AcgASECCyAEQcAASQ0ACyAEQUBqIgNBA00EQCAAIAM2AlQMAQsgACAEQQFxQQJyIgc2AlQgA0EBdiEBIANBDU0EQCAAIAcgAUEBayIKdCIINgJUQQEhByAQIAhBAXRqQQAgBGtBAXRqQYIMaiEGQQAhCwNAIAYgB0EBdCIHaiEMAkAgAkH///8HSwRAIAIhAQwBCyAAIAJBCHQiATYCACAAIAAoAhAiA0EBajYCECAAIAMgACgCDGotAAAgBUEIdHIiBTYCBAsCQCAMLwEAIgMgAUELdmwiAiAFTQRAIAAgBSACayIFNgIEIAAgASACayICNgIAIAwgAyADQQV2azsBACAAQQEgC3QgCGoiCDYCVCAHQQFyIQcMAQsgACACNgIAIAwgA0GAECADa0EFdmo7AQALIAtBAWoiCyAKRw0ACwwBCyABQQVrIQQDQAJAIAJB////B0sEQCACIQMMAQsgACACQQh0IgM2AgAgACAAKAIQIgFBAWo2AhAgASAAKAIMai0AACAFQQh0ciEFCyAAIANBAXYiAjYCACAAIAUgAmsiBkEfdSIBIAdBAXRqQQFqIgc2AlQgACABIAJxIAZqIgU2AgQgBEEBayIEDQALIAAgB0EEdCIHNgJUIANB////D00EQCAAIAJBCHQiAjYCACAAIAAoAhAiAUEBajYCECAAIAEgACgCDGotAAAgBUEIdHIiBTYCBAsgAAJ/IAAvAb4NIgEgAkELdmwiBCAFTQRAIAAgBSAEayIFNgIEIAAgB0EBciIHNgJUIAAgASABQQV2azsBvg0gAiAEayEEQQMMAQsgACABQYAQIAFrQQV2ajsBvg1BAgtBAXQiA2pBvA1qIQYgBEH///8HTQRAIAAgBEEIdCIENgIAIAAgACgCECIBQQFqNgIQIAAgASAAKAIMai0AACAFQQh0ciIFNgIECwJAIAYvAQAiASAEQQt2bCICIAVNBEAgACAFIAJrIgU2AgQgBiABIAFBBXZrOwEAIAAgB0ECaiIHNgJUIAQgAmshAiADQQFyIQMMAQsgBiABQYAQIAFrQQV2ajsBAAsgACADQQF0IgNqQbwNaiEGIAJB////B00EQCAAIAJBCHQiAjYCACAAIAAoAhAiAUEBajYCECAAIAEgACgCDGotAAAgBUEIdHIiBTYCBAsCQCAGLwEAIgEgAkELdmwiBCAFTQRAIAAgBSAEayIFNgIEIAYgASABQQV2azsBACAAIAdBBGoiBzYCVCACIARrIQQgA0EBciEDDAELIAYgAUGAECABa0EFdmo7AQALIARB////B00EQCAAIARBCHQiBDYCACAAIAAoAhAiAUEBajYCECAAIAEgACgCDGotAAAgBUEIdHIiBTYCBAsgACADQQF0akG8DWoiAS8BACICIARBC3ZsIgMgBU0EQCAAIAUgA2s2AgQgACAEIANrNgIAIAEgAiACQQV2azsBACAAIAdBCGo2AlQMAQsgACADNgIAIAEgAkGAECACa0EFdmo7AQALQQAhAiAAKAJUIgYgACgCJE8NAyAAKAIwIAZNDQMgACAAKAJoIgMgACgCKCAAKAIgIgprIgEgAyABIANJGyIIazYCaCAKIAZBf3NqIQIgBiAKTwRAIAAoAiwgAmohAgsgACgCGCIDIAJqLQAAIQEgACAKQQFqNgIgIAMgCmogAToAAAJAIAhBAWsiBUUNACAFQQFxBEAgACgCGCIGQQAgAkEBaiIBIAEgACgCLEYbIgJqLQAAIQMgACAAKAIgIgFBAWo2AiAgASAGaiADOgAAIAhBAmshBQsgCEECRg0AA0AgACgCGCIGQQAgAkEBaiIBIAEgACgCLEYbIgJqLQAAIQMgACAAKAIgIgFBAWo2AiAgASAGaiADOgAAIAAoAhgiBkEAIAJBAWoiASABIAAoAixGGyICai0AACEDIAAgACgCICIBQQFqNgIgIAEgBmogAzoAACAFQQJrIgUNAAsLIAAoAiAiCSAAKAIkTQ0AIAAgCTYCJAsgCSAAKAIoSQ0ACwtBASECIAAoAgAiAUH///8HSw0AIAAgAUEIdDYCACAAIAAoAhAiAUEBajYCECAAIAEgACgCDGotAAAgACgCBEEIdHI2AgQLIAILJgEBfyAABEAgACgCsAkiASgCPARAIAEoAhgQBQsgARAFIAAQBQsLMgEBfyAAIAApA4ABIAIgACgCECICayIDrXw3A4ABIAAgASACaiADIAAoAhgQA603AxgLgQEBAn8CQAJAIAJBBE8EQCAAIAFyQQNxDQEDQCAAKAIAIAEoAgBHDQIgAUEEaiEBIABBBGohACACQQRrIgJBA0sNAAsLIAJFDQELA0AgAC0AACIDIAEtAAAiBEYEQCABQQFqIQEgAEEBaiEAIAJBAWsiAg0BDAILCyADIARrDwtBAAsJAEG8oCAoAgALCQBBsKAgKAIAC9QzAhR/An4CQAJAAkACQAJAAkACQAJAAn8Cf0HQoMAAKAIAIgEoAiQEQCABKAIADAELIAFBADoAKCABQgA3AwAgAUIANwMYIAFByABqQeQAEAcgAUEMNgKsAUEACyEAQcCgICgCACENIAFBtKAgKAIAIg42AhAgAUHgAGohDyABQbYBaiEQIAFBsAFqIREgAUGoAWohCANAAkACQAJAAkACQAJAAkACQAJAAkAgCAJ/AkACQAJAIAAOCgECAAoLDAQFBgcOC0GwoCAoAgAhAyABKAKsASECQbSgICgCACEAQbigICgCACEGIAEoAqgBDAILIAggASgCqAEiAGpBCGpBtKAgKAIAIgJBsKAgKAIAakG4oCAoAgAgAmsiAiABKAKsASAAayIAIAAgAksbIgAQAkG0oCBBtKAgKAIAIABqNgIAQQAhAyABQQAgASgCqAEgAGoiACAAIAEoAqwBIgJGGzYCqAEgACACRw0LIAFBATYCACARQYAIQQYQDQRAQQUhAwwMCyAQQQJBABADIAEoALgBRwRAQQchAwwMC0EGIQMgEC0AAA0LIAEgAS0AtwEiADYCICAAQQ9LDQtBAiEDIABBBEsNC0EBIAB0QRNxRQ0LC0G0oCAoAgAiAEG4oCAoAgAiBkYEQEEAIQMMCwtBsKAgKAIAIgMgAGotAAAiAkUEQEG0oCAgAEEBajYCACABIAA2AhBBBiEAIAFBBjYCAAwMCyABQQA2AqgBIAFBAjYCACABIAJBAnRBBGoiAjYCrAEgASACNgJAQQALIgVqQQhqIAAgA2ogBiAAayIAIAIgBWsiAiAAIAJJGyIAEAJBtKAgIABBtKAgKAIAajYCAEEAIQMgAUEAIAEoAqgBIABqIgAgACABKAKsASICRhs2AqgBIAAgAkcNCSABIABBBGsiADYCrAEgESAAQQAQAyABIAEoAqwBIgVqKACwAUcEQEEHIQMMCgsgAUECNgKoASABLACxASIEQT9xBEBBBiEDDAoLQQIhAEJ/IRVCfyEUIARBwABxRQ0FIAEoAgQiAkUEQCABQgA3AwgLIAVBAiAFQQJLGyEGA0AgACAGRgRAQQchAwwLCyAAIAhqLQAIIQMgASAAQQFqIgA2AqgBIAEgASkDCCADQf8Aca0gAq2GhCIUNwMIIANBgAFxRQRAAkAgAw0AIAJFDQBBByEDDAwLIAFBADYCBAwHC0EHIQMgASACQQdqIgI2AgQgAkE/Rw0ACwwJCwJ/IAFBkAFqIQYDQEG4oCAoAgAhAkGwoCAoAgAhBCABKAIEIgVFBEAgAUIANwMIC0G0oCAoAgAiACACIAAgAksbIQICQANAAkAgACACRgRAQQAhAyACIQAMAQsgACAEai0AACEDQbSgICAAQQFqIgA2AgAgASABKQMIIANB/wBxrSAFrYaEIhQ3AwggA0GAAXFFBEAgAw0DIAVFDQNBByEDDAELQQchAyABIAVBB2oiBTYCBCAFQT9HDQELCyABIAEpA4ABIAAgASgCECIAayICrXw3A4ABIAEgACAEaiACIAEoAhgQA603AxggAwwCCyABQQA2AgQCQAJAAkACQAJAIAEoAngOAwACAQMLIAEgFDcDiAFBByABKQNYIBRSDQUaIAFBATYCeAwDCyABIAEpA5gBIBR8NwOYASABIAZBGCABKAKgARADNgKgASABQQE2AnggASABKQOIAUIBfSIUNwOIAQwCCyABQQI2AnggASABKQOQASAUfDcDkAELIAEpA4gBIRQLIBRCAFINAAtBAQsiA0EBRw0IIAFBBzYCAAsCQCABKQOAASIUQbSgICgCACIAIAEoAhAiBGutfEIDg1ANAEGwoCAoAgAhBkG4oCAoAgAgAEYEQCAAIQIMBAtBtKAgIABBAWoiAjYCAEEHIQMgACAGai0AAA0IAkAgFCACIARrrXxCA4NQDQBBsKAgKAIAIQYgAkG4oCAoAgBGDQRBtKAgIABBAmoiBTYCACACIAZqLQAADQkgFCAFIARrrXxCA4NQBEAgBSEADAILQbCgICgCACEGQbigICgCACAFRgRAIAUhAgwFC0G0oCAgAEEDaiICNgIAIAUgBmotAAANCSAUIAIgBGutfEIDg1ANAEG4oCAoAgAgAkYEQEGwoCAoAgAhBgwFC0G0oCAgAEEEajYCAAwJCyACIQALIAFBsKAgKAIAIAAQDEEHIQMgDyABQZABakEYEA0NByABQQg2AgALAn9BtKAgKAIAIQBBuKAgKAIAIQUDQEEAIAAgBUYNARogASkDGCEUIAEoAgQhA0G0oCAgAEEBaiICNgIAQQdBsKAgKAIAIABqLQAAIBQgA62Ip0H/AXFHDQEaIAEgA0EIaiIDNgIEIAIhACADQSBJDQALIAFBADYCBCABQgA3AxhBAQsiA0EBRw0GIAFBCTYCACABQQw2AqwBC0EAIQMgASABKAKoASIAakGwAWpBtKAgKAIAIgJBsKAgKAIAakG4oCAoAgAgAmsiAiABKAKsASAAayIAIAAgAksbIgAQAkG0oCBBtKAgKAIAIABqNgIAIAFBACABKAKoASAAaiIAIAAgASgCrAFGIgAbNgKoASAARQ0FQQchAAJAIAEvALoBQdm0AUcNACABQbQBakEGQQAQAyABKACwAUcNACABNQC0ASABKQOAAUICiFINACABLQC4AQ0AQQFBByABKAIgIAEtALkBRhshAAsgACEDDAULIAEgBiACEAxBACEDDAQLIAEgFDcDMCAEQQBIBEAgASgCBCICRQRAIAFCADcDCAsgACAFIAAgBUsbIQQDQCAAIARGBEBBByEDDAYLIAAgCGotAAghAyABIABBAWoiADYCqAEgASABKQMIIANB/wBxrSACrYaEIhU3AwgCQCADQYABcUUEQCADDQEgAkUNAUEHIQMMBwtBByEDIAEgAkEHaiICNgIEIAJBP0cNAQwGCwsgAUEANgIECyABIBU3AzggBSAAa0ECSQRAQQchAwwECyABIABBAWoiAjYCqAEgACAIai0ACEEhRwRAQQYhAwwECyABIABBAmoiBDYCqAEgAiAIai0ACEEBRwRAQQYhAwwEC0EHIQMgBCAFRg0DIAEgAEEDajYCqAEgASgCsAkhAEEGIQICQCAEIAhqLQAIIgNBJ0sNACAAIANBAXFBAnIgA0EBdkELanQiBTYCMAJ/AkAgACgCPCIDRQ0AQQQhAiAFIAAoAjRLDQIgACAFNgIsIANBAkcNACAFIABBOGoiAygCAE0NACAAKAIYEAUgACAAKAIwEAYiAjYCGCACDQBBAwwBCyAAQQA2AkAgAEEBOgBQIABBADYCaCAAQeTdAWohA0EACyECIANBADYCAAsgAiIDDQMgASgCqAEiACABKAKsASICIAAgAksbIQMCQANAIAAgA0YNASABIABBAWoiAjYCqAEgACAIaiEFIAIhACAFLQAIRQ0AC0EGIQMMBAsgAUEANgKoASABQgA3A1AgAUIANwNIIAFBAzYCAAsgAUG0oCAoAgA2AhAgAUHAoCAoAgA2AhQCfyABKAKwCSIEQejdAWohBSAEQfgAaiEKIARB5N0BaiELA38gBCgCQCEDAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAQbSgICgCACIAQbigICgCACICTwRAIANBB0YNAUEADBELIAMOCQECAwQFBgcACQ8LIAQoAkwhAwwHC0EBIQZBtKAgIABBAWo2AgBBsKAgKAIAIABqLQAAIgBFDQggAEEBRyAAQd8BTXFFBEAgBEGAAjsBUCAEKAI8RQRAIARBwKAgKAIAIgJBvKAgKAIAajYCGCAEQcSgICgCACACazYCLAsgBEIANwIcIARCADcCJAwLCyAELQBQRQ0KQQcMDgtBtKAgIABBAWo2AgBBsKAgKAIAIABqLQAAIQAgBEECNgJAIAQgBCgCSCAAQQh0ajYCSAwMC0G0oCAgAEEBajYCAEGwoCAoAgAgAGotAAAhACAEQQM2AkAgBCAAIAQoAkhqQQFqNgJIDAsLQbSgICAAQQFqNgIAQbCgICgCACAAai0AACEAIARBBDYCQCAEIABBCHQ2AkwMCgtBtKAgIABBAWo2AgBBsKAgKAIAIABqLQAAIQAgBCAEKAJENgJAIAQgACAEKAJMakEBajYCTAwJC0G0oCAgAEEBajYCAEEHIQZBsKAgKAIAIABqLQAAIgBB4AFLDQNBACEDIARBfyAAQS1JBH9BAAUgAEEtayIAIABB/wFxQS1uIgJBLWxrIQAgAkEBagt0QX9zNgJ0IABB/wFxQQlPBEAgAEEJayIAIABB/wFxQQluIgJBCWxrIQAgAkEBaiEDCyAEIAM2AnAgBCAAQf8BcSIANgJsIAAgA2pBBEsNAyAEQX8gA3RBf3M2AnBBACEAIARBADYCZCAEQgA3AlwgBEIANwJUA0AgCiAAQQF0IgJqQYAIOwEAIAogAkECcmpBgAg7AQAgAEECaiIAQbbuAEcNAAsgBEEGNgJAIARBBTYCCCAEQv////8PNwIAC0EHIAQoAkwiBkEFSQ0IGiAEKAIIIgMEQEG0oCAoAgAhAEG4oCAoAgAhBwNAQQAgACAHRg0KGiAEKAIEIQxBtKAgIABBAWoiAjYCAEGwoCAoAgAgAGotAAAhACAEIANBAWsiAzYCCCAEIAAgDEEIdHI2AgQgAiEAIAMNAAsLIARBBzYCQCAEIAZBBWsiAzYCTAsgBCAEKAIgIgBBxKAgKAIAQcCgICgCAGsiAiAEKAJIIgYgAiAGSRsiAmogBCgCLCIGIAYgAGsgAksbNgIoQbigICgCACIGQbSgICgCACICayEAAkACQCAEKALk3QEiB0UEQCADDQFBACEDCyAHIAtqQQRqQbCgICgCACACaiAAIAMgB2siAkEqIAdrIgMgAiADSRsiAiAAIAJJGyIAEAICfyAAIAQoAuTdASIDaiICIAQoAkxGBEAgAyALaiAAakEEakE/IAJrEAcgBCgC5N0BIABqDAELIAJBFE0EQCAEIAI2AuTdAUG0oCBBtKAgKAIAIABqNgIADAMLIAJBFWsLIQIgBEEANgIQIAQgBTYCDCAEIAI2AhRBByEGIAQQCkUNAyAEKAIQIgcgACAEKALk3QEiAmpLDQMgBCAEKAJMIAdrIgM2AkwgAiAHSwRAIAQgAiAHayIANgLk3QECQCAFIgIgByALakEEaiIDRg0AIAMgACACaiIHa0EAIABBAXRrTQRAIAIgAyAAEAIMAQsgAiADc0EDcSEGAkACQCACIANJBEAgBg0CIAJBA3FFDQEDQCAARQ0EIAIgAy0AADoAACADQQFqIQMgAEEBayEAIAJBAWoiAkEDcQ0ACwwBCwJAIAYNACAHQQNxBEADQCAARQ0FIAIgAEEBayIAaiIGIAAgA2otAAA6AAAgBkEDcQ0ACwsgAEEDTQ0AA0AgAiAAQQRrIgBqIAAgA2ooAgA2AgAgAEEDSw0ACwsgAEUNAgNAIAIgAEEBayIAaiAAIANqLQAAOgAAIAANAAsMAgsgAEEDTQ0AA0AgAiADKAIANgIAIANBBGohAyACQQRqIQIgAEEEayIAQQNLDQALCyAARQ0AA0AgAiADLQAAOgAAIAJBAWohAiADQQFqIQMgAEEBayIADQALCwwCC0G0oCBBtKAgKAIAIAcgAmtqIgI2AgAgBEEANgLk3QFBuKAgKAIAIgYgAmshAAsgAEEVTwRAQbCgICgCACEHIAQgAjYCECAEIAc2AgwgBCAGQRVrIAIgA2ogACADQRVqSRs2AhRBByEGIAQQCkUNAyAEKAJMIgAgBCgCECICQbSgICgCAGsiA0kNAyAEIAAgA2siAzYCTEG0oCAgAjYCAEG4oCAoAgAgAmsiAEEUSw0BCyAFQbCgICgCACACaiADIAAgACADSxsiABACIAQgADYC5N0BQbSgIEG0oCAoAgAgAGo2AgALIAQoAiAiAiAEKAIcIgNrIQAgBCAEKAI8BH8gBCgCLCACRgRAIARBADYCIAtBvKAgKAIAQcCgICgCAGogBCgCGCADaiAAEAIgBCgCIAUgAgs2AhxBwKAgQcCgICgCACAAaiICNgIAIAQgBCgCSCAAayIANgJIIABFBEBBByEGIAQoAkwNAiAEKAJoDQIgBCgCBA0CIARBADYCQAwFC0EAIQYgAkHEoCAoAgBGDQFBtKAgKAIAQbigICgCAEcNBiAEKALk3QEgBCgCTE8NBgwBCyAEKAJMIgNFDQFBACEGIAAgAk8NAANAQcSgICgCACIHQcCgICgCACIMTQ0BIAQgAyADIAQoAiwgBCgCICISayITIAIgAGsiAiAHIAxrIgcgAiAHSRsiAiACIBNLGyICIAIgA0sbIgJrNgJMIBIgBCgCGGpBsKAgKAIAIABqIAIQAiAEIAQoAiAgAmoiADYCICAAIAQoAiRLBEAgBCAANgIkCyAEIAQoAjwEfyAEKAIsIABGBEAgBEEANgIgC0G8oCAoAgBBwKAgKAIAakGwoCAoAgBBtKAgKAIAaiACEAIgBCgCIAUgAAs2AhxBwKAgQcCgICgCACACajYCAEG0oCBBtKAgKAIAIAJqIgA2AgAgBCgCTCIDRQ0CQbigICgCACICIABLDQALCyAGDAULIARBADYCQAwDCyAAQRh0QRh1QQBODQEgBEEBNgJAIAQgAEEQdEGAgPwAcTYCSCAAQcABTwRAIARBBTYCRCAEQQA6AFEMAwtBByAELQBRDQMaIARBBjYCRCAAQaABSQ0CIARCADcCVEEAIQAgBEEANgJkIARCADcCXANAIAogAEEBdCICakGACDsBACAKIAJBAnJqQYAIOwEAIABBAmoiAEG27gBHDQALCyAEQQU2AgggBEL/////DzcCAAwBCyAAQQJLBH9BBwUgBEKDgICAgAE3AkAMAQsLCyEDIAEgASkDSEG0oCAoAgAgASgCEGutfCIUNwNIIAEgASkDUEHAoCAoAgAgASgCFCICayIArXwiFTcDUCABKQMwIBRUBEBBByEDDAMLIAEpAzggFVQEQEEHIQMMAwsCQCABAn4CQAJAIAEoAiBBAWsOBAADAwEDC0G8oCAoAgAgAmogACABKAIYEAOtDAELQbygICgCACACaiEFIAEpAxhCf4UhFAJAIABFDQAgAEEBcQR/IAUxAAAgFEL/AYOFp0EDdEGwEGopAwAgFEIIiIUhFCAFQQFqIQUgAEEBawUgAAshAiAAQQFGDQADQCAFMQABIAUxAAAgFEL/AYOFp0EDdEGwEGopAwAgFEIIiIUiFEL/AYOFp0EDdEGwEGopAwAgFEIIiIUhFCAFQQJqIQUgAkECayICDQALCyAUQn+FCzcDGAsgA0EBRw0CAkAgASkDMCIUQn9RDQAgFCABKQNIUQ0AQQchAwwDCyABKQNQIRUCQCABKQM4IhRCf1EEQCAVIRQMAQtBByEDIBQgFVINAwsgASABKQNoIBR8NwNoIAEgASgCIEGQCGoxAAAgASkDYCABKQNIIAE1AkB8fHw3A2AgASAPQRggASgCcBADNgJwIAFBBDYCACABIAEpA1hCAXw3A1gLAkAgASkDSCIUQgODUA0AQQAhA0G0oCAoAgAiAEG4oCAoAgAiAkYNAkG0oCAgAEEBaiIFNgIAQbCgICgCACAAai0AAARAQQchAwwDCyABIBRCAXwiFTcDSCAVQgODUA0AIAIgBUYNAkG0oCAgAEECaiIENgIAQbCgICgCACAFai0AAARAQQchAwwDCyABIBRCAnwiFTcDSCAVQgODUA0AIAIgBEYNAkG0oCAgAEEDaiIFNgIAQbCgICgCACAEai0AAARAQQchAwwDCyABIBRCA3wiFTcDSCAVQgODUA0AIAIgBUYNAkG0oCAgAEEEajYCAEEHIQNBsKAgKAIAIAVqLQAADQIgASAUQgR8NwNICyABQQU2AgALAkACQAJAAkACQCABKAIgIgBBAWsOBAACAgECC0G0oCAoAgAhAEG4oCAoAgAhBQNAIAAgBUYEQEEAIQMMBgsgASkDGCEUIAEoAgQhA0G0oCAgAEEBaiICNgIAQbCgICgCACAAai0AACAUIAOtiKdB/wFxRwRAQQchAwwGCyABIANBCGoiAzYCBCACIQAgA0EgSQ0ACyABQgA3AxgMAgtBtKAgKAIAIQBBuKAgKAIAIQUDQCAAIAVGBEBBACEDDAULIAEpAxghFCABKAIEIQNBtKAgIABBAWoiAjYCAEGwoCAoAgAgAGotAAAgFCADrYinQf8BcUcEQEEHIQMMBQsgASADQQhqIgM2AgQgAiEAIANBwABJDQALIAFCADcDGAwBCyABKAIEIgIgAEGQCGotAAAiBU8NAEEAIQNBtKAgKAIAIgBBuKAgKAIAIgRGDQIDQAJAIABBAWohACACQQFqIgIgBUYNACAAIARHDQEMAwsLQbSgICAANgIACyABQQA2AgRBASEAIAFBATYCAAwCC0G0oCAgBDYCACABIAI2AgRBASEAIAIgBUkNACABQQE2AgAMAQsLAkAgASgCJEUEQAJAAkAgAw4CAAMBC0EHQQhBtKAgKAIAQbigICgCAEYbIQMLQcCgICANNgIAQbSgICAONgIAIAMMAgsCQCADDQAgDkG0oCAoAgBHDQAgDUHAoCAoAgBHDQAgAS0AKCEAIAFBAToAKCAAQQN0DAILIAFBADoAKAsgAwsOCQcGBwABAgMEBAULQQEhCQwFC0ECIQkMBAtBBCEJDAMLQQUhCQwCC0EGIQkMAQtBByEJC0HQoMAAKAIAEAsLIAkL9wQCA38DfkHAoCBCgICAgICAgAQ3AgBBvKAgQdCgIDYCAEG0oCBCADcCAEGwoCBBsCA2AgADQCAAQQJ0QbAIakEAQQBBAEEAIABBAXYiAUEBcWtBoIbi7X5xQQAgAEEBcWtBoIbi7X5xIAFzQQF2IgFzQQF2IgJBAXFrQaCG4u1+cUEAIAFBAXFrQaCG4u1+cSACc0EBdiIBc0EBdiICQQFxa0GghuLtfnFBACABQQFxa0GghuLtfnEgAnNBAXYiAXNBAXYiAkEBcWtBoIbi7X5xQQAgAUEBcWtBoIbi7X5xIAJzQQF2czYCACAAQQFqIgBBgAJHDQALA0AgBadBA3RBsBBqQgBCAEIAQgAgBUIBiCIDQgGDfULCnpy83fKVtkmDQgAgBUIBg31Cwp6cvN3ylbZJgyADhUIBiCIDhUIBiCIEQgGDfULCnpy83fKVtkmDQgAgA0IBg31Cwp6cvN3ylbZJgyAEhUIBiCIDhUIBiCIEQgGDfULCnpy83fKVtkmDQgAgA0IBg31Cwp6cvN3ylbZJgyAEhUIBiCIDhUIBiCIEQgGDfULCnpy83fKVtkmDQgAgA0IBg31Cwp6cvN3ylbZJgyAEhUIBiIU3AwAgBUIBfCIFQoACUg0AC0HQoMAAAn9BuAkQBiIABEAgAEECNgIkIABBqN4BEAYiAQR/IAFBgICABDYCNCABQQI2AjwgAUEANgIYIAFBADYCOCABBUEACyIBNgKwCSABBEAgAEEAOgAoIABCADcDACAAQgA3AxggAEHIAGpB5AAQByAAQQw2AqwBIAAMAgsgABAFC0EACyIANgIAIAAEf0EABUEAEAtBAQsLEAAjACAAa0FwcSIAJAAgAAsGACAAJAALBAAjAAsRAEG0oCAoAgBBuKAgKAIARgsJAEHAoCAoAgALFwBBxKAgIABBgIAgIABBgIAgSRs2AgALCwBBwKAgIAA2AgALFwBBuKAgIABBgIAgIABBgIAgSRs2AgALCwBBtKAgIAA2AgALCyoDAEGACAsF/Td6WFoAQZEICw8EBAQICAgQEBAgICBAQEAAQaAICwNQEmA=")||(F=O,O=t.locateFile?t.locateFile(F,A):A+F);var k=[];function H(t){var e=k[t];return e||(t>=k.length&&(k.length=t+1),k[t]=e=I.get(t)),e}function W(t){try{return m.grow(t-C.byteLength+65535>>>16),b(m.buffer),1}catch(t){}}var Y="function"==typeof atob?atob:function(t){var e,n,o,i,r,s,a="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",l="",c=0;t=t.replace(/[^A-Za-z0-9\+\/\=]/g,"");do{e=a.indexOf(t.charAt(c++))<<2|(i=a.indexOf(t.charAt(c++)))>>4,n=(15&i)<<4|(r=a.indexOf(t.charAt(c++)))>>2,o=(3&r)<<6|(s=a.indexOf(t.charAt(c++))),l+=String.fromCharCode(e),64!==r&&(l+=String.fromCharCode(n)),64!==s&&(l+=String.fromCharCode(o))}while(c<t.length);return l};function X(t){if(V(t))return function(t){if("boolean"==typeof d&&d){var e=Buffer.from(t,"base64");return new Uint8Array(e.buffer,e.byteOffset,e.byteLength)}try{for(var n=Y(t),o=new Uint8Array(n.length),i=0;i<n.length;++i)o[i]=n.charCodeAt(i);return o}catch(t){throw new Error("Converting base64 string to bytes failed.")}}(t.slice(U.length))}var K={b:function(t,e,n){x.copyWithin(t,e,e+n)},a:function(t){var e=x.length,n=2147483648;if((t>>>=0)>n)return!1;for(var o=1;o<=4;o*=2){var i=e*(1+.2/o);if(i=Math.min(i,t+100663296),W(Math.min(n,S(Math.max(t,i),65536))))return!0}return!1}};!function(){var e={a:K};function o(e,n){var o,i=e.exports;t.asm=i,b((m=t.asm.c).buffer),I=t.asm.o,o=t.asm.d,R.unshift(o),function(){if(N--,t.monitorRunDependencies&&t.monitorRunDependencies(N),0==N&&D){var e=D;D=null,e()}}()}function i(t){o(t.instance)}function s(t){return function(){if(!v&&(h||f)){if("function"==typeof fetch&&!G(O))return fetch(O,{credentials:"same-origin"}).then(function(t){if(!t.ok)throw"failed to load wasm binary file at '"+O+"'";return t.arrayBuffer()}).catch(function(){return Q(O)});if(r)return new Promise(function(t,e){r(O,function(e){t(new Uint8Array(e))},e)})}return Promise.resolve().then(function(){return Q(O)})}().then(function(t){return WebAssembly.instantiate(t,e)}).then(function(t){return t}).then(t,function(t){p("failed to asynchronously prepare wasm: "+t),P(t)})}if(N++,t.monitorRunDependencies&&t.monitorRunDependencies(N),t.instantiateWasm)try{return t.instantiateWasm(e,o)}catch(t){return p("Module.instantiateWasm callback failed with error: "+t),!1}(v||"function"!=typeof WebAssembly.instantiateStreaming||V(O)||G(O)||"function"!=typeof fetch?s(i):fetch(O,{credentials:"same-origin"}).then(function(t){return WebAssembly.instantiateStreaming(t,e).then(i,function(t){return p("wasm streaming compile failed: "+t),p("falling back to ArrayBuffer instantiation"),s(i)})})).catch(n)}(),t.___wasm_call_ctors=function(){return(t.___wasm_call_ctors=t.asm.d).apply(null,arguments)},t._init_decompressor=function(){return(t._init_decompressor=t.asm.e).apply(null,arguments)},t._decompress=function(){return(t._decompress=t.asm.f).apply(null,arguments)},t._get_in_buffer_ptr=function(){return(t._get_in_buffer_ptr=t.asm.g).apply(null,arguments)},t._get_out_buffer_ptr=function(){return(t._get_out_buffer_ptr=t.asm.h).apply(null,arguments)},t._in_buffer_set_pos=function(){return(t._in_buffer_set_pos=t.asm.i).apply(null,arguments)},t._in_buffer_set_size=function(){return(t._in_buffer_set_size=t.asm.j).apply(null,arguments)},t._out_buffer_set_pos=function(){return(t._out_buffer_set_pos=t.asm.k).apply(null,arguments)},t._out_buffer_set_size=function(){return(t._out_buffer_set_size=t.asm.l).apply(null,arguments)},t._get_curr_output_length=function(){return(t._get_curr_output_length=t.asm.m).apply(null,arguments)},t._is_input_end_reached=function(){return(t._is_input_end_reached=t.asm.n).apply(null,arguments)};var j,Z=t.stackSave=function(){return(Z=t.stackSave=t.asm.p).apply(null,arguments)},q=t.stackRestore=function(){return(q=t.stackRestore=t.asm.q).apply(null,arguments)},J=t.stackAlloc=function(){return(J=t.stackAlloc=t.asm.r).apply(null,arguments)};function $(t){this.name="ExitStatus",this.message="Program terminated with exit("+t+")",this.status=t}function tt(n){function o(){j||(j=!0,t.calledRun=!0,g||(z(R),e(t),t.onRuntimeInitialized&&t.onRuntimeInitialized(),function(){if(t.postRun)for("function"==typeof t.postRun&&(t.postRun=[t.postRun]);t.postRun.length;)L(t.postRun.shift());z(T)}()))}N>0||(function(){if(t.preRun)for("function"==typeof t.preRun&&(t.preRun=[t.preRun]);t.preRun.length;)B(t.preRun.shift());z(y)}(),N>0||(t.setStatus?(t.setStatus("Running..."),setTimeout(function(){setTimeout(function(){t.setStatus("")},1),o()},1)):o()))}if(t.cwrap=function(t,e,n,o){var i=(n=n||[]).every(function(t){return"number"===t});return"string"!==e&&i&&!o?_(t):function(){return E(t,e,n,arguments)}},D=function t(){j||tt(),j||(D=t)},t.run=tt,t.preInit)for("function"==typeof t.preInit&&(t.preInit=[t.preInit]);t.preInit.length>0;)t.preInit.pop()();return tt(),t.ready});const Ip=524288,Mp=["","Memory allocation failed","Memory usage limit reached","Unsupported check; not verifying file integrity","Not an .xz file","Unsupported options in the .xz headers","File is corrupt","Unknown decompression bug"];class Sp{constructor(t){this.manager=void 0!==t?t:Uh,this.crossOrigin="Anonymous",this.xz=null}init(){return this.xz?Promise.resolve():xp().then(t=>{this.li=t.cwrap("init_decompressor","number"),this.ci=t.cwrap("decompress","number"),this.ui=t.cwrap("get_in_buffer_ptr","number"),this.hi=t.cwrap("get_out_buffer_ptr","number"),this.fi=t.cwrap("in_buffer_set_pos",null,["number"]),this.di=t.cwrap("in_buffer_set_size",null,["number"]),this.Ai=t.cwrap("out_buffer_set_pos",null,["number"]),this.mi=t.cwrap("out_buffer_set_size",null,["number"]),this.pi=t.cwrap("get_curr_output_length","number"),this.gi=t.cwrap("is_input_end_reached","number"),this.xz=t})}load(t,e,n,o){void 0===t&&(t=""),void 0!==this.path&&(t=this.path+t);const i=this,r=Oh.get(t);if(void 0!==r)return i.manager.itemStart(t),setTimeout(function(){e&&e(r),i.manager.itemEnd(t)},0),r;const s=this.init(),a=new XMLHttpRequest;return a.open("GET",t,!0),a.addEventListener("load",function(r){const a=r.target.response;200===this.status||0===this.status?(0===this.status&&console.warn("v3d.XZLoader: HTTP Status 0 received."),s.then(()=>{i.decompressArrayBuffer(a,function(n){setTimeout(function(){e&&e(n),i.manager.itemEnd(t),Oh.add(t,n)},1)},function(t){if(n){n((2+1*t)/3)}},function(e){o&&o(e),i.manager.itemEnd(t),i.manager.itemError(t)})})):(o&&o(r),i.manager.itemEnd(t),i.manager.itemError(t))},!1),n&&a.addEventListener("progress",function(t){let e;e=t.lengthComputable?t.loaded/t.total:1;n(2*e/3)},!1),a.addEventListener("error",function(e){o&&o(e),i.manager.itemEnd(t),i.manager.itemError(t)},!1),a.responseType="arraybuffer",a.send(null),i.manager.itemStart(t),a}setCrossOrigin(t){return this.crossOrigin=t,this}setPath(t){return this.path=t,this}decompressArrayBuffer(t,e,n,o){const i=this;function r(t){const e=i.ui();i.xz.HEAPU8.set(t,e),i.fi(0),i.di(t.length),s()}function s(){i.Ai(0)}const a=i.li();if(0!=a)return console.error("XZLoader._emInitDecompressor: error code "+a+" ("+Mp[a]+")"),void(o&&o(a));const l=new Uint8Array(t),c=l.length,u=[];let h=0,f=Math.min(Ip,c),d=0;r(l.subarray(h,f)),function t(){const a=i.ci();if(a)console.error("XZLoader._emDecompress: error code "+a+" ("+Mp[a]+")"),o&&o(a);else{const o=i.pi();if(u.push(function(t){const e=i.hi();return new Uint8Array(i.xz.HEAPU8.subarray(e,e+t))}(o)),s(),i.gi()&&(h=f,f=Math.min(f+Ip,c),r(l.subarray(h,f))),n&&n(h/c),h==f){const t=u.reduce(function(t,e,n,o){return t+e.length},0),n=new Uint8Array(t);let o=0;u.forEach(function(t){n.set(t,o),o+=t.length}),e&&e(n.buffer)}else d++,d%2==0?setTimeout(t,1):t()}}()}}class bp extends Vh{constructor(t){super(t),this.reversed=!1}load(t,e,n,o){const i=this,r=new zh(this.manager);r.setPath(this.path),r.setResponseType("arraybuffer"),r.load(t,function(t){e(i.parse(t))},n,o)}parse(t){function e(t){var e,n=[];t.forEach(function(t){"m"===t.type.toLowerCase()?(e=[t],n.push(e)):"z"!==t.type.toLowerCase()&&e.push(t)});var o=[];return n.forEach(function(t){var e={type:"m",x:t[t.length-1].x,y:t[t.length-1].y};o.push(e);for(var n=t.length-1;n>0;n--){var i=t[n];e={type:i.type};void 0!==i.x2&&void 0!==i.y2?(e.x1=i.x2,e.y1=i.y2,e.x2=i.x1,e.y2=i.y1):void 0!==i.x1&&void 0!==i.y1&&(e.x1=i.x1,e.y1=i.y1),e.x=t[n-1].x,e.y=t[n-1].y,o.push(e)}}),o}return"undefined"==typeof opentype?(console.warn("v3d.TTFLoader: The loader requires opentype.js. Make sure it's included before using the loader."),null):function(t,n){for(var o=Math.round,i={},r=1e3/(t.unitsPerEm||2048),s=t.encoding.cmap.glyphIndexMap,a=Object.keys(s),l=0;l<a.length;l++){var c=a[l],u=t.glyphs.glyphs[s[c]];if(void 0!==c){var h={ha:o(u.advanceWidth*r),x_min:o(u.xMin*r),x_max:o(u.xMax*r),o:""};n&&(u.path.commands=e(u.path.commands)),u.path.commands.forEach(function(t){"c"===t.type.toLowerCase()&&(t.type="b"),h.o+=t.type.toLowerCase()+" ",void 0!==t.x&&void 0!==t.y&&(h.o+=o(t.x*r)+" "+o(t.y*r)+" "),void 0!==t.x1&&void 0!==t.y1&&(h.o+=o(t.x1*r)+" "+o(t.y1*r)+" "),void 0!==t.x2&&void 0!==t.y2&&(h.o+=o(t.x2*r)+" "+o(t.y2*r)+" ")}),i[String.fromCodePoint(u.unicode)]=h}}return{glyphs:i,familyName:t.getEnglishName("fullName"),ascender:o(t.tables.os2.sTypoAscender*r),descender:o(t.tables.os2.sTypoDescender*r),lineGap:t.tables.os2.sTypoLineGap*r,underlinePosition:t.tables.post.underlinePosition,underlineThickness:t.tables.post.underlineThickness,boundingBox:{xMin:t.tables.head.xMin*r,xMax:t.tables.head.xMax*r,yMin:t.tables.head.yMin*r,yMax:t.tables.head.yMax*r},resolution:1e3,original_font_information:t.tables.name}}(opentype.parse(t),this.reversed)}}class yp extends Hh{constructor(t){super(t),this.type=Q,Mi.isSafariWithUint16Bug()&&(console.warn("Safari 11/12 detected. Applying workaround for half-float texture bug"),this.type=G)}parse(t){const e=function(t,e){switch(t){case 1:console.error("v3d.RGBELoader Read Error: "+(e||""));break;case 2:console.error("v3d.RGBELoader Write Error: "+(e||""));break;case 3:console.error("v3d.RGBELoader Bad File Format: "+(e||""));break;default:console.error("v3d.RGBELoader: Error: "+(e||""))}return-1},n=function(t,e,n){e=e||1024;let o=t.pos,i=-1,r=0,s="",a=String.fromCharCode.apply(null,new Uint16Array(t.subarray(o,o+128)));for(;0>(i=a.indexOf("\n"))&&r<e&&o<t.byteLength;)s+=a,r+=a.length,o+=128,a+=String.fromCharCode.apply(null,new Uint16Array(t.subarray(o,o+128)));return-1<i&&(t.pos+=r+i+1,s+a.slice(0,i))},o=function(t,e,n,o){const i=t[e+3],r=Math.pow(2,i-128)/255;n[o+0]=t[e+0]*r,n[o+1]=t[e+1]*r,n[o+2]=t[e+2]*r,n[o+3]=1},i=function(t,e,n,o){const i=t[e+3],r=Math.pow(2,i-128)/255;n[o+0]=Qd(Math.min(t[e+0]*r,65504)),n[o+1]=Qd(Math.min(t[e+1]*r,65504)),n[o+2]=Qd(Math.min(t[e+2]*r,65504)),n[o+3]=Qd(1)},r=new Uint8Array(t);r.pos=0;const s=function(t){const o=/^\s*GAMMA\s*=\s*(\d+(\.\d+)?)\s*$/,i=/^\s*EXPOSURE\s*=\s*(\d+(\.\d+)?)\s*$/,r=/^\s*FORMAT=(\S+)\s*$/,s=/^\s*\-Y\s+(\d+)\s+\+X\s+(\d+)\s*$/,a={valid:0,string:"",comments:"",programtype:"RGBE",format:"",gamma:1,exposure:1,width:0,height:0};let l,c;if(t.pos>=t.byteLength||!(l=n(t)))return e(1,"no header found");if(!(c=l.match(/^#\?(\S+)/)))return e(3,"bad initial token");for(a.valid|=1,a.programtype=c[1],a.string+=l+"\n";l=n(t),!1!==l;)if(a.string+=l+"\n","#"!==l.charAt(0)){if((c=l.match(o))&&(a.gamma=parseFloat(c[1])),(c=l.match(i))&&(a.exposure=parseFloat(c[1])),(c=l.match(r))&&(a.valid|=2,a.format=c[1]),(c=l.match(s))&&(a.valid|=4,a.height=parseInt(c[1],10),a.width=parseInt(c[2],10)),2&a.valid&&4&a.valid)break}else a.comments+=l+"\n";return 2&a.valid?4&a.valid?a:e(3,"missing image size specifier"):e(3,"missing format specifier")}(r);if(-1!==s){const t=s.width,n=s.height,a=function(t,n,o){const i=n;if(i<8||i>32767||2!==t[0]||2!==t[1]||128&t[2])return new Uint8Array(t);if(i!==(t[2]<<8|t[3]))return e(3,"wrong scanline width");const r=new Uint8Array(4*n*o);if(!r.length)return e(4,"unable to allocate buffer space");let s=0,a=0;const l=4*i,c=new Uint8Array(4),u=new Uint8Array(l);let h=o;for(;h>0&&a<t.byteLength;){if(a+4>t.byteLength)return e(1);if(c[0]=t[a++],c[1]=t[a++],c[2]=t[a++],c[3]=t[a++],2!=c[0]||2!=c[1]||(c[2]<<8|c[3])!=i)return e(3,"bad rgbe scanline format");let n,o=0;for(;o<l&&a<t.byteLength;){n=t[a++];const i=n>128;if(i&&(n-=128),0===n||o+n>l)return e(3,"bad scanline data");if(i){const e=t[a++];for(let t=0;t<n;t++)u[o++]=e}else u.set(t.subarray(a,a+n),o),o+=n,a+=n}const f=i;for(let t=0;t<f;t++){let e=0;r[s]=u[t+e],e+=i,r[s+1]=u[t+e],e+=i,r[s+2]=u[t+e],e+=i,r[s+3]=u[t+e],s+=4}h--}return r}(r.subarray(r.pos),t,n);if(-1!==a){let e,r,l;switch(this.type){case G:l=a.length/4;const t=new Float32Array(4*l);for(let e=0;e<l;e++)o(a,4*e,t,4*e);e=t,r=G;break;case Q:l=a.length/4;const n=new Uint16Array(4*l);for(let t=0;t<l;t++)i(a,4*t,n,4*t);e=n,r=Q;break;default:console.error("v3d.RGBELoader: unsupported type: ",this.type)}return{width:t,height:n,data:e,header:s.string,gamma:s.gamma,exposure:s.exposure,type:r}}}return null}setDataType(t){return this.type=t,this}load(t,e,n,o){return super.load(t,function(t,n){switch(t.type){case G:case Q:t.encoding=Ot,t.minFilter=N,t.magFilter=N,t.generateMipmaps=!1,t.flipY=!0}e&&e(t,n)},n,o)}}const Rp=new pn,Tp=new Hn,Bp=new An,Lp=new An,Np=new ln,Dp=new Li,Pp=new Map;class Op extends mo{constructor(){super(),this.isPlaneReflectionProbe=!0,this.type="PlaneReflectionProbe",this.influenceDistance=1,this.falloff=.5,this.probeClipStart=.1,this.planeSize=new we(1,1),this.qualityFactor=.75,this.visibilityGroup=null,this.visibilityGroupInv=!1,this.boundingBox=new pn,this.normal=new An,this.textureMatrix=new Hn,this.virtualCamera=new Ei,this.reflectorWorldPosition=new An,this.cameraWorldPosition=new An,this.rotationMatrix=new Hn,this.view=new An,this.lookAtPosition=new An(0,0,-1),this.reflectorPlane=new Ri,this.clipPlane=new ln,this.target=new An;const t={minFilter:N,magFilter:N,format:W,encoding:Ft};this.renderTarget=new cn(1024,1024,t),this.renderTarget.texture.name="PlaneReflectionProbe",this.matrixWorldInverse=new Hn}calcLocalBounding(){const t=Bp.setScalar(0),e=Lp.set(2*this.planeSize.x,2*this.influenceDistance/this.scale.y,2*this.planeSize.y);this.boundingBox.setFromCenterAndSize(t,e)}_i(t){const e=Tp.multiplyMatrices(t.projectionMatrix,t.matrixWorldInverse);Dp.setFromProjectionMatrix(e);const n=Rp.copy(this.boundingBox).applyMatrix4(this.matrixWorld);return!Dp.intersectsBox(n)}Ei(t){!t.isPlaneReflectionProbe&&this.ii(t)||(Pp.set(t,t.layers.mask),t.layers.disableAll());const e=t.children;for(let t=0;t<e.length;t++)this.Ei(e[t])}makeMultisampleRenderTarget(t){this.renderTarget.samples=t}setSize(t,e){this.renderTarget.setSize(this.qualityFactor*t,this.qualityFactor*e)}setEncoding(t){this.renderTarget.texture.encoding=t}intersectsMesh(t){let e=!1;const n=t.geometry,o=Tp;o.copy(t.matrixWorld).invert(),o.multiply(this.matrixWorld);const i=this.boundingBox,r=Rp.copy(i).applyMatrix4(o);return null===n.boundingBox&&n.computeBoundingBox(),e=n.boundingBox.intersectsBox(r),e&&n.boundsTree&&(e=n.boundsTree.intersectsBox(i,o)),e}update(t,e,n){if(this.calcLocalBounding(),this._i(e))return;const o=this.reflectorWorldPosition;o.setFromMatrixPosition(this.matrixWorld);const i=this.cameraWorldPosition;i.setFromMatrixPosition(e.matrixWorld);const r=this.rotationMatrix;r.extractRotation(this.matrixWorld);const s=this.normal;s.set(0,1,0),s.applyMatrix4(r);const a=this.view;if(a.subVectors(o,i),a.dot(s)>0)return;this.Ei(t),a.reflect(s).negate(),a.add(o),r.extractRotation(e.matrixWorld);const l=this.lookAtPosition;l.set(0,0,-1),l.applyMatrix4(r),l.add(i);const c=this.target;c.subVectors(o,l),c.reflect(s).negate(),c.add(o);const u=this.virtualCamera;u.position.copy(a),u.up.set(0,1,0),u.up.applyMatrix4(r),u.up.reflect(s),u.lookAt(c),u.far=e.far,u.updateMatrixWorld();const h=u.projectionMatrix;h.copy(e.projectionMatrix);const f=this.textureMatrix;f.set(.5,0,0,.5,0,.5,0,.5,0,0,.5,.5,0,0,0,1),f.multiply(h),f.multiply(u.matrixWorldInverse);const d=this.reflectorPlane;d.setFromNormalAndCoplanarPoint(s,o),d.applyMatrix4(u.matrixWorldInverse);const A=this.clipPlane;A.set(d.normal.x,d.normal.y,d.normal.z,d.constant),Np.x=(Math.sign(A.x)+h.elements[8])/h.elements[0],Np.y=(Math.sign(A.y)+h.elements[9])/h.elements[5],Np.z=-1,Np.w=(1+h.elements[10])/h.elements[14],A.multiplyScalar(2/A.dot(Np)),h.elements[2]=A.x,h.elements[6]=A.y,h.elements[10]=A.z+1-this.probeClipStart,h.elements[14]=A.w;const v=n.getRenderTarget(),m=n.xr.enabled,p=n.shadowMap.autoUpdate,g=n.useOIT;n.xr.enabled=!1,n.shadowMap.autoUpdate=!1,n.useOIT=!1,n.setRenderTarget(this.renderTarget),n.state.buffers.depth.setMask(!0),!1===n.autoClear&&n.clear(),n.render(t,u),n.xr.enabled=m,n.shadowMap.autoUpdate=p,n.useOIT=g,n.setRenderTarget(v);const _=e.viewport;void 0!==_&&n.state.viewport(_),Pp.forEach((t,e)=>{e.layers.mask=t}),Pp.clear()}updateMatrixWorld(t){super.updateMatrixWorld(t),this.matrixWorldInverse.copy(this.matrixWorld).invert()}updateWorldMatrix(t,e){super.updateWorldMatrix(t,e),this.matrixWorldInverse.copy(this.matrixWorld).invert()}clone(){return(new this.constructor).copy(this)}copy(t){return super.copy(t),this.influenceDistance=t.influenceDistance,this.probeClipStart=t.probeClipStart,this.visibilityGroup=t.visibilityGroup,this.visibilityGroupInv=t.visibilityGroupInv,this}dispose(){null!==this.renderTarget&&(this.renderTarget.dispose(),this.renderTarget=null),this.dispatchEvent({type:"dispose"})}ii(t){if(null===this.visibilityGroup)return!0;if(!t.isMesh)return!0;return-1!==t.groupNames.indexOf(this.visibilityGroup)^this.visibilityGroupInv}}class Fp{static init(t,e){void 0!==t&&void 0!==e||console.error("RectAreaLightUniformsLib: Missing LTC data (required in Verge3D)");const n=new Float32Array(t),o=new Float32Array(e);Ui.LTC_FLOAT_1=new ul(n,64,64,W,G,C,y,y,N,T,1),Ui.LTC_FLOAT_2=new ul(o,64,64,W,G,C,y,y,N,T,1),Ui.LTC_FLOAT_1.name="RectArea.ltc1",Ui.LTC_FLOAT_2.name="RectArea.ltc2",Ui.LTC_FLOAT_1.needsUpdate=!0,Ui.LTC_FLOAT_2.needsUpdate=!0;const i=new Uint16Array(t.length);t.forEach(function(t,e){i[e]=Qd(t)});const r=new Uint16Array(e.length);e.forEach(function(t,e){r[e]=Qd(t)}),Ui.LTC_HALF_1=new ul(i,64,64,W,Q,C,y,y,N,T,1),Ui.LTC_HALF_2=new ul(r,64,64,W,Q,C,y,y,N,T,1),Ui.LTC_HALF_1.needsUpdate=!0,Ui.LTC_HALF_2.needsUpdate=!0}}class Up{constructor(t){this.isFont=!0,this.type="Font",this.data=t}generateShapes(t,e=100,n="left",o="topBaseline",i=-1,r=!1){const s=[],a=function(t,e,n,o,i,r,s){const a=String(t).split("\n"),l=[];for(let t=0;t<a.length;t++){let e=a[t];l[t]=Array.from(e)}let c=e/n.resolution;s&&(c*=(n.ascender-n.descender)/(n.boundingBox.yMax-n.boundingBox.yMin));-1===r?r=(n.ascender-n.descender+n.lineGap)*c:r*=e;const u=[];let h=0,f=0;const d=l.length,A=r*d,v=r*Math.abs(n.descender)/n.ascender,m=r-v;switch(i){case"topBaseline":default:f=0;break;case"top":f=-m;break;case"center":f=d>1?.5*A-m:-n.ascender/2*c;break;case"bottom":f=A-r-n.descender*c;break;case"bottomBaseline":f=A-r}for(let t=0;t<l.length;t++){const e=l[t];switch(o){case"left":default:h=0;break;case"center":h=-Gp(e,c,n)/2;break;case"right":h=-Gp(e,c,n)}for(let t=0;t<e.length;t++){const o=Vp(e[t],c,h,f,n);h+=o.offsetX,u.push(o.path)}f-=r}return u}(t,e,this.data,n,o,i,r);for(let t=0,e=a.length;t<e;t++)Array.prototype.push.apply(s,a[t].toShapes());return s}}function Vp(t,e,n,o,i){const r=i.glyphs[t]||i.glyphs["?"];if(!r)return void console.error('v3d.Font: character "'+t+'" does not exists in font family '+i.familyName+".");const s=new Vd;let a,l,c,u,h,f,d,A;if(r.o){const t=r.Ci||(r.Ci=r.o.split(" "));for(let i=0,r=t.length;i<r;){switch(t[i++]){case"m":a=t[i++]*e+n,l=t[i++]*e+o,s.moveTo(a,l);break;case"l":a=t[i++]*e+n,l=t[i++]*e+o,s.lineTo(a,l);break;case"q":c=t[i++]*e+n,u=t[i++]*e+o,h=t[i++]*e+n,f=t[i++]*e+o,s.quadraticCurveTo(h,f,c,u);break;case"b":c=t[i++]*e+n,u=t[i++]*e+o,h=t[i++]*e+n,f=t[i++]*e+o,d=t[i++]*e+n,A=t[i++]*e+o,s.bezierCurveTo(h,f,d,A,c,u)}}}return{offsetX:r.ha*e,path:s}}function Gp(t,e,n){let o=0;for(var i=0;i<t.length;i++){const r=t[i];o+=(n.glyphs[r]||n.glyphs["?"]).ha*e}return o}const Qp=new An,zp=new An;class kp extends mo{constructor(){super(),this.isClippingPlaneObject=!0,this.type="ClippingPlaneObject",this.plane=new Ri,this.clippingGroup=null,this.clipShadows=!1,this.negated=!1,this.clipIntersection=!1,this.crossSection=!1,this.crossSectionColor=new tn(16711680),this.crossSectionOpacity=1,this.crossSectionRenderSide=0,this.crossSectionSize=100,this.wi="blender"}updatePlane(){this.updateWorldMatrix(!0,!1),this.getWorldPosition(Qp);const t=this.matrixWorld.elements;zp.set(t[4],t[5],t[6]).normalize(),this.plane.setFromNormalAndCoplanarPoint(zp,Qp),this.negated&&this.plane.negate()}updateMatrixWorld(t){super.updateMatrixWorld(t),this.updatePlane()}needsClippingPlane(t){return t.isMesh&&(t.groupNames.indexOf(this.clippingGroup)>=0||null===this.clippingGroup)&&!t.isAuxClippingMesh}assignToObject(t,e=0){const n=this.plane,o=t.material,i=t.geometry;if(o.clippingPlanes=o.clippingPlanes||[],-1==o.clippingPlanes.indexOf(n)&&o.clippingPlanes.push(n),o.clipShadows=this.clipShadows,o.clipIntersection=this.clipIntersection,this.crossSection){this.cleanupAuxMeshes(t);const r=new No;r.depthWrite=!1,r.depthTest=!1,r.colorWrite=!1,r.stencilWrite=!0,r.stencilFunc=519,r.clipShadows=this.clipShadows,r.clipIntersection=this.clipIntersection;const s=!!t.isSkinnedMesh,a=t.morphTargetInfluences,l=ye(a)&&a.length>0,c=r.clone();let u;c.name="ClipCrossSectionStencilBack",c.side=1,c.clippingPlanes=[n],c.stencilFail=Wt,c.stencilZFail=Wt,c.stencilZPass=Wt,s?(u=new ll(i,c),u.skeleton=t.skeleton):u=new hi(i,c),u.renderOrder=e,u.name="ClipCrossSectionStencilBack",u.isAuxClippingMesh=!0,l&&(u.morphTargetInfluences=a.slice(),u.morphTargetDictionary=Object.assign({},t.morphTargetDictionary)),t.add(u);const h=r.clone();let f;h.name="ClipCrossSectionStencilFront",h.side=0,h.clippingPlanes=[n],h.stencilFail=Yt,h.stencilZFail=Yt,h.stencilZPass=Yt,s?(f=new ll(i,h),f.skeleton=t.skeleton):f=new hi(i,h),f.renderOrder=e+.1,f.name="ClipCrossSectionStencilFront",f.isAuxClippingMesh=!0,l&&(f.morphTargetInfluences=a.slice(),f.morphTargetDictionary=Object.assign({},t.morphTargetDictionary)),t.add(f),o.isMeshNodeMaterial&&(this.wi=o.profile)}}createCrossSectionPlane(t,e){this.cleanupAuxMeshes();const n=new Hm("ClipCrossSectionColor",this.crossSectionColor,this.crossSectionOpacity,this.wi);n.clippingPlanes=t.filter(t=>t!==this.plane),n.clipShadows=this.clipShadows,n.clipIntersection=this.clipIntersection,n.stencilWrite=!0,n.stencilRef=0,n.stencilFunc=517,n.stencilFail=Ht,n.stencilZFail=Ht,n.stencilZPass=Ht,n.side=this.crossSectionRenderSide,this.crossSectionOpacity<1&&(n.transparent=!0,n.premultipliedAlpha=!0,n.blending=5,n.blendEquation=a,n.blendSrc=h,n.blendDst=v);const o=new Oi(this.crossSectionSize,this.crossSectionSize);this.negated?o.rotateX(-Math.PI/2):o.rotateX(Math.PI/2);const i=new hi(o,n);i.name="ClipCrossSectionColor",i.isAuxClippingMesh=!0,i.renderOrder=e,i.onAfterRender=function(t){t.clearStencil()},this.add(i)}cleanupAuxMeshes(t=null){if(t)for(let e=t.children.length-1;e>=0;e--){const n=t.children[e];n.isAuxClippingMesh&&n.material.clippingPlanes[0]==this.plane&&(n.geometry.dispose(),n.material.dispose(),t.remove(n))}else for(let t=this.children.length-1;t>=0;t--){const e=this.children[t];e.isAuxClippingMesh&&(e.geometry.dispose(),e.material.dispose(),this.remove(e))}}copy(t){return super.copy(t),this.plane=t.plane,this.clippingGroup=t.clippingGroup,this.clipShadows=t.clipShadows,this.negated=t.negated,this.clipIntersection=t.clipIntersection,this.crossSection=t.crossSection,this.crossSectionColor.copy(t.crossSectionColor),this.crossSectionOpacity=t.crossSectionOpacity,this.crossSectionRenderSide=t.crossSectionRenderSide,this.crossSectionSize=t.crossSectionSize,this.wi=t.wi,this}}class Hp{constuctor(){this.isConstraint=!0,this.name="",this.type="Constraint",this.mute=!1}xi(t){t.matrixAutoUpdate&&t.matrix.compose(t.position,t.quaternion,t.scale),null==t.parent?t.matrixWorld.copy(t.matrix):t.matrixWorld.multiplyMatrices(t.parent.matrixWorld,t.matrix)}update(t){this.mute}copy(t){return this.name=t.name,this.mute=t.mute,this}clone(){return(new this.constructor).copy(this)}}class Wp extends Hp{constructor(t){super(),this.isTargetConstraint=!0,this.type="TargetConstraint",this.target=t}copy(t){return super.copy(t),this.target=t.target,this}clone(){return new this.constructor(this.target).copy(this)}}const Yp=new Hn,Xp=(new dn).setFromAxisAngle(new An(1,0,0),-Math.PI/2);class Kp extends Wp{constructor(t){super(t),this.isChildOfConstraint=!0,this.type="ChildOfConstraint",this.offsetMatrix=new Hn,this.fixCameraLightRotation=!1}copy(t){return super.copy(t),this.offsetMatrix.copy(t.offsetMatrix),this.fixCameraLightRotation=t.fixCameraLightRotation,this}update(t){super.update(t),this.mute||(Yp.multiplyMatrices(this.target.matrixWorld,this.offsetMatrix),Yp.decompose(t.position,t.quaternion,t.scale),this.fixCameraLightRotation&&(t.isCamera||t.isLight)&&t.quaternion.multiply(Xp))}}const jp=new An,Zp=new dn,qp=new An;class Jp extends Wp{constructor(t){super(t),this.isCopyLocationConstraint=!0,this.type="CopyLocationConstraint",this.useX=!0,this.useY=!0,this.useZ=!0,this.invertX=!1,this.invertY=!1,this.invertZ=!1,this.useOffset=!1,this.influence=1,this.Ii=!0,this.Mi=new An,this.Si=new An}copy(t){return super.copy(t),this.useX=t.useX,this.useY=t.useY,this.useZ=t.useZ,this.invertX=t.invertX,this.invertY=t.invertY,this.invertZ=t.invertZ,this.useOffset=t.useOffset,this.influence=t.influence,this.Ii=!1,this}update(t){super.update(t),this.mute||(this.target.matrixWorld.decompose(jp,Zp,qp),this.Ii&&(this.xi(t),t.getWorldPositionNU(this.Mi),this.Si.subVectors(jp,this.Mi),this.Ii=!1),this.useX?(this.invertX&&(jp.x=-jp.x),this.useOffset&&(jp.x-=this.Si.x)):jp.x=this.Mi.x,this.useY?(this.invertY&&(jp.y=-jp.y),this.useOffset&&(jp.y-=this.Si.y)):jp.y=this.Mi.y,this.useZ?(this.invertZ&&(jp.z=-jp.z),this.useOffset&&(jp.z-=this.Si.z)):jp.z=this.Mi.z,t.position.lerpVectors(this.Mi,jp,this.influence),t.parent&&t.parent.worldToLocal(t.position))}}const $p=(new dn).setFromAxisAngle(new An(1,0,0),-Math.PI/2),tg=new An,eg=new dn,ng=new An;class og extends Wp{constructor(t){super(t),this.isCopyRotationConstraint=!0,this.type="CopyRotationConstraint",this.useX=!0,this.useY=!0,this.useZ=!0,this.invertX=!1,this.invertY=!1,this.invertZ=!1,this.mixMode="REPLACE",this.influence=1,this.fixCameraLightRotation=!1,this.Ii=!0,this.bi=new dn}copy(t){return super.copy(t),this.useX=t.useX,this.useY=t.useY,this.useZ=t.useZ,this.invertX=t.invertX,this.invertY=t.invertY,this.invertZ=t.invertZ,this.mixMode=t.mixMode,this.influence=t.influence,this.fixCameraLightRotation=t.fixCameraLightRotation,this.Ii=!1,this}update(t){super.update(t),this.mute||(this.target.matrixWorld.decompose(tg,eg,ng),this.Ii&&(this.xi(t),t.matrixWorld.decompose(tg,this.bi,ng),this.Ii=!1),t.quaternion.copy(this.bi),(this.useX||this.useY||this.useZ)&&("REPLACE"==this.mixMode||"ADD"==this.mixMode||("BEFORE"==this.mixMode?eg.multiply(t.quaternion):"AFTER"==this.mixMode?eg.premultiply(t.quaternion):this.mixMode),t.quaternion.slerp(eg,this.influence)),t.parent&&(t.parent.matrixWorld.decompose(tg,eg,ng),t.quaternion.premultiply(eg.invert())),this.fixCameraLightRotation&&(t.isCamera||t.isLight)&&t.quaternion.multiply($p))}}const ig=new An,rg=new dn,sg=new An;class ag extends Wp{constructor(t){super(t),this.isCopyScaleConstraint=!0,this.type="CopyScaleConstraint",this.useX=!0,this.useY=!0,this.useZ=!0,this.power=1,this.useMakeUniform=!1,this.useOffset=!1,this.useAdd=!1,this.influence=1,this.yi=new An,this.Ri=new An,this.Ii=!0}copy(t){return super.copy(t),this.useX=t.useX,this.useY=t.useY,this.useZ=t.useZ,this.power=t.power,this.useMakeUniform=t.useMakeUniform,this.useOffset=t.useOffset,this.useAdd=t.useAdd,this.influence=t.influence,this.Ii=!1,this}update(t){if(super.update(t),!this.mute){if(this.target.matrixWorld.decompose(ig,rg,sg),this.Ii&&(this.xi(t),t.matrixWorld.decompose(ig,rg,this.yi),this.Ri.set(Math.pow(sg.x-this.yi.x,3),Math.pow(sg.y-this.yi.y,3),Math.pow(sg.z-this.yi.z,3)),this.Ii=!1),this.useMakeUniform){let t=1;this.useX&&(t*=sg.x),this.useY&&(t*=sg.y),this.useZ&&(t*=sg.z),t=Math.pow(Math.cbrt(t),this.power),sg.set(t,t,t),this.useOffset&&(this.useAdd?(sg.add(this.yi),sg.addScalar(-1)):sg.multiply(this.yi))}else sg.set(this.useX?Math.pow(sg.x,this.power):this.yi.x,this.useY?Math.pow(sg.y,this.power):this.yi.y,this.useZ?Math.pow(sg.z,this.power):this.yi.z),this.useOffset&&(this.useAdd?sg.set(this.useX?sg.x+this.yi.x-1:sg.x,this.useY?sg.y+this.yi.y-1:sg.y,this.useZ?sg.z+this.yi.z-1:sg.z):sg.set(this.useX?sg.x*this.yi.x:sg.x,this.useY?sg.y*this.yi.y:sg.y,this.useZ?sg.z*this.yi.z:sg.z));t.scale.copy(this.yi),t.scale.lerp(sg,this.influence)}}}const lg=(new dn).setFromAxisAngle(new An(1,0,0),-Math.PI/2),cg=new Hn,ug=new An,hg=new dn,fg=new An;class dg extends Wp{constructor(t){super(t),this.isCopyTransformsConstraint=!0,this.type="CopyTransformsConstraint",this.mixMode="REPLACE",this.influence=1,this.fixCameraLightRotation=!1,this.Ii=!0,this.Ti=new Hn}copy(t){return super.copy(t),this.mixMode=t.mixMode,this.influence=t.influence,this.fixCameraLightRotation=t.fixCameraLightRotation,this.Ii=!0,this}update(t){super.update(t),this.mute||(this.Ii&&(this.xi(t),this.Ti.copy(t.matrixWorld),this.Ii=!1),cg.copy(this.target.matrixWorld),"REPLACE"==this.mixMode||("BEFORE"==this.mixMode?cg.multiply(this.Ti):"AFTER"==this.mixMode&&cg.premultiply(this.Ti)),cg.decompose(ug,hg,fg),this.Ti.decompose(t.position,t.quaternion,t.scale),t.position.lerp(ug,this.influence),t.quaternion.slerp(hg,this.influence),t.scale.lerp(fg,this.influence),this.fixCameraLightRotation&&(t.isCamera||t.isLight)&&t.quaternion.multiply(lg))}}const Ag=(new dn).setFromAxisAngle(new An(1,0,0),-Math.PI/2),vg=new An,mg=new dn,pg=new An,gg=new An,_g=new An,Eg=new An,Cg=new An,wg={X:0,Y:1,Z:2,"-X":3,"-Y":4,"-Z":5},xg={0:new An(1,0,0),1:new An(0,1,0),2:new An(0,0,1),3:new An(-1,0,0),4:new An(0,-1,0),5:new An(0,0,-1)};class Ig extends Wp{constructor(t){super(t),this.isDampedTrackConstraint=!0,this.type="DampedTrackConstraint",this.trackAxis="X",this.influence=1,this.fixCameraLightRotation=!1,this.Ii=!0}copy(t){return super.copy(t),this.trackAxis=t.trackAxis,this.influence=t.influence,this.fixCameraLightRotation=t.fixCameraLightRotation,this.Ii=!1,this}update(t){if(super.update(t),!this.mute&&(this.target.matrixWorld.decompose(vg,mg,pg),this.Ii&&(this.xi(t),this.Ii=!1),t.matrixWorld.decompose(gg,mg,pg),_g.subVectors(vg,gg),0!=_g.length())){let e;if(_g.normalize(),Eg.copy(xg[wg[this.trackAxis]]),Eg.applyQuaternion(mg),0==Eg.length()&&Eg.copy(xg[wg[this.trackAxis]]),Eg.normalize(),Cg.crossVectors(Eg,_g),e=Eg.angleTo(_g),Cg.length()<Number.EPSILON){if(Math.abs(e)<Math.PI-.01)return;if(e=Math.PI,_g.copy(xg[(wg[this.trackAxis]+2)%6]),_g.applyQuaternion(mg),Cg.crossVectors(Eg,_g),0==Cg.length())return}Cg.normalize(),t.quaternion.premultiply(mg.setFromAxisAngle(Cg,e)),t.parent&&(t.parent.matrixWorld.decompose(vg,mg,pg),t.quaternion.premultiply(mg.invert())),this.fixCameraLightRotation&&(t.isCamera||t.isLight)&&t.quaternion.multiply(Ag)}}}const Mg={X:new An(1,0,0),Y:new An(0,1,0),Z:new An(0,0,1),"-X":new An(-1,0,0),"-Y":new An(0,-1,0),"-Z":new An(0,0,-1)},Sg=new An,bg=new An,yg=new An,Rg=new An;class Tg extends Wp{constructor(t){super(t),this.isFloorConstraint=!0,this.type="FloorConstraint",this.floorLocation="Y",this.offset=0,this.useRotation=!1}copy(t){return super.copy(t),this.floorLocation=t.floorLocation,this.offset=t.offset,this.useRotation=t.useRotation,this}update(t){if(super.update(t),this.mute)return;const e=t.position;Rg.copy(this.target.position);const n=this.target.scale,o=this.offset;if(this.useRotation){let t;switch(Sg.copy(Mg[this.floorLocation]),Sg.applyQuaternion(this.target.quaternion),this.floorLocation){case"X":Rg.x+=o*n.x,yg.subVectors(e,Rg),t=Sg.dot(yg),Sg.multiplyScalar(t),bg.subVectors(yg,Sg).add(Rg),bg.x>e.x?e.copy(bg):e.x=Math.max(e.x,Rg.x);break;case"Y":Rg.y+=o*n.y,yg.subVectors(e,Rg),t=Sg.dot(yg),Sg.multiplyScalar(t),bg.subVectors(yg,Sg).add(Rg),bg.y>e.y?e.copy(bg):e.y=Math.max(e.y,Rg.y);break;case"Z":Rg.z+=o*n.z,yg.subVectors(e,Rg),t=Sg.dot(yg),Sg.multiplyScalar(t),bg.subVectors(yg,Sg).add(Rg),bg.z>e.z?e.copy(bg):e.z=Math.max(e.z,Rg.z);break;case"-X":Rg.x+=o*n.x,yg.subVectors(e,Rg),t=Sg.dot(yg),Sg.multiplyScalar(t),bg.subVectors(yg,Sg).add(Rg),bg.x<e.x?e.copy(bg):e.x=Math.min(e.x,Rg.x);break;case"-Y":Rg.y+=o*n.y,yg.subVectors(e,Rg),t=Sg.dot(yg),Sg.multiplyScalar(t),bg.subVectors(yg,Sg).add(Rg),bg.y<e.y?e.copy(bg):e.y=Math.min(e.y,Rg.y);break;case"-Z":Rg.z+=o*n.z,yg.subVectors(e,Rg),t=Sg.dot(yg),Sg.multiplyScalar(t),bg.subVectors(yg,Sg).add(Rg),bg.z<e.z?e.copy(bg):e.z=Math.min(e.z,Rg.z)}}else switch(this.floorLocation){case"X":e.x=Math.max(e.x,Rg.x+o);break;case"Y":e.y=Math.max(e.y,Rg.y+o);break;case"Z":e.z=Math.max(e.z,Rg.z+o);break;case"-X":e.x=Math.min(e.x,Rg.x+o);break;case"-Y":e.y=Math.min(e.y,Rg.y+o);break;case"-Z":e.z=Math.min(e.z,Rg.z+o)}}}const Bg=new An,Lg=new dn,Ng=new An,Dg=new An;class Pg extends Wp{constructor(t){super(t),this.isLimitDistanceConstraint=!0,this.type="LimitDistanceConstraint",this.distance=0,this.limitMode="LIMITDIST_ONSURFACE",this.useTransformLimit=!1,this.influence=1,this.Mi=new An,this.Bi=0,this.Li=1,this.Ni=0}copy(t){return super.copy(t),this.distance=t.distance,this.limitMode=t.limitMode,this.useTransformLimit=t.useTransformLimit,this.influence=t.influence,this}update(t){super.update(t),this.mute||(this.Li=1,this.Ni=0,this.target.matrixWorld.decompose(Bg,Lg,Ng),this.xi(t),t.getWorldPositionNU(this.Mi),Dg.subVectors(this.Mi,Bg),this.Bi=Dg.length(),"LIMITDIST_INSIDE"==this.limitMode?this.Bi>=this.distance&&(this.Ni=1,0!=this.Bi&&(this.Li=this.distance/this.Bi)):"LIMITDIST_OUTSIDE"==this.limitMode?this.Bi<=this.distance&&(this.Ni=1,0!=this.Bi&&(this.Li=this.distance/this.Bi)):"LIMITDIST_ONSURFACE"==this.limitMode&&this.Bi-this.distance!=0&&(this.Ni=1,0!=this.Bi&&(this.Li=this.distance/this.Bi)),this.Ni&&(t.position.lerpVectors(this.Mi,Bg,(1-this.Li)*this.influence),t.parent&&t.parent.worldToLocal(t.position)))}}const Og=new An,Fg=new An,Ug=new An,Vg=new Hn;class Gg extends Wp{constructor(t=null){super(t),this.isLimitLocationConstraint=!0,this.type="LimitLocationConstraint",this.space=2,this.min=(new An).setScalar(-1/0),this.max=(new An).setScalar(1/0)}copy(t){return super.copy(t),this.min.copy(t.min),this.max.copy(t.max),this.space=t.space,this}update(t){if(super.update(t),!this.mute)switch(this.space){case 0:this.xi(t),Og.setFromMatrixPosition(t.matrixWorld),Og.clamp(this.min,this.max),Ug.copy(Og),null!==t.parent&&Ug.applyMatrix4(Vg.copy(t.parent.matrixWorld).invert()),t.position.copy(Ug);break;case 1:null!==this.target&&(this.xi(t),this.xi(this.target),Og.setFromMatrixPosition(t.matrixWorld),Fg.copy(Og),Fg.applyMatrix4(Vg.copy(this.target.matrixWorld).invert()),Fg.clamp(this.min,this.max),Og.copy(Fg),Og.applyMatrix4(this.target.matrixWorld),Ug.copy(Og),null!==t.parent&&Ug.applyMatrix4(Vg.copy(t.parent.matrixWorld).invert()),t.position.copy(Ug));break;default:t.position.clamp(this.min,this.max)}}}const Qg=new to;class zg extends Hp{constructor(){super(),this.isLimitRotationConstraint=!0,this.type="LimitRotationConstraint",this.axis="Y",this.min=0,this.max=2*Math.PI}copy(t){return super.copy(t),this.axis=t.axis,this.min=t.min,this.max=t.max,this}update(t){super.update(t),this.mute||("X"==this.axis?(Qg.setFromQuaternion(t.quaternion,"XYZ"),Qg.x=this.Di(Qg.x,this.min,this.max)):"Y"==this.axis?(Qg.setFromQuaternion(t.quaternion,"YZX"),Qg.y=this.Di(Qg.y,this.min,this.max)):"Z"==this.axis&&(Qg.setFromQuaternion(t.quaternion,"ZXY"),Qg.z=this.Di(Qg.z,this.min,this.max)),t.quaternion.setFromEuler(Qg))}Di(t,e,n){return Math.abs(n-e)<2*Math.PI&&(t=Ee(t,e,n)),t}}class kg extends Hp{constructor(){super(),this.isLimitScaleConstraint=!0,this.type="LimitScaleConstraint",this.min=(new An).setScalar(-1/0),this.max=(new An).setScalar(1/0)}copy(t){return super.copy(t),this.min.copy(t.min),this.max.copy(t.max),this}update(t){super.update(t),this.mute||t.scale.clamp(this.min,this.max)}}const Hg=(new dn).setFromAxisAngle(new An(1,0,0),-Math.PI/2),Wg=new An,Yg=new An,Xg=new An,Kg=new An,jg=new An,Zg=new Ri,qg=new An,Jg=new An,$g=new dn;class t_ extends Wp{constructor(t){super(t),this.isLockedTrackConstraint=!0,this.type="LockedTrackConstraint",this.trackAxis="X",this.lockAxis="Y",this.fixCameraLightRotation=!1}copy(t){return super.copy(t),this.trackAxis=t.trackAxis,this.lockAxis=t.lockAxis,this.fixCameraLightRotation=t.fixCameraLightRotation,this}update(t){if(super.update(t),this.mute)return;if(Xg.set("X"==this.trackAxis?1:"-X"==this.trackAxis?-1:0,"Y"==this.trackAxis?1:"-Y"==this.trackAxis?-1:0,"Z"==this.trackAxis?1:"-Z"==this.trackAxis?-1:0),Kg.set("X"==this.lockAxis?1:0,"Y"==this.lockAxis?1:0,"Z"==this.lockAxis?1:0),1==Math.abs(Xg.dot(Kg)))return;Wg.setFromMatrixPosition(t.matrixWorld),Yg.setFromMatrixPosition(this.target.matrixWorld),Zg.setFromNormalAndCoplanarPoint(Kg,Wg),Zg.projectPoint(Yg,jg).sub(Wg);const e=qg.crossVectors(Xg,jg).dot(Kg)>0?1:-1;t.setRotationFromAxisAngle(Zg.normal,e*Xg.angleTo(jg)),t.parent&&(t.parent.matrixWorld.decompose(Jg,$g,Jg),t.quaternion.premultiply($g.invert())),this.fixCameraLightRotation&&(t.isCamera||t.isLight)&&t.quaternion.multiply(Hg)}}const e_=new An(0,1,0),n_=(new dn).setFromAxisAngle(new An(1,0,0),-Math.PI/2),o_=new Ri,i_=new An,r_=new An,s_=new An,a_=new An,l_=new An,c_=new Hn,u_=new An,h_=new dn;class f_ extends Wp{constructor(t){super(t),this.isTrackToConstraint=!0,this.type="TrackToConstraint",this.trackAxis="X",this.upAxis="Y",this.fixCameraLightRotation=!1}copy(t){return super.copy(t),this.trackAxis=t.trackAxis,this.upAxis=t.upAxis,this.fixCameraLightRotation=t.fixCameraLightRotation,this}update(t){if(super.update(t),this.mute)return;const e=this.trackAxis[this.trackAxis.length-1],n=this.upAxis[this.upAxis.length-1],o="-"==this.trackAxis[0],i="-"==this.upAxis[0];if(e==n)return;i_.setFromMatrixPosition(t.matrixWorld),r_.setFromMatrixPosition(this.target.matrixWorld),s_.subVectors(r_,i_),s_.lengthSq()?s_.normalize():s_.set(0,-1,0),o_.set(s_,0),1!=Math.abs(s_.dot(e_))?o_.projectPoint(e_,a_).normalize():a_.set(0,0,-1),o&&s_.negate(),i&&a_.negate();let r="X"==e?s_:"X"==n?a_:null,s="Y"==e?s_:"Y"==n?a_:null,a="Z"==e?s_:"Z"==n?a_:null;r?s?a||(a=l_.crossVectors(r,s)):s=l_.crossVectors(a,r):r=l_.crossVectors(s,a),c_.makeBasis(r,s,a),t.setRotationFromMatrix(c_),t.parent&&(t.parent.matrixWorld.decompose(u_,h_,u_),t.quaternion.premultiply(h_.invert())),this.fixCameraLightRotation&&(t.isCamera||t.isLight)&&t.quaternion.multiply(n_)}}class d_ extends Wp{constructor(t){super(t),this.isFixOrthoZoomConstraint=!0,this.Pi=1}copy(t){super.copy(t),this.Pi=t.Pi}update(t){if(super.update(t),this.mute)return;const e=this.target;if(t.parent!==e||!e.isOrthographicCamera)return void console.error("FixOrthoZoom: object should be a direct child of the orthographic camera");const n=this.Pi/e.zoom;t.position.multiplyScalar(n),t.scale.multiplyScalar(n),this.Pi=e.zoom}}const A_=new An,v_=new An,m_=new dn,p_=new pn,g_=new Pn;class __ extends Wp{constructor(t){super(t),this.isCanvasFitConstraint=!0,this.type="CanvasFitConstraint",this.edgeH="NONE",this.edgeV="NONE",this.offset=0,this.fitShape="BOX",this.xr=null}copy(t){return super.copy(t),this.edgeH=t.edgeH,this.edgeV=t.edgeV,this.offset=t.offset,this.fitShape=t.fitShape,this.xr=t.xr,this}update(t){if(super.update(t),this.mute)return;if(t.parent!==this.target)return void console.error(`CanvasFitConstraint: object ${t.name} should be a direct child of the camera`);let e,n,o,i;e=this.xr&&this.xr.enabled&&this.xr.isPresenting?this.xr.getCamera():this.target;const r="LEFT"==this.edgeH?-1:"RIGHT"==this.edgeH?1:0,s="BOTTOM"==this.edgeV?-1:"TOP"==this.edgeV?1:0;e.isPerspectiveCamera&&(o=le(e.fov/2),n=Math.atan(e.aspect*Math.tan(o)),"LEFT"==this.edgeH&&(n*=r),"BOTTOM"==this.edgeV&&(o*=s),i=Math.abs(t.position.z)),t.geometry;let a=0,l=0,c=0,u=0;if(t.matrix.compose(t.position,t.quaternion,t.scale),"BOX"==this.fitShape)if(p_.makeEmpty(),t.resolveMultiMaterial().forEach(function(t){t.geometry&&(null==t.geometry.boundingBox&&t.geometry.computeBoundingBox(),p_.union(t.geometry.boundingBox))}),p_.isEmpty())a=-r*this.offset,l=-s*this.offset;else{p_.applyMatrix4(t.matrix);const e=p_.getCenter(A_).sub(t.position),n=p_.getSize(v_).addScalar(2*this.offset);a=-(.5*n.x*r+e.x),l=-(.5*n.y*s+e.y),c=n.x,u=n.y}else if("SPHERE"==this.fitShape)if(g_.makeEmpty(),t.resolveMultiMaterial().forEach(function(t){t.geometry&&(null===t.geometry.boundingSphere&&t.geometry.computeBoundingSphere(),g_.isEmpty()?g_.copy(t.geometry.boundingSphere):g_.union(t.geometry.boundingSphere))}),g_.isEmpty())a=-r*this.offset,l=-s*this.offset;else{g_.applyMatrix4(t.matrix),g_.radius+=this.offset;const i=A_.copy(g_.center).sub(t.position);a=-(g_.radius*r+i.x),l=-(g_.radius*s+i.y),e.isPerspectiveCamera&&(a/=Math.cos(n),l/=Math.cos(o)),c=2*g_.radius,u=2*g_.radius}else a=-r*this.offset,l=-s*this.offset;"STRETCH"==this.edgeH?(t.position.x=a,0!==c&&(t.scale.applyQuaternion(m_.copy(t.quaternion)),e.isPerspectiveCamera?t.scale.x*=2*i*Math.tan(n)/c:t.scale.x*=(e.right-e.left)/e.zoom/c,t.scale.applyQuaternion(m_.copy(t.quaternion).invert()))):"NONE"!==this.edgeH&&(e.isPerspectiveCamera?t.position.x=i*Math.tan(n)+a:t.position.x=(r<0?e.left:e.right)/e.zoom+a),"STRETCH"==this.edgeV?(t.position.y=l,0!==u&&(t.scale.applyQuaternion(m_.copy(t.quaternion)),e.isPerspectiveCamera?t.scale.y*=2*i*Math.tan(o)/u:t.scale.y*=(e.top-e.bottom)/e.zoom/u,t.scale.applyQuaternion(m_.copy(t.quaternion).invert()))):"NONE"!==this.edgeV&&(e.isPerspectiveCamera?t.position.y=i*Math.tan(o)+l:t.position.y=(s<0?e.bottom:e.top)/e.zoom+l)}}class E_ extends Hp{constructor(){super(),this.isCanvasBreakpointsConstraint=!0,this.type="CanvasBreakpointsConstraint",this.minWidth=0,this.maxWidth=1/0,this.minHeight=0,this.maxHeight=1/0,this.orientation="ALL",this.appInstance=null}copy(t){return super.copy(t),this.minWidth=t.minWidth,this.maxWidth=t.maxWidth,this.minHeight=t.minHeight,this.maxHeight=t.maxHeight,this.orientation=t.orientation,this.appInstance=t.appInstance,this}update(t){if(super.update(t),this.mute)return;if(!this.appInstance)return;const e=this.appInstance.getWidth(),n=this.appInstance.getHeight();let o;switch(this.orientation){case"ALL":o=!0;break;case"LANDSCAPE":o=e/n>=1;break;case"PORTRAIT":o=e/n<1}if(this.appInstance.getCamera()!==t||e>=this.minWidth&&e<=this.maxWidth&&n>=this.minHeight&&n<=this.maxHeight&&o)e>=this.minWidth&&e<=this.maxWidth&&n>=this.minHeight&&n<=this.maxHeight&&o?t.traverse(t=>{t.internVisible=!0}):t.traverse(t=>{t.internVisible=!1});else{let o=this.findAlternativeCamera(t,this.appInstance.scene,e,n);o&&this.appInstance.setCamera(o)}}findAlternativeCamera(t,e,n,o){let i,r,s=!1;return t&&e.traverse(function(e){if(!s&&e.isCamera&&e!=t)for(let t=0;t<e.constraints.length;t++){let a=e.constraints[t];if(a.isCanvasBreakpointsConstraint){switch(a.orientation){case"ALL":i=!0;break;case"LANDSCAPE":i=n/o>=1;break;case"PORTRAIT":i=n/o<1}n>=a.minWidth&&n<=a.maxWidth&&o>=a.minHeight&&o<=a.maxHeight&&i&&(r?(console.error("CanvasBreakpointsConstraint: two or more alternative cameras"),s=!0):r=e)}}}),r}}const C_=function(t){return!!t&&(!!t.dtype&&new RegExp("function View[0-9]+d(:?"+t.dtype+")+").test(String(t.constructor)))},w_=function(t){return!!t&&(void 0!==t.data&&Array.isArray(t.shape)&&void 0!==t.offset&&void 0!==t.stride)};function x_(t){return Array.isArray(t)||ArrayBuffer.isView(t)}function I_(t){if(t){if(C_(t)||w_(t))return"generic"===t.dtype?I_.GENERIC_NDARRAY:I_.NDARRAY;if(x_(t))return I_.ARRAY_OF_ARRAYS;throw new Error("Unhandled data type. Got type: "+typeof t)}}function M_(t){return t[0].toUpperCase()+t.slice(1)}I_.ARRAY_OF_ARRAYS="Arr",I_.NDARRAY="Nd",I_.GENERIC_NDARRAY="GenNd",I_.PACKED="PackArr";const S_=function(t,e){return function(e,n){void 0===e||Array.isArray(e)||(e=[e]);for(var o=[],i=0;i<e.length;i++)o.push(S_.sum(e[i]));if(n)for(e=0;e<o.length;e++)void 0!==n[e]&&(o[e]="("+o[e]+" + "+n[e]+") % "+n[e]);return t+o.join("_")}};function b_(t){return function(e,n){void 0===e||Array.isArray(e)||(e=[e]);for(var o=[],i=0;i<e.length;i++)o.push(S_.sum(e[i]));if(n)for(e=0;e<o.length;e++)void 0!==n[e]&&(o[e]="("+o[e]+" + "+n[e]+") % "+n[e]);return t(o)}}function y_(t,e){var n;if(e)switch(I_(e)){case I_.ARRAY_OF_ARRAYS:return b_(function(e){return t+"["+e.join("][")+"]"});case I_.GENERIC_NDARRAY:return b_(function(e){return t+".get("+e.join(",")+")"});case I_.NDARRAY:return b_(function(e){var o=[t+"Offset"];for(n=0;n<e.length;n++)o.push(t+"Stride"+n+" * ("+e[n]+")");return t+"["+o.join(" + ")+"]"});case I_.PACKED:default:return}}S_.sum=function(t){return 0===(t=(t=Array.isArray(t)?t:[t]).filter(function(t){return void 0!==t&&0!==t})).length&&t.push(0),t.join(" + ")};var R_=[],T_=[];const B_=function(t,e,n){if(1!==e)throw new Error("Numerical derivative not implemented for order n = "+e+".");var o,i=void 0===arguments[this.splineDimension+3]?1e-4:arguments[this.splineDimension+3];for(R_.length=this.splineDimension,o=0;o<this.splineDimension;o++)R_[o+1]=arguments[o+3];var r,s,a,l=this.domain,c=l[n][0],u=l[n][1],h=R_[n+1],f=(u-c)*i;for("closed"===this.boundary[n]?(r=c+(h-c-f+(a=u-c))%a,s=c+(h-c+f+a)%a,f*=2):(r=Math.min(u,Math.max(c,h-f)),f=(s=Math.min(u,Math.max(c,h+f)))-r),R_[n+1]=r,R_[0]=T_,this.evaluate.apply(null,R_),R_[n+1]=s,R_[0]=t,this.evaluate.apply(null,R_),o=0;o<this.dimension;o++)t[o]=(t[o]-T_[o])/f;return t},L_=function(t,e){for(var n=1,o=0,i=[];o<t.length;o++)n*=Array.isArray(t[o])?t[o][1]-t[o][0]:t[o],i[o]=Array.isArray(t[o])?t[o][0]:0;for(var r=0;r<n;r++)for(e(i.slice()),o=t.length-1;o>=0;o--){if(i[o]!==(Array.isArray(t[o])?t[o][1]:t[o])-1){i[o]++;break}i[o]=Array.isArray(t[o])?t[o][0]:0}},N_=function(t,e,n,o){var i,r=[];switch(I_(o)){case I_.NDARRAY:for(r.push("  const "+e+" = "+n+".data;"),r.push("  const "+e+"Offset = "+n+".offset;"),i=0;i<o.dimension;i++)r.push("  const "+e+"Stride"+i+" = "+n+".stride["+i+"];");break;case I_.ARRAY_OF_ARRAYS:r.push("  const "+e+" = "+n+";")}return r.join("\n")},D_=function(t,e,n){if(t){if(w_(t))return e+".shape["+n+"]";for(var o=e,i=0;i<n;i++)o+="[0]";return o+".length"}return"this.size["+n+"]"};var P_={},O_={};const F_=function(t,e,n,o,i,r,s){var a,l,c,u,h,f,d=e.splineDimension,A=e.points,v=e.degree,m=e.weights,p=void 0!==m,g=e.knots,_=e.dimension,E=e.boundary;if(null!=s){Array.isArray(s)||(s=[s]);var C=0;for(a=0;a<d;a++)void 0===s[a]&&(s[a]=0),C+=s[a];if(p&&C>1)throw new Error("Analytical derivative not implemented for rational b-splines with order n = "+C+".")}r&&(t="Basis"+t),s&&(t="Der"+s.join("_")+"_"+t);var w=P_[t];if(o)var x="function"==typeof o?o:console.log;if(w)return o&&x(O_[t]),w.bind(e);var I=[],M="evaluate"+t,S=n.point;r&&(S=function(t,e){for(var n=[],o=0;o<t.length;o++){for(var i=t[o],r=[],s=0;s<i.length;s++)0!==i[s]&&r.push(i[s]);i=r.join(" + "),e[o]&&(i="("+i+" + "+e[o]+") % "+e[o]),n.push(i+" === "+L(o))}return"(("+n.join(" && ")+") ? 1 : 0)"});var b=n.weight,y=n.knot,R=S_("k"),T=S_("x"),B=S_("w"),L=S_("i"),N=S_("t"),D=o?"domain":"d",P=S_(o?"size":"s"),O=S_(o?"knotIndex":"j"),F=!0;for(h=0;h<d;h++)x_(g)&&x_(g[h])&&(F=!1);function U(t){I.push("  "+(t||""))}function V(t){o&&U(t)}if(r)var G=[];var Q=[];for(a=0;a<d;a++)r&&G.push(L([a])),Q.push(N([a]));for(I.push("function "+M+" ("+(r?"":"out, ")+Q.join(", ")+(r?", "+G.join(", "):"")+") {"),U("let h, m, a, b;"),i&&(U("const "+D+" = this.domain;"),U("for (let i = 0; i < this.splineDimension; i++) {"),U("  a = arguments[i + 1];"),U("  if (a < "+D+"[i][0] || a > "+D+"[i][1] || a === undefined || isNaN(a)) {"),U("    throw new Error('Invalid Spline parameter in dimension '+i+'. Valid domain is ['+"+D+"[i][0]+', '+"+D+"[i][1]+']. but got t'+i+' = '+arguments[i + 1]+'.');"),U("  }"),U("}")),h=0;h<d;h++)U("let "+P(h)+" = "+D_(A,"this.points",h)+";");function z(t,e,n){return"("+t+") ? ("+e+") : ("+n+")"}I.push(N_(0,"x","this.points",A)),p&&I.push(N_(0,"w","this.weights",m)),F||I.push(N_(0,"k","this.knots",g));var k=[];for(h=0;h<d;h++)switch(I_(g)){case I_.NDARRAY:k[h]=!0;break;case I_.ARRAY_OF_ARRAYS:k[h]=x_(g[h])}for(h=0;h<d;h++)if(k[h])for(V("\n  // Bisect to locate the knot interval in dimension "+h+"\n"),U("let "+O(h)+" = 0;"),U("h = "+P(h)+";"),U("while(h > "+O(h)+" + 1) {"),U("  m = 0.5 * (h + "+O(h)+") | 0;"),U("  if ("+y([h,"m"])+" > "+N(h)+") h = m;"),U("  else "+O(h)+" = m;"),U("}"),V("\n  // Fetch knots for dimension "+h+"\n"),a=1-v[h];a<=v[h];a++)"closed"===E[h]?U(a<0?"let "+R([h,a+v[h]-1])+" = "+z(O(h)+" < "+-a,y([h,0])+" + "+y([h,[P(h),O(h),a]])+" - "+y([h,[P(h)]]),y([h,[O(h),a]]))+";":a>0?"let "+R([h,a+v[h]-1])+" = "+z(O(h)+" + "+a+" > "+P(h),y([h,P(h)])+" + "+y([h,a+" + "+O(h)+" - "+P(h)])+" - "+y([h,0]),y([h,[O(h),a]]))+";":"let "+R([h,a+v[h]-1])+" = "+y([h,[O(h),a]])+";"):U("let "+R([h,a+v[h]-1])+" = "+y([h,[O(h),a]])+";");else{for(V("\n  // Directly compute knot interval for dimension "+h+"\n"),"closed"===E[h]?U(O(h)+" = ("+N(h)+" | 0) % "+P(h)+";"):(U(O(h)+" = ("+N(h)+" | 0);"),U("if ("+O(h)+" < "+v[h]+") "+O(h)+" = "+v[h]+";"),U("if ("+O(h)+" > "+P(h)+" - 1) "+O(h)+" = "+P(h)+" - 1;")),V("\n  // Compute and clamp knots for dimension "+h+"\n"),a=1-v[h];a<=v[h];a++)U("let "+(f=R([h,a+v[h]-1]))+" = "+O(h)+" + "+a+";");if("clamped"===E[h])for(a=1-v[h];a<=v[h];a++)f=R([h,a+v[h]-1]),a<0&&U("if ("+f+" < "+v[h]+") "+f+" = "+v[h]+";"),a>0&&U("if ("+f+" > "+P(h)+") "+f+" = "+P(h)+";");"closed"===E[h]&&(V("\n  // Wrap the B-Spline parameter for closed boundary"),U(N(h)+" %= "+P(h)+";"))}for(h=0,c=[];h<d;h++)c[h]=v[h]+1;for(p&&(V("\n  // Fetch weights\n"),L_(c,function(t){for(var e=[],n=[],o=0;o<d;o++)e[o]=[O(o),t[o]-v[o]],"closed"===E[o]&&t[o]-v[o]<0&&(n[o]=P(o));U("let "+B(t)+" = "+b(e,n)+";")})),o&&U(p?"\n  // Fetch points and project into homogeneous (weighted) coordinates\n":"\n  // Fetch points\n"),L_(c,function(t){for(var e=[],n=[],o=0;o<d;o++)e[o]=[O(o),t[o]-v[o]],"closed"===E[o]&&t[o]-v[o]<0&&(n[o]=P(o));if(r)U(p?"let "+T(t)+" = "+S(e,n)+" * "+B(t)+";":"let "+T(t)+" = "+S(e,n)+";");else for(o=0;o<_;o++){var i=t.concat(o);e[d]=o,U(p?"let "+T(i)+" = "+S(e,n)+" * "+B(t)+";":"let "+T(i)+" = "+S(e,n)+";")}}),V("\n"),V("// Perform De Boor's algorithm"),h=c.length-1;h>=0;h--)for(c[h]=[v[h],v[h]+1],a=0;a<v[h];a++)for(V("\n  // Degree "+v[h]+" evaluation in dimension "+h+", step "+(a+1)+"\n"),l=v[h];l>a;l--){var H=s&&v[h]-a-s[h]<=0;H?(U("m = 1 / ("+R([h,l-a+v[h]-1])+" - "+R([h,l-1])+");"),p&&(U("a = ("+N(h)+" - "+R([h,l-1])+") * m;"),U("b = 1 - a;"))):(U("a = ("+N(h)+" - "+R([h,l-1])+") / ("+R([h,l-a+v[h]-1])+" - "+R([h,l-1])+");"),U("b = 1 - a;")),p&&L_(c,function(t){var e=t.slice(),n=t.slice();e[h]=l,n[h]=l-1,H&&p&&U("h = "+B(e)+";"),U(B(e)+" = b * "+B(n)+" + a * "+B(e)+";")}),L_(c,function(t){var e,n,o,i=t.slice(),s=t.slice();if(i[h]=l,s[h]=l-1,H){var c=a+1;if(r)e=p?"h * "+B(s)+" / "+B(i)+" * ":"",n=T(i)+(p?" / h":""),o=T(s)+(p?" / "+B(s):""),U(T(i)+" = "+c+" * "+e+"("+n+" - "+o+") * m;");else{var f=i.slice(),A=s.slice();for(u=0;u<_;u++)f[d]=A[d]=u,e=p?"h * "+B(s)+" / "+B(i)+" * ":"",n=T(f)+(p?" / h":""),o=T(A)+(p?" / "+B(s):""),U(T(f)+" = "+c+" * "+e+"("+n+" - "+o+") * m;")}}else if(r)U(T(i)+" = b * "+T(s)+" + a * "+T(i)+";");else for(u=0;u<_;u++)i[d]=s[d]=u,U(T(i)+" = b * "+T(s)+" + a * "+T(i)+";")}),V("\n")}if(o&&U(p?"\n  // Project back from homogeneous coordinates and return final output\n":"\n  // Return final output\n"),r)U(p?"return "+T(v)+" / "+B(v)+";":"return "+T(v)+";");else for(h=0;h<_;h++)U(p?"out["+h+"] = "+T(v.concat([h]))+" / "+B(v)+";":"out["+h+"] = "+T(v.concat([h]))+";");if(r||U("return out;"),I.push("}"),o){var W=I.join("\n");x(W),O_[t]=W}const Y=new Function([I.join("\n"),"; return ",M].join(""))();return P_[t]=Y,Y.bind(e)};var U_={};var V_={};var G_={open:"open",closed:"closed",clamped:"clamped"};function Q_(t){return null==t}function z_(t,e,n,o,i,r){var s,a;!t||x_(t)||C_(t)?(r=r||{},this.weights=o,this.knots=n,this.degree=e,this.points=t,this.boundary=i,this.debug=r.debug,this.checkBounds=!!r.checkBounds,Object.defineProperty(this,"size",{value:r.size,writable:!0,configurable:!0})):(r=t,this.debug=t.debug,this.checkBounds=!!t.checkBounds,this.weights=t.weights,this.knots=t.knots,this.degree=t.degree,this.boundary=t.boundary,this.points=t.points,Object.defineProperty(this,"size",{value:r.size,writable:!0,configurable:!0}));var l=I_(this.points),c=I_(this.weights),u=I_(this.knots);if(this.points)switch(l){case I_.GENERIC_NDARRAY:case I_.NDARRAY:Object.defineProperties(this,{splineDimension:{value:this.points.shape.length-1,writable:!1,configurable:!0},dimension:{value:this.points.shape[this.points.shape.length-1],writable:!1,configurable:!0},size:{get:function(){return this.points.shape.slice(0,this.points.shape.length-1)},set:function(){throw new Error("Cannot assign to read only property 'size'")},configurable:!0}});break;case I_.ARRAY_OF_ARRAYS:var h=0,f=this.size||[];f.length=0;for(var d=this.points;x_(d[0]);d=d[0])h++,f.push(d.length);if(0===h)throw new Error("Expected an array of points");Object.defineProperties(this,{splineDimension:{value:h,writable:!1,configurable:!0},dimension:{value:d.length,writable:!1,configurable:!0},size:{get:function(){var t=[];t.length=0;for(var e=0,n=this.points;e<this.splineDimension;e++,n=n[0])t[e]=n.length;return t},set:function(){throw new Error("Cannot assign to read only property 'size'")},configurable:!0}});break;case I_.PACKED:default:throw new Error("Expected either a packed array, array of arrays, or ndarray of points")}else{if(void 0===this.size||null===this.size)throw new Error("Either points or a control hull size must be provided.");if(x_(this.size)||Object.defineProperty(this,"size",{value:[this.size],writable:!0,configurable:!0}),0===this.size.length)throw new Error("`size` must be a number or an array of length at least one.");Object.defineProperties(this,{splineDimension:{value:this.size.length,writable:!1,configurable:!0},dimension:{value:0,writable:!1,configurable:!0}})}if(x_(this.degree)){for(s=0;s<this.splineDimension;s++)if(Q_(this.degree[s]))throw new Error("Missing degree in dimension "+(s+1))}else{var A=!Q_(this.degree),v=Q_(this.degree)?2:this.degree;for(this.degree=[],s=0;s<this.splineDimension;s++)if(this.size[s]<=v){if(A)throw new Error("Expected at least "+(v+1)+" points for degree "+v+" spline in dimension "+(s+1)+" but got only "+this.size[s]);this.degree[s]=this.size[s]-1}else this.degree[s]=v}if(a="string"!=typeof this.boundary?"open":this.boundary,!G_[a])throw new Error("Boundary type must be one of "+Object.keys(G_)+". Got "+a);for(this.boundary=x_(this.boundary)?this.boundary:[],this.boundary.length=this.splineDimension,s=0;s<this.splineDimension;s++)if(this.boundary[s]=Q_(this.boundary[s])?a:this.boundary[s],!G_[a])throw new Error("Boundary type must be one of "+Object.keys(G_)+". Got "+a+" for dimension "+(s+1));if(u===I_.ARRAY_OF_ARRAYS)for(x_(this.knots)&&this.knots.length>0&&!x_(this.knots[0])&&(this.knots=[this.knots]),s=0;s<this.splineDimension;s++){if(this.size[s]<=this.degree[s])throw new Error("Expected at least "+(this.degree[s]+1)+" points in dimension "+(s+1)+" but got "+this.size[s]+".");if(x_(this.knots[s])){if("closed"!==this.boundary[s]&&this.knots[s].length!==this.degree[s]+this.size[s]+1)throw new Error("Expected "+(this.degree[s]+this.size[s]+1)+" knots in dimension "+(s+1)+" but got "+this.knots[s].length+".");if("closed"===this.boundary[s]&&this.knots[s].length!==this.size[s]+1&&!(this.knots[s].length===this.size[s]+this.degree[s]+1))throw new Error("Expected "+(this.size[s]+1)+" knots for closed spline in dimension "+(s+1)+" but got "+this.knots[s].length+".")}}var m=function(t,e,n,o,i,r){var s,a=[],l=!1;for(s=0;s<t.splineDimension;s++){var c=x_(t.knots)&&x_(t.knots[s]);c&&(l=!0),a.push("Deg"+t.degree[s]+(c?"":"Uniform")+M_(t.boundary[s]))}var u=[[l?"NU":"",t.weights?"RBS":"BS"].join("")+t.dimension+"D",a.join("_")];return o&&u.push(o+"Pts"),i&&u.push(i+"Wts"),r&&u.push(r+"Kts"),e&&u.push("debug"),n&&u.push("chk"),u.join("_")}(this,this.debug,this.checkBounds,l,c,u);if(m!==this.ie){this.ie=m;var p=function(t){var e,n={};return(e=y_("x",t.points))&&(n.point=e),(e=y_("w",t.weights))&&(n.weight=e),(e=y_("k",t.knots))&&(n.knot=e),n}(this);this.evaluate=F_(this.ie,this,p,this.debug,this.checkBounds,!1),this.transform=function(t,e,n,o){var i,r,s,a,l,c,u,h,f=U_[t];if(f)return f.bind(e);var d=[],A="transform"+t;d.push("function "+A+"(m) {"),d.push("let i, w;"),d.push(N_(0,"x","this.points",e.points));var v=S_(o?"size":"s");for(i=0;i<e.splineDimension;i++)d.push("let "+v(i)+" = "+D_(e.points,"this.points",i)+";");for(a=[],i=0;i<e.splineDimension;i++)s="i"+i,a.push(s),d.push("for ("+s+" = "+v(i)+"- 1; "+s+" >= 0; "+s+"--) {");for(i=0;i<e.dimension;i++)d.push("x"+i+" = "+n.point(a.concat([i])));for(l=[],i=0;i<e.dimension;i++)l.push("m["+((e.dimension+1)*(i+1)-1)+"] * x"+i);for(l.push("m["+((e.dimension+1)*(e.dimension+1)-1)+"]"),d.push("const w = ("+l.join(" + ")+") || 1.0;"),i=0;i<e.dimension;i++){for(l=[],c=e.dimension,r=0;r<c;r++)l.push("m["+(r*(c+1)+i)+"] * x"+r);l.push("m["+(r*(c+1)+i)+"]"),h=n.point(a.concat([i])),u="("+l.join(" + ")+") / w",d.push(h+" = "+u+";")}for(i=e.splineDimension-1;i>=0;i--)d.push("}");d.push("return this;"),d.push("}");const m=new Function([d.join("\n"),"; return ",A].join(""))();return o&&console.log(d.join("\n")),U_[t]=m,m.bind(e)}(this.ie,this,p,this.debug),this.support=function(t,e,n,o,i){var r=V_[t];if(r)return r.bind(e);var s,a,l,c=e.degree,u=e.knots,h=e.splineDimension,f=e.boundary,d=[],A="support"+t,v=n.knot,m=S_("t"),p=o?"domain":"d",g=S_(o?"size":"s"),_=S_(o?"knotIndex":"i"),E=!0;for(l=0;l<h;l++)x_(u)&&x_(u[l])&&(E=!1);function C(t){d.push("  "+(t||""))}var w=[];for(s=0;s<h;s++)w.push(m([s]));d.push("function "+A+" (out, "+w.join(", ")+") {");var x=0;function I(t,e){C(void 0===e?"out["+x+++"] = "+t.join(" + ")+";":"out["+x+++"] = ("+t.join(" + ")+" + "+e+") % "+e+";")}for(C("let h, m;"),C("let c = 0;"),i&&(C("const "+p+" = this.domain;"),C("for (let i = 0; i < this.splineDimension; i++) {"),C("  a = arguments[i + 1];"),C("  if (a < "+p+"[i][0] || a > "+p+"[i][1] || a === undefined || isNaN(a)) {"),C("    throw new Error('Invalid Spline parameter in dimension '+i+'. Valid domain is ['+"+p+"[i][0]+', '+"+p+"[i][1]+']. but got t'+i+' = '+arguments[i + 1]+'.');"),C("  }"),C("}")),l=0;l<h;l++)C("let "+g(l)+" = "+D_(e.points,"this.points",l)+";");E||d.push(N_(0,"k","this.knots",u));var M=[];for(l=0;l<h;l++)switch(I_(u)){case I_.NDARRAY:M[l]=!0;break;case I_.ARRAY_OF_ARRAYS:M[l]=x_(u[l])}for(l=0;l<h;l++)M[l]?(C("let "+_(l)+" = 0;"),C("h = "+g(l)+";"),C("while(h > "+_(l)+" + 1) {"),C("  m = 0.5 * (h + "+_(l)+") | 0;"),C("  if ("+v([l,"m"])+" > "+m(l)+") h = m;"),C("  else "+_(l)+" = m;"),C("}")):"closed"===f[l]?C(_(l)+" = ("+m(l)+" | 0) % "+g(l)+";"):(C(_(l)+" = ("+m(l)+" | 0);"),C("if ("+_(l)+" < "+c[l]+") "+_(l)+" = "+c[l]+";"),C("if ("+_(l)+" > "+g(l)+" - 1) "+_(l)+" = "+g(l)+" - 1;"));for(l=0,a=[];l<h;l++)a[l]=c[l]+1;L_(a,function(t){for(var e=[],n=[],o=0;o<h;o++)e[o]=[_(o),t[o]-c[o]],"closed"===f[o]&&t[o]-c[o]<0&&(n[o]=g(o));for(o=0;o<h;o++)I(e[o],n[o])}),C("out.length = "+x+";"),C("return out;"),d.push("}"),o&&console.log(d.join("\n"));const S=new Function([d.join("\n"),"; return ",A].join(""))();return V_[t]=S,S.bind(e)}(this.ie,this,p,this.debug,this.checkBounds),this.evaluator=function(t,e){return F_(this.ie,this,p,this.debug,this.checkBounds,e,t)}}return this.numericalDerivative=B_.bind(this),this}function k_(){var t,e=[],n=this.points;n?w_(n)&&(t=n.shape):t=this.size;for(var o=0;o<this.splineDimension;o++){var i=t?t[o]:n.length,r=this.degree[o],s="closed"===this.boundary[o];if(this.knots&&this.knots[o]){var a=this.knots[o];e[o]=[a[s?0:r],a[i]]}else e[o]=[s?0:r,i];n&&(n=n[0])}return e}function H_(t,e,n,o,i,r){const s=function(t,e,n,o,i,r){return a(t,e,n,o,i,r),s},a=z_.bind(s);return Object.defineProperty(s,"domain",{get:k_}),a(t,e,n,o,i,r),s}const W_=(new dn).setFromAxisAngle(new An(1,0,0),-Math.PI/2),Y_={X:new An(1,0,0),Y:new An(0,1,0),Z:new An(0,0,1),"-X":new An(-1,0,0),"-Y":new An(0,-1,0),"-Z":new An(0,0,-1)},X_=new An(0,1,0),K_=new An(0,0,1),j_=0,Z_=1,q_=0,J_=1,$_=new An,tE=new dn,eE=new An,nE=new An,oE=new An,iE=new An,rE=new An,sE=new An,aE=new An,lE=new Hn,cE=new dn,uE=[0,0,0];class hE extends Hp{constructor(){super(),this.isMotionPathConstraint=!0,this.type="MotionPathConstraint",this.curve=null,this.firstDerivativeEvaluator=null,this.secondDerivativeEvaluatorForNonUniformBSplines=null,this.derivativeEvaluatorForWeights0=null,this.derivativeEvaluatorForWeights1=null,this.derivativeEvaluatorForWeights2=null,this.degree=3,this.cvs=[],this.knots=[],this.weights=[],this.value=0,this.follow=!0,this.frontAxis="Z",this.upAxis="Y",this.worldUpVector=new An(0,1,0),this.useChordLength=!1,this.chordsNum=0,this.chordLengths=[],this.bank=!1,this.bankScale=1,this.bankLimit=1/0,this.useFixedLocation=!1,this.fixedValue=0,this.usePointsTilt=!1,this.pointsTilt=[],this.pointsTiltEvaluator=null,this.offsetValue=0,this.useClampValue=!1,this.useCyclic=!1,this.useObjOffset=!1,this.useRelative=!1,this.usePosOffset=!0,this.objOffsetMode=j_,this.objOffsetRotMode=q_,this.influence=1,this.fixCameraLightRotation=!1,this.Ii=!0,this.Ti=new Hn,this.Oi=new An,this.Fi=new dn}copy(t){super.copy(t),this.degree=t.degree,this.cvs=[];for(let e=0;e<t.cvs.length;++e)this.cvs.push(t.cvs[e]);this.knots=[];for(let e=0;e<t.knots.length;++e)this.knots.push(t.knots[e]);this.weights=[];for(let e=0;e<t.weights.length;++e)this.weights.push(t.weights[e]);this.value=t.value,this.follow=t.follow,this.frontAxis=t.frontAxis,this.upAxis=t.upAxis,this.worldUpVector.copy(t.worldUpVector),this.useChordLength=t.useChordLength,this.chordsNum=t.chordsNum,this.bank=t.bank,this.bankScale=t.bankScale,this.bankLimit=t.bankLimit,this.useFixedLocation=t.useFixedLocation,this.fixedValue=t.fixedValue,this.usePointsTilt=t.usePointsTilt,this.pointsTilt=[];for(let e=0;e<t.pointsTilt.length;++e)this.pointsTilt.push(t.pointsTilt[e]);return this.offsetValue=t.offsetValue,this.useClampValue=t.useClampValue,this.useCyclic=t.useCyclic,this.useObjOffset=t.useObjOffset,this.useRelative=t.useRelative,this.usePosOffset=t.usePosOffset,this.objOffsetMode=t.objOffsetMode,this.objOffsetRotMode=t.objOffsetRotMode,this.influence=t.influence,this.fixCameraLightRotation=t.fixCameraLightRotation,this.Ii=!0,this}init(){const t=[],e=this.cvs;for(let n=0;n<e.length;n+=3)t.push([e[n],e[n+1],e[n+2]]);this.curve=H_({points:t,knots:this.knots,weights:this.weights,degree:this.degree}),this.firstDerivativeEvaluator=this.curve.evaluator(1);let n=H_({points:t,knots:this.knots,degree:this.degree});this.secondDerivativeEvaluatorForNonUniformBSplines=n.evaluator(2);const o=[];for(let t=0;t<this.weights.length;++t)o.push([this.weights[t]]);let i=H_({points:o,knots:this.knots,degree:this.degree});if(this.derivativeEvaluatorForWeights0=i.evaluator(0),this.derivativeEvaluatorForWeights1=i.evaluator(1),this.derivativeEvaluatorForWeights2=i.evaluator(2),this.usePointsTilt){const t=[];for(let e=0;e<this.pointsTilt.length;++e)t.push([this.pointsTilt[e]]);const e=H_({points:t,knots:this.knots,weights:this.weights,degree:this.degree});this.pointsTiltEvaluator=e.evaluator(0)}else this.pointsTiltEvaluator=null;if(this.useChordLength)if(this.chordLengths=[],this.chordsNum<=0){let t=1==this.degree?1:32;this.Ui(this.chordLengths,this.cvs.length/3*t)}else this.Ui(this.chordLengths,this.chordsNum)}update(t){if(super.update(t),this.mute)return;this.Ii&&(this.xi(t),t.matrixWorld.decompose(this.Oi,this.Fi,eE),this.Ti.copy(t.matrixWorld),this.useRelative&&(this.Vi($_,0),this.Oi.sub($_),this.Ti.setPosition(this.Oi)),this.usePosOffset||(this.Oi.set(0,0,0),this.Ti.setPosition(this.Oi)),this.Ii=!1);let e=this.useFixedLocation?this.fixedValue:this.value+this.offsetValue;this.useCyclic?e-=Math.floor(e):e=this.useClampValue?ie(e,0,1):Math.max(0,e),this.useChordLength&&(e=this.Gi(e,this.chordLengths));const n=this.curve.domain,o=e*(n[0][1]-n[0][0])+n[0][0];if(this.Vi(t.position,o),!this.follow&&this.useObjOffset&&(nE.addVectors(t.position,this.Oi),t.position.lerpVectors(this.Oi,nE,this.influence)),this.follow&&1!=Math.abs(Y_[this.frontAxis].dot(Y_[this.upAxis]))){const e=this.Qi(nE,o),n=oE.copy(e).normalize();if(this.zi(lE,n,this.worldUpVector),this.ki(tE,Y_[this.frontAxis],Y_[this.upAxis]),t.quaternion.setFromRotationMatrix(lE).multiply(tE),this.bank){const n=this.Hi(oE,o,t.position,e),i=this.Wi(e,n),r=iE.copy(Y_[this.upAxis]).applyQuaternion(t.quaternion);let s=this.Yi(i,e,n,r);s=this.Xi(s*this.bankScale,this.bankLimit),tE.setFromAxisAngle(Y_[this.frontAxis],s),t.quaternion.multiply(tE)}else if(this.usePointsTilt){this.pointsTiltEvaluator(uE,o);let e=uE[0];tE.setFromAxisAngle(Y_[this.frontAxis],e),t.quaternion.multiply(tE)}if(this.useObjOffset){if(this.objOffsetMode==Z_){const e=nE.setScalar(1);lE.compose(t.position,t.quaternion,e),this.objOffsetRotMode==J_&&lE.multiply(this.Ti),lE.decompose($_,tE,eE)}else this.objOffsetMode==j_&&($_.addVectors(t.position,this.Oi),this.objOffsetRotMode==q_?tE.copy(t.quaternion):this.objOffsetRotMode==J_&&tE.multiplyQuaternions(t.quaternion,this.Fi));t.position.lerpVectors(this.Oi,$_,this.influence),t.quaternion.slerpQuaternions(this.Fi,tE,this.influence)}this.fixCameraLightRotation&&(t.isCamera||t.isLight)&&t.quaternion.multiply(W_)}}Vi(t,e){return this.curve.evaluate(uE,e),t.fromArray(uE)}Qi(t,e){return this.firstDerivativeEvaluator(uE,e),t.fromArray(uE)}zi(t,e,n){const o=rE.copy(n),i=sE.crossVectors(o,e).normalize();return o.crossVectors(e,i),t.makeBasis(i,o,e),t}ki(t,e,n){t.setFromUnitVectors(e,K_);const o=rE.copy(X_),i=sE.copy(n).applyQuaternion(t),r=i.dot(o);if(1!=Math.abs(r)){const n=aE.crossVectors(i,o).dot(K_)>0?1:-1;cE.setFromAxisAngle(e,i.angleTo(o)*n),t.multiply(cE)}else r<0&&(cE.setFromAxisAngle(e,Math.PI),t.multiply(cE));return t}Yi(t,e,n,o){const i=rE.copy(e).add(n).normalize();return t*(sE.crossVectors(i,e).normalize().dot(o)>0?1:-1)}Wi(t,e){return rE.crossVectors(t,e).length()/Math.pow(t.length(),3)}Hi(t,e,n,o){this.secondDerivativeEvaluatorForNonUniformBSplines(uE,e);const i=rE.fromArray(uE);this.derivativeEvaluatorForWeights1(uE,e);const r=uE[0];this.derivativeEvaluatorForWeights2(uE,e);const s=uE[0];this.derivativeEvaluatorForWeights0(uE,e);const a=uE[0];return t.copy(i).sub(sE.copy(o).multiplyScalar(2*r)),t.sub(sE.copy(n).multiplyScalar(s)),t.divideScalar(a),t}Xi(t,e){return t>0?Math.min(t,e):Math.max(t,-e)}Ui(t,e){let n=1/Math.max(1,e-1),o=0,i=0;const r=this.curve.domain;let s=r[0][0],a=r[0][1]-r[0][0];const l=rE,c=sE;this.Vi(l,s);for(let r=0;r<e;++r)this.Vi(c,o*a+s),i+=l.subVectors(c,l).length(),t.push(i),l.copy(c),o+=n;return t}Gi(t,e){if(t<=0)return 0;if(t>=1)return 1;let n=t*e[e.length-1],o=0,i=0,r=e.length-1;for(;o<r;)i=o+Math.floor((r-o)/2),n>e[i]?o=i+1:r=i-1;return n>e[r]?r+=(n-e[r])/(e[r+1]-e[r]):r-=1-(n-e[r-1])/(e[r]-e[r-1]),r/(e.length-1)}}const fE=(new dn).setFromAxisAngle(new An(1,0,0),-Math.PI/2),dE=new An,AE=new dn,vE=new An,mE=new to,pE=new Hn,gE=new Hn,_E={X:0,Y:1,Z:2,"-X":0,"-Y":1,"-Z":2},EE=["x","y","z"],CE=new An,wE=new An,xE=new An,IE=new to;function ME(t,e,n,o=!1){if(e===n)return t;const i=t.y,r=t.z;return"Z_UP_RIGHT"===e&&"Y_UP_RIGHT"===n?(t.y=r,t.z=o?i:-i):"Y_UP_RIGHT"===e&&"Z_UP_RIGHT"===n?(t.y=o?r:-r,t.z=i):console.error("transformCoordsSpace: Unsupported coordinate space"),t}const SE=function(){const t=new to,e=new to,n=new An;return function(o,i){const r=t.copy(o).reorder("YZX"),s=e.copy(r).makeAlternative(),a=n.setFromEuler(r).lengthSq(),l=n.setFromEuler(s).lengthSq();return i.copy(a<l?r:s),ME(i,"Y_UP_RIGHT","Z_UP_RIGHT")}}();class bE extends Wp{constructor(t){super(t),this.isTransformationConstraint=!0,this.type="TransformationConstraint",this.coordSystem="Y_UP_RIGHT",this.fromMin=new An,this.fromMax=new An,this.toMin=new An,this.toMax=new An,this.mapFrom="POSITION",this.mapTo="POSITION",this.mapToAxisFromAxis=["X","Y","Z"],this.mixMode="REPLACE",this.ownerSpaceObj=null,this.targetSpaceObj=null,this.ownerSpace=0,this.targetSpace=0,this.useMotionExtrapolate=!1,this.influence=1,this.fixCameraLightRotation=!1,this.Ii=!0,this.Ti=new Hn,this.Ki=new Hn}copy(t){return super.copy(t),this.coordSystem=t.coordSystem,this.fromMin.copy(t.fromMin),this.fromMax.copy(t.fromMax),this.toMin.copy(t.toMin),this.toMax.copy(t.toMax),this.mapFrom=t.mapFrom,this.mapTo=t.mapTo,this.mapToAxisFromAxis=t.mapToAxisFromAxis,this.mixMode=t.mixMode,this.ownerSpaceObj=t.ownerSpaceObj,this.targetSpaceObj=t.targetSpaceObj,this.ownerSpace=t.ownerSpace,this.targetSpace=t.targetSpace,this.useMotionExtrapolate=t.useMotionExtrapolate,this.influence=t.influence,this.fixCameraLightRotation=t.fixCameraLightRotation,this.Ii=!0,this}update(t){if(super.update(t),this.mute)return;this.Ii&&(this.xi(t),this.Ti.copy(t.matrixWorld),this.Ki.copy(t.matrix),this.Ii=!1);const e=pE;if(0==this.targetSpace)e.copy(this.target.matrixWorld);else if(2==this.targetSpace)e.copy(this.target.matrix);else if(1==this.targetSpace){if(!this.targetSpaceObj)return;e.copy(this.targetSpaceObj.matrixWorld).invert(),e.multiply(this.target.matrixWorld)}if(e.decomposeE(dE,mE,vE),0==this.ownerSpace&&t.parent)this.Ti.decomposeE(t.position,t.rotation,t.scale);else if(2==this.ownerSpace)this.Ki.decomposeE(t.position,t.rotation,t.scale);else if(1==this.ownerSpace){if(!this.ownerSpaceObj)return;gE.copy(this.ownerSpaceObj.matrixWorld).invert(),gE.multiply(this.Ti),gE.decomposeE(t.position,t.rotation,t.scale)}const n=CE;if("POSITION"==this.mapFrom)n.copy(dE);else if("ROTATION"==this.mapFrom)if("Z_UP_RIGHT"==this.coordSystem){const t=SE(mE,IE);ME(t,this.coordSystem,"Y_UP_RIGHT"),n.copy(t)}else n.copy(mE);else"SCALE"==this.mapFrom&&n.copy(vE);const o=wE.set(0,0,0),i=n,r=this.fromMin,s=this.fromMax;for(const t of EE)s[t]-r[t]!=0&&(this.useMotionExtrapolate||(i[t]=Math.min(Math.max(i[t],r[t]),s[t])),o[t]=(i[t]-r[t])/(s[t]-r[t]));const a=this.toMin,l=this.toMax,c=xE;for(let t=0;t<3;t++){const e=EE[t];this.mapToAxisFromAxis[t].indexOf("-")>-1?c[e]=a[e]+(1-o[EE[_E[this.mapToAxisFromAxis[t]]]])*(l[e]-a[e]):c[e]=a[e]+o[EE[_E[this.mapToAxisFromAxis[t]]]]*(l[e]-a[e])}if("POSITION"==this.mapTo)"ADD"==this.mixMode?c.add(t.position):this.mixMode,t.position.lerp(c,this.influence);else if("ROTATION"==this.mapTo){const e=AE;if("ADD"==this.mixMode){const n=IE.set(0,0,0,"XYZ");"Z_UP_RIGHT"==this.coordSystem?(SE(t.rotation,n),ME(n,this.coordSystem,"Y_UP_RIGHT"),n.x+=c.x,n.y+=c.y,n.z+=c.z,n.order="YZX"):n.set(t.rotation.x+c.x,t.rotation.y+c.y,t.rotation.z+c.z),e.setFromEuler(n)}else{const n=IE.setFromVector3(c);"Z_UP_RIGHT"==this.coordSystem&&(n.order="YZX"),e.setFromEuler(n),"AFTER"==this.mixMode?e.premultiply(t.quaternion):"BEFORE"==this.mixMode?e.multiply(t.quaternion):this.mixMode}t.quaternion.slerp(e,this.influence)}else"SCALE"==this.mapTo&&("REPLACE"==this.mixMode||"MULTIPLY"==this.mixMode&&c.multiply(t.scale),t.scale.lerp(c,this.influence));if(0==this.ownerSpace&&t.parent)t.matrixWorld.compose(t.position,t.quaternion,t.scale),t.matrix.multiplyMatrices(pE.copy(t.parent.matrixWorld).invert(),t.matrixWorld),t.matrix.decompose(t.position,t.quaternion,t.scale);else if(1==this.ownerSpace){if(!this.ownerSpaceObj)return;t.matrixWorld.compose(t.position,t.quaternion,t.scale),t.matrixWorld.premultiply(pE.copy(this.ownerSpaceObj.matrixWorld)),t.matrix.copy(t.matrixWorld),t.parent&&t.matrix.premultiply(pE.copy(t.parent.matrixWorld).invert()),t.matrix.decompose(t.position,t.quaternion,t.scale)}"ROTATION"==this.mapTo&&this.fixCameraLightRotation&&(t.isCamera||t.isLight)&&t.quaternion.multiply(fE)}}const yE=["IMAGE_AR","SKYDOME_LIGHT_AR","TEXTURE_BL","TEX_IMAGE_BL","TEX_ENVIRONMENT_BL","BITMAP_MX","BITMAP_ENV_MX","REFLECT_REFRACT_MX","FILE_MY","OSL_NODE"];class RE extends Vh{constructor(t){super(t),this.ktx2Loader=null,this.pluginCallbacks=[],this.register(function(t){return new NE(t)}),this.register(function(t){return new DE(t)}),this.register(function(t){return new VE(t)}),this.register(function(t){return new GE(t)}),this.register(function(t){return new QE(t)}),this.register(function(t){return new zE(t)}),this.register(function(t){return new kE(t)}),this.register(function(t){return new HE(t)}),this.register(function(t){return new WE(t)}),this.register(function(t){return new YE(t)}),this.register(function(t){return new XE(t)}),this.onProgress=null}load(t,e,n,o){const i=this;let r;i.onProgress=n||function(){},r=""!==this.resourcePath?this.resourcePath:""!==this.path?this.path:Xh.extractUrlBase(t);const s=-1!=t.indexOf(".xz",t.length-3);let a;s?a=new Sp(i.manager):(a=new zh(i.manager),a.setResponseType("arraybuffer"));const l=function(t){i.onProgress&&i.onProgress(.3*t*100)};let c=l;a instanceof zh&&(c=function(t){const e=t.lengthComputable?t.loaded/t.total:1;l(e)}),a.load(t,function(t){try{i.parse(t,r,e,o,s)}catch(t){void 0!==o&&o(t.constructor===Error?t:new Error("v3d.GLTFLoader: Unable to parse model."))}},c,o)}setKTX2Loader(t){return this.ktx2Loader=t,this}setMeshoptDecoder(){return console.error("v3d.GLTFLoader: Mesh optimization is not supported, please use LZMA compression."),this}setDRACOLoader(){return console.error("v3d.GLTFLoader: Draco compression is not supported, please use LZMA compression."),this}register(t){return-1===this.pluginCallbacks.indexOf(t)&&this.pluginCallbacks.push(t),this}unregister(t){return-1!==this.pluginCallbacks.indexOf(t)&&this.pluginCallbacks.splice(this.pluginCallbacks.indexOf(t),1),this}parse(t,e,n,o,i){let r;const s={},a={};if("string"==typeof t)r=t;else{if(Xh.decodeText(new Uint8Array(t,0,4))===PE){try{s[BE.KHR_BINARY_GLTF]=new UE(t)}catch(t){return void(o&&o(t))}r=s[BE.KHR_BINARY_GLTF].content}else r=Xh.decodeText(new Uint8Array(t))}const l=JSON.parse(r);if(void 0===l.asset||l.asset.version[0]<2)return void(o&&o(new Error("v3d.GLTFLoader: Unsupported asset. glTF versions >=2.0 are supported.")));const c=this,u=new CC(l,{path:e||this.resourcePath||"",crossOrigin:this.crossOrigin,requestHeader:this.requestHeader,manager:this.manager,ktx2Loader:this.ktx2Loader,loadBinXZ:i,onProgress:function(t){c.onProgress&&c.onProgress(t)}});for(let t=0;t<this.pluginCallbacks.length;t++){const e=this.pluginCallbacks[t](u);a[e.name]=e,s[e.name]=!0}if(l.extensionsUsed)for(let t=0;t<l.extensionsUsed.length;++t){const e=l.extensionsUsed[t],n=l.extensionsRequired||[];if(e===BE.KHR_MATERIALS_UNLIT)s[e]=new LE;else n.indexOf(e)>=0&&void 0===a[e]&&console.warn('v3d.GLTFLoader: Unknown extension "'+e+'".')}u.setExtensions(s),u.setPlugins(a),u.parse(function(t){c.onProgress&&c.onProgress(100),n(t)},o)}parseAsync(t,e){const n=this;return new Promise(function(o,i){n.parse(t,e,o,i)})}}function TE(){let t={};return{get:function(e){return t[e]},add:function(e,n){t[e]=n},remove:function(e){delete t[e]},removeAll:function(){t={}}}}const BE={KHR_BINARY_GLTF:"KHR_binary_glTF",KHR_MATERIALS_UNLIT:"KHR_materials_unlit",KHR_TEXTURE_BASISU:"KHR_texture_basisu",EXT_TEXTURE_WEBP:"EXT_texture_webp",S8S_V3D_ANIMATION:"S8S_v3d_animation",S8S_V3D_CAMERA:"S8S_v3d_camera",S8S_V3D_MATERIALS:"S8S_v3d_materials",S8S_V3D_MESH:"S8S_v3d_mesh",S8S_V3D_NODE:"S8S_v3d_node",S8S_V3D_SCENE:"S8S_v3d_scene",S8S_V3D_TEXTURE:"S8S_v3d_texture",S8S_V3D_LIGHTS:"S8S_v3d_lights",S8S_V3D_LIGHT_PROBES:"S8S_v3d_light_probes",S8S_V3D_CURVES:"S8S_v3d_curves",S8S_V3D_CLIPPING_PLANES:"S8S_v3d_clipping_planes"};class LE{constructor(){this.name=BE.KHR_MATERIALS_UNLIT}getMaterialType(){return No}extendParams(t,e,n){const o=[];t.color=new tn(1,1,1),t.opacity=1;const i=e.pbrMetallicRoughness;if(i){if(Array.isArray(i.baseColorFactor)){const e=i.baseColorFactor;t.color.fromArray(e),t.opacity=e[3]}void 0!==i.baseColorTexture&&o.push(n.assignTexture(t,"map",i.baseColorTexture,Ft))}return Promise.all(o)}}class NE{constructor(t){this.parser=t,this.name=BE.KHR_TEXTURE_BASISU}loadTexture(t){const e=this.parser,n=e.json,o=n.textures[t];if(!o.extensions||!o.extensions[this.name])return null;const i=o.extensions[this.name],r=e.options.ktx2Loader;if(!r){if(n.extensionsRequired&&n.extensionsRequired.indexOf(this.name)>=0)throw new Error("v3d.GLTFLoader: setKTX2Loader must be called before loading KTX2 textures");return null}return e.loadTextureImage(t,i.source,r)}}class DE{constructor(t){this.parser=t,this.name=BE.EXT_TEXTURE_WEBP,this.isSupported=null}loadTexture(t){const e=this.name,n=this.parser,o=n.json,i=o.textures[t];if(!i.extensions||!i.extensions[e])return null;const r=i.extensions[e],s=o.images[r.source];let a=n.textureLoader;if(s.uri){const t=n.options.manager.getHandler(s.uri);null!==t&&(a=t)}return this.detectSupport().then(function(i){if(i)return n.loadTextureImage(t,r.source,a);if(o.extensionsRequired&&o.extensionsRequired.indexOf(e)>=0)throw new Error("v3d.GLTFLoader: WebP required by asset but unsupported.");return n.loadTexture(t)})}detectSupport(){return this.isSupported||(this.isSupported=new Promise(function(t){const e=new Image;e.src="data:image/webp;base64,UklGRiIAAABXRUJQVlA4IBYAAAAwAQCdASoBAAEADsD+JaQAA3AAAAAA",e.onload=e.onerror=function(){t(1===e.height)}})),this.isSupported}}const PE="glTF",OE=1313821514,FE=5130562;class UE{constructor(t){this.name=BE.KHR_BINARY_GLTF,this.content=null,this.body=null;const e=new DataView(t,0,12);if(this.header={magic:Xh.decodeText(new Uint8Array(t.slice(0,4))),version:e.getUint32(4,!0),length:e.getUint32(8,!0)},this.header.magic!==PE)throw new Error("v3d.GLTFLoader: Unsupported glTF-Binary header.");if(this.header.version<2)throw new Error("v3d.GLTFLoader: Legacy binary file detected.");const n=this.header.length-12,o=new DataView(t,12);let i=0;for(;i<n;){const e=o.getUint32(i,!0);i+=4;const n=o.getUint32(i,!0);if(i+=4,n===OE){const n=new Uint8Array(t,12+i,e);this.content=Xh.decodeText(n)}else if(n===FE){const n=12+i;this.body=t.slice(n,n+e)}i+=e}if(null===this.content)throw new Error("v3d.GLTFLoader: JSON content not found.")}}class VE{constructor(t){this.parser=t,this.name=BE.S8S_V3D_LIGHTS,this.cache={refs:{},uses:{}}}ji(){const t=this.parser,e=this.parser.json.nodes||[];for(let n=0,o=e.length;n<o;n++){const o=e[n];o.extensions&&o.extensions[this.name]&&void 0!==o.extensions[this.name].light&&t.Zi(this.cache,o.extensions[this.name].light)}}qi(t){var e;const n=this.parser,o="light:"+t;let i=n.cache.get(o);if(i)return i;const r=n.json,s=((r.extensions&&r.extensions[this.name]||{}).lights||[])[t];let a;const l=(new tn).fromArray(s.color),c=null!=(e=s.intensity)?e:1;switch(s.type){case"point":a=new of(l,c);break;case"directional":a=new Ef(l,c);break;case"spot":a=new Jh(l,c);break;case"area":a=new sf(l,c,s.width,s.height);break;case"ambient":a=new Cf(l,c);break;default:console.error("v3d.GLTFLoader: Invalid light type",s.type)}let u;return ye(s.distance)&&(a.distance=s.distance),ye(s.decay)&&(a.decay=s.decay,"blender"!=s.profile||ye(s.power)||(a.userData.usePowerUnits=!0,a.power=c)),ye(s.power)&&(a.userData.usePowerUnits=!0,a.power=s.power),ye(s.angle)&&(a.angle=s.angle),ye(s.penumbra)&&(a.penumbra=s.penumbra),a.isRectAreaLight&&Fp.init(s.ltcMat1,s.ltcMat2),ye(s.shadow)?(a.castShadow=s.shadow.enabled,a.shadow.bias=s.shadow.bias,a.shadow.expBias=s.shadow.expBias,a.shadow.slopeScaledBias=s.shadow.slopeScaledBias,a.shadow.radius=s.shadow.radius,a.shadow.mapSize.width=s.shadow.mapSize,a.shadow.mapSize.height=s.shadow.mapSize,a.shadow.camera.near=s.shadow.cameraNear,a.shadow.camera.far=s.shadow.cameraFar,a.isSpotLight?(a.shadow.camera.fov=ce(s.shadow.cameraFov),a.shadow.useMinFov90="blender"===s.profile):a.isDirectionalLight&&(ye(s.shadow.cameraOrthoLeft)&&ye(s.shadow.cameraOrthoRight)&&ye(s.shadow.cameraOrthoBottom)&&ye(s.shadow.cameraOrthoTop)&&(a.shadow.camera.left=s.shadow.cameraOrthoLeft,a.shadow.camera.right=s.shadow.cameraOrthoRight,a.shadow.camera.bottom=s.shadow.cameraOrthoBottom,a.shadow.camera.top=s.shadow.cameraOrthoTop),a.shadow.maxDistance=s.shadow.cameraFar,ye(s.shadow.csm)&&(ye(s.shadow.csm.count)&&(a.shadow.numCascades=s.shadow.csm.count),ye(s.shadow.csm.maxDistance)&&(a.shadow.maxDistance=s.shadow.csm.maxDistance),ye(s.shadow.csm.fade)&&(a.shadow.fade=s.shadow.csm.fade),ye(s.shadow.csm.exponent)&&(a.shadow.exponent=s.shadow.csm.exponent),ye(s.shadow.csm.lightMargin)&&(a.shadow.lightMargin=s.shadow.csm.lightMargin)),a.shadow.createCascades()),a.shadow.camera.updateProjectionMatrix()):a.castShadow=!1,a.name=s.name?n.createUniqueName(s.name):"",(a.isDirectionalLight||a.isSpotLight)&&ye(s.target)?(a.isFreeLight=!1,u=n.getDependency("node",s.target)):a.isDirectionalLight||a.isSpotLight?(a.isFreeLight=!0,u=Promise.resolve()):u=Promise.resolve(),u.then(t=>(t&&(a.target=t),i=Promise.resolve(a),n.cache.add(o,i),i))}createNodeAttachment(t){const e=this,n=this.parser,o=n.json.nodes[t],i=(o.extensions&&o.extensions[this.name]||{}).light;return void 0===i?null:this.qi(i).then(function(t){return n.Ji(e.cache,i,t)})}}class GE{constructor(t){this.parser=t,this.name=BE.S8S_V3D_LIGHT_PROBES,this.cache={refs:{},uses:{}}}ji(){const t=this.parser,e=this.parser.json.nodes||[];for(let n=0,o=e.length;n<o;n++){const o=e[n];o.extensions&&o.extensions[this.name]&&void 0!==o.extensions[this.name].lightProbe&&t.Zi(this.cache,o.extensions[this.name].lightProbe)}}$i(t){const e=this.parser,n="lightProbe:"+t;let o=e.cache.get(n);if(o)return o;const i=e.json,r=((i.extensions&&i.extensions[this.name]||{}).lightProbes||[])[t];let s;const a=r.type;if("SPHERE"==a||"CUBEMAP"==a){switch(s=new Ep,r.influenceType){case"ELIPSOID":s.influenceType=1;break;case"BOX":s.influenceType=2}switch(r.parallaxType){case"ELIPSOID":s.parallaxType=1;break;case"BOX":s.parallaxType=2}s.parallaxDistance=r.parallaxDistance,s.probeClipEnd=r.clipEnd,s.probeIntensity=r.intensity,s.influenceGroup=r.influenceGroup,s.influenceGroupInv=r.influenceGroupInv}else s=new Op,s.falloff=r.falloff,ye(r.planeSize)&&s.planeSize.set(r.planeSize[0],r.planeSize[1]);return s.influenceDistance=r.influenceDistance,s.probeClipStart=r.clipStart,s.visibilityGroup=r.visibilityGroup,s.visibilityGroupInv=r.visibilityGroupInv,s.name=e.createUniqueName(r.name||"lightProbe_"+t),o=Promise.resolve(s),e.cache.add(n,o),o}createNodeAttachment(t){const e=this,n=this.parser,o=n.json.nodes[t],i=(o.extensions&&o.extensions[this.name]||{}).lightProbe;return void 0===i?null:this.$i(i).then(function(t){return n.Ji(e.cache,i,t)})}}class QE{constructor(t){this.parser=t,this.name=BE.S8S_V3D_CURVES,this.cache={refs:{},uses:{}}}ji(){const t=this.parser,e=this.parser.json.nodes||[];for(let n=0,o=e.length;n<o;n++){const o=e[n];o.extensions&&o.extensions[this.name]&&void 0!==o.extensions[this.name].curve&&t.Zi(this.cache,o.extensions[this.name].curve)}}tr(){return new Promise(function(t){Ge("opentype.js",function(){t()},function(){console.error("GLTFLoader: opentype.js module not found, please copy it to your app directory"),t()})})}er(t){const e=this.parser,n="font:"+t;let o=e.cache.get(n);if(o)return o;const i=e.json,r=((i.extensions&&i.extensions[this.name]||{}).fonts||[])[t];let s=r.uri,a=!1;return void 0!==r.bufferView&&(s=e.getDependency("bufferView",r.bufferView).then(function(t){a=!0;const e=new Blob([t],{type:r.mimeType});return s=URL.createObjectURL(e),s})),Promise.all([this.tr(),s]).then(function(t){if(s=t[1],"undefined"==typeof opentype)return null;const n=new bp;return n.setCrossOrigin(e.options.crossOrigin),new Promise(function(t,o){n.load(Xh.resolveURL(s,e.options.path),t,void 0,o)}).then(function(t){return new Up(t)},function(t){return null})}).then(function(t){return!0===a&&URL.revokeObjectURL(s),o=Promise.resolve(t),e.cache.add(n,o),o})}nr(t){const e=this.parser,n="curve:"+t;let o=e.cache.get(n);if(o)return o;const i=e.json,r=((i.extensions&&i.extensions[this.name]||{}).curves||[])[t];let s,a=r.type;const l=[];return l.push(this.er(r.font)),void 0!==r.material?l.push(e.getDependency("material",r.material)):l.push(vC(e.cache)),Promise.all(l).then(function(i){const l=i[0],c=i[1];if(null===l&&(a="empty"),"font"===a){const t=r.bevelSize>0||r.bevelThickness>0,e=new zc(r.text,{font:l,size:r.size,height:r.height,curveSegments:r.curveSegments,bevelEnabled:t,bevelThickness:r.bevelThickness,bevelSize:r.bevelSize,bevelSegments:r.bevelSegments,alignX:r.alignX,alignY:r.alignY,lineHeight:r.lineHeight,scaledEmSize:r.scaledEmSize});s=new hi(e,c)}else s=new mo;return s.name=e.createUniqueName(r.name||"curve_"+t),o=Promise.resolve(s),e.cache.add(n,o),o})}createNodeAttachment(t){const e=this,n=this.parser,o=n.json.nodes[t],i=(o.extensions&&o.extensions[this.name]||{}).curve;return void 0===i?null:this.nr(i).then(function(t){return n.Ji(e.cache,i,t)})}}class zE{constructor(t){this.parser=t,this.name=BE.S8S_V3D_CLIPPING_PLANES,this.cache={refs:{},uses:{}}}ji(){const t=this.parser,e=this.parser.json.nodes||[];for(let n=0,o=e.length;n<o;n++){const o=e[n];o.extensions&&o.extensions[this.name]&&void 0!==o.extensions[this.name].clippingPlane&&t.Zi(this.cache,o.extensions[this.name].clippingPlane)}}ir(t){const e=this.parser,n="clippingPlane:"+t;let o=e.cache.get(n);if(o)return o;const i=e.json,r=((i.extensions&&i.extensions[this.name]||{}).clippingPlanes||[])[t],s=new kp;return s.clippingGroup=r.clippingGroup,s.clipShadows=r.clipShadows,s.negated=r.negated,s.clipIntersection=r.clipIntersection,s.crossSection=r.crossSection,s.crossSectionColor=(new tn).fromArray(r.color),s.crossSectionOpacity=r.opacity,s.crossSectionSize=r.size,s.crossSectionRenderSide=AC[r.renderSide],s.name=e.createUniqueName(r.name||"clippingPlane_"+t),o=Promise.resolve(s),e.cache.add(n,o),o}createNodeAttachment(t){const e=this,n=this.parser,o=n.json.nodes[t],i=(o.extensions&&o.extensions[this.name]||{}).clippingPlane;return void 0===i?null:this.ir(i).then(function(t){return n.Ji(e.cache,i,t)})}}class kE{constructor(t){this.name=BE.S8S_V3D_SCENE,this.parser=t}getAssetSuite(t){const e=["Blender","3ds Max","Maya"];for(let n=0;n<e.length;n++){const o=e[n];if(t.includes(o))return o.replace("3ds ","").toUpperCase()}return""}beforeRoot(){let t=this.parser.json.asset.generator||"";if(t.indexOf("Verge3D")>-1){const e=this.getAssetSuite(t);o!==e&&console.warn("The glTF asset was exported from "+function(t){switch(t){case"BLENDER":return"Blender";case"MAX":return"3ds Max";case"MAYA":return"Maya";default:return""}}(e)+". It may not be fully compatible with Verge3D "+Le()+"."),t.match(/(\d+).(\d+).(\d+)/)||(t+=" v0.0.0"),Pe(t,n,2)<0&&console.warn("Loading glTF with outdated version of Verge3D runtime. Please update your application!"),Pe(t,i[e],3)>0&&console.warn("Loading glTF exported with older version of Verge3D. Please reexport your scene!")}}afterRoot(t){const e=this.parser,n=e.json,o=n.scenes[n.scene||0],i=t.scene,r=ye(o.extensions)?o.extensions[BE.S8S_V3D_SCENE]:void 0,s=[],a=[],l=[];let c;return c=o&&r&&ye(r.worldMaterial)?e.getDependency("material",r.worldMaterial):Promise.resolve(),c.then(e=>{const n={};e&&(n.material=e),t.world=n}).then(()=>(e.assignedMaterials.forEach(function(t){t.isMeshNodeMaterial&&t.traverseNodes(function(n){"TEX_COORD_BL"===n.originData.type&&ye(n.originData.object)&&n.originData.object>-1&&(s.push(e.getDependency("node",n.originData.object)),a.push(n),l.push(t))})}),Promise.all(s))).then(e=>{for(let t=0;t<e.length;t++){const n=e[t],o=a[t],i=l[t],r=i.nodeTexCoordObjectMap[o.originData.name];i.nodeTexCoordObject[r]=n}const n=[];for(let e=0;e<t.cameras.length;e++){const o=t.cameras[e];let r=!1;o.traverseAncestors(function(t){t==i&&(r=!0)}),r&&n.push(o)}t.cameras=n;const r={};if(o){const t=ye(o.extensions)?o.extensions[BE.S8S_V3D_SCENE]:void 0;if(t){if(ye(t.shadowMap)){switch(r.shadowMap={enabled:!0},t.shadowMap.type){case"BASIC":r.shadowMap.type=0;break;case"BILINEAR":r.shadowMap.type=1;break;case"PCFSOFT":console.warn("v3d.GLTFLoader: PCF Bilinear shadows deprecated since Verge3D 4.7, using PCF (with poisson disk sampling) instead"),r.shadowMap.type=2;break;case"PCF":case"PCFPOISSON":r.shadowMap.type=2;break;case"ESM":r.shadowMap.type=3}let e;e=t.shadowMap.renderSingleSided?t.shadowMap.renderReverseSided?1:0:2,i.traverse(function(t){const n=t.material;n&&(n.shadowSide=e)}),r.esmDistanceScale=t.shadowMap.esmDistanceScale}if(ye(t.aaMethod)&&(r.aaMethod=t.aaMethod),ye(t.useHDR)&&(r.useHDR=t.useHDR),ye(t.useOIT)&&(r.useOIT=t.useOIT),ye(t.unitsScaleFactor)&&(r.unitsScaleFactor=t.unitsScaleFactor),ye(t.toneMapping)){switch(t.toneMapping.type){case"logarithmicMax":r.toneMapping=6,r.toneMappingBrightness=t.toneMapping.brightness,r.toneMappingContrast=t.toneMapping.contrast,r.toneMappingMidTones=t.toneMapping.midTones,r.toneMappingPhysicalScale=t.toneMapping.physicalScale,r.toneMappingChromaticAdaptation=t.toneMapping.chromaticAdaptation,r.toneMappingWhiteColor=(new tn).fromArray(t.toneMapping.whiteColor),r.toneMappingColorDifferentiation=t.toneMapping.colorDifferentiation,r.toneMappingExteriorDaylight=t.toneMapping.exteriorDaylight;break;case"physicalMax":r.toneMapping=7,r.toneMappingWhiteBalance=(new tn).fromArray(t.toneMapping.whiteBalance),r.toneMappingHighlights=t.toneMapping.highlights,r.toneMappingMidTones=t.toneMapping.midTones,r.toneMappingShadows=t.toneMapping.shadows,r.toneMappingSaturation=t.toneMapping.saturation,r.toneMappingPhysicalScale=t.toneMapping.physicalScale,r.toneMappingAperture=t.toneMapping.aperture,r.toneMappingShutter=t.toneMapping.shutter,r.toneMappingISO=t.toneMapping.iso,r.toneMappingVignetting=t.toneMapping.vignetting;break;case"filmicBlender":r.toneMapping=8;break;case"agxBlender":r.toneMapping=9;break;case"pbrNeutral":r.toneMapping=10;break;case"linear":r.toneMapping=1}switch(t.toneMapping.look){case"NONE":r.toneMappingLook=0;break;case"AGX_PUNCHY":r.toneMappingLook=1;break;default:"agxBlender"===t.toneMapping.type&&console.warn(`v3d.GLTFLoader: ${t.toneMapping.look} look is not supported, fallback to None`),r.toneMappingLook=0}ye(t.toneMapping.exposure)&&(r.toneMappingExposure=t.toneMapping.exposure)}if(ye(t.pmremMaxTileSize)&&(r.pmremMaxTileSize=t.pmremMaxTileSize),ye(t.iblEnvironmentMode))switch(t.iblEnvironmentMode){case"PMREM":default:r.iblEnvironmentMode=0;break;case"PROBE_CUBEMAP":console.warn("v3d.GLTFLoader: Cubemap probes deprecated since Verge3D 4.3, using PMREM instead"),r.iblEnvironmentMode=0;break;case"PROBE":r.iblEnvironmentMode=1;break;case"NONE":r.iblEnvironmentMode=2}ye(t.postprocessing)&&(i.postprocessing=t.postprocessing)}}t.renderer=r})}}class HE{constructor(t){this.name=BE.S8S_V3D_NODE,this.parser=t}extendNodeParams(t,e){const n=e.extensions&&e.extensions[this.name];if(!n)return t;if(n.hidden&&(t.visible=!1),t.isMesh&&(ye(n.useCastShadows)?t.castShadow=n.useCastShadows:ye(t.material.castShadow)&&(t.castShadow=t.material.castShadow),ye(n.useShadows)?t.receiveShadow=n.useShadows:ye(t.material.receiveShadow)&&(t.receiveShadow=t.material.receiveShadow)),ye(n.objectIndex)&&(t.objectIndex=n.objectIndex),ye(n.objectColor)&&(t.objectColor=(new tn).fromArray(n.objectColor),t.objectAlpha=n.objectColor[3]),t.renderOrder=n.renderOrder,t.frustumCulled=n.frustumCulling,ye(n.groupNames)&&(t.groupNames=n.groupNames),ye(n.hidpiCompositing)&&(t.hidpiCompositing=n.hidpiCompositing),t.isMesh&&t.material.isMeshNodeMaterial){const e=t.material;(e.hasNode("MATTE_SHADOW_MX")||e.hasNode("SHADOW_MATTE_AR"))&&(e.transparent=!1,e.premultipliedAlpha=!0,bC(e),t.renderOrder-=1e3,t.castShadow=!1,t.receiveShadow=!0)}return this.processConstraints(t,n.constraints)}processConstraints(t,e=[]){if(t.isMaterialGeneratedMesh)return t;const n=this.parser,o=[];for(let t=0;t<e.length;t++){const i=e[t];ye(i.target)?o.push(n.getDependency("node",i.target)):o.push(Promise.resolve(null))}return Promise.all(o).then(function(o){for(let i=0;i<e.length;i++){const r=e[i],s=o[i];let a;switch(r.type){case"copyLocation":a=new Jp(s),a.useX=!ye(r.useX)||r.useX,a.useY=!ye(r.useY)||r.useY,a.useZ=!ye(r.useZ)||r.useZ,a.invertX=!!ye(r.invertX)&&r.invertX,a.invertY=!!ye(r.invertY)&&r.invertY,a.invertZ=!!ye(r.invertZ)&&r.invertZ,a.useOffset=!ye(r.useOffset)||r.useOffset,a.influence=ye(r.influence)?r.influence:1;break;case"copyRotation":a=new og(s),a.useX=!ye(r.useX)||r.useX,a.useY=!ye(r.useY)||r.useY,a.useZ=!ye(r.useZ)||r.useZ,a.invertX=!!ye(r.invertX)&&r.invertX,a.invertY=!!ye(r.invertY)&&r.invertY,a.invertZ=!!ye(r.invertZ)&&r.invertZ,a.mixMode=ye(r.mixMode)?r.mixMode:"REPLACE",a.influence=ye(r.influence)?r.influence:1,a.fixCameraLightRotation=!!ye(r.fixCameraLightRotation)&&r.fixCameraLightRotation;break;case"copyScale":a=new ag(s),a.useX=!ye(r.useX)||r.useX,a.useY=!ye(r.useY)||r.useY,a.useZ=!ye(r.useZ)||r.useZ,a.power=ye(r.power)?r.power:1,a.useMakeUniform=!!ye(r.useMakeUniform)&&r.useMakeUniform,a.useOffset=!!ye(r.useOffset)&&r.useOffset,a.useAdd=!!ye(r.useAdd)&&r.useAdd,a.influence=ye(r.influence)?r.influence:1;break;case"copyTransforms":a=new dg(s),a.mixMode=ye(r.mixMode)?r.mixMode:"REPLACE",a.influence=ye(r.influence)?r.influence:1,a.fixCameraLightRotation=!!ye(r.fixCameraLightRotation)&&r.fixCameraLightRotation;break;case"dampedTrack":a=new Ig(s),a.trackAxis=r.trackAxis,a.influence=ye(r.influence)?r.influence:1,a.fixCameraLightRotation=!!ye(r.fixCameraLightRotation)&&r.fixCameraLightRotation;break;case"limitDistance":a=new Pg(s),a.distance=ye(r.distance)?r.distance:0,a.limitMode=ye(r.limitMode)?r.limitMode:"LIMITDIST_INSIDE",a.useTransformLimit=!!ye(r.useTransformLimit)&&r.useTransformLimit,a.influence=ye(r.influence)?r.influence:1;break;case"limitLocation":switch(a=new Gg(s),r.space){case"CUSTOM":a.space=1;break;case"WORLD":a.space=0;break;default:a.space=2}a.min.set(Number(r.minX),Number(r.minY),Number(r.minZ)),a.max.set(Number(r.maxX),Number(r.maxY),Number(r.maxZ));break;case"limitRotation":a=new zg,a.axis=r.axis,a.min=r.min,a.max=r.max;break;case"limitScale":a=new kg,a.min.set(Number(r.minX),Number(r.minY),Number(r.minZ)),a.max.set(Number(r.maxX),Number(r.maxY),Number(r.maxZ));break;case"lockedTrack":a=new t_(s),a.trackAxis=r.trackAxis,a.lockAxis=r.lockAxis,a.fixCameraLightRotation=!!ye(r.fixCameraLightRotation)&&r.fixCameraLightRotation;break;case"trackTo":a=new f_(s),a.trackAxis=r.trackAxis,a.upAxis=r.upAxis,a.fixCameraLightRotation=!!ye(r.fixCameraLightRotation)&&r.fixCameraLightRotation;break;case"childOf":a=new Kp(s),a.offsetMatrix=(new Hn).fromArray(r.offsetMatrix),a.fixCameraLightRotation=!!ye(r.fixCameraLightRotation)&&r.fixCameraLightRotation;break;case"floor":a=new Tg(s),a.floorLocation=r.floorLocation,a.offset=r.offset,a.useRotation=!!ye(r.useRotation)&&r.useRotation;break;case"fixOrthoZoom":a=new d_(s);break;case"canvasFit":a=new __(s),a.edgeH=r.edgeH,a.edgeV=r.edgeV,a.fitShape=r.fitShape,a.offset=r.offset,"SPHERE"==r.fitShape&&t.resolveMultiMaterial().forEach(function(t){t.geometry&&t.geometry.computeBoundingSphere()});break;case"canvasBreakpoints":a=new E_,a.minWidth=Number(r.minWidth),a.maxWidth=Number(r.maxWidth),a.minHeight=Number(r.minHeight),a.maxHeight=Number(r.maxHeight),a.orientation=r.orientation;break;case"motionPath":a=new hE,a.degree=r.degree,a.cvs=[];for(let t=0;t<r.cvs.length;++t)a.cvs.push(Number(r.cvs[t]));a.knots=[];for(let t=0;t<r.knots.length;++t)a.knots.push(Number(r.knots[t]));a.weights=[];for(let t=0;t<r.weights.length;++t)a.weights.push(Number(r.weights[t]));if(a.value=ye(r.value)?r.value:0,a.follow=!!ye(r.follow)&&r.follow,a.frontAxis=ye(r.frontAxis)?r.frontAxis:"Z",a.upAxis=ye(r.upAxis)?r.upAxis:"Y",a.worldUpVector=ye(r.worldUpVector)?(new An).fromArray(r.worldUpVector).normalize():new An(0,1,0),a.useChordLength=!!ye(r.useChordLength)&&r.useChordLength,a.bank=!!ye(r.bank)&&r.bank,a.bankScale=ye(r.bankScale)?r.bankScale:1,a.bankLimit=ye(r.bankLimit)?r.bankLimit:1/0,a.useFixedLocation=!!ye(r.useFixedLocation)&&r.useFixedLocation,a.fixedValue=ye(r.fixedValue)?r.fixedValue:0,a.usePointsTilt=!!ye(r.usePointsTilt)&&r.usePointsTilt,a.pointsTilt=[],ye(r.pointsTilt))for(let t=0;t<r.pointsTilt.length;++t)a.pointsTilt.push(Number(r.pointsTilt[t]));a.offsetValue=ye(r.offsetValue)?r.offsetValue:0,a.useClampValue=!!ye(r.useClampValue)&&r.useClampValue,a.useCyclic=!!ye(r.useCyclic)&&r.useCyclic,a.useObjOffset=!!ye(r.useObjOffset)&&r.useObjOffset,a.useRelative=!!ye(r.useRelative)&&r.useRelative,a.usePosOffset=!ye(r.usePosOffset)||r.usePosOffset,a.objOffsetMode=ye(r.objOffsetMode)?r.objOffsetMode:0,a.objOffsetRotMode=ye(r.objOffsetRotMode)?r.objOffsetRotMode:0,a.influence=ye(r.influence)?r.influence:1,a.fixCameraLightRotation=!!ye(r.fixCameraLightRotation)&&r.fixCameraLightRotation,a.init();break;case"transformation":switch(a=new bE(s),a.fromMin.set(Number(r.fromMin[0]),Number(r.fromMin[1]),Number(r.fromMin[2])),a.fromMax.set(Number(r.fromMax[0]),Number(r.fromMax[1]),Number(r.fromMax[2])),a.toMin.set(Number(r.toMin[0]),Number(r.toMin[1]),Number(r.toMin[2])),a.toMax.set(Number(r.toMax[0]),Number(r.toMax[1]),Number(r.toMax[2])),a.mapToAxisFromAxis=r.mapToAxisFromAxis,a.mapFrom=r.mapFrom,a.mapTo=r.mapTo,r.ownerSpace){case"CUSTOM":a.ownerSpace=1;break;case"LOCAL":a.ownerSpace=2;break;default:a.ownerSpace=0}switch(r.targetSpace){case"CUSTOM":a.targetSpace=1;break;case"LOCAL":a.targetSpace=2;break;default:a.targetSpace=0}ye(r.ownerSpaceObj)&&n.getDependency("node",r.ownerSpaceObj).then(t=>{a.ownerSpaceObj=t}),ye(r.targetSpaceObj)&&n.getDependency("node",r.targetSpaceObj).then(t=>{a.targetSpaceObj=t}),a.useMotionExtrapolate=r.useMotionExtrapolate,a.mixMode=r.mixMode,a.influence=r.influence,a.fixCameraLightRotation=!!ye(r.fixCameraLightRotation)&&r.fixCameraLightRotation}a&&(a.name=r.name,a.mute=r.mute,t.constraints.push(a))}return t})}}class WE{constructor(t){this.name=BE.S8S_V3D_CAMERA,this.parser=t}extendCameraParams(t,e){const n=this.parser,o=e.extensions&&e.extensions[this.name];if(!o)return Promise.resolve(t);if(t.controlSettings=new Dm(o.controls,o.enablePan,o.rotateSpeed,o.moveSpeed),t.viewportFit.type=3,ye(o.viewportFitType))switch(o.viewportFitType){case"VERTICAL":t.viewportFit.type=1;break;case"HORIZONTAL":t.viewportFit.type=2;break;case"AUTO":t.viewportFit.type=3;break;case"FILL":t.viewportFit.type=4;break;case"OVERSCAN":t.viewportFit.type=5}ye(o.viewportFitInitialAspect)&&(t.viewportFit.initialAspect=o.viewportFitInitialAspect),ye(o.orbitMinDistance)&&(t.controlSettings.orbitMinDistance=o.orbitMinDistance),ye(o.orbitMaxDistance)&&(t.controlSettings.orbitMaxDistance=o.orbitMaxDistance),ye(o.orbitMinZoom)&&(t.controlSettings.orbitMinZoom=o.orbitMinZoom),ye(o.orbitMaxZoom)&&(t.controlSettings.orbitMaxZoom=o.orbitMaxZoom),ye(o.orbitMinPolarAngle)&&(t.controlSettings.orbitMinPolarAngle=o.orbitMinPolarAngle),ye(o.orbitMaxPolarAngle)&&(t.controlSettings.orbitMaxPolarAngle=o.orbitMaxPolarAngle),ye(o.orbitMinAzimuthAngle)&&(t.controlSettings.orbitMinAzimuthAngle=o.orbitMinAzimuthAngle),ye(o.orbitMaxAzimuthAngle)&&(t.controlSettings.orbitMaxAzimuthAngle=o.orbitMaxAzimuthAngle);const i=[];if(ye(o.orbitTarget))if(o.orbitTarget instanceof Array){const t=new mo;t.position.fromArray(o.orbitTarget),i.push(Promise.resolve(t))}else i.push(n.getDependency("node",o.orbitTarget));else i.push(Promise.resolve());return ye(o.fpsCollisionMaterial)?i.push(n.getDependency("material",o.fpsCollisionMaterial)):i.push(Promise.resolve()),ye(o.fpsGazeLevel)&&(t.controlSettings.gazeLevel=o.fpsGazeLevel),ye(o.fpsStoryHeight)&&(t.controlSettings.storyHeight=o.fpsStoryHeight),ye(o.enablePointerLock)&&(t.controlSettings.enablePointerLock=o.enablePointerLock),Promise.all(i).then(e=>(e[0]&&(t.controlSettings.orbitTarget=e[0]),e[1]&&(t.controlSettings.collisionMaterial=e[1]),t))}}class YE{constructor(t){this.name=BE.S8S_V3D_MATERIALS,this.parser=t}getMaterialType(t){const e=this.parser.json.materials[t];return e.extensions&&e.extensions[this.name]?Ph:null}extendMaterialParams(t,e){const n=this.parser.json,o=n.materials[t];if(!o.extensions||!o.extensions[this.name])return Promise.resolve();const i=o.extensions[this.name],r=[];if(ye(i.nodeGraph)){const t=Ph.nodeGraphFromExtGraph(i.nodeGraph);e.nodeGraph=t,Ph.nodeGraphTraverse(t,t=>{const e=t.originData;yE.indexOf(e.type)>-1&&ye(e.texture)?r.push(this.assignTextureNode(e)):"RAMP_MY"==e.type&&(e.wrapS=sC[e.wrapS]||b,e.wrapT=sC[e.wrapT]||b)});const o=n.extensions&&n.extensions[this.name]||{};if(o&&o.nodeGraphs){e.additionalNodeGraphs={};for(let t in o.nodeGraphs){const n=Ph.nodeGraphFromExtGraph(o.nodeGraphs[t]);e.additionalNodeGraphs[t]=n,Ph.nodeGraphTraverse(n,t=>{const e=t.originData;yE.indexOf(e.type)>-1&&r.push(this.assignTextureNode(e))})}}}return ye(i.profile)&&(e.profile=i.profile),ye(i.renderSide)&&(e.side=AC[i.renderSide]),ye(i.useShadows)&&(e.receiveShadow=i.useShadows),ye(i.useCastShadows)&&(e.castShadow=i.useCastShadows),ye(i.depthWrite)&&(e.depthWrite=i.depthWrite),ye(i.depthPrepass)&&(e.depthPrepass=i.depthPrepass),ye(i.depthTest)&&(e.depthTest=i.depthTest),ye(i.dithering)&&(e.dithering=i.dithering),ye(i.materialIndex)&&(e.materialIndex=i.materialIndex),!0===i.alphaToCoverage&&(e.alphaToCoverage=!0),ye(i.gtaoVisible)&&(e.gtaoVisible=i.gtaoVisible),delete e.metalness,delete e.roughness,Promise.all(r)}assignTextureNode(t){return this.parser.getDependency("texture",t.texture).then(function(e){t.texture=e})}assignTransparency(t,e,n){const o=e.extensions[this.name]||{};if(t.premultipliedAlpha=n==dC.BLEND,n==dC.BLEND)if(ye(o.blendMode)){const e=o.blendMode;t.blending=5,ye(e.blendEquation)&&(t.blendEquation=aC[e.blendEquation]),ye(e.blendEquationAlpha)&&(t.blendEquationAlpha=aC[e.blendEquationAlpha]),ye(e.srcRGB)&&(t.blendSrc=lC[e.srcRGB]),ye(e.dstRGB)&&(t.blendDst=lC[e.dstRGB]),ye(e.srcAlpha)&&(t.blendSrcAlpha=lC[e.srcAlpha]),ye(e.dstAlpha)&&(t.blendDstAlpha=lC[e.dstAlpha])}else t.useAddTransparency()?t.blending=2:bC(t)}}class XE{constructor(t){this.parser=t,this.name=BE.S8S_V3D_TEXTURE,this.textureLoaderRGBE=new yp,this.textureLoaderRGBE.setCrossOrigin(this.parser.options.crossOrigin),this.textureLoaderRGBE.setRequestHeader(this.parser.options.requestHeader)}loadTexture(t){const e=this.name,n=this.parser,o=n.json,i=o.textures[t];if(!i.extensions||!i.extensions[e])return null;const r=i.extensions[e];if(!ye(r.source))return null;const s=o.images[r.source];let a=n.textureLoader;if("hdr"==(s.uri||"").split(".").pop()||"image/vnd.radiance"==s.mimeType?a=this.textureLoaderRGBE:"xz"!=(s.uri||"").split(".").pop()&&"application/x-xz"!=s.mimeType||(a=new Sp),s.uri){const t=n.options.manager.getHandler(s.uri);null!==t&&(a=t)}return n.loadTextureImage(t,r.source,a)}extendTextureParams(t,e,n){const o=this.name;if(!e.extensions||!e.extensions[o])return null;const i=e.extensions[o],r=i.colorSpace.startsWith("linear")||"non-color"==i.colorSpace?Ot:Ft;t.encoding=r,(n instanceof yp||n instanceof Sp)&&(t.minFilter=N),ye(i.anisotropy)&&(t.anisotropy=i.anisotropy)}}class KE extends Zc{constructor(t,e,n,o){super(t,e,n,o)}copySampleValue_(t){const e=this.resultBuffer,n=this.sampleValues,o=this.valueSize,i=t*o*3+o;for(let t=0;t!==o;t++)e[t]=n[i+t];return e}interpolate_(t,e,n,o){const i=this.resultBuffer,r=this.sampleValues,s=this.valueSize,a=2*s,l=3*s,c=o-e,u=(n-e)/c,h=u*u,f=h*u,d=t*l,A=d-l,v=-2*f+3*h,m=f-h,p=1-v,g=m-h+u;for(let t=0;t!==s;t++){const e=r[A+t+s],n=r[A+t+a]*c,o=r[d+t+s],l=r[d+t]*c;i[t]=p*e+g*n+v*o+m*l}return i}}const jE=new dn;class ZE extends KE{interpolate_(t,e,n,o){const i=super.interpolate_(t,e,n,o);return jE.fromArray(i).normalize().toArray(i),i}}const qE=0,JE=1,$E=2,tC=3,eC=4,nC=5,oC=6,iC={5120:Int8Array,5121:Uint8Array,5122:Int16Array,5123:Uint16Array,5125:Uint32Array,5126:Float32Array},rC={9728:T,9729:N,9984:B,9985:D,9986:L,9987:P},sC={33071:y,33648:R,10497:b},aC={32774:a,32778:101,32779:102},lC={0:u,1:h,768:202,769:203,770:A,771:v,772:206,773:207,774:208,775:209,776:210},cC={SCALAR:1,VEC2:2,VEC3:3,VEC4:4,MAT2:4,MAT3:9,MAT4:16},uC={POSITION:"position",NORMAL:"normal",TANGENT:"tangent",TEXCOORD_0:"uv",TEXCOORD_1:"uv2",COLOR_0:"color",WEIGHTS_0:"skinWeight",JOINTS_0:"skinIndex"},hC={scale:"scale",translation:"position",rotation:"quaternion",weights:"morphTargetInfluences",intensity:"intensity",power:"power"},fC={CUBICSPLINE:void 0,LINEAR:Rt,STEP:yt},dC={OPAQUE:"OPAQUE",MASK:"MASK",BLEND:"BLEND"},AC={FRONT:0,BACK:1,DOUBLE:2,TWO_PASS_DOUBLE:3};function vC(t){return void 0===t.DefaultMaterial&&(t.DefaultMaterial=new Wc({color:16777215,emissive:0,metalness:1,roughness:1,transparent:!1,depthTest:!0,side:0,receiveShadow:!0,castShadow:!0})),t.DefaultMaterial}function mC(t,e,n){for(const o in n.extensions)void 0===t[o]&&(e.userData.gltfExtensions=e.userData.gltfExtensions||{},e.userData.gltfExtensions[o]=n.extensions[o])}function pC(t,e){void 0!==e.extras&&("object"==typeof e.extras?Object.assign(t.userData,e.extras):console.warn("v3d.GLTFLoader: Ignoring primitive type .extras, "+e.extras))}function gC(t,e){if(t.updateMorphTargets(),void 0!==e.weights)for(let n=0,o=e.weights.length;n<o;n++)t.morphTargetInfluences[n]=e.weights[n];if(e.extras&&Array.isArray(e.extras.targetNames)){const n=e.extras.targetNames;if(t.morphTargetInfluences.length===n.length){t.morphTargetDictionary={};for(let e=0,o=n.length;e<o;e++)t.morphTargetDictionary[n[e]]=e}else console.warn("v3d.GLTFLoader: Invalid extras.targetNames length. Ignoring names.")}}function _C(t){let e=t.indices+":"+function(t){let e="";const n=Object.keys(t).sort();for(let o=0,i=n.length;o<i;o++)e+=n[o]+":"+t[n[o]]+";";return e}(t.attributes)+":"+t.mode;return e}function EC(t){switch(t){case Int8Array:return 1/127;case Uint8Array:return 1/255;case Int16Array:return 1/32767;case Uint16Array:return 1/65535;default:throw new Error("v3d.GLTFLoader: Unsupported normalized accessor component type.")}}new Hn;class CC{constructor(t={},e={}){this.json=t,this.extensions={},this.plugins={},this.options=e,this.onProgress=e.onProgress||function(){},this.cache=new TE,this.associations=new Map,this.primitiveCache={},this.meshCache={refs:{},uses:{}},this.cameraCache={refs:{},uses:{}},this.lightCache={refs:{},uses:{}},this.sourceCache={},this.textureCache={},this.nodeNamesUsed={};let n=!1,o=!1,i=-1;"undefined"!=typeof navigator&&(n=!0===/^((?!chrome|android).)*safari/i.test(navigator.userAgent),o=navigator.userAgent.indexOf("Firefox")>-1,i=o?navigator.userAgent.match(/Firefox\/([0-9]+)\./)[1]:-1),"undefined"==typeof createImageBitmap||n||o&&i<98?this.textureLoader=new Wh(this.options.manager):this.textureLoader=new Yh(this.options.manager),this.textureLoader.setCrossOrigin(this.options.crossOrigin),this.textureLoader.setRequestHeader(this.options.requestHeader),this.fileLoader=new zh(this.options.manager),this.fileLoader.setResponseType("arraybuffer"),"use-credentials"===this.options.crossOrigin&&this.fileLoader.setWithCredentials(!0),this.assignedMaterials=[]}setExtensions(t){this.extensions=t}setPlugins(t){this.plugins=t}parse(t,e){const n=this,o=this.json,i=this.extensions;this.cache.removeAll(),this.po(function(t){return t.ji&&t.ji()}),Promise.all(this.po(function(t){return t.beforeRoot&&t.beforeRoot()})).then(function(){return Promise.all([n.getDependencies("scene"),n.getDependencies("animation"),n.getDependencies("camera")])}).then(function(e){const r={scene:e[0][o.scene||0],scenes:e[0],animations:e[1],cameras:e[2],asset:o.asset,parser:n,userData:{}};mC(i,r,o),pC(r,o),Promise.all(n.po(function(t){return t.afterRoot&&t.afterRoot(r)})).then(function(){t(r)})}).catch(e)}ji(){const t=this.json.nodes||[],e=this.json.skins||[],n=this.json.meshes||[];for(let n=0,o=e.length;n<o;n++){const o=e[n].joints;for(let e=0,n=o.length;e<n;e++)t[o[e]].isBone=!0}for(let e=0,o=t.length;e<o;e++){const o=t[e];void 0!==o.mesh&&(this.Zi(this.meshCache,o.mesh),void 0!==o.skin&&(n[o.mesh].isSkinnedMesh=!0)),void 0!==o.camera&&this.Zi(this.cameraCache,o.camera)}}Zi(t,e){void 0!==e&&(void 0===t.refs[e]&&(t.refs[e]=t.uses[e]=0),t.refs[e]++)}Ji(t,e,n){if(t.refs[e]<=1)return n;const o=n.clone(),i=(t,e)=>{const n=this.associations.get(t);null!=n&&this.associations.set(e,n);for(const[n,o]of t.children.entries())i(o,e.children[n])};return i(n,o),o.name+="_instance_"+t.uses[e]++,o}rr(t){const e=Object.values(this.plugins);e.push(this);for(let n=0;n<e.length;n++){const o=t(e[n]);if(o)return o}return null}po(t){const e=Object.values(this.plugins);e.unshift(this);const n=[];for(let o=0;o<e.length;o++){const i=t(e[o]);i&&n.push(i)}return n}getDependency(t,e){const n=t+":"+e;let o=this.cache.get(n);if(!o){switch(t){case"scene":o=this.loadScene(e);break;case"node":o=this.loadNode(e);break;case"mesh":o=this.rr(function(t){return t.loadMesh&&t.loadMesh(e)});break;case"accessor":o=this.loadAccessor(e);break;case"bufferView":o=this.rr(function(t){return t.loadBufferView&&t.loadBufferView(e)});break;case"buffer":o=this.loadBuffer(e);break;case"material":o=this.rr(function(t){return t.loadMaterial&&t.loadMaterial(e)});break;case"texture":o=this.rr(function(t){return t.loadTexture&&t.loadTexture(e)});break;case"skin":o=this.loadSkin(e);break;case"animation":o=this.loadAnimation(e);break;case"camera":o=this.loadCamera(e);break;default:throw new Error("Unknown type: "+t)}this.cache.add(n,o)}return o}getDependencies(t){let e=this.cache.get(t);if(!e){const n=this,o=this.json[t+("mesh"===t?"es":"s")]||[];e=Promise.all(o.map(function(e,o){return n.getDependency(t,o)})),this.cache.add(t,e)}return e}loadBuffer(t){const e=this,n=this.json.buffers[t];if(n.type&&"arraybuffer"!==n.type)throw new Error("v3d.GLTFLoader: "+n.type+" buffer type is not supported.");if(void 0===n.uri&&0===t)return Promise.resolve(this.extensions[BE.KHR_BINARY_GLTF].body);const o=this.options;return new Promise(function(t){let i,r;o.loadBinXZ?(i=Xh.resolveURL(n.uri,o.path)+".xz",r=new Sp):(i=Xh.resolveURL(n.uri,o.path),r=e.fileLoader);const s=function(t){if(e.onProgress){const n=100*(.3+.7*t);e.onProgress(n)}};let a=s;r instanceof zh&&(a=function(t){const e=t.lengthComputable?t.loaded/t.total:1;s(e)}),r.load(i,t,a)})}loadBufferView(t){const e=this.json.bufferViews[t];return this.getDependency("buffer",e.buffer).then(function(t){const n=e.byteLength||0,o=e.byteOffset||0;return t.slice(o,o+n)})}loadAccessor(t){const e=this.json,n=this.json.accessors[t];if(void 0===n.bufferView&&void 0===n.sparse){const t=cC[n.type],e=iC[n.componentType],o=!0===n.normalized,i=new e(n.count*t);return Promise.resolve(new Oo(i,t,o))}const o=[];return void 0!==n.bufferView?o.push(this.getDependency("bufferView",n.bufferView)):o.push(null),void 0!==n.sparse&&(o.push(this.getDependency("bufferView",n.sparse.indices.bufferView)),o.push(this.getDependency("bufferView",n.sparse.values.bufferView))),Promise.all(o).then(function(t){const o=t[0],i=cC[n.type],r=iC[n.componentType],s=r.BYTES_PER_ELEMENT*i,a=n.byteOffset||0,l=void 0!==n.bufferView?e.bufferViews[n.bufferView].byteStride:void 0,c=!0===n.normalized;let u,h;if(l&&l!==s&&console.error("v3d.GLTFLoader: Interleaved attributes are not supported"),u=null===o?new r(n.count*i):new r(o,a,n.count*i),h=new Oo(u,i,c),void 0!==n.sparse){const e=cC.SCALAR,s=iC[n.sparse.indices.componentType],a=n.sparse.indices.byteOffset||0,l=n.sparse.values.byteOffset||0,c=new s(t[1],a,n.sparse.count*e),u=new r(t[2],l,n.sparse.count*i);null!==o&&(h=new Oo(h.array.slice(),h.itemSize,h.normalized));for(let t=0,e=c.length;t<e;t++){const e=c[t];if(h.setX(e,u[t*i]),i>=2&&h.setY(e,u[t*i+1]),i>=3&&h.setZ(e,u[t*i+2]),i>=4&&h.setW(e,u[t*i+3]),i>=5)throw new Error("v3d.GLTFLoader: Unsupported itemSize in sparse BufferAttribute.")}}return h})}loadTexture(t){const e=this.json,n=this.options,o=e.textures[t].source,i=e.images[o];let r=this.textureLoader;if(i.uri){const t=n.manager.getHandler(i.uri);null!==t&&(r=t)}return this.loadTextureImage(t,o,r)}loadTextureImage(t,e,n){const o=this,i=this.json,r=i.textures[t],s=i.images[e],a=(s.uri||s.bufferView)+":"+r.sampler;if(this.textureCache[a])return this.textureCache[a];const l=this.loadImageSource(e,n).then(function(e){e.flipY=!1,e.name=r.name||s.name||"";const a=(i.samplers||{})[r.sampler]||{};return e.magFilter=rC[a.magFilter]||N,e.minFilter=rC[a.minFilter]||P,e.wrapS=sC[a.wrapS]||b,e.wrapT=sC[a.wrapT]||b,o.po(function(t){return t.extendTextureParams&&t.extendTextureParams(e,r,n)}),o.associations.set(e,{textures:t}),e}).catch(function(){return null});return this.textureCache[a]=l,l}loadImageSource(t,e){const n=this,o=this.json,i=this.options;if(void 0!==this.sourceCache[t])return this.sourceCache[t].then(t=>t.clone());const r=o.images[t],s=self.URL||self.webkitURL;let a=r.uri||"",l=!1;if(void 0!==r.bufferView)a=n.getDependency("bufferView",r.bufferView).then(function(t){l=!0;const e=new Blob([t],{type:r.mimeType});return a=s.createObjectURL(e),a});else if(void 0===r.uri)throw new Error("v3d.GLTFLoader: Image "+t+" is missing URI and bufferView");const c=Promise.resolve(a).then(function(t){return new Promise(function(n,o){let r=n;!0===e.isImageBitmapLoader&&(r=function(t){const e=new an(t);e.needsUpdate=!0,n(e)}),e.load(Xh.resolveURL(t,i.path),r,void 0,o)})}).then(function(t){if(t instanceof ArrayBuffer){return n.plugins[BE.S8S_V3D_TEXTURE].textureLoaderRGBE.loadAsync(s.createObjectURL(new Blob([t],{type:"image/vnd.radiance"})))}return Promise.resolve(t)}).then(function(t){var e;return!0===l&&s.revokeObjectURL(a),t.userData.mimeType=r.mimeType||((e=r.uri).search(/\.jpe?g($|\?)/i)>0||0===e.search(/^data\:image\/jpeg/)?"image/jpeg":e.search(/\.webp($|\?)/i)>0||0===e.search(/^data\:image\/webp/)?"image/webp":"image/png"),t}).catch(function(t){return console.error("v3d.GLTFLoader: Couldn't load texture",a),new an});return this.sourceCache[t]=c,c}assignTexture(t,e,n,o){return this.getDependency("texture",n.index).then(function(i){return i?(void 0===n.texCoord||0==n.texCoord||"aoMap"===e&&1==n.texCoord||console.warn("v3d.GLTFLoader: Custom UV set "+n.texCoord+" for texture "+e+" not yet supported."),void 0!==o&&(i.encoding=o),t[e]=i,i):null})}assignFinalMaterial(t,e,n){const o=t.geometry;let i=t.material;const r=void 0===o.attributes.tangent,s=void 0!==o.attributes.color&&!i.isMeshNodeMaterial,a=void 0===o.attributes.normal,l=i.isMeshNodeMaterial&&(i.nodeValue.length||i.nodeRGB.length),c=i.isMeshNodeMaterial&&i.hasNode("TEX_COORD_BL"),u=i.isMeshNodeMaterial&&Object.getOwnPropertyNames(e).length>0&&i.hasNode("UVMAP_BL"),h=i.isMeshNodeMaterial&&Object.getOwnPropertyNames(n).length>0&&(i.hasNode("ATTRIBUTE_BL")||i.hasNode("VERTEX_COLOR_BL")||i.hasNode("USER_DATA_COLOR_AR"));if(t.isPoints){const t="PointsMaterial:"+i.uuid;let e=this.cache.get(t);e||(e=new Bl,Lo.prototype.copy.call(e,i),e.color.copy(i.color),e.map=i.map,e.sizeAttenuation=!1,this.cache.add(t,e)),i=e}else if(t.isLine){const t="LineBasicMaterial:"+i.uuid;let e=this.cache.get(t);e||(e=new El,Lo.prototype.copy.call(e,i),e.color.copy(i.color),this.cache.add(t,e)),i=e}if(r||s||a||l||c||u||h){let t="ClonedMaterial:"+i.uuid+":";r&&(t+="derivative-tangents:"),s&&(t+="vertex-colors:"),a&&(t+="flat-shading:");const o=ne();l&&(t=o),c&&(t=o),u&&(t=o),h&&(t=o);let f=this.cache.get(t);f||(f=i.clone(),s&&(f.vertexColors=!0),a&&(f.flatShading=!0),r&&f.normalScale&&(f.normalScale.y*=-1),f.isMeshNodeMaterial&&(Object.assign(f.nodeUVAliases,e),Object.assign(f.nodeVCAliases,n),f.updateNodeGraph()),this.cache.add(t,f),this.associations.set(f,this.associations.get(i))),i=f}i.aoMap&&void 0===o.attributes.uv2&&void 0!==o.attributes.uv&&o.setAttribute("uv2",o.attributes.uv),t.material=i,this.assignedMaterials.includes(i)||this.assignedMaterials.push(i)}getMaterialType(){return Wc}loadMaterial(t){const e=this,n=this.json,o=this.extensions,i=n.materials[t];let r;const s={},a=i.extensions||{},l=[];if(!0===i.doubleSided&&(s.side=2),a[BE.KHR_MATERIALS_UNLIT]){const t=o[BE.KHR_MATERIALS_UNLIT];r=t.getMaterialType(),l.push(t.extendParams(s,i,e))}else{const n=i.pbrMetallicRoughness||{};if(s.color=new tn(1,1,1),s.opacity=1,Array.isArray(n.baseColorFactor)){const t=n.baseColorFactor;s.color.fromArray(t),s.opacity=t[3]}void 0!==n.baseColorTexture&&l.push(e.assignTexture(s,"map",n.baseColorTexture,Ft)),s.metalness=void 0!==n.metallicFactor?n.metallicFactor:1,s.roughness=void 0!==n.roughnessFactor?n.roughnessFactor:1,void 0!==n.metallicRoughnessTexture&&(l.push(e.assignTexture(s,"metalnessMap",n.metallicRoughnessTexture)),l.push(e.assignTexture(s,"roughnessMap",n.metallicRoughnessTexture))),r=this.rr(function(e){return e.getMaterialType&&e.getMaterialType(t)}),l.push(Promise.all(this.po(function(e){return e.extendMaterialParams&&e.extendMaterialParams(t,s)})))}const c=i.alphaMode||dC.OPAQUE;if(c===dC.BLEND?(s.transparent=!0,r!==Ph&&(s.depthWrite=!1)):(s.transparent=!1,c===dC.MASK&&(s.alphaTest=void 0!==i.alphaCutoff?i.alphaCutoff:.5)),void 0!==i.normalTexture&&r!==No&&(l.push(e.assignTexture(s,"normalMap",i.normalTexture)),s.normalScale=new we(1,1),void 0!==i.normalTexture.scale)){const t=i.normalTexture.scale;s.normalScale.set(t,t)}return void 0!==i.occlusionTexture&&r!==No&&(l.push(e.assignTexture(s,"aoMap",i.occlusionTexture)),void 0!==i.occlusionTexture.strength&&(s.aoMapIntensity=i.occlusionTexture.strength)),void 0!==i.emissiveFactor&&r!==No&&(s.emissive=(new tn).fromArray(i.emissiveFactor)),void 0!==i.emissiveTexture&&r!==No&&l.push(e.assignTexture(s,"emissiveMap",i.emissiveTexture,Ft)),Promise.all(l).then(function(){const n=new r(s);i.name&&(n.name=i.name),n.map&&(n.map.encoding=Ft),n.emissiveMap&&(n.emissiveMap.encoding=Ft);const a=e.plugins[BE.S8S_V3D_MATERIALS];return n.isMeshNodeMaterial&&a.assignTransparency(n,i,c),n.isMeshStandardMaterial&&n.normalScale&&a&&ye(a.profile)&&"max"==a.profile&&(n.normalScale.y=-n.normalScale.y),pC(n,i),e.associations.set(n,{materials:t}),i.extensions&&mC(o,n,i),n})}createUniqueName(t){const e=t;let n=e;for(let t=1;this.nodeNamesUsed[n];++t)n=e+"_"+t;return this.nodeNamesUsed[n]=!0,n}loadGeometries(t){const e=this;this.extensions;const n=this.primitiveCache,o=[];for(let i=0,r=t.length;i<r;i++){const r=t[i],s=_C(r),a=n[s];if(a)o.push(a.promise);else{let t=xC(new Xo,r,e);n[s]={primitive:r,promise:t},o.push(t)}}return Promise.all(o)}loadMesh(t){const e=this,n=this.json,o=this.extensions,i=n.meshes[t],r=i.primitives,s=[],a=ye(i.extensions)?i.extensions[BE.S8S_V3D_MESH]:void 0;for(let t=0,e=r.length;t<e;t++){const e=void 0===r[t].material?vC(this.cache):this.getDependency("material",r[t].material);s.push(e)}return s.push(e.loadGeometries(r)),Promise.all(s).then(function(n){const s=n.slice(0,n.length-1),l=n[n.length-1],c=[];for(let n=0,u=l.length;n<u;n++){const u=l[n],h=r[n];let f;const d=s[n];if(h.mode===eC||h.mode===nC||h.mode===oC||void 0===h.mode)f=!0===i.isSkinnedMesh?new ll(u,d):new hi(u,d),!0!==f.isSkinnedMesh||f.geometry.attributes.skinWeight.normalized||f.normalizeSkinWeights(),h.mode===nC?f.geometry=Um(f.geometry,1):h.mode===oC&&(f.geometry=Um(f.geometry,2));else if(h.mode===JE)if(a){const t=new VA;t.fromBufferGeometry(u);const e=new Kc({color:ye(a.lineColor)?(new tn).fromArray(a.lineColor):new tn(1,1,1),lineWidth:ye(a.lineWidth)?a.lineWidth:1,sizeAttenuation:0});f=new hi(t.geometry,e),f.userData.originalLineGeom=u}else f=new Rl(u,d);else if(h.mode===tC)f=new Sl(u,d);else if(h.mode===$E)f=new Tl(u,d);else{if(h.mode!==qE)throw new Error("v3d.GLTFLoader: Primitive mode unsupported: "+h.mode);f=new Ol(u,d)}Object.keys(f.geometry.morphAttributes).length>0&&gC(f,i),f.name=e.createUniqueName(i.name||"mesh_"+t),pC(f,i),h.extensions&&mC(o,f,h);const A={},v={};if(f.material.isMeshNodeMaterial&&a){if(a.uvLayers)for(let t in a.uvLayers)A[t]=MC(a.uvLayers[t]);if(a.colorLayers)for(let t in a.colorLayers)v[t]=SC(a.colorLayers[t])}e.assignFinalMaterial(f,A,v),c.push(f)}for(let n=0,o=c.length;n<o;n++)e.associations.set(c[n],{meshes:t,primitives:n});if(1===c.length)return c[0];const u=new Ra;e.associations.set(u,{meshes:t});for(let t=0,n=c.length;t<n;t++)c[t].name=e.createUniqueName(i.name+"MatMesh"+t),c[t].isMaterialGeneratedMesh=!0,u.add(c[t]);return u})}loadCamera(t){let e;const n=this.json.cameras[t],o=n[n.type];if(o)return"perspective"===n.type?e=new Ei(ce(o.yfov),o.aspectRatio||1,o.znear||1,o.zfar||2e6):"orthographic"===n.type&&(e=new Xi(-o.xmag,o.xmag,o.ymag,-o.ymag,o.znear,o.zfar)),n.name&&(e.name=n.name),pC(e,n),this.rr(function(t){return t.extendCameraParams&&t.extendCameraParams(e,n)});console.warn("v3d.GLTFLoader: Missing camera parameters.")}loadSkin(t){const e=this.json.skins[t],n=[];for(let t=0,o=e.joints.length;t<o;t++)n.push(this.getDependency("node",e.joints[t]));return void 0!==e.inverseBindMatrices?n.push(this.getDependency("accessor",e.inverseBindMatrices)):n.push(null),Promise.all(n).then(function(t){const n=t.pop(),o=t,i=[],r=[];for(let t=0,s=o.length;t<s;t++){const s=o[t];if(s){i.push(s);const e=new Hn;null!==n&&e.fromArray(n.array,16*t),r.push(e)}else console.warn('v3d.GLTFLoader: Joint "%s" could not be found.',e.joints[t])}return new dl(i,r)})}loadAnimation(t){const e=this.json.animations[t],n=[],o=[],i=[],r=[],s=[];for(let t=0,a=e.channels.length;t<a;t++){const a=e.channels[t],l=e.samplers[a.sampler],c=a.target,u=c.node,h=void 0!==e.parameters?e.parameters[l.input]:l.input,f=void 0!==e.parameters?e.parameters[l.output]:l.output;n.push(this.getDependency("node",u)),o.push(this.getDependency("accessor",h)),i.push(this.getDependency("accessor",f)),r.push(l),s.push(c)}return Promise.all([Promise.all(n),Promise.all(o),Promise.all(i),Promise.all(r),Promise.all(s),this.getDependencies("material")]).then(function(n){const o=n[0],i=n[1],r=n[2],s=n[3],a=n[4],l=[];for(let t=0,e=o.length;t<e;t++){const e=o[t],c=i[t],u=r[t],h=s[t],f=a[t];if(void 0===e)continue;let d;e.updateMatrix();let A="";switch(hC[f.path]){case hC.weights:d=Kf;break;case hC.rotation:d=Xf;break;case hC.translation:case hC.scale:d=Hf;break;case hC.intensity:d=Kf;break;default:if(f.path.indexOf("constraint")>-1){d=Kf,A="constraints["+f.path.match(/".*"/g)[0]+"]."+f.path.match(/[^\\.]*$/g)[0]}else{let t;d=Hf,f.path.indexOf("nodeValue")>-1?(t=f.path.match(/".*"/g)[0],A="material.nodeValue["+t+"]"):f.path.indexOf("nodeRGB")>-1&&(t=f.path.match(/".*"/g)[0],A="material.nodeRGB["+t+"]")}}const v=e.name?e.name:e.uuid,m=void 0!==h.interpolation?fC[h.interpolation]:Rt,p=[];if(hC[f.path]===hC.weights)e.traverse(function(t){t.morphTargetInfluences&&p.push(t.name?t.name:t.uuid)});else if(f.path.indexOf("material")>-1){const t=n[5];e.traverse(function(e){if(!e.isMesh)return;if(!e.material.isMeshNodeMaterial)return;let n=!1;if(f.extras){n=t[f.extras.material].name===e.material.name;const o=f.path.match(/\["(.*)"\]/);n=n&&null!==o&&null!==e.material.findNodeByName(o[1])}else n=!0;n&&p.push(e.name?e.name:e.uuid)})}else p.push(v);let g=u.array;if(u.normalized){const t=EC(g.constructor),e=new Float32Array(g.length);for(let n=0,o=g.length;n<o;n++)e[n]=g[n]*t;g=e}for(let t=0,e=p.length;t<e;t++){const e=new d(p[t]+"."+(""!==A?A:hC[f.path]),c.array,g,m);"CUBICSPLINE"===h.interpolation&&(e.createInterpolant=function(t){return new(this instanceof Xf?ZE:KE)(this.times,this.values,this.getValueSize()/3,t)},e.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline=!0),l.push(e)}}const c=e.name?e.name:"animation_"+t,u={clip:new cd(c,void 0,l),nodeId:o[0].id,auto:!0,loop:St,repetitions:1/0,startAt:0},h=ye(e.extensions)?e.extensions[BE.S8S_V3D_ANIMATION]:void 0;if(h){u.auto=h.auto;const t=h.repeatInfinite?1/0:h.repeatCount;switch(h.loop){case"ONCE":u.loop=Mt;break;case"REPEAT":u.loop=St,u.repetitions=t;break;case"PING_PONG":u.loop=bt,u.repetitions=t}u.startAt=h.offset}return u})}createNodeMesh(t){const e=this.json,n=this,o=e.nodes[t];return void 0===o.mesh?null:n.getDependency("mesh",o.mesh).then(function(t){const e=n.Ji(n.meshCache,o.mesh,t);return void 0!==o.weights&&e.traverse(function(t){if(t.isMesh)for(let e=0,n=o.weights.length;e<n;e++)t.morphTargetInfluences[e]=o.weights[e]}),e})}loadNode(t){const e=this.json,n=this.extensions,o=this,i=e.nodes[t],r=i.name?o.createUniqueName(i.name):"";return function(){const e=[],n=o.rr(function(e){return e.createNodeMesh&&e.createNodeMesh(t)});return n&&e.push(n),void 0!==i.camera&&e.push(o.getDependency("camera",i.camera).then(function(t){return o.Ji(o.cameraCache,i.camera,t)})),o.po(function(e){return e.createNodeAttachment&&e.createNodeAttachment(t)}).forEach(function(t){e.push(t)}),Promise.all(e)}().then(function(e){let s;if(s=!0===i.isBone?new cl:e.length>1?new Ra:1===e.length?e[0]:new mo,s!==e[0])for(let t=0,n=e.length;t<n;t++)s.add(e[t]);if(i.name&&(s.userData.name=i.name,s.name=r),pC(s,i),i.extensions&&mC(n,s,i),void 0!==i.matrix){const t=new Hn;t.fromArray(i.matrix),s.applyMatrix4(t)}else void 0!==i.translation&&s.position.fromArray(i.translation),void 0!==i.rotation&&s.quaternion.fromArray(i.rotation),void 0!==i.scale&&s.scale.fromArray(i.scale);return o.associations.has(s)||o.associations.set(s,{}),o.associations.get(s).nodes=t,s}).then(function(t){return t.resolveMultiMaterial().forEach(e=>{o.rr(function(n){if(e!==t)return n.extendNodeParams&&n.extendNodeParams(e,i)})}),o.rr(function(e){return e.extendNodeParams&&e.extendNodeParams(t,i)})})}loadScene(t){const e=this.json,n=this.extensions,o=this.json.scenes[t],i=this,r=new Ni;o.name&&(r.name=i.createUniqueName(o.name)),pC(r,o),o.extensions&&mC(n,r,o);const s=o.nodes||[],a=[];for(let t=0,n=s.length;t<n;t++)a.push(wC(s[t],r,e,i));return Promise.all(a).then(function(){return i.associations=(t=>{const e=new Map;for(const[t,n]of i.associations)(t instanceof Lo||t instanceof an)&&e.set(t,n);return t.traverse(t=>{const n=i.associations.get(t);null!=n&&e.set(t,n)}),e})(r),r})}}function wC(t,e,n,o){const i=n.nodes[t];return o.getDependency("node",t).then(function(t){return void 0===i.skin?t:o.getDependency("skin",i.skin).then(function(e){return t.traverse(function(t){t.isSkinnedMesh&&t.bind(e,t.matrixWorld)}),t})}).then(function(t){e.add(t),(t.isDirectionalLight||t.isSpotLight)&&t.isFreeLight&&e.add(t.target);const r=[];if(i.children){const e=i.children;for(let i=0,s=e.length;i<s;i++){const s=e[i];r.push(wC(s,t,n,o))}}return Promise.all(r)})}function xC(t,e,n){const o=e.attributes,i=[];function r(e,o){return n.getDependency("accessor",e).then(function(e){t.setAttribute(o,e)})}for(const e in o){const n=uC[e]||IC(e)||e.toLowerCase();n in t.attributes||i.push(r(o[e],n))}if(void 0!==e.indices&&!t.index){const o=n.getDependency("accessor",e.indices).then(function(e){t.setIndex(e)});i.push(o)}return pC(t,e),function(t,e,n){const o=e.attributes,i=new pn;if(void 0===o.POSITION)return;{const t=n.json.accessors[o.POSITION],e=t.min,r=t.max;if(void 0===e||void 0===r)return void console.warn("v3d.GLTFLoader: Missing min/max properties for accessor POSITION.");if(i.set(new An(e[0],e[1],e[2]),new An(r[0],r[1],r[2])),t.normalized){const e=EC(iC[t.componentType]);i.min.multiplyScalar(e),i.max.multiplyScalar(e)}}const r=e.targets;if(void 0!==r){const t=new An,e=new An;for(let o=0,i=r.length;o<i;o++){const i=r[o];if(void 0!==i.POSITION){const o=n.json.accessors[i.POSITION],r=o.min,s=o.max;if(void 0!==r&&void 0!==s){if(e.setX(Math.max(Math.abs(r[0]),Math.abs(s[0]))),e.setY(Math.max(Math.abs(r[1]),Math.abs(s[1]))),e.setZ(Math.max(Math.abs(r[2]),Math.abs(s[2]))),o.normalized){const t=EC(iC[o.componentType]);e.multiplyScalar(t)}t.max(e)}else console.warn("v3d.GLTFLoader: Missing min/max properties for accessor POSITION.")}}i.expandByVector(t)}t.boundingBox=i;const s=new Pn;i.getCenter(s.center),s.radius=i.min.distanceTo(i.max)/2,t.boundingSphere=s}(t,e,n),Promise.all(i).then(function(){return void 0!==e.targets?function(t,e,n){let o=!1,i=!1;for(let t=0,n=e.length;t<n;t++){const n=e[t];if(void 0!==n.POSITION&&(o=!0),void 0!==n.NORMAL&&(i=!0),o&&i)break}if(!o&&!i)return Promise.resolve(t);const r=[],s=[];for(let a=0,l=e.length;a<l;a++){const l=e[a];if(o){const e=void 0!==l.POSITION?n.getDependency("accessor",l.POSITION):t.attributes.position;r.push(e)}if(i){const e=void 0!==l.NORMAL?n.getDependency("accessor",l.NORMAL):t.attributes.normal;s.push(e)}}return Promise.all([Promise.all(r),Promise.all(s)]).then(function(e){const n=e[0],r=e[1];return o&&(t.morphAttributes.position=n),i&&(t.morphAttributes.normal=r),t.morphTargetsRelative=!0,t})}(t,e.targets,n):t})}function IC(t){return t.indexOf("TEXCOORD_")>-1?MC(t):t.indexOf("COLOR_")>-1?SC(t):""}function MC(t){return"TEXCOORD_0"==t?"uv":"uv"+String(Number(t.split("TEXCOORD_")[1])+1)}function SC(t){return"COLOR_0"==t?"color":"color"+String(Number(t.split("COLOR_")[1])+1)}function bC(t){t.blending=5,t.blendEquation=a,t.blendSrc=h,t.blendDst=v}const yC=new tn;class RC extends Zt{constructor(t,e,n=512,o=512){super(),this.scene=t,this.camera=e,this.width=n,this.height=o,this.distance=.1,this.factor=1,this.precision=1,this.bentNormals=!1,this.noiseTexture=this.createNoiseTexture(),this.fsQuad=new Ir(null);const i=new Er;i.type=V,this.renderTargetNormalDepth=new cn(this.width,this.height,{format:W,depthTexture:i,depthBuffer:!0}),this.renderTargetNormalDepth.texture.name="GTAO.normal",this.renderTargetNormalDepth.depthTexture.name="GTAO.depth",this.renderTargetGTAO=new cn(this.width,this.height),this.renderTargetGTAO.texture.name="GTAO.gtao",this.renderTargetBlurX=new cn(this.width,this.height),this.renderTargetBlurX.texture.name="GTAO.blur",this.renderTarget=new cn(this.width,this.height),this.renderTarget.texture.name="GTAO.rt",this.materialNormal=new Yc({}),this.materialGTAO=new gi({type:"GTAO",defines:{ORTHO_CAMERA:0,CALC_BENT_NORMALS:0},extensions:{derivatives:!0},uniforms:{tNormal:{value:null},tDepth:{value:null},tNoise:{value:null},occlDistance:{value:.1},factor:{value:1},occlPrecision:{value:1},mainCameraProjMat:{value:new Hn},resolution:{value:new we}},vertexShader:Fi.pp_plane_vert,fragmentShader:Fi.pp_gtao_frag}),this.materialBlur=new gi({type:"GTAOBlur",defines:{},uniforms:{tDiffuse:{value:null},tNormal:{value:null},direction:{value:new we},resolution:{value:new we}},customPrepTokens:{BLUR_RADIUS_PX:2},vertexShader:Fi.pp_plane_vert,fragmentShader:Fi.pp_gtao_blur_frag}),this.St={}}setCamera(t){this.camera=t}setSize(t,e){this.width=t,this.height=e,this.renderTargetNormalDepth.setSize(t,e),this.renderTargetGTAO.setSize(t,e),this.renderTargetBlurX.setSize(t,e),this.renderTarget.setSize(t,e),this.materialGTAO.uniforms.mainCameraProjMat.value.copy(this.camera.projectionMatrix),this.materialGTAO.uniforms.resolution.value.set(this.renderTargetGTAO.width,this.renderTargetGTAO.height),this.materialBlur.uniforms.resolution.value.set(this.renderTargetGTAO.width,this.renderTargetGTAO.height)}dispose(){this.dispatchEvent({type:"dispose"}),this.renderTargetNormalDepth.dispose(),this.renderTargetGTAO.dispose(),this.renderTargetBlurX.dispose(),this.renderTarget.dispose(),this.materialNormal.dispose(),this.materialGTAO.dispose(),this.materialBlur.dispose(),this.noiseTexture.dispose()}Tt(){this.scene.traverse(t=>this.St[t.id]=t.layers.mask)}Bt(){this.scene.traverse(t=>{t.layers.disableAll();const e=t instanceof hi&&t.material&&!t.material.gtaoVisible,n=t instanceof hi&&t.material&&t.material.isMeshNodeMaterial&&(t.material.alphaTest>0||t.material.alphaToCoverage);e?t.layers.enable(0):n?t.layers.enable(1):t.layers.enable(2)})}Nt(){this.scene.traverse(t=>t.layers.mask=this.St[t.id])}sr(){this.scene.traverse(t=>{t instanceof hi&&t.material&&t.material.isMeshNodeMaterial&&(t.material.defines.NORMAL_OUTPUT=Number(t.material.alphaTest>0||t.material.alphaToCoverage),t.material.needsUpdate=!0)})}lr(){this.scene.traverse(t=>{t instanceof hi&&t.material&&t.material.isMeshNodeMaterial&&(t.material.defines.NORMAL_OUTPUT=0,t.material.needsUpdate=!0)})}render(t){this.Tt(),this.Bt(),this.camera.layers.disableAll(),this.camera.layers.enable(1),this.sr(),this.cr(t,null,this.renderTargetNormalDepth,8355839,1,!0),this.lr(),this.camera.layers.disableAll(),this.camera.layers.enable(2),this.cr(t,this.materialNormal,this.renderTargetNormalDepth,null,null,!0),this.Nt(),this.materialGTAO.defines.ORTHO_CAMERA=this.camera.isOrthographicCamera?1:0,this.materialGTAO.defines.CALC_BENT_NORMALS=this.bentNormals?1:0,this.materialGTAO.needsUpdate=!0,this.materialGTAO.uniforms.tNormal.value=this.renderTargetNormalDepth.texture,this.materialGTAO.uniforms.tDepth.value=this.renderTargetNormalDepth.depthTexture,this.materialGTAO.uniforms.tNoise.value=this.noiseTexture,this.materialGTAO.uniforms.occlDistance.value=this.distance,this.materialGTAO.uniforms.factor.value=this.factor,this.materialGTAO.uniforms.occlPrecision.value=this.precision,this.materialGTAO.uniforms.mainCameraProjMat.value.copy(this.camera.projectionMatrix),this.materialGTAO.uniforms.resolution.value.set(this.renderTargetGTAO.width,this.renderTargetGTAO.height),this.ur(t,this.materialGTAO,this.renderTargetGTAO),this.materialBlur.uniforms.tDiffuse.value=this.renderTargetGTAO.texture,this.materialBlur.map=this.renderTargetGTAO.texture,this.materialBlur.uniforms.tNormal.value=this.renderTargetNormalDepth.texture,this.materialBlur.uniforms.direction.value.set(1,0),this.materialBlur.uniforms.resolution.value.set(this.renderTargetGTAO.width,this.renderTargetGTAO.height),this.ur(t,this.materialBlur,this.renderTargetBlurX),this.materialBlur.uniforms.tDiffuse.value=this.renderTargetBlurX.texture,this.materialBlur.map=this.renderTargetBlurX.texture,this.materialBlur.uniforms.direction.value.set(0,1),this.materialBlur.uniforms.resolution.value.set(this.renderTargetBlurX.width,this.renderTargetBlurX.height),this.ur(t,this.materialBlur,this.renderTarget)}cr(t,e,n,o,i,r){const s=t.getRenderTarget(),a=t.getClearColor(yC),l=t.getClearAlpha(),c=t.autoClear,u=this.scene.background;t.setRenderTarget(n),null!=o&&(t.setClearColor(o),t.setClearAlpha(null!=i?i:0),t.clear()),t.autoClear=!1,r&&(this.scene.background=null),e&&(this.scene.overrideMaterial=e),t.render(this.scene,this.camera),this.scene.overrideMaterial=null,t.setRenderTarget(s),t.setClearColor(a),t.setClearAlpha(l),t.autoClear=c,this.scene.background=u}ur(t,e,n,o,i){const r=t.getRenderTarget(),s=t.getClearColor(yC),a=t.getClearAlpha(),l=t.autoClear;t.setRenderTarget(n),null!=o&&(t.setClearColor(o),t.setClearAlpha(null!=i?i:0),t.clear()),t.autoClear=!1,this.fsQuad.material=e,this.fsQuad.render(t),t.setRenderTarget(r),t.setClearColor(s),t.setClearAlpha(a),t.autoClear=l}createNoiseTexture(){const t=new Uint8Array([101,192,145,80,53,136,86,207,229,131,240,6,58,41,171,13,199,63,175,128,113,55,246,66,115,213,157,59,243,114,68,169,255,60,216,5,200,37,250,65,170,48,153,108,125,211,137,29,120,82,38,213,25,198,15,150,33,131,173,16,140,180,9,206,134,20,117,176,99,222,124,190,95,33,198,221,86,68,241,157,227,142,253,96,72,135,169,102,204,253,89,195,50,233,94,38,185,86,235,72,149,163,25,2,146,75,254,14,164,189,0,100,49,187,162,8,181,222,240,52,7,73,41,109,210,123,76,150,226,161,44,11,242,51,107,232,212,116,177,54,141,37,207,77,115,19,59,235,110,42,83,122,160,184,224,148,2,164,248,24,203,109,129,192,208,138,83,182,61,132,28,229,96,121,224,173,248,197,88,127,147,29,193,210,139,96,237,30,63,191,102,54,69,178,32,93,63,170,36,247,17,201,80,155,245,18,60,133,151,32,219,206,165,67,230,20,57,12,171,128,84,221,139,13,236,146,220,252,20,120,222,150,99,166,43,108,196,183,89,45,9,107,74,49,4,100,175,117,246,71,198,113,241,39,174,119,46,82,1,157,105,195,72,9,127,239,217,6,69,145,211,166,230,181,240,136,190,251,87,155,35,219,143,50,22,159,213,92,191,127,212,41,135,237,50,206,88,58,176,118,36,234,27,114,64,93,157,119,21,214,45,129,187,105,92,208,182,66,6,249,27,167,62,185,78,172,29,160,188,25,139,249,161,84,130,254,203,14,37,226,59,143,77,238,0,166,18,254,79,133,103,153,205,113,94,246,12,216,100,116,227,76,209,48,97,186,1,53,144,192,82,169,108,179,28,198,65,228,42,151,122,197,233,53,74,222,24,146,123,56,141,255,3,151,106,20,200,220,73,174,104,216,131,248,7,209,156,86,112,136,177,58,223,11,36,140,241,8,195,178,232,85,200,43,65,180,240,133,61,149,120,231,22,46,71,30,92,230,121,52,242,215,97,26,110,186,89,172,158,102,50,70,34,156,15,189,126,91,34,168,10,245,39,91,163,243,152,202,140,42,188,17,163,8,203,77,156,237,63,118,32,130,251,165,112,208,98,235,161,213,228,81,110,194,178,14,125,185,111,61,173,103,253,71,144,39,125,250,45,207,15,217,177,202,88,1,226,132,75,26,56,12,119,203,46,137,66,209,77,220,3,238,19,80,129,218,179,90,193,168,132,98,146,81,19,235,142,59,183,44,250,174,104,144,69,155,251,97,230,145,33,99,49,159,212,196,31,56,110,225,22,62,2,183,245,55,123,40,106,215,17,150,116,218,194,238,31,186,0,23,55,162,241,194,135,87,118,147,236,4,158,244,75,117,228,35,109,194,67,155,78,168,199,91,64,8,135,47,88,169,212,129,181,111,11,65,170,227,40,68,176,95,201,46,142,209,154,90,165,218,255,188,232,27,121,244,35,163,79,206,124,242,103,72,223,83,204,123,25,247,10,191,111,136,26,85,187,18,236,51,134,7,144,13,99,48,138,227,190,101,223,24,153,60,41,149,30,255,45,152,184,103,78,162,51,252,217,128,171,104,70,197,30,84,114,57,176,205,70,4,148,54,253,181,113,6,231,191,134,172,95,220,56,211,141,233,205,16,66,40,224,5,122,243,179,211,226,127,247,158,85,111,174,126,15,73,202,167,87,215,17,116,3,71,130,19,35,90,124,154,182,98,248,148,57,156,96,43,73,196,34,16,218,237,42,208,94,143,38,247,122,67,52,201,234,164,249,177,199,61,1,108,76,167,31,204,80,231,22,170,0,147,93,120,183,64,28,161,239,57,185,105,28,159,139,184,106,40,81,114,145,242,219,190,239,53,138,112,11,187,133,107,204,239,168,54,141,102,193,81,221,134,9,216,78,229,244,90,23,153,225,10,95,160,43,132,23,214,195,89,47,215,252,62,38,82,228,21,214,251,2,151,109,21,175,197,149,44,5,173,64,210,52,196,69,29,172,83,118,13,154,236,175,119,26,159,137,112,189,44,131,75,171,121,49,232,92,126,62,101,205,130,117,250,138,180,125,207,254,58,225,97,67,37,142,74,98,182,210,7,68,152,202,94,34,243,200,70,39,252,166,16,224,188,32,84,21,100,231,12,106,148,199,178,249,164,5,229,55,245,87,165,234,105,14,225,60,184,140,158,214,27,115,143,74,51,162,147,238,47,76,167,36,137,3,48,126,104,201,189,128,18,47,124,31,244,180,160,115,23,10,101,79,179,193,233,93,246,107,217,4,192,154,221,91,186,234,79,24,219,85,33,152,223]),e=new Uint8Array([7,87,145,233,57,15,124,219,7,163,132,35,222,160,41,99,10,23,228,253,53,207,65,214,94,146,248,134,214,15,97,230,201,181,41,105,189,206,171,100,146,78,188,106,177,87,141,232,198,122,70,178,149,26,124,174,16,55,115,35,70,179,158,111,74,241,122,159,29,90,47,242,23,229,213,16,245,72,26,183,58,136,205,43,86,239,139,226,77,188,203,86,224,144,50,30,135,62,11,218,255,68,156,185,59,121,91,49,199,152,219,109,243,162,14,221,113,192,3,100,42,152,233,168,22,123,251,210,153,191,99,173,139,114,2,133,201,32,169,135,64,118,1,47,89,31,102,76,154,35,63,164,255,127,9,62,106,187,4,91,44,222,17,80,39,209,237,82,107,251,148,11,231,174,208,130,194,171,234,184,248,121,216,199,110,28,212,137,240,77,164,232,25,128,247,150,57,193,20,160,44,211,75,191,96,37,81,254,147,66,8,140,54,21,177,89,74,51,175,93,39,199,55,115,84,202,104,179,230,124,97,222,64,177,27,111,239,158,17,57,105,219,42,209,95,132,231,13,144,244,194,157,226,18,143,180,66,166,48,5,74,32,169,142,7,241,128,52,216,137,185,228,26,124,84,166,189,71,38,158,221,115,1,65,123,102,250,216,34,242,140,113,212,188,249,85,118,197,156,89,5,70,116,167,202,153,240,114,4,246,203,100,46,185,84,31,209,173,6,130,196,22,225,91,155,61,16,49,103,229,36,206,173,249,46,92,12,73,33,223,142,60,172,126,22,234,135,246,151,75,52,97,161,79,182,12,235,132,207,150,184,20,78,143,101,28,196,235,134,178,53,195,24,108,82,215,150,55,168,110,43,189,233,144,207,59,125,44,168,108,34,220,69,166,244,58,225,125,149,63,213,104,253,93,155,184,11,250,73,96,201,8,218,88,14,117,223,105,247,193,71,88,254,122,3,132,191,113,10,181,40,83,0,162,127,41,210,235,122,36,195,18,228,65,131,176,253,38,19,165,0,146,27,203,178,54,96,234,43,159,90,218,245,112,191,229,18,79,66,137,51,160,180,141,118,164,30,101,154,71,137,94,217,56,238,134,17,153,200,80,29,204,67,23,155,52,172,33,145,198,175,7,223,103,87,244,41,79,236,204,51,186,81,199,176,112,77,224,40,110,170,223,144,251,174,131,98,205,73,121,247,97,238,116,29,204,62,2,213,183,145,24,125,241,228,45,31,129,160,92,188,246,62,6,102,50,116,15,240,140,10,218,59,45,151,83,167,255,130,157,107,55,92,219,110,5,61,147,252,8,212,51,12,140,75,126,183,215,83,194,43,226,88,165,109,187,21,215,68,39,192,20,239,198,12,68,174,159,99,121,192,70,231,177,119,209,237,19,154,33,232,163,65,180,29,200,129,4,231,135,182,98,147,76,118,165,136,248,40,211,14,85,169,107,25,151,100,36,164,197,92,58,136,2,123,106,148,252,75,210,162,53,120,9,233,217,46,28,226,83,128,195,245,224,38,141,205,61,249,86,48,227,114,255,186,207,77,236,16,56,39,102,85,30,247,203,60,87,179,103,186,56,152,22,180,131,53,236,81,15,190,134,175,8,72,147,24,99,48,215,192,172,139,240,196,149,108,168,17,127,157,252,1,206,114,74,161,98,3,186,156,120,221,27,108,211,129,40,170,242,158,131,91,115,225,20,178,71,45,222,142,197,36,66,145,93,234,34,198,67,217,109,243,45,67,161,237,54,195,224,85,112,6,32,69,155,9,64,123,212,3,94,242,76,113,214,25,170,49,220,119,148,28,170,90,10,200,143,80,95,153,18,64,202,175,220,250,42,208,96,163,254,133,185,21,52,230,190,126,244,138,13,86,254,58,138,211,125,179,251,34,2,183,248,126,143,54,187,78,136,235,193,50,32,82,117,173,161,98,9,82,63,105,187,19,205,37,230,76,21,104,60,167,119,214,106,37,227,13,101,120,167,25,109,146,227,201,60,238,38,148,206,181,42,163,236,176,128,107,154,184,50,225,208,133,232,49,73,165,90,239,152,204,0,89,182,72,11,156,101,217,14,130,252,111,227,5,72,95,47,196,0,245,94,149,13,84,27,150,193,19,181,68,30,48,243,61,221,127,246,24,138,190,69,88,57,26,141,210,151,220,249,67,117,166,35,194,112,176,202,95,237,139,208,111,129,216,190,142,37,171,197,81,47,119,229,159,200,171,79,120,33,133,169,23,213,80,138,238,69,44,253,63,117,4,56,250,172,78,157,93,116,6,104,162,241,31,182,1,103,46,243,189,59]),n=new Uint8Array(2048);for(let o=0;o<1024;o++)n[2*o]=t[o],n[2*o+1]=e[o];const o=new ul(n,32,32,Z,O);return o.name="GTAO.noise",o.wrapS=b,o.wrapT=b,o.needsUpdate=!0,o}}class TC{constructor(t=4){this.pool=t,this.queue=[],this.workers=[],this.workersResolve=[],this.workerStatus=0}hr(t){if(!this.workers[t]){const e=this.workerCreator();e.addEventListener("message",this.dr.bind(this,t)),this.workers[t]=e}}Ar(){for(let t=0;t<this.pool;t++)if(!(this.workerStatus&1<<t))return t;return-1}dr(t,e){const n=this.workersResolve[t];if(n&&n(e),this.queue.length){const{resolve:e,msg:n,transfer:o}=this.queue.shift();this.workersResolve[t]=e,this.workers[t].postMessage(n,o)}else this.workerStatus^=1<<t}setWorkerCreator(t){this.workerCreator=t}setWorkerLimit(t){this.pool=t}postMessage(t,e){return new Promise(n=>{const o=this.Ar();-1!==o?(this.hr(o),this.workerStatus|=1<<o,this.workersResolve[o]=n,this.workers[o].postMessage(t,e)):this.queue.push({resolve:n,msg:t,transfer:e})})}dispose(){this.workers.forEach(t=>t.terminate()),this.workersResolve.length=0,this.workers.length=0,this.queue.length=0,this.workerStatus=0}}const BC=new WeakMap;let LC=0;class NC extends Vh{constructor(t){super(t),this.transcoderPath="",this.transcoderBinary=null,this.transcoderPending=null,this.workerPool=new TC,this.workerSourceURL="",this.workerConfig=null,"undefined"!=typeof MSC_TRANSCODER&&console.warn('v3d.KTX2Loader: Please update to latest "basis_transcoder". "msc_basis_transcoder" is no longer supported in three.js r125+.')}setTranscoderPath(t){return this.transcoderPath=t,this}setWorkerLimit(t){return this.workerPool.setWorkerLimit(t),this}detectSupport(t){return this.workerConfig={astcSupported:t.extensions.has("WEBGL_compressed_texture_astc"),etc1Supported:t.extensions.has("WEBGL_compressed_texture_etc1"),etc2Supported:t.extensions.has("WEBGL_compressed_texture_etc"),dxtSupported:t.extensions.has("WEBGL_compressed_texture_s3tc")&&t.extensions.has("WEBGL_compressed_texture_s3tc_srgb"),bptcSupported:t.extensions.has("EXT_texture_compression_bptc"),pvrtcSupported:t.extensions.has("WEBGL_compressed_texture_pvrtc")||t.extensions.has("WEBKIT_WEBGL_compressed_texture_pvrtc")},t.capabilities.isWebGL2&&(this.workerConfig.etc1Supported=!1),this}dispose(){return this.workerPool.dispose(),this.workerSourceURL&&URL.revokeObjectURL(this.workerSourceURL),this}init(){if(!this.transcoderPending){const t=new zh(this.manager);t.setPath(this.transcoderPath),t.setWithCredentials(this.withCredentials);const e=t.loadAsync("basis_transcoder.js"),n=new zh(this.manager);n.setPath(this.transcoderPath),n.setResponseType("arraybuffer"),n.setWithCredentials(this.withCredentials);const o=n.loadAsync("basis_transcoder.wasm");this.transcoderPending=Promise.all([e,o]).then(([t,e])=>{const n=NC.BasisWorker.toString(),o=["/* constants */","let _EngineFormat = "+JSON.stringify(NC.EngineFormat),"let _TranscoderFormat = "+JSON.stringify(NC.TranscoderFormat),"let _BasisFormat = "+JSON.stringify(NC.BasisFormat),"/* basis_transcoder.js */",t,"/* worker */",n.substring(n.indexOf("{")+1,n.lastIndexOf("}"))].join("\n");this.workerSourceURL=URL.createObjectURL(new Blob([o])),this.transcoderBinary=e,this.workerPool.setWorkerCreator(()=>{const t=new Worker(this.workerSourceURL),e=this.transcoderBinary.slice(0);return t.postMessage({type:"init",config:this.workerConfig,transcoderBinary:e},[e]),t})}),LC>0&&console.warn("v3d.KTX2Loader: Multiple active KTX2 loaders may cause performance issues. Use a single KTX2Loader instance, or call .dispose() on old instances."),LC++}return this.transcoderPending}load(t,e,n,o){if(null===this.workerConfig)throw new Error("v3d.KTX2Loader: Missing initialization with `.detectSupport(renderer)`.");const i=new zh(this.manager);i.setResponseType("arraybuffer"),i.setWithCredentials(this.withCredentials);const r=new Ul;return i.load(t,t=>{if(BC.has(t)){return BC.get(t).promise.then(e).catch(o)}this.vr([t]).then(function(t){r.copy(t),r.needsUpdate=!0,e&&e(r)}).catch(o)},n,o),r}mr(t){const{mipmaps:e,width:n,height:o,format:i,type:r,error:s,dfdTransferFn:a,dfdFlags:l}=t;if("error"===r)return Promise.reject(s);const c=new Ul(e,n,o,i,O);return c.minFilter=1===e.length?N:P,c.magFilter=N,c.generateMipmaps=!1,c.needsUpdate=!0,c.encoding=2===a?Ft:Ot,c.premultiplyAlpha=!!(1&l),c}vr(t,e={}){const n=e,o=this.init().then(()=>this.workerPool.postMessage({type:"transcode",buffers:t,taskConfig:n},t)).then(t=>this.mr(t.data));return BC.set(t[0],{promise:o}),o}dispose(){return URL.revokeObjectURL(this.workerSourceURL),this.workerPool.dispose(),LC--,this}}NC.BasisFormat={ETC1S:0,UASTC_4x4:1},NC.TranscoderFormat={ETC1:0,ETC2:1,BC1:2,BC3:3,BC4:4,BC5:5,BC7_M6_OPAQUE_ONLY:6,BC7_M5:7,PVRTC1_4_RGB:8,PVRTC1_4_RGBA:9,ASTC_4x4:10,ATC_RGB:11,ATC_RGBA_INTERPOLATED_ALPHA:12,RGBA32:13,RGB565:14,BGR565:15,RGBA4444:16},NC.EngineFormat={RGBAFormat:W,RGBA_ASTC_4x4_Format:ut,RGBA_BPTC_Format:It,RGBA_ETC2_EAC_Format:ct,RGBA_PVRTC_4BPPV1_Format:rt,RGBA_S3TC_DXT5_Format:nt,RGB_ETC1_Format:at,RGB_ETC2_Format:lt,RGB_PVRTC_4BPPV1_Format:ot,RGB_S3TC_DXT1_Format:$},NC.BasisWorker=function(){let t,e,n;const o=_EngineFormat,i=_TranscoderFormat,r=_BasisFormat;self.addEventListener("message",function(s){const u=s.data;switch(u.type){case"init":t=u.config,h=u.transcoderBinary,e=new Promise(t=>{n={wasmBinary:h,onRuntimeInitialized:t},BASIS(n)}).then(()=>{n.initializeBasis(),void 0===n.KTX2File&&console.warn("v3d.KTX2Loader: Please update Basis Universal transcoder.")});break;case"transcode":e.then(()=>{try{const{width:e,height:s,hasAlpha:h,mipmaps:f,format:d,dfdTransferFn:A,dfdFlags:v}=function(e){const s=new n.KTX2File(new Uint8Array(e));function u(){s.close(),s.delete()}if(!s.isValid())throw u(),new Error("v3d.KTX2Loader:    Invalid or unsupported .ktx2 file");const h=s.isUASTC()?r.UASTC_4x4:r.ETC1S,f=s.getWidth(),d=s.getHeight(),A=s.getLevels(),v=s.getHasAlpha(),m=s.getDFDTransferFunc(),p=s.getDFDFlags(),{transcoderFormat:g,engineFormat:_}=function(e,n,s,u){let h,f;const d=e===r.ETC1S?a:l;for(let o=0;o<d.length;o++){const i=d[o];if(t[i.if]&&(i.basisFormat.includes(e)&&!(u&&i.transcoderFormat.length<2)&&(!i.needsPowerOfTwo||c(n)&&c(s))))return h=i.transcoderFormat[u?1:0],f=i.engineFormat[u?1:0],{transcoderFormat:h,engineFormat:f}}return console.warn("v3d.KTX2Loader: No suitable compressed texture format found. Decoding to RGBA32."),h=i.RGBA32,f=o.RGBAFormat,{transcoderFormat:h,engineFormat:f}}(h,f,d,v);if(!f||!d||!A)throw u(),new Error("v3d.KTX2Loader:    Invalid texture");if(!s.startTranscoding())throw u(),new Error("v3d.KTX2Loader: .startTranscoding failed");const E=[];for(let t=0;t<A;t++){const e=s.getImageLevelInfo(t,0,0),n=e.origWidth,o=e.origHeight,i=new Uint8Array(s.getImageTranscodedSizeInBytes(t,0,0,g));if(!s.transcodeImage(i,t,0,0,g,0,-1,-1))throw u(),new Error("v3d.KTX2Loader: .transcodeImage failed.");E.push({data:i,width:n,height:o})}return u(),{width:f,height:d,hasAlpha:v,mipmaps:E,format:_,dfdTransferFn:m,dfdFlags:p}}(u.buffers[0]),m=[];for(let t=0;t<f.length;++t)m.push(f[t].data.buffer);self.postMessage({type:"transcode",id:u.id,width:e,height:s,hasAlpha:h,mipmaps:f,format:d,dfdTransferFn:A,dfdFlags:v},m)}catch(t){console.error(t),self.postMessage({type:"error",id:u.id,error:t.message})}})}var h});const s=[{if:"astcSupported",basisFormat:[r.UASTC_4x4],transcoderFormat:[i.ASTC_4x4,i.ASTC_4x4],engineFormat:[o.RGBA_ASTC_4x4_Format,o.RGBA_ASTC_4x4_Format],priorityETC1S:1/0,priorityUASTC:1,needsPowerOfTwo:!1},{if:"bptcSupported",basisFormat:[r.ETC1S,r.UASTC_4x4],transcoderFormat:[i.BC7_M5,i.BC7_M5],engineFormat:[o.RGBA_BPTC_Format,o.RGBA_BPTC_Format],priorityETC1S:3,priorityUASTC:2,needsPowerOfTwo:!1},{if:"dxtSupported",basisFormat:[r.ETC1S,r.UASTC_4x4],transcoderFormat:[i.BC1,i.BC3],engineFormat:[o.RGB_S3TC_DXT1_Format,o.RGBA_S3TC_DXT5_Format],priorityETC1S:4,priorityUASTC:5,needsPowerOfTwo:!1},{if:"etc2Supported",basisFormat:[r.ETC1S,r.UASTC_4x4],transcoderFormat:[i.ETC1,i.ETC2],engineFormat:[o.RGB_ETC2_Format,o.RGBA_ETC2_EAC_Format],priorityETC1S:1,priorityUASTC:3,needsPowerOfTwo:!1},{if:"etc1Supported",basisFormat:[r.ETC1S,r.UASTC_4x4],transcoderFormat:[i.ETC1],engineFormat:[o.RGB_ETC1_Format],priorityETC1S:2,priorityUASTC:4,needsPowerOfTwo:!1},{if:"pvrtcSupported",basisFormat:[r.ETC1S,r.UASTC_4x4],transcoderFormat:[i.PVRTC1_4_RGB,i.PVRTC1_4_RGBA],engineFormat:[o.RGB_PVRTC_4BPPV1_Format,o.RGBA_PVRTC_4BPPV1_Format],priorityETC1S:5,priorityUASTC:6,needsPowerOfTwo:!0}],a=s.sort(function(t,e){return t.priorityETC1S-e.priorityETC1S}),l=s.sort(function(t,e){return t.priorityUASTC-e.priorityUASTC});function c(t){return t<=2||!(t&t-1)&&0!==t}};class DC{static fromCubeTexture(t){let e=0;const n=new An,o=new An,i=new tn,r=[0,0,0,0,0,0,0,0,0],s=new wf,a=s.coefficients;for(let s=0;s<6;s++){const l=t.image[s],c=l.width,u=l.height,h=document.createElement("canvas");h.width=c,h.height=u;const f=h.getContext("2d");f.drawImage(l,0,0,c,u);const d=f.getImageData(0,0,c,u),A=d.data,v=d.width,m=2/v;for(let l=0,c=A.length;l<c;l+=4){i.setRGB(A[l]/255,A[l+1]/255,A[l+2]/255),PC(i,t.encoding);const c=l/4,u=(c%v+.5)*m-1,h=1-(Math.floor(c/v)+.5)*m;switch(s){case 0:n.set(-1,h,-u);break;case 1:n.set(1,h,u);break;case 2:n.set(-u,1,-h);break;case 3:n.set(-u,-1,h);break;case 4:n.set(-u,h,1);break;case 5:n.set(u,h,-1)}const f=n.lengthSq(),d=4/(Math.sqrt(f)*f);e+=d,o.copy(n).normalize(),wf.getBasisAt(o,r);for(let t=0;t<9;t++)a[t].x+=r[t]*i.r*d,a[t].y+=r[t]*i.g*d,a[t].z+=r[t]*i.b*d}}const l=4*Math.PI/e;for(let t=0;t<9;t++)a[t].x*=l,a[t].y*=l,a[t].z*=l;return new xf(s)}static fromCubeRenderTarget(t,e){let n=0;const o=new An,i=new An,r=new tn,s=[0,0,0,0,0,0,0,0,0],a=new wf,l=a.coefficients,c=e.texture.type;for(let a=0;a<6;a++){const u=e.width,h=new(c===Q?Uint16Array:c===G?Float32Array:Uint8Array)(u*u*4);t.readRenderTargetPixels(e,0,0,u,u,h,a);const f=2/u;for(let t=0,d=h.length;t<d;t+=4){c===Q?r.setRGB(zd(h[t]),zd(h[t+1]),zd(h[t+2])):c===G?r.setRGB(h[t],h[t+1],h[t+2]):r.setRGB(h[t]/255,h[t+1]/255,h[t+2]/255),PC(r,e.texture.encoding);const d=t/4,A=(d%u+.5)*f-1,v=1-(Math.floor(d/u)+.5)*f;switch(a){case 0:o.set(1,v,-A);break;case 1:o.set(-1,v,A);break;case 2:o.set(A,1,-v);break;case 3:o.set(A,-1,v);break;case 4:o.set(A,v,1);break;case 5:o.set(-A,v,-1)}const m=o.lengthSq(),p=4/(Math.sqrt(m)*m);n+=p,i.copy(o).normalize(),wf.getBasisAt(i,s);for(let t=0;t<9;t++)l[t].x+=s[t]*r.r*p,l[t].y+=s[t]*r.g*p,l[t].z+=s[t]*r.b*p}}const u=4*Math.PI/n;for(let t=0;t<9;t++)l[t].x*=u,l[t].y*=u,l[t].z*=u;return new xf(a)}}function PC(t,e){switch(e){case Ft:t.convertSRGBToLinear();break;case Ot:break;default:console.warn("WARNING: LightProbeGenerator convertColorToLinear() encountered an unsupported encoding.")}return t}class OC extends Sl{constructor(t,e){const n=new Xo;n.setAttribute("position",new Vo([1,1,0,-1,1,0,-1,-1,0,1,-1,0,1,1,0],3)),n.computeBoundingSphere();super(n,new El({fog:!1})),this.light=t,this.color=e,this.type="RectAreaLightHelper";const o=new Xo;o.setAttribute("position",new Vo([1,1,0,-1,1,0,-1,-1,0,1,1,0,-1,-1,0,1,-1,0],3)),o.computeBoundingSphere(),this.add(new hi(o,new No({side:1,fog:!1})))}updateMatrixWorld(){if(this.scale.set(.5*this.light.width,.5*this.light.height,1),void 0!==this.color)this.material.color.set(this.color),this.children[0].material.color.set(this.color);else{this.material.color.copy(this.light.color).multiplyScalar(this.light.intensity);const t=this.material.color,e=Math.max(t.r,t.g,t.b);e>1&&t.multiplyScalar(1/e),this.children[0].material.color.copy(this.material.color)}this.matrixWorld.extractRotation(this.light.matrixWorld).scale(this.scale).copyPosition(this.light.matrixWorld),this.children[0].matrixWorld.copy(this.matrixWorld)}dispose(){this.geometry.dispose(),this.material.dispose(),this.children[0].geometry.dispose(),this.children[0].material.dispose()}}var FC=function(){var t=0,e=document.createElement("div");function n(t){return e.appendChild(t.dom),t}function o(n){for(var o=0;o<e.children.length;o++)e.children[o].style.display=o===n?"block":"none";t=n}e.style.cssText="position:absolute;top:0;left:0;cursor:pointer;opacity:0.9;z-index:10000",e.addEventListener("click",function(n){n.preventDefault(),o(++t%e.children.length)},!1);var i=(performance||Date).now(),r=i,s=0,a=n(new FC.Panel("FPS","#0ff","#002")),l=n(new FC.Panel("MS","#0f0","#020"));if(self.performance&&self.performance.memory)var c=n(new FC.Panel("MB","#f08","#201"));return o(0),{REVISION:16,dom:e,addPanel:n,showPanel:o,begin:function(){i=(performance||Date).now()},end:function(){s++;var t=(performance||Date).now();if(l.update(t-i,200),t>=r+1e3&&(a.update(1e3*s/(t-r),100),r=t,s=0,c)){var e=performance.memory;c.update(e.usedJSHeapSize/1048576,e.jsHeapSizeLimit/1048576)}return t},update:function(){i=this.end()}}};FC.Panel=function(t,e,n){var o=1/0,i=0,r=Math.round,s=r(window.devicePixelRatio||1),a=80*s,l=48*s,c=3*s,u=2*s,h=3*s,f=15*s,d=74*s,A=30*s,v=document.createElement("canvas");v.width=a,v.height=l,v.style.cssText="width:80px;height:48px";var m=v.getContext("2d");return m.font="bold "+9*s+"px Helvetica,Arial,sans-serif",m.textBaseline="top",m.fillStyle=n,m.fillRect(0,0,a,l),m.fillStyle=e,m.fillText(t,c,u),m.fillRect(h,f,d,A),m.fillStyle=n,m.globalAlpha=.9,m.fillRect(h,f,d,A),{dom:v,update:function(l,p){o=Math.min(o,l),i=Math.max(i,l),m.fillStyle=n,m.globalAlpha=1,m.fillRect(0,0,a,f),m.fillStyle=e,m.fillText(r(l)+" "+t+" ("+r(o)+"-"+r(i)+")",c,u),m.drawImage(v,h+s,f,d-s,A,h,f,d-s,A),m.fillRect(h+d-s,f,s,A),m.fillStyle=n,m.globalAlpha=.9,m.fillRect(h+d-s,f,s,r((1-l/p)*A))}}};const UC=new An,VC=new An;class GC extends Rl{constructor(t,e=1,n=16711680){var o;const i=new Xo;if(null==(o=t.geometry)?void 0:o.attributes.normal){const e=t.geometry.attributes.normal.count,n=new Vo(2*e*3,3);i.setAttribute("position",n)}super(i,new El({color:n,toneMapped:!1})),this.object=t,this.size=e,this.type="VertexNormalsHelper",this.matrixAutoUpdate=!1,this.update()}update(){var t,e;const n=this.geometry.attributes.position,o=null==(t=this.object.geometry)?void 0:t.attributes.position,i=null==(e=this.object.geometry)?void 0:e.attributes.normal;if(n&&o&&i){let t=0;for(let e=0,r=o.count;e<r;e++)UC.fromBufferAttribute(o,e),VC.fromBufferAttribute(i,e),VC.normalize().multiplyScalar(this.size).add(UC),n.setXYZ(t,UC.x,UC.y,UC.z),t+=1,n.setXYZ(t,VC.x,VC.y,VC.z),t+=1;n.needsUpdate=!0}}dispose(){this.geometry.dispose(),this.material.dispose()}}class QC extends Rl{constructor(t,e="white"){super(new kc(t.geometry),new El({color:e})),this.type="WireframeHelper",this.matrixAutoUpdate=!1}dispose(){this.geometry.dispose(),this.material.dispose()}}const zC=1.25,kC=65535,HC=Math.pow(2,-24),WC=Symbol("SKIP_GENERATION");function YC(t){return function(t){return t.index?t.index.count:t.attributes.position.count}(t)/3}function XC(t,e){if(!t.index){const n=t.attributes.position.count,o=function(t,e=ArrayBuffer){return t>65535?new Uint32Array(new e(4*t)):new Uint16Array(new e(2*t))}(n,e.useSharedArrayBuffer?SharedArrayBuffer:ArrayBuffer);t.setIndex(new Oo(o,1));for(let t=0;t<n;t++)o[t]=t}}function KC(t,e){const n=YC(t),o=e||t.drawRange,i=o.start/3,r=(o.start+o.count)/3,s=Math.max(0,i),a=Math.min(n,r)-s;return[{offset:Math.floor(s),count:Math.floor(a)}]}function jC(t,e){if(!t.groups||!t.groups.length)return KC(t,e);const n=[],o=new Set,i=e||t.drawRange,r=i.start/3,s=(i.start+i.count)/3;for(const e of t.groups){const t=e.start/3,n=(e.start+e.count)/3;o.add(Math.max(r,t)),o.add(Math.min(s,n))}const a=Array.from(o.values()).sort((t,e)=>t-e);for(let t=0;t<a.length-1;t++){const e=a[t],o=a[t+1];n.push({offset:Math.floor(e),count:Math.floor(o-e)})}return n}function ZC(t,e,n,o,i){let r=1/0,s=1/0,a=1/0,l=-1/0,c=-1/0,u=-1/0,h=1/0,f=1/0,d=1/0,A=-1/0,v=-1/0,m=-1/0;for(let o=6*e,i=6*(e+n);o<i;o+=6){const e=t[o+0],n=t[o+1],i=e-n,p=e+n;i<r&&(r=i),p>l&&(l=p),e<h&&(h=e),e>A&&(A=e);const g=t[o+2],_=t[o+3],E=g-_,C=g+_;E<s&&(s=E),C>c&&(c=C),g<f&&(f=g),g>v&&(v=g);const w=t[o+4],x=t[o+5],I=w-x,M=w+x;I<a&&(a=I),M>u&&(u=M),w<d&&(d=w),w>m&&(m=w)}o[0]=r,o[1]=s,o[2]=a,o[3]=l,o[4]=c,o[5]=u,i[0]=h,i[1]=f,i[2]=d,i[3]=A,i[4]=v,i[5]=m}function qC(t,e,n){return n.min.x=e[t],n.min.y=e[t+1],n.min.z=e[t+2],n.max.x=e[t+3],n.max.y=e[t+4],n.max.z=e[t+5],n}function JC(t){let e=-1,n=-1/0;for(let o=0;o<3;o++){const i=t[o+3]-t[o];i>n&&(n=i,e=o)}return e}function $C(t,e){e.set(t)}function tw(t,e,n){let o,i;for(let r=0;r<3;r++){const s=r+3;o=t[r],i=e[r],n[r]=o<i?o:i,o=t[s],i=e[s],n[s]=o>i?o:i}}function ew(t,e,n){for(let o=0;o<3;o++){const i=e[t+2*o],r=e[t+2*o+1],s=i-r,a=i+r;s<n[o]&&(n[o]=s),a>n[o+3]&&(n[o+3]=a)}}function nw(t){const e=t[3]-t[0],n=t[4]-t[1],o=t[5]-t[2];return 2*(e*n+n*o+o*e)}const ow=32,iw=(t,e)=>t.candidate-e.candidate,rw=new Array(ow).fill().map(()=>({count:0,bounds:new Float32Array(6),rightCacheBounds:new Float32Array(6),leftCacheBounds:new Float32Array(6),candidate:0})),sw=new Float32Array(6);class aw{constructor(){this.boundingData=new Float32Array(6)}}function lw(t,e,n,o,i,r){let s=o,a=o+i-1;const l=r.pos,c=2*r.axis;for(;;){for(;s<=a&&n[6*s+c]<l;)s++;for(;s<=a&&n[6*a+c]>=l;)a--;if(!(s<a))return s;for(let t=0;t<3;t++){let n=e[3*s+t];e[3*s+t]=e[3*a+t],e[3*a+t]=n}for(let t=0;t<6;t++){let e=n[6*s+t];n[6*s+t]=n[6*a+t],n[6*a+t]=e}s++,a--}}function cw(t,e,n,o,i,r){let s=o,a=o+i-1;const l=r.pos,c=2*r.axis;for(;;){for(;s<=a&&n[6*s+c]<l;)s++;for(;s<=a&&n[6*a+c]>=l;)a--;if(!(s<a))return s;{let e=t[s];t[s]=t[a],t[a]=e;for(let t=0;t<6;t++){let e=n[6*s+t];n[6*s+t]=n[6*a+t],n[6*a+t]=e}s++,a--}}}function uw(t,e){return 65535===e[t+15]}function hw(t,e){return e[t+6]}function fw(t,e){return e[t+14]}function dw(t){return t+8}function Aw(t,e){return e[t+6]}function vw(t,e){return e[t+7]}function mw(t){return t}let pw,gw,_w,Ew;const Cw=Math.pow(2,32);function ww(t){return"count"in t?1:1+ww(t.left)+ww(t.right)}function xw(t,e,n){return pw=new Float32Array(n),gw=new Uint32Array(n),_w=new Uint16Array(n),Ew=new Uint8Array(n),Iw(t,e)}function Iw(t,e){const n=t/4,o=t/2,i="count"in e,r=e.boundingData;for(let t=0;t<6;t++)pw[n+t]=r[t];if(i){if(e.buffer){const o=e.buffer;Ew.set(new Uint8Array(o),t);for(let e=t,i=t+o.byteLength;e<i;e+=32){uw(e/2,_w)||(gw[e/4+6]+=n)}return t+o.byteLength}{const i=e.offset,r=e.count;return gw[n+6]=i,_w[o+14]=r,_w[o+15]=kC,t+32}}{const o=e.left,i=e.right,r=e.splitAxis;let s;if(s=Iw(t+32,o),s/4>Cw)throw new Error("MeshBVH: Cannot store child pointer greater than 32 bits.");return gw[n+6]=s/4,s=Iw(s,i),gw[n+7]=r,s}}function Mw(t,e,n,o,i){const{maxDepth:r,verbose:s,maxLeafTris:a,strategy:l,onProgress:c,indirect:u}=i,h=t.pr,f=t.geometry,d=f.index?f.index.array:null,A=u?cw:lw,v=YC(f),m=new Float32Array(6);let p=!1;const g=new aw;return ZC(e,n,o,g.boundingData,m),function t(n,o,i,c=null,u=0){!p&&u>=r&&(p=!0,s&&(console.warn(`MeshBVH: Max depth of ${r} reached when generating BVH. Consider increasing maxDepth.`),console.warn(f)));if(i<=a||u>=r)return _(o+i),n.offset=o,n.count=i,n;const v=function(t,e,n,o,i,r){let s=-1,a=0;if(0===r)s=JC(e),-1!==s&&(a=(e[s]+e[s+3])/2);else if(1===r)s=JC(t),-1!==s&&(a=function(t,e,n,o){let i=0;for(let r=e,s=e+n;r<s;r++)i+=t[6*r+2*o];return i/n}(n,o,i,s));else if(2===r){const r=nw(t);let l=zC*i;const c=6*o,u=6*(o+i);for(let t=0;t<3;t++){const o=e[t],h=(e[t+3]-o)/ow;if(i<8){const e=[...rw];e.length=i;let o=0;for(let i=c;i<u;i+=6,o++){const r=e[o];r.candidate=n[i+2*t],r.count=0;const{bounds:s,leftCacheBounds:a,rightCacheBounds:l}=r;for(let t=0;t<3;t++)l[t]=1/0,l[t+3]=-1/0,a[t]=1/0,a[t+3]=-1/0,s[t]=1/0,s[t+3]=-1/0;ew(i,n,s)}e.sort(iw);let h=i;for(let t=0;t<h;t++){const n=e[t];for(;t+1<h&&e[t+1].candidate===n.candidate;)e.splice(t+1,1),h--}for(let o=c;o<u;o+=6){const i=n[o+2*t];for(let t=0;t<h;t++){const r=e[t];i>=r.candidate?ew(o,n,r.rightCacheBounds):(ew(o,n,r.leftCacheBounds),r.count++)}}for(let n=0;n<h;n++){const o=e[n],c=o.count,u=i-o.count,h=o.leftCacheBounds,f=o.rightCacheBounds;let d=0;0!==c&&(d=nw(h)/r);let A=0;0!==u&&(A=nw(f)/r);const v=1+zC*(d*c+A*u);v<l&&(s=t,l=v,a=o.candidate)}}else{for(let t=0;t<ow;t++){const e=rw[t];e.count=0,e.candidate=o+h+t*h;const n=e.bounds;for(let t=0;t<3;t++)n[t]=1/0,n[t+3]=-1/0}for(let e=c;e<u;e+=6){let i=~~((n[e+2*t]-o)/h);i>=ow&&(i=31);const r=rw[i];r.count++,ew(e,n,r.bounds)}const e=rw[31];$C(e.bounds,e.rightCacheBounds);for(let t=30;t>=0;t--){const e=rw[t],n=rw[t+1];tw(e.bounds,n.rightCacheBounds,e.rightCacheBounds)}let f=0;for(let e=0;e<31;e++){const n=rw[e],o=n.count,c=n.bounds,u=rw[e+1].rightCacheBounds;0!==o&&(0===f?$C(c,sw):tw(c,sw,sw)),f+=o;let h=0,d=0;0!==f&&(h=nw(sw)/r);const A=i-f;0!==A&&(d=nw(u)/r);const v=1+zC*(h*f+d*A);v<l&&(s=t,l=v,a=n.candidate)}}}}else console.warn(`MeshBVH: Invalid build strategy value ${r} used.`);return{axis:s,pos:a}}(n.boundingData,c,e,o,i,l);if(-1===v.axis)return _(o+i),n.offset=o,n.count=i,n;const g=A(h,d,e,o,i,v);if(g===o||g===o+i)_(o+i),n.offset=o,n.count=i;else{n.splitAxis=v.axis;const r=new aw,s=o,a=g-o;n.left=r,ZC(e,s,a,r.boundingData,m),t(r,s,a,m,u+1);const l=new aw,c=g,h=i-a;n.right=l,ZC(e,c,h,l.boundingData,m),t(l,c,h,m,u+1)}return n}(g,n,o,m),g;function _(t){c&&c(t/v)}}function Sw(t,e){const n=t.geometry;e.indirect&&(t.pr=function(t,e){const n=(t.index?t.index.count:t.attributes.position.count)/3,o=n>65536,i=o?4:2,r=e?new SharedArrayBuffer(n*i):new ArrayBuffer(n*i),s=o?new Uint32Array(r):new Uint16Array(r);for(let t=0,e=s.length;t<e;t++)s[t]=t;return s}(n,e.useSharedArrayBuffer),function(t,e){const n=YC(t),o=jC(t,e).sort((t,e)=>t.offset-e.offset),i=o[o.length-1];i.count=Math.min(n-i.offset,i.count);let r=0;return o.forEach(({count:t})=>r+=t),n!==r}(n,e.range)&&!e.verbose&&console.warn('MeshBVH: Provided geometry contains groups or a range that do not fully span the vertex contents while using the "indirect" option. BVH may incorrectly report intersections on unrendered portions of the geometry.')),t.pr||XC(n,e);const o=e.useSharedArrayBuffer?SharedArrayBuffer:ArrayBuffer,i=function(t,e=null,n=null,o=null){const i=t.attributes.position,r=t.index?t.index.array:null,s=YC(t),a=i.normalized;let l;null===e?(l=new Float32Array(6*s),n=0,o=s):(l=e,n=n||0,o=o||s);const c=i.array,u=i.offset||0,h=["getX","getY","getZ"];for(let t=n;t<n+o;t++){const e=3*t,n=6*t;let o=e+0,s=e+1,f=e+2;r&&(o=r[o],s=r[s],f=r[f]),a||(o=3*o+u,s=3*s+u,f=3*f+u);for(let t=0;t<3;t++){let e,r,u;a?(e=i[h[t]](o),r=i[h[t]](s),u=i[h[t]](f)):(e=c[o+t],r=c[s+t],u=c[f+t]);let d=e;r<d&&(d=r),u<d&&(d=u);let A=e;r>A&&(A=r),u>A&&(A=u);const v=(A-d)/2,m=2*t;l[n+m+0]=d+v,l[n+m+1]=v+(Math.abs(d)+v)*HC}}return l}(n),r=e.indirect?KC(n,e.range):jC(n,e.range);t.gr=r.map(n=>{const r=Mw(t,i,n.offset,n.count,e),s=ww(r),a=new o(32*s);return xw(0,r,a),a})}class bw{constructor(){this.min=1/0,this.max=-1/0}setFromPointsField(t,e){let n=1/0,o=-1/0;for(let i=0,r=t.length;i<r;i++){const r=t[i][e];n=r<n?r:n,o=r>o?r:o}this.min=n,this.max=o}setFromPoints(t,e){let n=1/0,o=-1/0;for(let i=0,r=e.length;i<r;i++){const r=e[i],s=t.dot(r);n=s<n?s:n,o=s>o?s:o}this.min=n,this.max=o}isSeparated(t){return this.min>t.max||t.min>this.max}}bw.prototype.setFromBox=function(){const t=new An;return function(e,n){const o=n.min,i=n.max;let r=1/0,s=-1/0;for(let n=0;n<=1;n++)for(let a=0;a<=1;a++)for(let l=0;l<=1;l++){t.x=o.x*n+i.x*(1-n),t.y=o.y*a+i.y*(1-a),t.z=o.z*l+i.z*(1-l);const c=e.dot(t);r=Math.min(c,r),s=Math.max(c,s)}this.min=r,this.max=s}}();const yw=function(){const t=new An,e=new An,n=new An;return function(o,i,r){const s=o.start,a=t,l=i.start,c=e;n.subVectors(s,l),t.subVectors(o.end,o.start),e.subVectors(i.end,i.start);const u=n.dot(c),h=c.dot(a),f=c.dot(c),d=n.dot(a),A=a.dot(a)*f-h*h;let v,m;v=0!==A?(u*h-d*f)/A:0,m=(u+v*h)/f,r.x=v,r.y=m}}(),Rw=function(){const t=new we,e=new An,n=new An;return function(o,i,r,s){yw(o,i,t);let a=t.x,l=t.y;if(a>=0&&a<=1&&l>=0&&l<=1)return o.at(a,r),void i.at(l,s);if(a>=0&&a<=1)return l<0?i.at(0,s):i.at(1,s),void o.closestPointToPoint(s,!0,r);if(l>=0&&l<=1)return a<0?o.at(0,r):o.at(1,r),void i.closestPointToPoint(r,!0,s);{let t,c;t=a<0?o.start:o.end,c=l<0?i.start:i.end;const u=e,h=n;return o.closestPointToPoint(c,!0,e),i.closestPointToPoint(t,!0,n),u.distanceToSquared(c)<=h.distanceToSquared(t)?(r.copy(u),void s.copy(c)):(r.copy(t),void s.copy(h))}}}(),Tw=function(){const t=new An,e=new An,n=new Ri,o=new gd;return function(i,r){const{radius:s,center:a}=i,{a:l,b:c,c:u}=r;o.start=l,o.end=c;if(o.closestPointToPoint(a,!0,t).distanceTo(a)<=s)return!0;o.start=l,o.end=u;if(o.closestPointToPoint(a,!0,t).distanceTo(a)<=s)return!0;o.start=c,o.end=u;if(o.closestPointToPoint(a,!0,t).distanceTo(a)<=s)return!0;const h=r.getPlane(n);if(Math.abs(h.distanceToPoint(a))<=s){const t=h.projectPoint(a,e);if(r.containsPoint(t))return!0}return!1}}();function Bw(t){return Math.abs(t)<1e-15}class Lw extends To{constructor(...t){super(...t),this.isExtendedTriangle=!0,this.satAxes=new Array(4).fill().map(()=>new An),this.satBounds=new Array(4).fill().map(()=>new bw),this.points=[this.a,this.b,this.c],this.sphere=new Pn,this.plane=new Ri,this.needsUpdate=!0}intersectsSphere(t){return Tw(t,this)}update(){const t=this.a,e=this.b,n=this.c,o=this.points,i=this.satAxes,r=this.satBounds,s=i[0],a=r[0];this.getNormal(s),a.setFromPoints(s,o);const l=i[1],c=r[1];l.subVectors(t,e),c.setFromPoints(l,o);const u=i[2],h=r[2];u.subVectors(e,n),h.setFromPoints(u,o);const f=i[3],d=r[3];f.subVectors(n,t),d.setFromPoints(f,o),this.sphere.setFromPoints(this.points),this.plane.setFromNormalAndCoplanarPoint(s,t),this.needsUpdate=!1}}Lw.prototype.closestPointToSegment=function(){const t=new An,e=new An,n=new gd;return function(o,i=null,r=null){const{start:s,end:a}=o,l=this.points;let c,u=1/0;for(let s=0;s<3;s++){const a=(s+1)%3;n.start.copy(l[s]),n.end.copy(l[a]),Rw(n,o,t,e),c=t.distanceToSquared(e),c<u&&(u=c,i&&i.copy(t),r&&r.copy(e))}return this.closestPointToPoint(s,t),c=s.distanceToSquared(t),c<u&&(u=c,i&&i.copy(t),r&&r.copy(s)),this.closestPointToPoint(a,t),c=a.distanceToSquared(t),c<u&&(u=c,i&&i.copy(t),r&&r.copy(a)),Math.sqrt(u)}}(),Lw.prototype.intersectsTriangle=function(){const t=new Lw,e=new Array(3),n=new Array(3),o=new bw,i=new bw,r=new An,s=new An,a=new An,l=new An,c=new An,u=new gd,h=new gd,f=new gd,d=new An;function A(t,e,n){const o=t.points;let i=0,r=-1;for(let t=0;t<3;t++){const{start:a,end:l}=u;a.copy(o[t]),l.copy(o[(t+1)%3]),u.delta(s);const c=Bw(e.distanceToPoint(a));if(Bw(e.normal.dot(s))&&c){n.copy(u),i=2;break}const h=e.intersectLine(u,d);if(!h&&c&&d.copy(a),(h||c)&&!Bw(d.distanceTo(l))){if(i<=1){(1===i?n.start:n.end).copy(d),c&&(r=i)}else if(i>=2){(1===r?n.start:n.end).copy(d),i=2;break}if(i++,2===i&&-1===r)break}}return i}return function(s,u=null,d=!1){this.needsUpdate&&this.update(),s.isExtendedTriangle?s.needsUpdate&&s.update():(t.copy(s),t.update(),s=t);const v=this.plane,m=s.plane;if(Math.abs(v.normal.dot(m.normal))>1-1e-10){const t=this.satBounds,a=this.satAxes;n[0]=s.a,n[1]=s.b,n[2]=s.c;for(let e=0;e<4;e++){const i=t[e],r=a[e];if(o.setFromPoints(r,n),i.isSeparated(o))return!1}const l=s.satBounds,c=s.satAxes;e[0]=this.a,e[1]=this.b,e[2]=this.c;for(let t=0;t<4;t++){const n=l[t],i=c[t];if(o.setFromPoints(i,e),n.isSeparated(o))return!1}for(let t=0;t<4;t++){const s=a[t];for(let t=0;t<4;t++){const a=c[t];if(r.crossVectors(s,a),o.setFromPoints(r,e),i.setFromPoints(r,n),o.isSeparated(i))return!1}}return u&&(d||console.warn("ExtendedTriangle.intersectsTriangle: Triangles are coplanar which does not support an output edge. Setting edge to 0, 0, 0."),u.start.set(0,0,0),u.end.set(0,0,0)),!0}{const t=A(this,m,h);if(1===t&&s.containsPoint(h.end))return u&&(u.start.copy(h.end),u.end.copy(h.end)),!0;if(2!==t)return!1;const e=A(s,v,f);if(1===e&&this.containsPoint(f.end))return u&&(u.start.copy(f.end),u.end.copy(f.end)),!0;if(2!==e)return!1;if(h.delta(a),f.delta(l),a.dot(l)<0){let t=f.start;f.start=f.end,f.end=t}const n=h.start.dot(a),o=h.end.dot(a),i=f.start.dot(a),r=f.end.dot(a);return(n===r||i===o||o<i!==n<r)&&(u&&(c.subVectors(h.start,f.start),c.dot(a)>0?u.start.copy(h.start):u.start.copy(f.start),c.subVectors(h.end,f.end),c.dot(a)<0?u.end.copy(h.end):u.end.copy(f.end)),!0)}}}(),Lw.prototype.distanceToPoint=function(){const t=new An;return function(e){return this.closestPointToPoint(e,t),e.distanceTo(t)}}(),Lw.prototype.distanceToTriangle=function(){const t=new An,e=new An,n=["a","b","c"],o=new gd,i=new gd;return function(r,s=null,a=null){const l=s||a?o:null;if(this.intersectsTriangle(r,l))return(s||a)&&(s&&l.getCenter(s),a&&l.getCenter(a)),0;let c=1/0;for(let e=0;e<3;e++){let o;const i=n[e],l=r[i];this.closestPointToPoint(l,t),o=l.distanceToSquared(t),o<c&&(c=o,s&&s.copy(t),a&&a.copy(l));const u=this[i];r.closestPointToPoint(u,t),o=u.distanceToSquared(t),o<c&&(c=o,s&&s.copy(u),a&&a.copy(t))}for(let l=0;l<3;l++){const u=n[l],h=n[(l+1)%3];o.set(this[u],this[h]);for(let l=0;l<3;l++){const u=n[l],h=n[(l+1)%3];i.set(r[u],r[h]),Rw(o,i,t,e);const f=t.distanceToSquared(e);f<c&&(c=f,s&&s.copy(t),a&&a.copy(e))}}return Math.sqrt(c)}}();class Nw{constructor(t,e,n){this.isOrientedBox=!0,this.min=new An,this.max=new An,this.matrix=new Hn,this.invMatrix=new Hn,this.points=new Array(8).fill().map(()=>new An),this.satAxes=new Array(3).fill().map(()=>new An),this.satBounds=new Array(3).fill().map(()=>new bw),this.alignedSatBounds=new Array(3).fill().map(()=>new bw),this.needsUpdate=!1,t&&this.min.copy(t),e&&this.max.copy(e),n&&this.matrix.copy(n)}set(t,e,n){this.min.copy(t),this.max.copy(e),this.matrix.copy(n),this.needsUpdate=!0}copy(t){this.min.copy(t.min),this.max.copy(t.max),this.matrix.copy(t.matrix),this.needsUpdate=!0}}Nw.prototype.update=function(){const t=this.matrix,e=this.min,n=this.max,o=this.points;for(let i=0;i<=1;i++)for(let r=0;r<=1;r++)for(let s=0;s<=1;s++){const a=o[1*i|2*r|4*s];a.x=i?n.x:e.x,a.y=r?n.y:e.y,a.z=s?n.z:e.z,a.applyMatrix4(t)}const i=this.satBounds,r=this.satAxes,s=o[0];for(let t=0;t<3;t++){const e=r[t],n=i[t],a=o[1<<t];e.subVectors(s,a),n.setFromPoints(e,o)}const a=this.alignedSatBounds;a[0].setFromPointsField(o,"x"),a[1].setFromPointsField(o,"y"),a[2].setFromPointsField(o,"z"),this.invMatrix.copy(this.matrix).invert(),this.needsUpdate=!1},Nw.prototype.intersectsBox=function(){const t=new bw;return function(e){this.needsUpdate&&this.update();const n=e.min,o=e.max,i=this.satBounds,r=this.satAxes,s=this.alignedSatBounds;if(t.min=n.x,t.max=o.x,s[0].isSeparated(t))return!1;if(t.min=n.y,t.max=o.y,s[1].isSeparated(t))return!1;if(t.min=n.z,t.max=o.z,s[2].isSeparated(t))return!1;for(let n=0;n<3;n++){const o=r[n],s=i[n];if(t.setFromBox(o,e),s.isSeparated(t))return!1}return!0}}(),Nw.prototype.intersectsTriangle=function(){const t=new Lw,e=new Array(3),n=new bw,o=new bw,i=new An;return function(r){this.needsUpdate&&this.update(),r.isExtendedTriangle?r.needsUpdate&&r.update():(t.copy(r),t.update(),r=t);const s=this.satBounds,a=this.satAxes;e[0]=r.a,e[1]=r.b,e[2]=r.c;for(let t=0;t<3;t++){const o=s[t],i=a[t];if(n.setFromPoints(i,e),o.isSeparated(n))return!1}const l=r.satBounds,c=r.satAxes,u=this.points;for(let t=0;t<3;t++){const e=l[t],o=c[t];if(n.setFromPoints(o,u),e.isSeparated(n))return!1}for(let t=0;t<3;t++){const r=a[t];for(let t=0;t<4;t++){const s=c[t];if(i.crossVectors(r,s),n.setFromPoints(i,e),o.setFromPoints(i,u),n.isSeparated(o))return!1}}return!0}}(),Nw.prototype.closestPointToPoint=function(t,e){return this.needsUpdate&&this.update(),e.copy(t).applyMatrix4(this.invMatrix).clamp(this.min,this.max).applyMatrix4(this.matrix),e},Nw.prototype.distanceToPoint=function(){const t=new An;return function(e){return this.closestPointToPoint(e,t),e.distanceTo(t)}}(),Nw.prototype.distanceToBox=function(){const t=["x","y","z"],e=new Array(12).fill().map(()=>new gd),n=new Array(12).fill().map(()=>new gd),o=new An,i=new An;return function(r,s=0,a=null,l=null){if(this.needsUpdate&&this.update(),this.intersectsBox(r))return(a||l)&&(r.getCenter(i),this.closestPointToPoint(i,o),r.closestPointToPoint(o,i),a&&a.copy(o),l&&l.copy(i)),0;const c=s*s,u=r.min,h=r.max,f=this.points;let d=1/0;for(let t=0;t<8;t++){const e=f[t];i.copy(e).clamp(u,h);const n=e.distanceToSquared(i);if(n<d&&(d=n,a&&a.copy(e),l&&l.copy(i),n<c))return Math.sqrt(n)}let A=0;for(let o=0;o<3;o++)for(let i=0;i<=1;i++)for(let r=0;r<=1;r++){const s=(o+1)%3,a=(o+2)%3,l=1<<o|i<<s|r<<a,c=f[i<<s|r<<a],d=f[l];e[A].set(c,d);const v=t[o],m=t[s],p=t[a],g=n[A],_=g.start,E=g.end;_[v]=u[v],_[m]=i?u[m]:h[m],_[p]=r?u[p]:h[m],E[v]=h[v],E[m]=i?u[m]:h[m],E[p]=r?u[p]:h[m],A++}for(let t=0;t<=1;t++)for(let e=0;e<=1;e++)for(let n=0;n<=1;n++){i.x=t?h.x:u.x,i.y=e?h.y:u.y,i.z=n?h.z:u.z,this.closestPointToPoint(i,o);const r=i.distanceToSquared(o);if(r<d&&(d=r,a&&a.copy(o),l&&l.copy(i),r<c))return Math.sqrt(r)}for(let t=0;t<12;t++){const r=e[t];for(let t=0;t<12;t++){const e=n[t];Rw(r,e,o,i);const s=o.distanceToSquared(i);if(s<d&&(d=s,a&&a.copy(o),l&&l.copy(i),s<c))return Math.sqrt(s)}}return Math.sqrt(d)}}();class Dw{constructor(t){this._r=t,this.Er=[]}getPrimitive(){const t=this.Er;return 0===t.length?this._r():t.pop()}releasePrimitive(t){this.Er.push(t)}}class Pw extends Dw{constructor(){super(()=>new Lw)}}const Ow=new Pw;const Fw=new class{constructor(){this.float32Array=null,this.uint16Array=null,this.uint32Array=null;const t=[];let e=null;this.setBuffer=n=>{e&&t.push(e),e=n,this.float32Array=new Float32Array(n),this.uint16Array=new Uint16Array(n),this.uint32Array=new Uint32Array(n)},this.clearBuffer=()=>{e=null,this.float32Array=null,this.uint16Array=null,this.uint32Array=null,0!==t.length&&this.setBuffer(t.pop())}}};let Uw,Vw;const Gw=[],Qw=new Dw(()=>new pn);function zw(t,e,n,o,i,r){Uw=Qw.getPrimitive(),Vw=Qw.getPrimitive(),Gw.push(Uw,Vw),Fw.setBuffer(t.gr[e]);const s=kw(0,t.geometry,n,o,i,r);Fw.clearBuffer(),Qw.releasePrimitive(Uw),Qw.releasePrimitive(Vw),Gw.pop(),Gw.pop();const a=Gw.length;return a>0&&(Vw=Gw[a-1],Uw=Gw[a-2]),s}function kw(t,e,n,o,i=null,r=0,s=0){const{float32Array:a,uint16Array:l,uint32Array:c}=Fw;let u=2*t;if(uw(u,l)){const h=hw(t,c),f=fw(u,l);return qC(t,a,Uw),o(h,f,!1,s,r+t,Uw)}{const d=dw(t),A=Aw(t,c);let v,m,p,g,_=d,E=A;if(i&&(p=Uw,g=Vw,qC(_,a,p),qC(E,a,g),v=i(p),m=i(g),m<v)){_=A,E=d;const b=v;v=m,m=b,p=g}p||(p=Uw,qC(_,a,p));const C=n(p,uw(2*_,l),v,s+1,r+_);let w;if(2===C){const y=M(_);w=o(y,S(_)-y,!0,s+1,r+_,p)}else w=C&&kw(_,e,n,o,i,r,s+1);if(w)return!0;g=Vw,qC(E,a,g);const x=n(g,uw(2*E,l),m,s+1,r+E);let I;if(2===x){const R=M(E);I=o(R,S(E)-R,!0,s+1,r+E,g)}else I=x&&kw(E,e,n,o,i,r,s+1);return!!I;function M(t){const{uint16Array:e,uint32Array:n}=Fw;let o=2*t;for(;!uw(o,e);)o=2*(t=dw(t));return hw(t,n)}function S(t){const{uint16Array:e,uint32Array:n}=Fw;let o=2*t;for(;!uw(o,e);)o=2*(t=Aw(t,n));return hw(t,n)+fw(o,e)}}}const Hw=new An,Ww=new An;const Yw=parseInt(n)>=169,Xw=new An,Kw=new An,jw=new An,Zw=new we,qw=new we,Jw=new we,$w=new An,tx=new An,ex=new An,nx=new An;function ox(t,e,n,o,i,r,s){const a=3*o;let l=a+0,c=a+1,u=a+2;const h=t.index;t.index&&(l=h.getX(l),c=h.getX(c),u=h.getX(u));const{position:f,normal:d,uv:A,uv1:v}=t.attributes,m=function(t,e,n,o,i,r,s,a,l,c,u){Xw.fromBufferAttribute(e,r),Kw.fromBufferAttribute(e,s),jw.fromBufferAttribute(e,a);const h=function(t,e,n,o,i,r,s,a){let l;if(l=1===r?t.intersectTriangle(o,n,e,!0,i):t.intersectTriangle(e,n,o,2!==r,i),null===l)return null;const c=t.origin.distanceTo(i);return c<s||c>a?null:{distance:c,point:i.clone()}}(t,Xw,Kw,jw,nx,l,c,u);if(h){const e=new An;To.getBarycoord(nx,Xw,Kw,jw,e),o&&(Zw.fromBufferAttribute(o,r),qw.fromBufferAttribute(o,s),Jw.fromBufferAttribute(o,a),h.uv=To.getInterpolation(nx,Xw,Kw,jw,Zw,qw,Jw,new we)),i&&(Zw.fromBufferAttribute(i,r),qw.fromBufferAttribute(i,s),Jw.fromBufferAttribute(i,a),h.uv1=To.getInterpolation(nx,Xw,Kw,jw,Zw,qw,Jw,new we)),n&&($w.fromBufferAttribute(n,r),tx.fromBufferAttribute(n,s),ex.fromBufferAttribute(n,a),h.normal=To.getInterpolation(nx,Xw,Kw,jw,$w,tx,ex,new An),h.normal.dot(t.direction)>0&&h.normal.multiplyScalar(-1));const l={a:r,b:s,c:a,normal:new An,materialIndex:0};To.getNormal(Xw,Kw,jw,l.normal),h.face=l,h.faceIndex=r,Yw&&(h.barycoord=e)}return h}(n,f,d,A,v,l,c,u,e,r,s);return m?(m.faceIndex=o,i&&i.push(m),m):null}function ix(t,e,n,o){const i=t.a,r=t.b,s=t.c;let a=e,l=e+1,c=e+2;n&&(a=n.getX(a),l=n.getX(l),c=n.getX(c)),i.x=o.getX(a),i.y=o.getY(a),i.z=o.getZ(a),r.x=o.getX(l),r.y=o.getY(l),r.z=o.getZ(l),s.x=o.getX(c),s.y=o.getY(c),s.z=o.getZ(c)}function rx(t,e,n,o,i,r,s){const{geometry:a}=n,{index:l}=a,c=a.attributes.position;for(let n=t,a=e+t;n<a;n++){let t;if(t=n,ix(s,3*t,l,c),s.needsUpdate=!0,o(s,t,i,r))return!0}return!1}function sx(t,e=null){e&&Array.isArray(e)&&(e=new Set(e));const n=t.geometry,o=n.index?n.index.array:null,i=n.attributes.position;let r,s,a,l,c=0;const u=t.gr;for(let t=0,e=u.length;t<e;t++)r=u[t],s=new Uint32Array(r),a=new Uint16Array(r),l=new Float32Array(r),h(0,c),c+=r.byteLength;function h(t,n,r=!1){const c=2*t;if(a[c+15]===kC){const e=s[t+6];let n=1/0,r=1/0,u=1/0,h=-1/0,f=-1/0,d=-1/0;for(let t=3*e,s=3*(e+a[c+14]);t<s;t++){let e=o[t];const s=i.getX(e),a=i.getY(e),l=i.getZ(e);s<n&&(n=s),s>h&&(h=s),a<r&&(r=a),a>f&&(f=a),l<u&&(u=l),l>d&&(d=l)}return(l[t+0]!==n||l[t+1]!==r||l[t+2]!==u||l[t+3]!==h||l[t+4]!==f||l[t+5]!==d)&&(l[t+0]=n,l[t+1]=r,l[t+2]=u,l[t+3]=h,l[t+4]=f,l[t+5]=d,!0)}{const o=t+8,i=s[t+6],a=o+n,c=i+n;let u=r,f=!1,d=!1;e?u||(f=e.has(a),d=e.has(c),u=!f&&!d):(f=!0,d=!0);const A=u||d;let v=!1;(u||f)&&(v=h(o,n,u));let m=!1;A&&(m=h(i,n,u));const p=v||m;if(p)for(let e=0;e<3;e++){const n=o+e,r=i+e,s=l[n],a=l[n+3],c=l[r],u=l[r+3];l[t+e]=s<c?s:c,l[t+e+3]=a>u?a:u}return p}}}function ax(t,e,n,o,i){let r,s,a,l,c,u;const h=1/n.direction.x,f=1/n.direction.y,d=1/n.direction.z,A=n.origin.x,v=n.origin.y,m=n.origin.z;let p=e[t],g=e[t+3],_=e[t+1],E=e[t+3+1],C=e[t+2],w=e[t+3+2];return h>=0?(r=(p-A)*h,s=(g-A)*h):(r=(g-A)*h,s=(p-A)*h),f>=0?(a=(_-v)*f,l=(E-v)*f):(a=(E-v)*f,l=(_-v)*f),!(r>l||a>s)&&((a>r||isNaN(r))&&(r=a),(l<s||isNaN(s))&&(s=l),d>=0?(c=(C-m)*d,u=(w-m)*d):(c=(w-m)*d,u=(C-m)*d),!(r>u||c>s)&&((c>r||r!=r)&&(r=c),(u<s||s!=s)&&(s=u),r<=i&&s>=o))}function lx(t,e,n,o,i,r,s){const{geometry:a}=n,{index:l}=a,c=a.attributes.position;for(let a=t,u=e+t;a<u;a++){let t;if(t=n.resolveTriangleIndex(a),ix(s,3*t,l,c),s.needsUpdate=!0,o(s,t,i,r))return!0}return!1}function cx(t,e,n,o,i,r,s){Fw.setBuffer(t.gr[e]),ux(0,t,n,o,i,r,s),Fw.clearBuffer()}function ux(t,e,n,o,i,r,s){const{float32Array:a,uint16Array:l,uint32Array:c}=Fw,u=2*t;if(uw(u,l)){!function(t,e,n,o,i,r,s,a){const{geometry:l,pr:c}=t;for(let t=o,c=o+i;t<c;t++)ox(l,e,n,t,r,s,a)}(e,n,o,hw(t,c),fw(u,l),i,r,s)}else{const l=dw(t);ax(l,a,o,r,s)&&ux(l,e,n,o,i,r,s);const u=Aw(t,c);ax(u,a,o,r,s)&&ux(u,e,n,o,i,r,s)}}const hx=["x","y","z"];function fx(t,e,n,o,i,r){Fw.setBuffer(t.gr[e]);const s=dx(0,t,n,o,i,r);return Fw.clearBuffer(),s}function dx(t,e,n,o,i,r){const{float32Array:s,uint16Array:a,uint32Array:l}=Fw;let c=2*t;if(uw(c,a)){return function(t,e,n,o,i,r,s){const{geometry:a,pr:l}=t;let c=1/0,u=null;for(let t=o,l=o+i;t<l;t++){let o;o=ox(a,e,n,t,null,r,s),o&&o.distance<c&&(u=o,c=o.distance)}return u}(e,n,o,hw(t,l),fw(c,a),i,r)}{const a=vw(t,l),c=hx[a],u=o.direction[c]>=0;let h,f;u?(h=dw(t),f=Aw(t,l)):(h=Aw(t,l),f=dw(t));const d=ax(h,s,o,i,r)?dx(h,e,n,o,i,r):null;if(d){const t=d.point[c];if(u?t<=s[f+a]:t>=s[f+a+3])return d}const A=ax(f,s,o,i,r)?dx(f,e,n,o,i,r):null;return d&&A?d.distance<=A.distance?d:A:d||A||null}}const Ax=new pn,vx=new Lw,mx=new Lw,px=new Hn,gx=new Nw,_x=new Nw;function Ex(t,e,n,o){Fw.setBuffer(t.gr[e]);const i=Cx(0,t,n,o);return Fw.clearBuffer(),i}function Cx(t,e,n,o,i=null){const{float32Array:r,uint16Array:s,uint32Array:a}=Fw;let l=2*t;null===i&&(n.boundingBox||n.computeBoundingBox(),gx.set(n.boundingBox.min,n.boundingBox.max,o),i=gx);if(!uw(l,s)){const s=t+8,l=a[t+6];qC(s,r,Ax);if(i.intersectsBox(Ax)&&Cx(s,e,n,o,i))return!0;qC(l,r,Ax);return!!(i.intersectsBox(Ax)&&Cx(l,e,n,o,i))}{const i=e.geometry,c=i.index,u=i.attributes.position,h=n.index,f=n.attributes.position,d=hw(t,a),A=fw(l,s);if(px.copy(o).invert(),n.boundsTree){qC(t,r,_x),_x.matrix.copy(px),_x.needsUpdate=!0;const e=n.boundsTree.shapecast({intersectsBounds:t=>_x.intersectsBox(t),intersectsTriangle:t=>{t.a.applyMatrix4(o),t.b.applyMatrix4(o),t.c.applyMatrix4(o),t.needsUpdate=!0;for(let e=3*d,n=3*(A+d);e<n;e+=3)if(ix(mx,e,c,u),mx.needsUpdate=!0,t.intersectsTriangle(mx))return!0;return!1}});return e}for(let t=3*d,e=3*(A+d);t<e;t+=3){ix(vx,t,c,u),vx.a.applyMatrix4(px),vx.b.applyMatrix4(px),vx.c.applyMatrix4(px),vx.needsUpdate=!0;for(let t=0,e=h.count;t<e;t+=3)if(ix(mx,t,h,f),mx.needsUpdate=!0,vx.intersectsTriangle(mx))return!0}}}const wx=new Hn,xx=new Nw,Ix=new Nw,Mx=new An,Sx=new An,bx=new An,yx=new An;function Rx(t,e,n,o={},i={},r=0,s=1/0){e.boundingBox||e.computeBoundingBox(),xx.set(e.boundingBox.min,e.boundingBox.max,n),xx.needsUpdate=!0;const a=t.geometry,l=a.attributes.position,c=a.index,u=e.attributes.position,h=e.index,f=Ow.getPrimitive(),d=Ow.getPrimitive();let A=Mx,v=Sx,m=null,p=null;i&&(m=bx,p=yx);let g=1/0,_=null,E=null;return wx.copy(n).invert(),Ix.matrix.copy(wx),t.shapecast({boundsTraverseOrder:t=>xx.distanceToBox(t),intersectsBounds:(t,e,n)=>n<g&&n<s&&(e&&(Ix.min.copy(t.min),Ix.max.copy(t.max),Ix.needsUpdate=!0),!0),intersectsRange:(t,o)=>{if(e.boundsTree){return e.boundsTree.shapecast({boundsTraverseOrder:t=>Ix.distanceToBox(t),intersectsBounds:(t,e,n)=>n<g&&n<s,intersectsRange:(e,i)=>{for(let s=e,a=e+i;s<a;s++){ix(d,3*s,h,u),d.a.applyMatrix4(n),d.b.applyMatrix4(n),d.c.applyMatrix4(n),d.needsUpdate=!0;for(let e=t,n=t+o;e<n;e++){ix(f,3*e,c,l),f.needsUpdate=!0;const t=f.distanceToTriangle(d,A,m);if(t<g&&(v.copy(A),p&&p.copy(m),g=t,_=e,E=s),t<r)return!0}}}})}for(let i=0,s=YC(e);i<s;i++){ix(d,3*i,h,u),d.a.applyMatrix4(n),d.b.applyMatrix4(n),d.c.applyMatrix4(n),d.needsUpdate=!0;for(let e=t,n=t+o;e<n;e++){ix(f,3*e,c,l),f.needsUpdate=!0;const t=f.distanceToTriangle(d,A,m);if(t<g&&(v.copy(A),p&&p.copy(m),g=t,_=e,E=i),t<r)return!0}}}}),Ow.releasePrimitive(f),Ow.releasePrimitive(d),g===1/0?null:(o.point?o.point.copy(v):o.point=v.clone(),o.distance=g,o.faceIndex=_,i&&(i.point?i.point.copy(p):i.point=p.clone(),i.point.applyMatrix4(wx),v.applyMatrix4(wx),i.distance=v.sub(i.point).length(),i.faceIndex=E),o)}function Tx(t,e=null){e&&Array.isArray(e)&&(e=new Set(e));const n=t.geometry,o=n.index?n.index.array:null,i=n.attributes.position;let r,s,a,l,c=0;const u=t.gr;for(let t=0,e=u.length;t<e;t++)r=u[t],s=new Uint32Array(r),a=new Uint16Array(r),l=new Float32Array(r),h(0,c),c+=r.byteLength;function h(n,r,c=!1){const u=2*n;if(a[u+15]===kC){const e=s[n+6];let r=1/0,c=1/0,h=1/0,f=-1/0,d=-1/0,A=-1/0;for(let n=e,s=e+a[u+14];n<s;n++){const e=3*t.resolveTriangleIndex(n);for(let t=0;t<3;t++){let n=e+t;n=o?o[n]:n;const s=i.getX(n),a=i.getY(n),l=i.getZ(n);s<r&&(r=s),s>f&&(f=s),a<c&&(c=a),a>d&&(d=a),l<h&&(h=l),l>A&&(A=l)}}return(l[n+0]!==r||l[n+1]!==c||l[n+2]!==h||l[n+3]!==f||l[n+4]!==d||l[n+5]!==A)&&(l[n+0]=r,l[n+1]=c,l[n+2]=h,l[n+3]=f,l[n+4]=d,l[n+5]=A,!0)}{const t=n+8,o=s[n+6],i=t+r,a=o+r;let u=c,f=!1,d=!1;e?u||(f=e.has(i),d=e.has(a),u=!f&&!d):(f=!0,d=!0);const A=u||d;let v=!1;(u||f)&&(v=h(t,r,u));let m=!1;A&&(m=h(o,r,u));const p=v||m;if(p)for(let e=0;e<3;e++){const i=t+e,r=o+e,s=l[i],a=l[i+3],c=l[r],u=l[r+3];l[n+e]=s<c?s:c,l[n+e+3]=a>u?a:u}return p}}}function Bx(t,e,n,o,i,r,s){Fw.setBuffer(t.gr[e]),Lx(0,t,n,o,i,r,s),Fw.clearBuffer()}function Lx(t,e,n,o,i,r,s){const{float32Array:a,uint16Array:l,uint32Array:c}=Fw,u=2*t;if(uw(u,l)){!function(t,e,n,o,i,r,s,a){const{geometry:l,pr:c}=t;for(let t=o,u=o+i;t<u;t++)ox(l,e,n,c?c[t]:t,r,s,a)}(e,n,o,hw(t,c),fw(u,l),i,r,s)}else{const l=dw(t);ax(l,a,o,r,s)&&Lx(l,e,n,o,i,r,s);const u=Aw(t,c);ax(u,a,o,r,s)&&Lx(u,e,n,o,i,r,s)}}const Nx=["x","y","z"];function Dx(t,e,n,o,i,r){Fw.setBuffer(t.gr[e]);const s=Px(0,t,n,o,i,r);return Fw.clearBuffer(),s}function Px(t,e,n,o,i,r){const{float32Array:s,uint16Array:a,uint32Array:l}=Fw;let c=2*t;if(uw(c,a)){return function(t,e,n,o,i,r,s){const{geometry:a,pr:l}=t;let c=1/0,u=null;for(let t=o,h=o+i;t<h;t++){let o;o=ox(a,e,n,l?l[t]:t,null,r,s),o&&o.distance<c&&(u=o,c=o.distance)}return u}(e,n,o,hw(t,l),fw(c,a),i,r)}{const a=vw(t,l),c=Nx[a],u=o.direction[c]>=0;let h,f;u?(h=dw(t),f=Aw(t,l)):(h=Aw(t,l),f=dw(t));const d=ax(h,s,o,i,r)?Px(h,e,n,o,i,r):null;if(d){const t=d.point[c];if(u?t<=s[f+a]:t>=s[f+a+3])return d}const A=ax(f,s,o,i,r)?Px(f,e,n,o,i,r):null;return d&&A?d.distance<=A.distance?d:A:d||A||null}}const Ox=new pn,Fx=new Lw,Ux=new Lw,Vx=new Hn,Gx=new Nw,Qx=new Nw;function zx(t,e,n,o){Fw.setBuffer(t.gr[e]);const i=kx(0,t,n,o);return Fw.clearBuffer(),i}function kx(t,e,n,o,i=null){const{float32Array:r,uint16Array:s,uint32Array:a}=Fw;let l=2*t;null===i&&(n.boundingBox||n.computeBoundingBox(),Gx.set(n.boundingBox.min,n.boundingBox.max,o),i=Gx);if(!uw(l,s)){const s=t+8,l=a[t+6];qC(s,r,Ox);if(i.intersectsBox(Ox)&&kx(s,e,n,o,i))return!0;qC(l,r,Ox);return!!(i.intersectsBox(Ox)&&kx(l,e,n,o,i))}{const i=e.geometry,c=i.index,u=i.attributes.position,h=n.index,f=n.attributes.position,d=hw(t,a),A=fw(l,s);if(Vx.copy(o).invert(),n.boundsTree){qC(t,r,Qx),Qx.matrix.copy(Vx),Qx.needsUpdate=!0;const i=n.boundsTree.shapecast({intersectsBounds:t=>Qx.intersectsBox(t),intersectsTriangle:t=>{t.a.applyMatrix4(o),t.b.applyMatrix4(o),t.c.applyMatrix4(o),t.needsUpdate=!0;for(let n=d,o=A+d;n<o;n++)if(ix(Ux,3*e.resolveTriangleIndex(n),c,u),Ux.needsUpdate=!0,t.intersectsTriangle(Ux))return!0;return!1}});return i}for(let t=d,n=A+d;t<n;t++){const n=e.resolveTriangleIndex(t);ix(Fx,3*n,c,u),Fx.a.applyMatrix4(Vx),Fx.b.applyMatrix4(Vx),Fx.c.applyMatrix4(Vx),Fx.needsUpdate=!0;for(let t=0,e=h.count;t<e;t+=3)if(ix(Ux,t,h,f),Ux.needsUpdate=!0,Fx.intersectsTriangle(Ux))return!0}}}const Hx=new Hn,Wx=new Nw,Yx=new Nw,Xx=new An,Kx=new An,jx=new An,Zx=new An;function qx(t,e,n,o={},i={},r=0,s=1/0){e.boundingBox||e.computeBoundingBox(),Wx.set(e.boundingBox.min,e.boundingBox.max,n),Wx.needsUpdate=!0;const a=t.geometry,l=a.attributes.position,c=a.index,u=e.attributes.position,h=e.index,f=Ow.getPrimitive(),d=Ow.getPrimitive();let A=Xx,v=Kx,m=null,p=null;i&&(m=jx,p=Zx);let g=1/0,_=null,E=null;return Hx.copy(n).invert(),Yx.matrix.copy(Hx),t.shapecast({boundsTraverseOrder:t=>Wx.distanceToBox(t),intersectsBounds:(t,e,n)=>n<g&&n<s&&(e&&(Yx.min.copy(t.min),Yx.max.copy(t.max),Yx.needsUpdate=!0),!0),intersectsRange:(o,i)=>{if(e.boundsTree){const a=e.boundsTree;return a.shapecast({boundsTraverseOrder:t=>Yx.distanceToBox(t),intersectsBounds:(t,e,n)=>n<g&&n<s,intersectsRange:(e,s)=>{for(let C=e,w=e+s;C<w;C++){const e=a.resolveTriangleIndex(C);ix(d,3*e,h,u),d.a.applyMatrix4(n),d.b.applyMatrix4(n),d.c.applyMatrix4(n),d.needsUpdate=!0;for(let e=o,n=o+i;e<n;e++){const n=t.resolveTriangleIndex(e);ix(f,3*n,c,l),f.needsUpdate=!0;const o=f.distanceToTriangle(d,A,m);if(o<g&&(v.copy(A),p&&p.copy(m),g=o,_=e,E=C),o<r)return!0}}}})}for(let s=0,a=YC(e);s<a;s++){ix(d,3*s,h,u),d.a.applyMatrix4(n),d.b.applyMatrix4(n),d.c.applyMatrix4(n),d.needsUpdate=!0;for(let e=o,n=o+i;e<n;e++){const n=t.resolveTriangleIndex(e);ix(f,3*n,c,l),f.needsUpdate=!0;const o=f.distanceToTriangle(d,A,m);if(o<g&&(v.copy(A),p&&p.copy(m),g=o,_=e,E=s),o<r)return!0}}}}),Ow.releasePrimitive(f),Ow.releasePrimitive(d),g===1/0?null:(o.point?o.point.copy(v):o.point=v.clone(),o.distance=g,o.faceIndex=_,i&&(i.point?i.point.copy(p):i.point=p.clone(),i.point.applyMatrix4(Hx),v.applyMatrix4(Hx),i.distance=v.sub(i.point).length(),i.faceIndex=E),o)}const Jx=new Fw.constructor,$x=new Fw.constructor,tI=new Dw(()=>new pn),eI=new pn,nI=new pn,oI=new pn,iI=new pn;let rI=!1;function sI(t,e,n,o,i,r=0,s=0,a=0,l=0,c=null,u=!1){let h,f;u?(h=$x,f=Jx):(h=Jx,f=$x);const d=h.float32Array,A=h.uint32Array,v=h.uint16Array,m=f.float32Array,p=f.uint32Array,g=f.uint16Array,_=2*e,E=uw(2*t,v),C=uw(_,g);let w=!1;if(C&&E)w=u?i(hw(e,p),fw(2*e,g),hw(t,A),fw(2*t,v),l,s+e,a,r+t):i(hw(t,A),fw(2*t,v),hw(e,p),fw(2*e,g),a,r+t,l,s+e);else if(C){const c=tI.getPrimitive();qC(e,m,c),c.applyMatrix4(n);const h=dw(t),f=Aw(t,A);qC(h,d,eI),qC(f,d,nI);const v=c.intersectsBox(eI),p=c.intersectsBox(nI);w=v&&sI(e,h,o,n,i,s,r,l,a+1,c,!u)||p&&sI(e,f,o,n,i,s,r,l,a+1,c,!u),tI.releasePrimitive(c)}else{const h=dw(e),f=Aw(e,p);qC(h,m,oI),qC(f,m,iI);const v=c.intersectsBox(oI),g=c.intersectsBox(iI);if(v&&g)w=sI(t,h,n,o,i,r,s,a,l+1,c,u)||sI(t,f,n,o,i,r,s,a,l+1,c,u);else if(v)if(E)w=sI(t,h,n,o,i,r,s,a,l+1,c,u);else{const e=tI.getPrimitive();e.copy(oI).applyMatrix4(n);const c=dw(t),f=Aw(t,A);qC(c,d,eI),qC(f,d,nI);const v=e.intersectsBox(eI),m=e.intersectsBox(nI);w=v&&sI(h,c,o,n,i,s,r,l,a+1,e,!u)||m&&sI(h,f,o,n,i,s,r,l,a+1,e,!u),tI.releasePrimitive(e)}else if(g)if(E)w=sI(t,f,n,o,i,r,s,a,l+1,c,u);else{const e=tI.getPrimitive();e.copy(iI).applyMatrix4(n);const c=dw(t),h=Aw(t,A);qC(c,d,eI),qC(h,d,nI);const v=e.intersectsBox(eI),m=e.intersectsBox(nI);w=v&&sI(f,c,o,n,i,s,r,l,a+1,e,!u)||m&&sI(f,h,o,n,i,s,r,l,a+1,e,!u),tI.releasePrimitive(e)}}return w}const aI=new Nw,lI=new pn,cI={strategy:0,maxDepth:40,maxLeafTris:10,useSharedArrayBuffer:!1,setBoundingBox:!0,onProgress:null,indirect:!1,verbose:!0,range:null};class uI{static serialize(t,e={}){e={cloneBuffers:!0,...e};const n=t.geometry,o=t.gr,i=t.pr,r=n.getIndex();let s;return s=e.cloneBuffers?{roots:o.map(t=>t.slice()),index:r?r.array.slice():null,indirectBuffer:i?i.slice():null}:{roots:o,index:r?r.array:null,indirectBuffer:i},s}static deserialize(t,e,n={}){n={setIndex:!0,indirect:Boolean(t.indirectBuffer),...n};const{index:o,roots:i,indirectBuffer:r}=t,s=new uI(e,{...n,[WC]:!0});if(s.gr=i,s.pr=r||null,n.setIndex){const n=e.getIndex();if(null===n){const n=new Oo(t.index,1,!1);e.setIndex(n)}else n.array!==o&&(n.array.set(o),n.needsUpdate=!0)}return s}get indirect(){return!!this.pr}constructor(t,e={}){if(!t.isBufferGeometry)throw new Error("MeshBVH: Only BufferGeometries are supported.");if((e=Object.assign({...cI,[WC]:!1},e)).useSharedArrayBuffer&&"undefined"==typeof SharedArrayBuffer)throw new Error("MeshBVH: SharedArrayBuffer is not available.");this.geometry=t,this.gr=null,this.pr=null,e[WC]||(Sw(this,e),!t.boundingBox&&e.setBoundingBox&&(t.boundingBox=this.getBoundingBox(new pn))),this.resolveTriangleIndex=e.indirect?t=>this.pr[t]:t=>t}refit(t=null){return(this.indirect?Tx:sx)(this,t)}traverse(t,e=0){const n=this.gr[e],o=new Uint32Array(n),i=new Uint16Array(n);!function e(r,s=0){const a=2*r,l=i[a+15]===kC;if(l){const e=o[r+6],c=i[a+14];t(s,l,new Float32Array(n,4*r,6),e,c)}else{const i=r+8,a=o[r+6],c=o[r+7];t(s,l,new Float32Array(n,4*r,6),c)||(e(i,s+1),e(a,s+1))}}(0)}raycast(t,e=0,n=0,o=1/0){const i=this.gr,r=this.geometry,s=[],a=e.isMaterial,l=Array.isArray(e),c=r.groups,u=a?e.side:e,h=this.indirect?Bx:cx;for(let r=0,a=i.length;r<a;r++){const i=l?e[c[r].materialIndex].side:u,a=s.length;if(h(this,r,i,t,s,n,o),l){const t=c[r].materialIndex;for(let e=a,n=s.length;e<n;e++)s[e].face.materialIndex=t}}return s}raycastFirst(t,e=0,n=0,o=1/0){const i=this.gr,r=this.geometry,s=e.isMaterial,a=Array.isArray(e);let l=null;const c=r.groups,u=s?e.side:e,h=this.indirect?Dx:fx;for(let r=0,s=i.length;r<s;r++){const i=h(this,r,a?e[c[r].materialIndex].side:u,t,n,o);null!=i&&(null==l||i.distance<l.distance)&&(l=i,a&&(i.face.materialIndex=c[r].materialIndex))}return l}intersectsGeometry(t,e){let n=!1;const o=this.gr,i=this.indirect?zx:Ex;for(let r=0,s=o.length;r<s&&(n=i(this,r,t,e),!n);r++);return n}shapecast(t){const e=Ow.getPrimitive(),n=this.indirect?lx:rx;let{boundsTraverseOrder:o,intersectsBounds:i,intersectsRange:r,intersectsTriangle:s}=t;if(r&&s){const t=r;r=(o,i,r,a,l)=>!!t(o,i,r,a,l)||n(o,i,this,s,r,a,e)}else r||(r=s?(t,o,i,r)=>n(t,o,this,s,i,r,e):(t,e,n)=>n);let a=!1,l=0;const c=this.gr;for(let t=0,e=c.length;t<e;t++){const e=c[t];if(a=zw(this,t,i,r,o,l),a)break;l+=e.byteLength}return Ow.releasePrimitive(e),a}bvhcast(t,e,n){let{intersectsRanges:o,intersectsTriangles:i}=n;const r=Ow.getPrimitive(),s=this.geometry.index,a=this.geometry.attributes.position,l=this.indirect?t=>{const e=this.resolveTriangleIndex(t);ix(r,3*e,s,a)}:t=>{ix(r,3*t,s,a)},c=Ow.getPrimitive(),u=t.geometry.index,h=t.geometry.attributes.position,f=t.indirect?e=>{const n=t.resolveTriangleIndex(e);ix(c,3*n,u,h)}:t=>{ix(c,3*t,u,h)};if(i){const t=(t,n,o,s,a,u,h,d)=>{for(let A=o,v=o+s;A<v;A++){f(A),c.a.applyMatrix4(e),c.b.applyMatrix4(e),c.c.applyMatrix4(e),c.needsUpdate=!0;for(let e=t,o=t+n;e<o;e++)if(l(e),r.needsUpdate=!0,i(r,c,e,A,a,u,h,d))return!0}return!1};if(o){const e=o;o=function(n,o,i,r,s,a,l,c){return!!e(n,o,i,r,s,a,l,c)||t(n,o,i,r,s,a,l,c)}}else o=t}return function(t,e,n,o){if(rI)throw new Error("MeshBVH: Recursive calls to bvhcast not supported.");rI=!0;const i=t.gr,r=e.gr;let s,a=0,l=0;const c=(new Hn).copy(n).invert();for(let t=0,e=i.length;t<e;t++){Jx.setBuffer(i[t]),l=0;const e=tI.getPrimitive();qC(mw(0),Jx.float32Array,e),e.applyMatrix4(c);for(let t=0,i=r.length;t<i&&($x.setBuffer(r[t]),s=sI(0,0,n,c,o,a,l,0,0,e),$x.clearBuffer(),l+=r[t].length,!s);t++);if(tI.releasePrimitive(e),Jx.clearBuffer(),a+=i[t].length,s)break}return rI=!1,s}(this,t,e,o)}intersectsBox(t,e){return aI.set(t.min,t.max,e),aI.needsUpdate=!0,this.shapecast({intersectsBounds:t=>aI.intersectsBox(t),intersectsTriangle:t=>aI.intersectsTriangle(t)})}intersectsSphere(t){return this.shapecast({intersectsBounds:e=>t.intersectsBox(e),intersectsTriangle:e=>e.intersectsSphere(t)})}closestPointToGeometry(t,e,n={},o={},i=0,r=1/0){return(this.indirect?qx:Rx)(this,t,e,n,o,i,r)}closestPointToPoint(t,e={},n=0,o=1/0){return function(t,e,n={},o=0,i=1/0){const r=o*o,s=i*i;let a=1/0,l=null;if(t.shapecast({boundsTraverseOrder:t=>(Hw.copy(e).clamp(t.min,t.max),Hw.distanceToSquared(e)),intersectsBounds:(t,e,n)=>n<a&&n<s,intersectsTriangle:(t,n)=>{t.closestPointToPoint(e,Hw);const o=e.distanceToSquared(Hw);return o<a&&(Ww.copy(Hw),a=o,l=n),o<r}}),a===1/0)return null;const c=Math.sqrt(a);return n.point?n.point.copy(Ww):n.point=Ww.clone(),n.distance=c,n.faceIndex=l,n}(this,t,e,n,o)}getBoundingBox(t){t.makeEmpty();return this.gr.forEach(e=>{qC(0,new Float32Array(e),lI),t.union(lI)}),t}}function hI(t,e,n){return null===t?null:(t.point.applyMatrix4(e.matrixWorld),t.distance=t.point.distanceTo(n.ray.origin),t.object=e,t)}const fI=new kn,dI=new An,AI=new Hn,vI=hi.prototype.raycast,mI=class extends hi{}.prototype.raycast,pI=new An,gI=new hi,_I=[];function EI(t,e){this.isBatchedMesh?CI.call(this,t,e):wI.call(this,t,e)}function CI(t,e){if(this.boundsTrees){const n=this.boundsTrees,o=this.Cr||this.wr,i=this.Ir||this.Mr,r=this.matrixWorld;gI.material=this.material,gI.geometry=this.geometry;const s=gI.geometry.boundsTree,a=gI.geometry.drawRange;null===gI.geometry.boundingSphere&&(gI.geometry.boundingSphere=new Pn);for(let s=0,a=o.length;s<a;s++){if(!this.getVisibleAt(s))continue;const a=o[s].geometryIndex;if(gI.geometry.boundsTree=n[a],this.getMatrixAt(s,gI.matrixWorld).premultiply(r),!gI.geometry.boundsTree){this.getBoundingBoxAt(a,gI.geometry.boundingBox),this.getBoundingSphereAt(a,gI.geometry.boundingSphere);const t=i[a];gI.geometry.setDrawRange(t.start,t.count)}gI.raycast(t,_I);for(let t=0,n=_I.length;t<n;t++){const n=_I[t];n.object=this,n.batchId=s,e.push(n)}_I.length=0}gI.geometry.boundsTree=s,gI.geometry.drawRange=a,gI.material=null,gI.geometry=null}else mI.call(this,t,e)}function wI(t,e){if(this.geometry.boundsTree){if(this.isAuxClippingMesh)return;if(void 0===this.material)return;try{AI.copy(this.matrixWorld).invert()}catch(t){return}fI.copy(t.ray).applyMatrix4(AI),pI.setFromMatrixScale(this.matrixWorld),dI.copy(fI.direction).multiply(pI);const n=dI.length(),o=t.near/n,i=t.far/n,r=this.geometry.boundsTree;if(!0===t.firstHitOnly){const n=hI(r.raycastFirst(fI,this.material,o,i),this,t);n&&e.push(n)}else{const n=r.raycast(fI,this.material,o,i);for(let o=0,i=n.length;o<i;o++){const i=hI(n[o],this,t);i&&e.push(i)}}}else vI.call(this,t,e)}function xI(t={}){return this.boundsTree=new uI(this,t),this.boundsTree}function II(){this.boundsTree=null}const MI=["toneMapping","toneMappingLook","toneMappingExposure","toneMappingMidTones","toneMappingPhysicalScale","toneMappingBrightness","toneMappingContrast","toneMappingChromaticAdaptation","toneMappingWhiteColor","toneMappingColorDifferentiation","toneMappingExteriorDaylight","toneMappingWhiteBalance","toneMappingHighlights","toneMappingShadows","toneMappingSaturation","toneMappingAperture","toneMappingShutter","toneMappingISO","toneMappingVignetting"],SI=.6,bI=.4,yI={type:"afterFirstRender"},RI={type:"afterRender"},TI={type:"beforeRender"},BI={type:"dispose"},LI={type:"pause"},NI={type:"resume"},DI={type:"sceneLoad"};function PI(t,e,n){return 2*$t*Math.atan(Math.tan(Jt*t/2)*e/n)}Xo.prototype.toJSON=function(){return console.error("v3d.BufferGeometry.toJSON() has been removed, use glTF format for export."),{}},mo.prototype.toJSON=function(){return console.error("v3d.Object3D.toJSON() has been removed, use glTF format for export."),{}},Lo.prototype.toJSON=function(){return console.error("v3d.Material.toJSON() has been removed, use glTF format for export."),{}},Ph.nodeGraphDiffuse=function(t,e,n){console.error("v3d.MeshNodeMaterial.nodeGraphDiffuse has been deprecated. Use v3d.MaterialUtils.createDiffuseMaterial instead.");return Hm("",t,e,n).nodeGraph};var OI,FI,UI={calcCameraZoomToObjectsParams:(OI=new pn,FI=new Pn,function(t,e,n,o,i){var r=OI.makeEmpty();e.forEach(function(t){r.expandByObject(t)});var s=r.getBoundingSphere(FI);UI.calcCameraZoomToSphereParams(t,s,n,o,i)}),calcCameraZoomToSphereParams:function(){const t=new An;return function(e,n,o,i,r){if(e.isOrthographicCamera){let t=Math.min(e.top,e.right);r[0]=t/n.radius,o.setFromMatrixPosition(e.matrixWorld),i.copy(n.center)}else{let r=le(e.fov/2);e.aspect<1&&(r=Math.atan(e.aspect*Math.tan(r)));let s=n.radius/Math.sin(r);const a=e.getWorldDirection(t);o.copy(n.center).addScaledVector(a,-s),i.copy(n.center)}}}()},VI={normalizeDialectOptions:function(t){var e={delimiter:",",doublequote:!0,lineterminator:"\n",quotechar:'"',skipinitialspace:!0,skipinitialrows:0};for(var n in t)e[n.toLowerCase()]=t[n];return e},parse:function(t,e){(!e||e&&!e.lineterminator)&&(t=VI.normalizeLineTerminator(t,e));var n=VI.normalizeDialectOptions(e);t=VI.chomp(t,n.lineterminator);var o,i,r="",s=!1,a=!1,l="",c=[],u=[];for(i=function(t){var e=String.prototype.trim?function(t){return t.trim()}:function(t){return t.replace(/^\s*/,"").replace(/\s*$/,"")};return!0!==a&&(""===t?t=null:!0===n.skipinitialspace&&(t=e(t)),/^\d+$/.test(t)?t=parseInt(t,10):/^\d*\.\d+$|^\d+\.\d*$/.test(t)&&(t=parseFloat(t,10))),t},o=0;o<t.length;o+=1)r=t.charAt(o),!1!==s||r!==n.delimiter&&r!==n.lineterminator?r!==n.quotechar?l+=r:s?t.charAt(o+1)===n.quotechar?(l+=n.quotechar,o+=1):s=!1:(s=!0,a=!0):(l=i(l),c.push(l),r===n.lineterminator&&(u.push(c),c=[]),l="",a=!1);return l=i(l),c.push(l),u.push(c),n.skipinitialrows&&(u=u.slice(n.skipinitialrows)),u},normalizeLineTerminator:function(t,e){return(e=e||{}).lineterminator?t:t.replace(/(\r\n|\n|\r)/gm,"\n")},chomp:function(t,e){return t.charAt(t.length-e.length)!==e?t:t.substring(0,t.length-e.length)}};const GI=new An(1,0,0),QI=new An,zI=new An,kI=new dn;function HI(){}Object.assign(HI.prototype,{onUpdate:function(t){},onFinish:function(){}});function WI(t){hi.call(this),this.type="CubeTextureHelper",this.geometry=new di(2,2,2,1,1,1),this.geometry.computeBoundingSphere(),this.material=new No,this.material.envMap=t}WI.prototype=Object.create(hi.prototype),WI.prototype.constructor=WI;class YI extends mo{constructor(t){super(),this.isAnnotationControl=!0,this.doUpdate=!0,this.projected=new An,this.container=t,this.updatedCallback=null}clone(){return new this.constructor(this.container).copy(this)}update(t){if(this.doUpdate){var e=this.projected;this.getWorldPosition(e).project(t);var n=this.container.offsetWidth,o=this.container.offsetHeight,i=(.5+e.x/2)*n,r=(.5-e.y/2)*o;e.x=i,e.y=r;var s=e.z<=1&&i>=0&&i<=n&&r>=0&&r<=o;this.visible=s,this.updatedCallback&&this.updatedCallback(e.x,e.y,s)}}}var XI=new La,KI=new An,jI=new An,ZI=new An;const qI=new An,JI=new dn,$I=new dn;var tM=Object.freeze({__proto__:null,rotateVRCamera:function(t,e,n){const o=t.parent;o&&!o.isScene&&(JI.setFromAxisAngle(e,n),JI.premultiply(t.quaternion),JI.premultiply(o.quaternion),o.quaternion.multiplyQuaternions(JI,$I.copy(t.quaternion).invert()))},translateVRCamera:function(t,e,n){const o=t.parent;o&&!o.isScene&&(qI.copy(e).applyQuaternion(t.quaternion).applyQuaternion(o.quaternion),o.position.add(qI.multiplyScalar(n)))}});if("undefined"!=typeof window&&(window.__V3D__?console.warn("WARNING: Multiple instances of Verge3D being imported."):window.__V3D__=n),"undefined"!=typeof document){const t=document.createElement("style");t.appendChild(document.createTextNode('.v3d-container {overflow: hidden;z-index: 0;}.v3d-canvas {position: absolute;top: 0;bottom: 0;left: 0;right: 0;z-index: -1;}.v3d-simple-preloader-background {background-color: #fff;position: absolute;top: 0;bottom: 0;left: 0;right: 0;z-index: 1;height: 100%;width: 100%;}.v3d-simple-preloader-container {--v3d-preloader-img-width: 120px;--v3d-preloader-img-height: 120px;position: absolute;top: 50%;left: 50%;transform: translate(-50%, -50%);width: calc(var(--v3d-preloader-img-width) + 60px);height: calc(var(--v3d-preloader-img-height) + 60px);}.v3d-simple-preloader-bar {background: linear-gradient(90deg, #1458ae, #4388e0);width: 0%;height: 3px;margin: 15px -1px;border: 1px solid;border-radius: 50px;border-color: #2b70c7;}.v3d-simple-preloader-logo {width: var(--v3d-preloader-img-width);height: var(--v3d-preloader-img-height);background-image: url(\'data:image/svg+xml,%3C%3Fxml version="1.0" encoding="UTF-8" standalone="no"%3F%3E%3Csvg width="120" height="120" viewBox="0 0 31.75 31.75" version="1.1" id="svg5409" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns="http://www.w3.org/2000/svg" xmlns:svg="http://www.w3.org/2000/svg" xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns%23" xmlns:cc="http://creativecommons.org/ns%23" xmlns:dc="http://purl.org/dc/elements/1.1/"%3E%3Cdefs id="defs5403"%3E%3ClinearGradient xlink:href="%23linearGradient3077" id="linearGradient4375" gradientUnits="userSpaceOnUse" x1="172.91336" y1="78.689407" x2="193.7847" y2="53.806618" gradientTransform="matrix(1.1562901,0,0,1.1583991,-194.29093,208.80811)" /%3E%3ClinearGradient id="linearGradient3077"%3E%3Cstop style="stop-color:%230048a5;stop-opacity:1" offset="0" id="stop3073" /%3E%3Cstop style="stop-color:%234b86d1;stop-opacity:1" offset="1" id="stop3075" /%3E%3C/linearGradient%3E%3C/defs%3E%3Cmetadata id="metadata5406"%3E%3Crdf:RDF%3E%3Ccc:Work rdf:about=""%3E%3Cdc:format%3Eimage/svg+xml%3C/dc:format%3E%3Cdc:type rdf:resource="http://purl.org/dc/dcmitype/StillImage" /%3E%3C/cc:Work%3E%3C/rdf:RDF%3E%3C/metadata%3E%3Cg id="layer1" transform="translate(0,-270.54167)"%3E%3Cpath style="display:inline;fill:url(%23linearGradient4375);fill-opacity:1;stroke:none;stroke-width:0.9171;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:1" d="m 15.945207,270.5417 c -1.669933,-0.007 -3.344811,1.1051 -7.2273169,3.32785 -7.76503612,4.4455 -7.2281318,3.52338 -7.2677439,12.48309 -0.03948,8.95973 -0.56829626,8.03286 7.1571159,12.5471 7.7254249,4.51422 6.6598479,4.50948 14.4248479,0.064 7.765036,-4.4455 7.228132,-3.52338 7.267744,-12.48309 0.03948,-8.95973 0.568296,-8.03287 -7.157116,-12.5471 -3.862718,-2.25711 -5.527635,-3.38445 -7.197531,-3.39185 z m -0.0132,2.85167 c 1.6836,0.007 3.363685,0.8128 6.115359,2.4207 5.503323,3.21577 6.107199,4.27438 6.078963,10.65695 -0.02832,6.3826 -0.641388,7.43578 -6.172923,10.60259 -5.531523,3.16682 -6.748576,3.16139 -12.2518993,-0.0544 -5.503299,-3.21578 -6.1071633,-4.27439 -6.0789633,-10.65697 0.02844,-6.38259 0.6413884,-7.43577 6.1729353,-10.6026 2.7657613,-1.5834 4.4529153,-2.37377 6.1365283,-2.3663 z m -0.154249,1.6177 c -2.694169,0.0343 -5.683359,3.07006 -7.236352,6.07548 -1.5776528,3.05311 -2.4803533,5.94456 -2.1086051,9.65753 0.1618801,1.61652 1.6983849,3.67982 3.5378539,4.71425 -0.3909602,-3.2062 -0.1707481,-6.34306 0.5400002,-8.94693 0.71076,-2.60387 2.83223,-6.82883 5.337159,-6.82316 2.504954,0.006 4.626375,4.22704 5.337123,6.83091 0.710725,2.60386 0.930961,5.74073 0.539989,8.94693 1.839481,-1.03442 3.375985,-3.09779 3.537853,-4.71432 0.371749,-3.71296 -0.53082,-6.60428 -2.108485,-9.6574 -1.547604,-2.99499 -4.52153,-6.01988 -7.24846,-6.08267 -0.0426,-9.5e-4 -0.08532,-10e-4 -0.128028,-6.2e-4 z m 0.131713,8.9184 a 2.4731483,2.4776591 0 0 0 -1.188637,0.29153 2.4731483,2.4776591 0 0 0 -1.017889,3.35228 2.4731483,2.4776591 0 0 0 3.34619,1.01974 2.4731483,2.4776591 0 0 0 1.017877,-3.35231 2.4731483,2.4776591 0 0 0 -2.157541,-1.31124 z" id="path4130" /%3E%3C/g%3E%3C/svg%3E\');background-size: 100% 100%;background-repeat: no-repeat;margin: 20px auto;}.v3d-annotation {position: absolute;top: -0.7em;left: -0.5em;width: auto;min-width: 1em;height: 1.4em;padding: 0.3em 0.5em;border: 1px solid #fff;border-radius: 2em;font-size: 16px;font-family: sans-serif;line-height: 1.4em;color: #fff;text-align: center;user-select: none;background: rgba(0, 0, 0, 0.8);}.v3d-annotation-transparent {opacity: 0.5;}.v3d-annotation-dialog {position: absolute;top: 85%;left: 85%;font-family: sans-serif;user-select: none;padding: 1em;min-width: 200px;color: #fff;background: rgba(0, 0, 0, 0.8);border-radius: 1em;font-size: 12px;line-height: 1.2;transition: opacity .5s;visibility: hidden;}.v3d-mobile-forward {position: absolute;width: 62px;height: 62px;bottom: 31px;left: 50%;margin-left: -31px;background-image: url(\'data:image/svg+xml,%3C%3Fxml version="1.0" encoding="UTF-8" standalone="no"%3F%3E%3Csvg width="62" height="62" viewBox="0 0 16.404167 16.404167" version="1.1" id="svg2719" sodipodi:docname="move_forward.svg" inkscape:version="1.1.2 (b8e25be833, 2022-02-05)" xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape" xmlns:sodipodi="http://sodipodi.sourceforge.net/DTD/sodipodi-0.dtd" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns="http://www.w3.org/2000/svg" xmlns:svg="http://www.w3.org/2000/svg" xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns%23" xmlns:cc="http://creativecommons.org/ns%23" xmlns:dc="http://purl.org/dc/elements/1.1/"%3E%3Csodipodi:namedview id="namedview7548" pagecolor="%23505050" bordercolor="%23eeeeee" borderopacity="1" inkscape:pageshadow="0" inkscape:pageopacity="0" inkscape:pagecheckerboard="0" showgrid="false" inkscape:snap-global="false" inkscape:zoom="7.1451613" inkscape:cx="42.266366" inkscape:cy="15.814898" inkscape:window-width="1920" inkscape:window-height="1137" inkscape:window-x="-8" inkscape:window-y="-8" inkscape:window-maximized="1" inkscape:current-layer="svg2719" /%3E%3Cdefs id="defs2713"%3E%3ClinearGradient gradientTransform="translate(-524.2581,-935.78503)" xlink:href="%23linearGradient2768" id="linearGradient2673" x1="501.88306" y1="942.95502" x2="508.08038" y2="935.61182" gradientUnits="userSpaceOnUse" /%3E%3ClinearGradient id="linearGradient2768"%3E%3Cstop style="stop-color:%23414141;stop-opacity:1" offset="0" id="stop2764" /%3E%3Cstop style="stop-color:%23767676;stop-opacity:1" offset="1" id="stop2766" /%3E%3C/linearGradient%3E%3ClinearGradient gradientTransform="translate(-521.96226,-941.8579)" xlink:href="%23linearGradient2648" id="linearGradient2665" x1="495.62714" y1="948.00964" x2="508.85629" y2="934.78046" gradientUnits="userSpaceOnUse" /%3E%3ClinearGradient id="linearGradient2648"%3E%3Cstop style="stop-color:%23ebebeb;stop-opacity:1" offset="0" id="stop2644" /%3E%3Cstop style="stop-color:%23ffffff;stop-opacity:1" offset="1" id="stop2646" /%3E%3C/linearGradient%3E%3Cfilter style="color-interpolation-filters:sRGB" id="filter2688" x="-0.12" width="1.24" y="-0.12" height="1.24"%3E%3CfeGaussianBlur stdDeviation="0.66145835" id="feGaussianBlur2690" /%3E%3C/filter%3E%3ClinearGradient inkscape:collect="always" xlink:href="%23linearGradient2768" id="linearGradient7749" x1="6.0107598" y1="11.942085" x2="11.430239" y2="4.0917845" gradientUnits="userSpaceOnUse" /%3E%3ClinearGradient inkscape:collect="always" xlink:href="%23linearGradient2648" id="linearGradient8251" x1="4.2536402" y1="13.238126" x2="12.150527" y2="2.9068334" gradientUnits="userSpaceOnUse" /%3E%3Cfilter inkscape:collect="always" style="color-interpolation-filters:sRGB" id="filter8772" x="-0.10840111" y="-0.10840111" width="1.2168022" height="1.2168022"%3E%3CfeGaussianBlur inkscape:collect="always" stdDeviation="0.59752352" id="feGaussianBlur8774" /%3E%3C/filter%3E%3C/defs%3E%3Cmetadata id="metadata2716"%3E%3Crdf:RDF%3E%3Ccc:Work rdf:about=""%3E%3Cdc:format%3Eimage/svg+xml%3C/dc:format%3E%3Cdc:type rdf:resource="http://purl.org/dc/dcmitype/StillImage" /%3E%3C/cc:Work%3E%3C/rdf:RDF%3E%3C/metadata%3E%3Ccircle style="fill:%23000000;stroke-width:0.230841;stroke-linecap:round;stroke-linejoin:round;fill-opacity:0.5;filter:url(%23filter8772)" id="circle8626" cx="8.2020836" cy="8.2020836" r="6.6145835" /%3E%3Ccircle style="fill:url(%23linearGradient8251);stroke-width:0.230841;stroke-linecap:round;stroke-linejoin:round;fill-opacity:1" id="path7652" cx="8.2020836" cy="8.2020836" r="6.6145835" /%3E%3Cpath d="m 4.2333333,6.7138018 c 0,0.9875367 0.4960933,2.4804692 0.4960933,2.4804692 h 1.984375 c 0,-0.7441408 0.2480473,-1.1782225 0.496094,-1.612305 0.2480467,-0.4340817 0.4960942,-0.8681642 0.4960942,-1.6123037 0,-0.8743657 -0.2480475,-2.7285166 -1.4882817,-2.7285166 -1.240234,0 -1.9843749,1.9843749 -1.9843748,3.4726561 z m 1.4882816,4.4648442 c 0.5472533,0 0.9921867,-0.444934 0.9921867,-0.992188 V 9.6903643 h -1.984375 v 0.4960937 c 0,0.547254 0.4449341,0.992188 0.9921883,0.992188 z M 12.170834,8.6981768 c 0,-1.4882808 -0.744141,-3.4726553 -1.984376,-3.4726553 -1.240234,0 -1.4882807,1.8541503 -1.4882807,2.7285153 0,0.74414 0.2480467,1.1782226 0.4960933,1.6123041 0.2480467,0.4340821 0.4960934,0.8681641 0.4960934,1.6123051 h 1.984376 c 0,0 0.496094,-1.4929325 0.496094,-2.4804692 z m -1.488281,4.4648442 c 0.547253,0 0.992187,-0.444935 0.992187,-0.992188 V 11.674739 H 9.690364 v 0.496094 c 0,0.547253 0.444935,0.992188 0.992189,0.992188 z" id="path7734" style="stroke-width:0.0155029;fill-opacity:1;fill:url(%23linearGradient7749)" /%3E%3C/svg%3E\');touch-action: none;-webkit-user-select: none;user-select: none;}.v3d-webgl-error-container {position: absolute;top: 50%;left: 50%;margin-top: -80px;margin-left: -200px;width: 400px;height: 160px;text-align: center;z-index: 10;}.v3d-webgl-error-image {width: 160px;height: 160px;background-repeat: no-repeat;margin: 0px auto;background-image: url(\'data:image/svg+xml,%3C%3Fxml version="1.0" encoding="UTF-8" standalone="no"%3F%3E%3Csvg width="160" height="160" viewBox="0 0 42.333332 42.333333" version="1.1" id="svg1" inkscape:version="1.3 (0e150ed6c4, 2023-07-21)" sodipodi:docname="webgl-error.svg" xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape" xmlns:sodipodi="http://sodipodi.sourceforge.net/DTD/sodipodi-0.dtd" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns="http://www.w3.org/2000/svg" xmlns:svg="http://www.w3.org/2000/svg"%3E%3Csodipodi:namedview id="namedview1" pagecolor="%23ffffff" bordercolor="%23eeeeee" borderopacity="1" inkscape:showpageshadow="false" inkscape:pageopacity="0" inkscape:pagecheckerboard="false" inkscape:deskcolor="%23d1d1d1" inkscape:document-units="px" labelstyle="default" shape-rendering="auto" inkscape:clip-to-page="false" inkscape:zoom="1.6017536" inkscape:cx="-5.3066837" inkscape:cy="78.97594" inkscape:window-width="1920" inkscape:window-height="1137" inkscape:window-x="-8" inkscape:window-y="-8" inkscape:window-maximized="1" inkscape:current-layer="layer1" /%3E%3Cdefs id="defs1"%3E%3Cfilter inkscape:collect="always" style="color-interpolation-filters:sRGB" id="filter1" x="-0.18167429" y="-0.16562716" width="1.3633486" height="1.3312543"%3E%3CfeGaussianBlur inkscape:collect="always" stdDeviation="2.1910722" id="feGaussianBlur1" /%3E%3C/filter%3E%3ClinearGradient inkscape:collect="always" xlink:href="%23linearGradient3259" id="linearGradient10" x1="863.9444" y1="1424.3892" x2="892.88947" y2="1424.3892" gradientUnits="userSpaceOnUse" /%3E%3ClinearGradient inkscape:collect="always" id="linearGradient3259"%3E%3Cstop style="stop-color:%23c90000;stop-opacity:1" offset="0" id="stop3255" /%3E%3Cstop style="stop-color:%23ff0a0a;stop-opacity:1" offset="1" id="stop3257" /%3E%3C/linearGradient%3E%3C/defs%3E%3Cg inkscape:label="Layer 1" inkscape:groupmode="layer" id="layer1"%3E%3Cg id="g2" style="display:inline" transform="translate(-857.25025,-1403.2226)"%3E%3Cpath id="path10" style="fill:%23e40505;fill-opacity:0.4;stroke-width:0.0581876;filter:url(%23filter1)" d="m 878.41691,1413.9426 c 1.49459,-0.033 2.34009,1.1428 2.29362,2.1957 l -0.39169,8.8754 c -0.0465,1.0529 -0.84799,1.9018 -1.90193,1.9018 -1.05394,0 -1.8516,-0.8491 -1.90193,-1.9018 l -0.42433,-8.8754 c -0.0503,-1.0527 0.83167,-2.163 2.32626,-2.1957 z m -0.18948,15.5145 c 1.4715,-0.1102 2.72596,1.0544 2.72522,2.53 0.0257,3.4066 -5.09721,3.4066 -5.07148,0 -6.7e-4,-1.3275 1.02252,-2.4308 2.34626,-2.53 z m 0.26002,-20.9425 c -1.67293,-0.01 -3.35083,1.1046 -7.24038,3.3274 -7.77912,4.4454 -7.24153,3.5234 -7.28121,12.483 -0.0397,8.9596 -0.56935,8.0329 7.17011,12.547 7.73941,4.5142 6.67221,4.5096 14.45131,0.064 7.77911,-4.4455 7.241,-3.5233 7.28069,-12.483 0.0397,-8.9596 0.56933,-8.0328 -7.1701,-12.547 -3.86972,-2.257 -5.53749,-3.384 -7.21042,-3.3915 z m -0.0134,2.8509 v 6e-4 c 1.68666,0.01 3.37009,0.8126 6.12676,2.4205 5.51329,3.2157 6.11834,4.2746 6.09006,10.6572 -0.0283,6.3825 -0.64255,7.4357 -6.18411,10.6025 -5.54155,3.1668 -6.76089,3.161 -12.27419,-0.055 -5.51329,-3.2158 -6.11831,-4.2742 -6.09007,-10.6567 0.0284,-6.3825 0.64255,-7.4357 6.18412,-10.6025 2.77079,-1.5834 4.46077,-2.3737 6.14743,-2.3663 z" sodipodi:nodetypes="zssssszsccssssssssssccsssssssc" /%3E%3Cpath id="path3" style="fill:url(%23linearGradient10);stroke-width:0.0581876" d="m 878.41691,1413.9426 c 1.49459,-0.033 2.34009,1.1428 2.29362,2.1957 l -0.39169,8.8754 c -0.0465,1.0529 -0.84799,1.9018 -1.90193,1.9018 -1.05394,0 -1.8516,-0.8491 -1.90193,-1.9018 l -0.42433,-8.8754 c -0.0503,-1.0527 0.83167,-2.163 2.32626,-2.1957 z m -0.18948,15.5145 c 1.4715,-0.1102 2.72596,1.0544 2.72522,2.53 0.0257,3.4066 -5.09721,3.4066 -5.07148,0 -6.7e-4,-1.3275 1.02252,-2.4308 2.34626,-2.53 z m 0.26002,-20.9425 c -1.67293,-0.01 -3.35083,1.1046 -7.24038,3.3274 -7.77912,4.4454 -7.24153,3.5234 -7.28121,12.483 -0.0397,8.9596 -0.56935,8.0329 7.17011,12.547 7.73941,4.5142 6.67221,4.5096 14.45131,0.064 7.77911,-4.4455 7.241,-3.5233 7.28069,-12.483 0.0397,-8.9596 0.56933,-8.0328 -7.1701,-12.547 -3.86972,-2.257 -5.53749,-3.384 -7.21042,-3.3915 z m -0.0134,2.8509 v 6e-4 c 1.68666,0.01 3.37009,0.8126 6.12676,2.4205 5.51329,3.2157 6.11834,4.2746 6.09006,10.6572 -0.0283,6.3825 -0.64255,7.4357 -6.18411,10.6025 -5.54155,3.1668 -6.76089,3.161 -12.27419,-0.055 -5.51329,-3.2158 -6.11831,-4.2742 -6.09007,-10.6567 0.0284,-6.3825 0.64255,-7.4357 6.18412,-10.6025 2.77079,-1.5834 4.46077,-2.3737 6.14743,-2.3663 z" sodipodi:nodetypes="zssssszsccssssssssssccsssssssc" /%3E%3C/g%3E%3C/g%3E%3C/svg%3E\');background-size: 100% 100%;}.v3d-webgl-error {font-family: Arial;font-size: 16px;}.v3d-webgl-error-link {font-style: italic;font-weight: bolder;}.v3d-webgl-error-link {color: #015fb1;}')),document.head.insertBefore(t,document.head.firstChild)}t.ACESFilmicToneMapping=4,t.AVERAGE=1,t.AddEquation=a,t.AddOperation=2,t.AdditiveAnimationBlendMode=Pt,t.AdditiveBlending=2,t.AgXBlenderToneMapping=9,t.AlphaFormat=1021,t.AlwaysDepth=1,t.AlwaysStencilFunc=519,t.AmbientLight=Cf,t.AmbientLightProbe=function(){console.error("v3d.AmbientLightProbe has been removed in Verge3D 4.11, use IBL instead.")},t.AnimationClip=cd,t.AnimationLoader=function(){console.error("v3d.AnimationLoader has been removed, use glTF format for asset loading.")},t.AnimationMixer=fd,t.AnimationObjectGroup=class{constructor(){this.isAnimationObjectGroup=!0,this.uuid=ne(),this.Sr=Array.prototype.slice.call(arguments),this.nCachedObjects_=0;const t={};this.br=t;for(let e=0,n=arguments.length;e!==n;++e)t[arguments[e].uuid]=e;this.yr=[],this.Rr=[],this.En=[],this.Tr={};const e=this;this.stats={objects:{get total(){return e.Sr.length},get inUse(){return this.total-e.nCachedObjects_}},get bindingsPerObject(){return e.En.length}}}add(){const t=this.Sr,e=this.br,n=this.yr,o=this.Rr,i=this.En,r=i.length;let s,a=t.length,l=this.nCachedObjects_;for(let c=0,u=arguments.length;c!==u;++c){const u=arguments[c],h=u.uuid;let f=e[h];if(void 0===f){f=a++,e[h]=f,t.push(u);for(let t=0,e=r;t!==e;++t)i[t].push(new ad(u,n[t],o[t]))}else if(f<l){s=t[f];const a=--l,c=t[a];e[c.uuid]=f,t[f]=c,e[h]=a,t[a]=u;for(let t=0,e=r;t!==e;++t){const e=i[t],r=e[a];let s=e[f];e[f]=r,void 0===s&&(s=new ad(u,n[t],o[t])),e[a]=s}}else t[f]!==s&&console.error("v3d.AnimationObjectGroup: Different objects with the same UUID detected. Clean the caches or recreate your infrastructure when reloading scenes.")}this.nCachedObjects_=l}remove(){const t=this.Sr,e=this.br,n=this.En,o=n.length;let i=this.nCachedObjects_;for(let r=0,s=arguments.length;r!==s;++r){const s=arguments[r],a=s.uuid,l=e[a];if(void 0!==l&&l>=i){const r=i++,c=t[r];e[c.uuid]=l,t[l]=c,e[a]=r,t[r]=s;for(let t=0,e=o;t!==e;++t){const e=n[t],o=e[r],i=e[l];e[l]=o,e[r]=i}}}this.nCachedObjects_=i}uncache(){const t=this.Sr,e=this.br,n=this.En,o=n.length;let i=this.nCachedObjects_,r=t.length;for(let s=0,a=arguments.length;s!==a;++s){const a=arguments[s].uuid,l=e[a];if(void 0!==l)if(delete e[a],l<i){const s=--i,a=t[s],c=--r,u=t[c];e[a.uuid]=l,t[l]=a,e[u.uuid]=s,t[s]=u,t.pop();for(let t=0,e=o;t!==e;++t){const e=n[t],o=e[s],i=e[c];e[l]=o,e[s]=i,e.pop()}}else{const i=--r,s=t[i];i>0&&(e[s.uuid]=l),t[l]=s,t.pop();for(let t=0,e=o;t!==e;++t){const e=n[t];e[l]=e[i],e.pop()}}}this.nCachedObjects_=i}subscribe_(t,e){const n=this.Tr;let o=n[t];const i=this.En;if(void 0!==o)return i[o];const r=this.yr,s=this.Rr,a=this.Sr,l=a.length,c=this.nCachedObjects_,u=new Array(l);o=i.length,n[t]=o,r.push(t),s.push(e),i.push(u);for(let n=c,o=a.length;n!==o;++n){const o=a[n];u[n]=new ad(o,t,e)}return u}unsubscribe_(t){const e=this.Tr,n=e[t];if(void 0!==n){const o=this.yr,i=this.Rr,r=this.En,s=r.length-1,a=r[s];e[t[s]]=n,r[n]=a,r.pop(),i[n]=i[s],i.pop(),o[n]=o[s],o.pop()}}},t.AnimationUtils=zf,t.Annotation=class extends YI{constructor(t,e,n){super(t),this.isAnnotation=!0,this.type="Annotation",this.character=e,this.dialogContents=n,this.annotation=document.createElement("div"),this.annotation.innerHTML=e,this.annotation.className="v3d-annotation",this.container.appendChild(this.annotation),this.annotationDialogVisible=!1,this.annotationDialog=document.createElement("div"),this.annotationDialog.innerHTML=n,this.annotationDialog.className="v3d-annotation-dialog",this.annotation.appendChild(this.annotationDialog),this.fadeObscured=!0,this.obscured=!1;var o=!1,i=this;function r(t){t.target==i.annotation?0==i.annotationDialog.innerHTML.length||i.obscured||(i.annotationDialogVisible=!i.annotationDialogVisible,i.annotationDialog.style.visibility=i.annotationDialogVisible?"visible":"hidden",i.annotationDialogVisible?i.annotation.style.zIndex="2":i.annotation.style.zIndex="1"):t.target.className.indexOf("v3d-annotation")>-1&&(i.annotationDialogVisible=!1,i.annotationDialog.style.visibility="hidden",i.annotation.style.zIndex=i.obscured?"auto":"1")}this.Br=function(t){r(t),o=!0},document.body.addEventListener("touchstart",this.Br,!1),this.Lr=function(t){o||r(t),o=!1},document.body.addEventListener("mousedown",this.Lr,!1)}raycast(){}clone(){return new this.constructor(this.container,this.character,this.dialogContents).copy(this)}update(t){if(super.update(t),this.doUpdate){var e=this.projected,n=this.annotation;if(n.style.transform="translate("+e.x+"px, "+e.y+"px)",n.style.visibility=this.visible?"visible":"hidden",this.annotationDialog.style.visibility=this.visible&&this.annotationDialogVisible?"visible":"hidden",this.fadeObscured){t.getWorldPositionNU(KI),this.getWorldPositionNU(jI),ZI.copy(jI).sub(KI).normalize(),XI.set(KI,ZI),XI.far=KI.distanceTo(jI);var o=XI.intersectObject(this.findRoot(),!0);o.length>1||1==o.length&&o[0].object!=this.parent?(n.classList.add("v3d-annotation-transparent"),this.obscured=!0,n.style.zIndex="auto",this.annotationDialog.style.visibility="hidden"):(n.classList.remove("v3d-annotation-transparent"),n.style.zIndex="visible"==this.annotationDialog.style.visibility?"2":"1",this.obscured=!1)}}}setDialogVisibility(t){t?(this.annotationDialogVisible=!0,this.annotationDialog.style.visibility="visible",this.annotation.style.zIndex="2"):(this.annotationDialogVisible=!1,this.annotationDialog.style.visibility="hidden",this.annotation.style.zIndex="1")}dispose(){var t=this.annotation.parentElement;t&&t.removeChild(this.annotation),document.body.removeEventListener("touchstart",this.Br,!1),document.body.removeEventListener("mousedown",this.Lr,!1)}},t.AnnotationControl=YI,t.App=class extends Zt{constructor(t,e={},n=null){if(super(),this.container=t instanceof HTMLElement?t:document.getElementById(t),this.scene=null,this.camera=null,this.clock=new If,this.mixer=null,this.renderCallbacks=[],this.compileCallbacks=[],this.elapsed=0,this.frame=0,this.preloader=n,this.worldCubemapRes=1024,this.ti=256,this.Nr=64,this.Dr=[],this.Pr=new Set,this.xrSession=null,this.xrCameraParent=null,this.xrControllers=[],e=e||{},!Mi.checkWebGL()){const t=e.webglErrorMsg||'Ouch! Your device does not support WebGL.<br>Find out how to fix this <a href="https://www.soft8soft.com/webgl-supported-browsers-and-troubleshooting/" target="_top" class="v3d-webgl-error-link">here</a>.';return void Mi.showWebGLErrorMessage(this.container,t)}Xe.legacyMode=!1;const o={};o.alpha=!!ye(e.alpha)&&e.alpha,o.depth=!ye(e.depth)||e.depth,o.stencil=!ye(e.stencil)||e.stencil,o.antialias=!ye(e.antialias)||e.antialias,o.premultipliedAlpha=!ye(e.premultipliedAlpha)||e.premultipliedAlpha,o.preserveDrawingBuffer=!!ye(e.preserveDrawingBuffer)&&e.preserveDrawingBuffer,Mi.isSafariWithMultisamplingBug()&&(console.warn("v3d.App: disabling buggy context AA on Safari 15.4"),o.antialias=!1),this.renderer=new Oa(o),ip.prepareRenderer(this.renderer),this.clearBkgOnLoad=!1,this.registerServiceKeys=!0,this.frameRateDivider=1,this.enableRender=!0,this.disableRenderTrigger=0,this.ssaaOnPause=!1,this.renderer.setSize(this.container.offsetWidth,this.container.offsetHeight),this.renderer.outputEncoding=Ft,this.container.appendChild(this.renderer.domElement),this.container.classList.add("v3d-container"),this.renderer.domElement.classList.add("v3d-canvas"),this.container.setAttribute("translate","no"),this.Or=()=>{this.Fr()},this.renderer.domElement.addEventListener("webglcontextrestored",this.Or),this.loader=new RE;const i=(new NC).setTranscoderPath(Ve()).detectSupport(this.renderer);this.loader.setKTX2Loader(i),Xo.prototype.computeBoundsTree=xI,Xo.prototype.disposeBoundsTree=II,hi.prototype.raycast=EI,this.actions=[],this.$o=0,this.Ur=null,this.Vr=null,this.Jo="",this.qo=0,this.Gr={background:null,postprocessing:null,useOIT:!1},this.cssRenderer=null,this.cssScene=null,this.stats=null,op.drawWatermark(this),op.addToAppList(this)}Qr(t){var e,n,o;const i=this,r=Mi.checkHalfFloatTex(this.renderer,!0),s=this.renderer.capabilities.isWebGL2;if(t.renderer.shadowMap&&(this.renderer.shadowMap.enabled=t.renderer.shadowMap.enabled,this.renderer.shadowMap.type=t.renderer.shadowMap.type,r||3!==this.renderer.shadowMap.type||(this.renderer.shadowMap.type=2,t.scene.traverse(function(t){t.isLight&&t.castShadow&&t.shadow&&(t.shadow.bias/=100)}))),this.aaMethod=null!=(e=t.renderer.aaMethod)?e:"AUTO","AUTO"===this.aaMethod||s||(console.warn("v3d.App: setting anti-aliasing to Auto for WebGL 1.0 renderer"),this.aaMethod="AUTO"),this.useHDR=Boolean(t.renderer.useHDR&&r),this.useHDR&&!s&&(console.warn("v3d.App: disabling HDR for WebGL 1.0 renderer"),this.useHDR=!1),this.renderer.useOIT=null!=(n=t.renderer.useOIT)&&n,this.renderer.useOIT&&!s&&(console.warn("v3d.App: disabling order-independent transparency for WebGL 1.0 renderer"),this.renderer.useOIT=!1),this.renderer.unitsScaleFactor=null!=(o=t.renderer.unitsScaleFactor)?o:1,t.renderer.toneMapping)for(let e=0;e<MI.length;e++){const n=MI[e];ye(t.renderer[n])&&(this.renderer[n]=t.renderer[n])}void 0!==t.renderer.pmremMaxTileSize&&(this.ti=t.renderer.pmremMaxTileSize),void 0!==t.renderer.iblEnvironmentMode&&(this.$o=t.renderer.iblEnvironmentMode),void 0!==t.renderer.esmDistanceScale&&(this.renderer.shadowMap.esmDistanceScale=t.renderer.esmDistanceScale);let a=!1;t.scene.traverse(function(t){t.hidpiCompositing&&(s&&t.traverse(e=>{t.isMesh&&(e.layers.set(7),e.isMaterialGeneratedMesh&&t.parent.layers.set(7))}),a=!0)}),a&&(s?(i.useHiDPIRenderPass=!0,i.renderer.setPixelRatio(window.devicePixelRatio)):console.warn("v3d.App: disabling HiDPI pass for WebGL 1.0 renderer")),i.useHiDPIRenderPass&&t.scene.traverse(function(t){t.isLight&&t.layers.enable(7)})}zr(t){t.scene&&t.scene.traverse(function(t){const e=t.geometry;t.isMesh&&e.computeBoundsTree&&0===Object.keys(e.morphAttributes).length&&e.computeBoundsTree({verbose:!1})})}kr(t){t.scene&&t.scene.traverse(t=>{if(t.isCubeReflectionProbe)this.Hr(t);else if(t.isPlaneReflectionProbe){let e=this.Wr(this.renderer,4);e>0&&t.makeMultisampleRenderTarget(e)}})}Hr(t){switch(t.setSize(this.ti),this.$o){case 0:t.onUpdate=t=>this.generateRTargetPMREM(t);break;case 1:case 2:t.onUpdate=()=>null}}Yr(t,e){t.traverse(t=>{(t.isCubeReflectionProbe||t.isPlaneReflectionProbe)&&t.setEncoding(e)})}Xr(){if(2==this.$o)return;const t=new Ni;t.worldMaterial=this.scene.worldMaterial,null===this.scene.worldEnvMapProbe&&(this.scene.worldEnvMapProbe=new Ep(this.ti),this.scene.worldEnvMapProbe.influenceType=0,this.scene.worldEnvMapProbe.parallaxType=0);const e=this.scene.worldEnvMapProbe;switch(this.$o){case 0:e.onUpdate=t=>this.generateRTargetPMREM(t);break;case 1:e.onUpdate=t=>{const e=t.clone();e.setSize(this.Nr,this.Nr),Mi.checkHalfFloatReadPixels(this.renderer)?e.texture.type=Q:Mi.checkFloatReadPixels(this.renderer)?e.texture.type=G:(console.warn("v3d.App: Target platform does not support reading pixels in float format, expect quality loss."),e.texture.type=O),e.texture.format=W,e.texture.encoding=Ot;const n=new hp(t.texture);return n.render(this.renderer,e),n.dispose(),this.Kr(),this.Ur=DC.fromCubeRenderTarget(this.renderer,e),this.scene.add(this.Ur),e.dispose(),null}}e.update(t,this.renderer)}jr(t){const e=this;t.scene&&t.scene.traverse(function(t){const n=t.material;n&&e.useHDR&&(n.toneMapped=!1,n.useFloatTex=Mi.checkFloatTex(e.renderer,!0),n.isMeshNodeMaterial&&n.updateNodeGraph(!0))})}Zr(t,e){const n=this;!n.mixer&&t.animations&&t.animations.length&&(n.mixer=new fd(n.scene)),(t.animations||[]).forEach(function(t){const o=e.getObjectById(t.nodeId);if(o){let i;t.clip.objectUUID=o.uuid,i=o.id==e.id||""!==o.name&&"root"!==o.name&&"."!==o.name&&o.name!==e.name&&o.name!==e.uuid?n.mixer.clipAction(t.clip,e):n.mixer.clipAction(t.clip,o),i.setLoop(t.loop,t.repetitions,!0),i.startAt(t.startAt+n.mixer.time),i.clampWhenFinished=!0,t.auto?i.play():(i.stop(),i.paused=!0),i.objectUUID=o.uuid,n.actions.push(i)}})}qr(t,e){t.traverse(function(t){if(t.material){(Array.isArray(t.material)?t.material:[t.material]).forEach(function(n){void 0!==n.program&&e(t,n,n.program.getTexUniformCount())})}})}Wr(t,e){return Math.min(e,t.capabilities.maxSamples)}Jr(t,e,n,o){const i=this,r=i.compileCallbacks;for(let t=0;t<r.length;t++)r[t](i);const s=i.renderer.getRenderTarget();i.renderer.setRenderTarget(n),i.renderer.compileAsync(t,e,function(t){t>=1&&i.renderer.setRenderTarget(s),o&&o(100*t)})}$r(t){this.scene.traverse(function(e){const n=e.material;n&&n.alphaToCoverage&&(t>0?(n.transparent=!1,n.premultipliedAlpha=!1,n.blending=0):n.alphaToCoverage=!1)})}Fr(t){this.scene&&this.scene.worldMaterial&&(this.updateEnvironment(this.scene.worldMaterial),this.updateReflectionProbes(this.scene))}assignClippingPlanes(t){const e=this;let n=[],o=[],i=[],r=-1e3;t.traverse(function(e){e.isClippingPlaneObject&&(n.push(e),o.push(e.plane),t.traverse(function(t){e.needsClippingPlane(t)&&e.assignToObject(t,r++)}),i.push(r++))});for(let t=0;t<n.length;t++){const e=n[t];e.crossSection&&e.createCrossSectionPlane(o,i[t])}n.length&&(e.renderer.localClippingEnabled=!0,e.postprocessing&&e.postprocessing.composer.setStencil(!0))}updateConstraints(t){const e=this;t.traverse(function(n){for(let o=0;o<n.constraints.length;o++){const i=n.constraints[o];i.isCanvasBreakpointsConstraint&&(i.appInstance=e),i.isCanvasFitConstraint&&(i.xr=e.renderer.xr),t.userData&&t.userData.coordSystem&&i.coordSystem&&(i.coordSystem=t.userData.coordSystem)}})}loadScene(t,e,n,o){const i=this;i.renderer?(i.Jo=t,i.qo=performance.now(),i.preloader&&i.preloader.onUpdate(0),this.loader.load(t,function(t){i.scene=t.scene||new Ni;let o=null;t.cameras&&t.cameras.length?i.camera=t.cameras[0]:(o=qm(i.scene),i.camera=Jm(o,i.container.offsetWidth/i.container.offsetHeight),i.scene.add(i.camera)),i.camera.controlSettings||(o=o||qm(i.scene),$m(i.camera,qm(i.scene)),i.camera.viewportFit.type=1),i.Qr(t),i.kr(t),i.jr(t),i.Zr(t,i.scene);const r=t.world.material;r&&(i.scene.background=new tn,i.scene.worldMaterial=r,i.updateEnvironment(r)),i.initPostprocessing(),i.assignClippingPlanes(i.scene),i.updateConstraints(i.scene),i.onResize&&i.onResize(),i.scene.updateWorldMatrix(!1,!0),i.scene.matrixWorldAutoUpdate=!1,i.scene.visible=!1,i.scene.disableChildRendering=!0;const s=function(){i.scene&&i.qr(i.scene,function(t,e,n){n>8&&console.warn(`v3d.App: Material "${e.name}" on object "${t.name}" exceeds iOS limit of 8 textures (has ${n}).`)}),i.qo=performance.now()-i.qo,i.dispatchEvent({...DI}),ke("observe",{loadingTime:i.qo}),i.removeEventListener("afterFirstRender",s)},a=i.postprocessing?i.postprocessing.composer.renderTarget1:null;i.Jr(i.scene,i.camera,a,function(o){const r=(60+bI*o)/1;n&&n(r),i.preloader&&i.preloader.onUpdate(r),r>=100&&(i.zr(t),i.addEventListener("afterFirstRender",s),e&&setTimeout(function(){i.scene.visible=!0,i.scene.disableChildRendering=!1,i.updateReflectionProbes(i.scene),e(i.scene)},16),t=null)}),i.clearBkgOnLoad&&(i.scene.background=null),i.registerServiceKeys&&op.registerServiceKeys(i)},function(t){const e=SI*t/1;n&&n(e),i.preloader&&i.preloader.onUpdate(e)},function(t){console.error(t),o&&o(t)}),window.removeEventListener("resize",this.Vr,!1),this.Vr=function(){i.onResize&&i.onResize()},window.addEventListener("resize",this.Vr,!1)):o&&o("WebGL not found")}appendScene(t,e,n,o,i,r){const s=this;s.renderer?(void 0===i&&(i=!0),void 0===r&&(r=!0),s.preloader&&s.preloader.onUpdate(0),this.loader.load(t,function(t){const o=t.scene||new Ni,a=[];o.traverse(function(t){(t.isCamera&&!i||t.isLight&&!r)&&a.push(t)}),a.forEach(function(t){s.unload(t)}),s.scene&&(s.scene.add(o),s.kr(t),s.jr(t),s.Zr(t,o),s.scene.updateWorldMatrix(!1,!0));const l=s.postprocessing?s.postprocessing.composer.renderTarget1:null,c=s.scene||o;s.assignClippingPlanes(c),s.updateConstraints(c),o.visible=!1,o.disableChildRendering=!0,s.Jr(c,s.camera||new _i,l,function(i){const r=(60+bI*i)/1;n&&n(r),s.preloader&&s.preloader.onUpdate(r),r>=100&&(s.zr(t),s.qr(o,function(t,e,n){n>8&&console.warn(`v3d.App: Material "${e.name}" on object "${t.name}" exceeds iOS limit of 8 textures (has ${n}).`)}),e&&setTimeout(function(){o.visible=!0,o.disableChildRendering=!1,s.updateReflectionProbes(s.scene),e(o)},16),t=null)})},function(t){const e=SI*t/1;n&&n(e),s.preloader&&s.preloader.onUpdate(e)},function(t){console.error(t),o&&o(t)})):o&&o("WebGL not found")}unload(t){const e=this;function n(t){if(t.isAnnotation)t.dispose();else if(t.isLight&&t.shadow&&t.shadow.isLightShadow)t.shadow.dispose();else if(t.isCamera&&t.controlSettings&&t.controlSettings.orbitTarget)n(t.controlSettings.orbitTarget);else if(t.isScene){const e=t.worldMaterial;null!==e&&(zm(e),e.dispose()),null!==t.worldEnvMapProbe&&(t.worldEnvMapProbe.dispose(),t.worldEnvMapProbe=null)}else if(t.isMesh){t.geometry.dispose(),t.geometry.disposeBoundsTree&&t.geometry.disposeBoundsTree();const e=t.material;zm(e),e.dispose()}}if(t||(t=e.scene),t===e.scene){if(e.scene&&(e.scene.traverse(n),e.disposeEnvironment()),e.scene=null,e.disableControls(),e.camera=null,e.mixer&&(e.mixer.stopAllAction(),e.actions.forEach(function(t){e.mixer.uncacheAction(t.getClip(),t.getRoot())})),e.mixer=null,e.actions=[],e.postprocessing){if(e.postprocessing.composer)for(let t in e.postprocessing){const n=e.postprocessing[t];(n instanceof Cr||n instanceof Cp)&&n.dispose()}e.disablePostprocessing()}e.postprocessing=null,Ir.dispose(),e.renderer&&e.renderer.disposeInternalCaches(),op.unregisterServiceKeys(e),e.useHiDPIRenderPass=!1,e.renderer.setPixelRatio(1)}else if(e.scene&&(t.traverse(n),t.parent&&t.parent.remove(t)),e.mixer)for(let t=e.actions.length-1;t>=0;t--){const n=e.actions[t];Zm(e.scene,n)||(n.stop(),e.mixer.uncacheAction(n.getClip(),n.getRoot()),e.actions.splice(t,1))}}dispose(){this.scene&&this.unload(),this.renderer&&(this.renderer.forceContextLoss(),this.renderer.dispose(),this.renderer.domElement.removeEventListener("webglcontextrestored",this.Or),this.Or=null,this.renderer.domElement.parentElement===this.container&&this.container.removeChild(this.renderer.domElement)),this.renderer=null,this.disableCSSRenderer(),this.loader=null,window.removeEventListener("resize",this.Vr,!1),this.Vr=null,this.renderCallbacks.length=0,this.compileCallbacks.length=0,op.removeFromAppList(this),Oh.clear(),this.dispatchEvent({...BI}),delete this.t}getWidth(){return this.container.offsetWidth}getHeight(){return this.container.offsetHeight}onResize(){if(!this.renderer)return;this.enableRender&&!this.ssaaOnPause||(this.enableRendering(),this.disableRendering(1));const t=this.getWidth(),e=this.getHeight();if(this.renderer.setSize(t,e),this.cssRenderer&&this.cssRenderer.setSize(t,e),this.postprocessing&&(this.postprocessing.gtaoGenerator&&this.postprocessing.gtaoGenerator.setSize(t,e),this.postprocessing.composer.setSize(t,e)),this.scene){this.scene.traverse(n=>{n.isPlaneReflectionProbe&&n.setSize(t,e)});const n=t/e,o=this.camera;if(o.isPerspectiveCamera){const t=o.aspect<o.viewportFit.initialAspect,e=n<o.viewportFit.initialAspect;switch(o.viewportFit.type){case 1:o.aspect=n;break;case 2:o.fov=PI(o.fov,o.aspect,n),o.aspect=n;break;case 3:t&&e?o.fov=PI(o.fov,o.aspect,n):t&&!e?o.fov=PI(o.fov,o.aspect,o.viewportFit.initialAspect):!t&&e&&(o.fov=PI(o.fov,o.viewportFit.initialAspect,n)),o.aspect=n;break;case 5:t&&e?o.fov=PI(o.fov,o.aspect,n):t&&!e?o.fov=PI(o.fov,o.viewportFit.initialAspect,n):!t&&e&&(o.fov=PI(o.fov,o.aspect,n)),o.aspect=n;break;case 4:t||e?t&&!e?o.fov=PI(o.fov,o.viewportFit.initialAspect,n):!t&&e&&(o.fov=PI(o.fov,o.aspect,o.viewportFit.initialAspect)):o.fov=PI(o.fov,o.aspect,n),o.aspect=n}}else if(o.isOrthographicCamera){let t,e;switch(o.viewportFit.type){case 1:case 5:t=o.top*n,o.left=-t,o.right=t;break;case 2:case 4:e=o.right/n,o.bottom=-e,o.top=e;break;case 3:const i=(o.right-o.left)/(o.top-o.bottom)<o.viewportFit.initialAspect,r=n<o.viewportFit.initialAspect;t=i&&r?o.right:i&&!r?o.right*n/o.viewportFit.initialAspect:!i&&r?o.top*o.viewportFit.initialAspect:o.top*n,o.left=-t,o.right=t,o.bottom=-t/n,o.top=t/n}}o.updateProjectionMatrix()}}run(){this.preloader&&(this.preloader.onFinish(),this.preloader=null),this.animate()}animate(){const t=this;t.renderer.setAnimationLoop(function(){t.stats&&t.stats.begin();const e=t.clock.getDelta();t.elapsed=e,t.mixer&&t.mixer.update(e),t.controls&&!t.xrSession&&t.controls.update(e);const n=t.renderCallbacks;for(let o=0;o<n.length;o++)n[o](e,t.clock.elapsedTime);t.frame%t.frameRateDivider==0&&t.enableRender&&(t.render(),0===t.frame&&t.dispatchEvent({...yI})),t.frame++,t.disableRenderTrigger&&0==--t.disableRenderTrigger&&(t.enableRender=!1),t.stats&&t.stats.end()})}enableRendering(){this.disableRenderTrigger=0,this.enableRender=!0,this.ssaaOnPause&&this.enableSSAA(0,!0)}disableRendering(t){this.xrSession||(((t=t||0)||this.ssaaOnPause)&&this.enableRender&&0==this.disableRenderTrigger?(this.disableRenderTrigger=this.ssaaOnPause?32:t,this.ssaaOnPause&&this.enableSSAA(4,!0)):0==t&&(this.enableRender=!1))}pause(){this.renderer.setAnimationLoop(null),this.clock.stop(),this.dispatchEvent({...LI})}resume(){this.animate(),this.clock.start(),this.dispatchEvent({...NI})}setFrameRateDivider(t){this.frameRateDivider=t}render(){this.dispatchEvent({...TI});const t=!!this.scene&&!!this.camera;if(t&&(this.scene.updateMatrixWorld(),this.scene.traverse(t=>{t.isPlaneReflectionProbe&&t.update(this.scene,this.camera,this.renderer)})),this.renderer.gtaoMapEnabled=!0,this.postprocessing){const t=this.postprocessing.gtaoGenerator;t&&t.render(this.renderer);this.postprocessing.composer.render(this.elapsed)}else t&&this.renderer.render(this.scene,this.camera);if(t&&this.useHiDPIRenderPass){const t=this.camera.layers.mask,e=this.scene.background,n=this.renderer.autoClear,o=this.renderer.useOIT;this.camera.layers.set(7),this.scene.background=null,this.renderer.autoClear=!1,this.renderer.useOIT=!1,this.renderer.clearDepth(),this.renderer.render(this.scene,this.camera),this.camera.layers.mask=t,this.scene.background=e,this.renderer.autoClear=n,this.renderer.useOIT=o}this.cssRenderer&&this.cssRenderer.render(this.cssScene,this.camera),this.renderer.gtaoMapEnabled=!1,this.dispatchEvent({...RI})}enableControls(t){const e=this.camera;if(!e.controlSettings)return;const n=e.controlSettings.type;if(this.controls&&e===this.controls.object&&(this.controls instanceof wm&&"ORBIT"===n||this.controls instanceof Lm&&"FLYING"===n||this.controls instanceof Rm&&"FIRST_PERSON"===n));else switch(this.disableControls(),n){case"ORBIT":this.controls=new wm(e,t||this.renderer.domElement);break;case"FLYING":this.controls=new Lm(e,t||this.renderer.domElement);break;case"FIRST_PERSON":this.controls=new Rm(e,t||this.renderer.domElement);break;default:this.controls=null}this.controls&&(e.controlSettings.assignToControls(this.controls,this.scene),this.controls.update())}disableControls(){this.controls&&(this.controls.dispose(),this.controls=null)}setCamera(t){let e=[];if(this.camera)for(let t=this.camera.children.length-1;t>=0;t--){const n=this.camera.children[t];n instanceof Rf&&(e.push(n),n.removeFromParent())}if(this.camera=t,this.postprocessing){const e=this.postprocessing.composer.passes;for(let n=0;n<e.length;n++)e[n].setCamera(t);this.postprocessing.renderPass&&this.postprocessing.renderPass.setCamera(t),this.postprocessing.ssaaRenderPass&&this.postprocessing.ssaaRenderPass.setCamera(t),this.postprocessing.gtaoGenerator&&this.postprocessing.gtaoGenerator.setCamera(t)}t.controlSettings?this.cssRenderer?this.enableControls(this.container):this.enableControls():this.disableControls();for(let n=0;n<e.length;n++)t.add(e[n]);this.onResize()}getCamera(t=!1){return t&&this.camera&&this.renderer&&this.renderer.xr.enabled&&this.renderer.xr.isPresenting?this.renderer.xr.getCamera():this.camera}initPostprocessing(){(this.scene.postprocessing&&this.scene.postprocessing.length||this.useHDR||this.useHiDPIRenderPass||"AUTO"!=this.aaMethod||this.renderer.useOIT)&&this.enablePostprocessing(this.scene.postprocessing||[]),this.renderer.useOIT&&(this.useHiDPIRenderPass?console.warn("v3d.App: Order-Independent Transparency is not compatible with HiDPI Compositing, disabling OIT"):this.renderer.setOIT(1,this.postprocessing.composer.writeBuffer.samples)),this.postprocessing||this.$r(this.renderer.getContextAttributes().antialias?4:0)}enablePostprocessing(t){if(this.xrSession)return;if(!this.renderer.capabilities.isWebGL2)return void console.warn("v3d.App: postprocessing is only supported for WebGL 2.0");const e={format:W,stencilBuffer:!1};let n;if(this.useHDR?(e.type=Q,e.encoding=Ot):(e.type=O,e.encoding=Ft),this.Yr(this.scene,e.encoding),this.postprocessing)n=this.postprocessing.composer;else{this.postprocessing={};const t=new QA(this.scene,this.camera);this.postprocessing.renderPass=t;let o=0;switch(this.aaMethod){case"AUTO":case"MSAA4":o=this.Wr(this.renderer,4);break;case"MSAA8":o=this.Wr(this.renderer,8);break;case"MSAA16":o=this.Wr(this.renderer,16)}Mi.checkSwiftShader(this.renderer)&&(console.warn("v3d.App: disabling buggy multisampling on SwiftShader renderer"),o=0),Mi.isSafariWithMultisamplingBug()&&(console.warn("v3d.App: disabling buggy multisampling on Safari 15.4"),o=0);const i=new cn(this.getWidth(),this.getHeight(),e);i.texture.name="EffectComposer.rt1",i.samples=o,n=new Cp(this.renderer,i),n.addPass(t),this.postprocessing.composer=n;const r=new YA;n.addPass(r),this.postprocessing.toneMapPass=r,this.useHDR||(r.material.toneMapped=!1);if(0==o&&"NONE"!=this.aaMethod){const t=new jd(this.scene,this.camera);n.addPass(t),this.postprocessing.fxaaPass=t}this.$r(o)}t.length&&this.postprocessing.copyPass&&(n.passes.splice(n.passes.indexOf(this.postprocessing.copyPass),1),this.postprocessing.copyPass=null);for(let o=0;o<t.length;o++){const i=t[o];let r=n.passes.length-1;switch(n.passes[r]instanceof jd&&r--,i.type){case"afterimage":const t=i.damp;let o;this.postprocessing.afterimagePass?(o=this.postprocessing.afterimagePass,o.damp=t):(o=new Hd(new we(this.getWidth(),this.getHeight()),t,e),n.insertPass(o,r),this.postprocessing.afterimagePass=o);break;case"bloom":const s=i.strength,a=i.radius,l=i.threshold;let c;this.postprocessing.bloomPass?(c=this.postprocessing.bloomPass,c.strength=s,c.radius=a,c.threshold=l):(c=new Wd(new we(this.getWidth(),this.getHeight()),s,a,l,e),n.insertPass(c,r),this.postprocessing.bloomPass=c);break;case"brightnessContrast":let u;this.postprocessing.brightnessContrastPass?u=this.postprocessing.brightnessContrastPass:(u=new Kd,n.insertPass(u,r),this.postprocessing.brightnessContrastPass=u),u.brightness=i.brightness,u.contrast=i.contrast;break;case"dof":let h;this.postprocessing.bokehPass?h=this.postprocessing.bokehPass:(h=new Yd(this.scene,this.camera,{width:this.getWidth(),height:this.getHeight()}),n.insertPass(h,r),this.postprocessing.bokehPass=h),h.focus=i.focus,h.aperture=i.aperture,h.maxblur=i.maxblur,h.depthLeakThreshold=i.depthLeakThreshold;break;case"grayscale":if(!this.postprocessing.grayscalePass){const t=new Zd;n.insertPass(t,r),this.postprocessing.grayscalePass=t}break;case"gtao":if(!Mi.checkDepthTex(this.renderer)){console.warn("v3d.App: disabling GTAO since your hardware does not support depth textures");break}if("ARM"===Mi.getGPUVendor(this.renderer)&&Mi.getGPUModel(this.renderer).startsWith("Mali-")){console.warn("v3d.App: disabling buggy GTAO on Mali devices");break}let f=this.postprocessing.gtaoGenerator;if(!f){f=this.postprocessing.gtaoGenerator=new RC(this.scene,this.camera,this.getWidth(),this.getHeight());const t=e=>{f.removeEventListener("dispose",t),this.renderer.disposeGTAO()};f.addEventListener("dispose",t),this.renderer.gtaoMap=f.renderTarget.texture}f.distance=i.distance,f.factor=i.factor,f.precision=i.precision,f.bentNormals=i.bentNormals;break;case"outline":let d;this.postprocessing.outlinePass?d=this.postprocessing.outlinePass:(d=new GA(new we(this.getWidth(),this.getHeight()),this.scene,this.camera),n.insertPass(d,r),this.postprocessing.outlinePass=d),d.edgeStrength=i.edgeStrength,d.edgeGlow=i.edgeGlow,d.edgeThickness=i.edgeThickness,d.pulsePeriod=i.pulsePeriod,d.visibleEdgeColor.fromArray(i.visibleEdgeColor),d.hiddenEdgeColor.fromArray(i.hiddenEdgeColor),d.hiddenEdgeColor.setW(Number(i.renderHiddenEdge));break;case"ssr":if(!Mi.checkHalfFloatTex(this.renderer,!1)){console.warn("v3d.App: disabling SSR since your hardware does not support half float textures");break}const A=ye(i.useRefract)&&i.useRefract,v=ye(i.simpleRefraction)&&i.simpleRefraction;let m;m=A&&!v?this.postprocessing.ssrPassRefract:A&&v?this.postprocessing.ssrPassSimpleRefract:this.postprocessing.ssrPassReflect,m||(m=new WA(this.scene,this.camera),n.insertPassAfter(m,[this.postprocessing.renderPass,this.postprocessing.ssrPassRefract,this.postprocessing.ssrPassReflect,this.postprocessing.ssrPassSimpleRefract]),A&&!v?this.postprocessing.ssrPassRefract=m:A&&v?this.postprocessing.ssrPassSimpleRefract=m:this.postprocessing.ssrPassReflect=m),m.useRefract=A,m.simpleRefraction=v,ye(i.objects)&&(m.objects=i.objects),ye(i.intensity)&&(m.intensity=i.intensity),ye(i.steps)&&(m.steps=i.steps),ye(i.stride)&&(m.stride=i.stride),ye(i.binarySearchSteps)&&(m.binarySearchSteps=i.binarySearchSteps),ye(i.renderTargetScale)&&(m.renderTargetScale=i.renderTargetScale),ye(i.maxDistance)&&(m.maxDistance=i.maxDistance),ye(i.jitter)&&(m.jitter=i.jitter),ye(i.renderAfter)&&(m.renderAfter=i.renderAfter),this.onResize&&this.onResize();break;default:console.error(`v3d.App: wrong postprocessing effect "${i.type}"`)}}if(1==n.passes.length){const t=new Xd(Vi.copy);n.passes.push(t),this.postprocessing.copyPass=t}}disablePostprocessing(t,e){if(!this.postprocessing)return;const n=this.postprocessing.gtaoGenerator;!e&&n&&(n.dispose(),this.postprocessing.gtaoGenerator=null);const o=["afterimagePass","bloomPass","brightnessContrastPass","bokehPass","grayscalePass","ssrPassReflect","ssrPassRefract","ssrPassSimpleRefract"];t||o.push("outlinePass");const i=this.postprocessing.composer;for(let t=0;t<o.length;t++){const e=o[t];this.postprocessing[e]&&(i.passes.splice(i.passes.indexOf(this.postprocessing[e]),1),this.postprocessing[e].dispose(),this.postprocessing[e]=null)}if("AUTO"!=this.aaMethod||1!=i.passes.length||this.postprocessing.gtaoGenerator){if(1==i.passes.length){const t=new Xd(Vi.copy);i.passes.push(t),this.postprocessing.copyPass=t}}else this.postprocessing.renderPass.dispose(),this.postprocessing.composer.dispose(),this.postprocessing=null}enableSSAA(t,e){if(this.postprocessing||this.enablePostprocessing([]),!this.postprocessing)return;if(t>0&&(this.postprocessing.ssrPassRefract||this.postprocessing.ssrPassReflect))return;const n=this;this.scene.traverse(function(e){e.isAnnotationControl&&(e.update(n.camera),e.doUpdate=!Boolean(t))});const o=this.postprocessing.composer;if(t>0&&o.passes[0]instanceof QA){let i;this.postprocessing.ssaaRenderPass?i=this.postprocessing.ssaaRenderPass:(i=new kA(this.scene,this.camera),this.postprocessing.ssaaRenderPass=i,e&&i.addEventListener("iteration",function(e){e.frame==t*t-1&&(o.enableAllPasses(),o.renderToScreen=!0,o.passes[o.passes.length-1].renderToScreen=!0,n.disableRenderTrigger=1)})),i.sampleLevel=t||4,o.passes[0]=i,this.postprocessing.fxaaPass&&o.passes.splice(o.passes.length-1,1),e&&(i.iterative=!0,i.iterativeFrame=0,o.disableAllPasses(),o.renderToScreen=!1,i.enabled=!0)}else t>0?(o.passes[0].sampleLevel=t||4,e&&(ssaaRenderPass.iterative=!0,ssaaRenderPass.iterativeFrame=0,o.disableAllPasses(),o.renderToScreen=!1,ssaaRenderPass.enabled=!0)):0==t&&o.passes[0]instanceof kA&&(o.passes[0]=this.postprocessing.renderPass,this.postprocessing.fxaaPass&&o.passes.push(this.postprocessing.fxaaPass),o.enableAllPasses(),o.renderToScreen=!0)}updateEnvironment(t){const e=this.renderer.xr.enabled;if(this.renderer.xr.enabled=!1,this.disposeEnvironment(),t.toneMapped=!1,null!==this.scene.background){const e=0===this.renderer.toneMapping?t.worldMaterialColor():null;null!==e?this.scene.background=e:(this.scene.background=dp(this.renderer,t,this.worldCubemapRes,{encoding:Ft,format:W,generateMipmaps:!0,minFilter:P,type:Q}).texture,this.scene.backgroundToneMapped=!this.useHDR)}0===this.$o&&new sr(this.renderer,this.ti,!0).compileCubemapShader(),this.Xr(),this.renderer.xr.enabled=e}disposeEnvironment(){this.Kr();let t=this.scene.background;t&&t&&(t.isTexture||t.isCubeTexture)&&t.dispose()}Kr(){null!==this.Ur&&(this.scene.remove(this.Ur),this.Ur=null)}updateReflectionProbes(t){t.traverse(t=>{t.isCubeReflectionProbe&&t.update(this.scene,this.renderer)})}generateRTargetPMREM(t){if(!t.isWebGLCubeRenderTarget)return null;const e=new sr(this.renderer,this.ti,!0),n=e.fromCubemap(t.texture);return e.dispose(),n}initWebXR(t,e,n,o,i,r){n=n||function(){},o=o||function(){},i=i||function(){},r=r||{};const s=this;function a(t){s.xrSession.removeEventListener("end",a),i();for(let t=0;t<s.xrControllers.length;t++){const e=s.xrControllers[t];e.removeEventListener("connected",l),s.scene.remove(e)}if(s.xrControllers=[],s.xrCameraParent){const t=s.camera;t.removeFromParent(),s.scene.add(t),s.scene.remove(s.xrCameraParent),s.xrCameraParent=null}if(s.xrSession=null,s.Gr.background&&(s.scene.background=s.Gr.background,s.Gr.background=null),s.postprocessing=s.Gr.postprocessing,s.Gr.postprocessing=null,s.postprocessing){const t=s.postprocessing.gtaoGenerator;t&&(s.renderer.gtaoMap=t.renderTarget.texture)}s.renderer.useOIT=s.Gr.useOIT,s.Gr.useOIT=!1,s.onResize()}function l(t){const e=t.data,n=t.target;if("tracked-pointer"==e.targetRayMode){const t=(new Xo).setFromPoints([new An(0,0,0),new An(0,0,-1)]),e=new Sl(t);e.name=n.name+"_RAY",e.scale.z=5,n.add(e)}else if("gaze"==e.targetRayMode){const t=(new Wh).load("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEAAAABACAYAAACqaXHeAAAIQXpUWHRSYXcgcHJvZmlsZSB0eXBlIGV4aWYAAHja7ZhZltw2DEX/uYosQSQ4LofjOdlBlp8LSqquHt12nD+X3JIKYpEg3sMDZDP/+XuZv/iIOGd8SDmWGA8+vvjiKjf5OD91n+3h93l//PWI76/s5vHAYRKucn7N8bJP7I7x7rL3a56KPTxNVOb1oL1+UK+JXL4WuOz3QmLPBY5rYlOvicRdK18utnNbRyw5PW+hX+PX9XyHgT+jJy/JxRBt8py9O1KKhfvsDp+I21BHV3dFfxfaNdGb7+Ye6vDJTbFycM7qoeC+FKmi93rGaSzCvUjY53J6ClrOHIn7csf1689Xnpvb9QvyV5A+7uwn9iekzQ7o/UDeIBQf1w/tNrzYzTOkG7enlWN8rPzKnufRXu35Rk3/1hp5rXnurvrIluO1qXsr+45xTaO1fxU5En/hyBpsPQpHJiU6PBqQrHF0W6wDxmW9HbbaZee+dttx0bvpElfnuhPbDcYMGMX1DbfXwy6XAH5IBvgOHQSre/hi97JlL9dtZuFhs4E9lsksP/lPh/nOoLU0oaw98iNW+OU00/BCkbPWHJZhIGLXFdSwA3wfbz+Kq4Bg2GHObLAeTWcA/hbsC7lkAy0MDFzPBLZpXBMQIjwIOGMFBI5oJdhoj4SwJWsJZAagiutOvGvAYkNwAyedF4mAQxawNr9Jdg91wZ1mhBAggkQjCWxITcDyPsCf5DMcqkGCDyHEkEIOJdQoUTMsxhRVUWuS5FNIMaWUU0nVZMk+hxxzyjmXXIsrguKGQj6WXEqplUUrM1d+XRlQa3NNmm+hxZZabqXV7kyX7nvosaeee+l1uCGDPB5xpJFHGXXaCZWmn2HGmWaeZdYF1ZYsv8KKK628iln1gdoF67vjJ1CzF2puI6UD0wM1rCndU1iVk6CYgZjzFsCTImDFOKeYHdl67xQ5xewoTkXQ4WRQcIZVxEDQT+vCsg/sXpALRuLvwc0AhPsdyBmF7hvIvcftI9RG3YVONkKahhrUQ8i+VdbM1eWqlfLLq/nRgO9e/0z0Z6LfNtEKlJIcBGEJdi4Y3YtQv/vMn9hbb2uO2qngQp1HkExeIqtF6sbqOjSLnimwjeScNfUo89iTZO/b7GHNot9iXc1v+ypRmpg4x9DZbZ/owSyht5CoP3X52YZQTUprFa0ItmIdx22xPvAvogdcVPyXdoNjrZpJ4+lZTtdDaj62hxnWigOhXduzQx+mQvaPZrNbk99ZfVDsDIMlgtBQLro75kMVI3Xb63P8HRXr6s2O0hI7YuI8TZLWlq8z1NZmxkfWRLdoCMcQIVAj5kCbeFkOhcg11PO8o7M6r+Z4Y/iJq4KdFVJt3w261qI9nXagWtvw6cKp96g4ZMIw/NZERidb2NYSDUzpabXiF3EzpaKqdZNqZSuTXqnN0CtBntdNmZYJStprx7kgxZCka/XWsc9qwzRVdkRnFEWjy8mRQDknXhkExoYgj6QNm96PWsKsM8EoejmdKOblTRMIQOt3ucsgJUigEUldCH5vJRCMcd1I1wWdMmKMNfyqcepalKOCefgzY9iGzOJ/Jd3Mhw9aLbrhTCyntQ44IOYBgdocpAPBbbGP1siF1bRxHYNyFKjJcD0EaAQs0EU0zcCEBBDNiuQn3CFPANTv3epZWd+CRs2zU7Og7coEZKcArFQGA8BOU5faUL/I3J0OuVAw2xqHzAHbywZiudFiNEM9XIMa3edcw7USP5WUzT5RLsA6JZ9SD/K07JoZAFUiPmdQak0CPlGYa/MptVDJT20yYguxkIT0DXQKexSrkjpz8QhlimYmdYF13enoS7Lj9CkCxcXzCa7Esl8AQBq6rDabFASNxDfMWcgaRzTRgIFeBRmje5n4GAJmnGIHE2qUtOBqhOpzOhnrHtCJiJnTPoAA9FmVwgzCETw7yqmHPwbBfIbCOxC6jSogCHVjYzWhLEk1KTQonoYhUIEbIQd4p42Wliu5ngJtT8Le6LXS6CdV5xIA+p3l6GY+dKCrHMp8mK0bSBPGK/WJ/d4U1PdiM3WhDiU9dQCRH6o4sxerpKcUyJGASZrjLVvTQ/XiJ0sAAj9ayPYW+8IbpLzW/3KkLUIvEnQKEG6FLW3OF3aksFMFtoZp+I0+giNUtd4xUutm3LTnZxLXmFQ5el3WkFEIPtPMorRGG2sfslIJ8NIaqxnbBKp7ckpOgDThLLn1kBGbnmRkvcgIlH+WkbLIoOC1LCAksc5RuviYqfE0yZeFd/2vomk+DSfceh1PLZ5k35uI3vXUvC+oKlTrUVBJ56eSyhJ5flhTzS8U1Q+v5ptF9aXK7ZuWNaXDJshY1S4xofutu27qtutxVSPSrffPqhGj39Ujan+5K9IXxXq+FPp3UhsAdw3TwQG5G3aWmEBohrt4qthpkCbBz4ntlcQXXreum5R1sbAXHs2QldBo9LOroE+gIaj52mBwabjzC2+lX17NjwbodeuhtFsPof1Q0UMOyTI0EO45g2lqG8k2i809EsB4quEkUrK1cKgW8mZb+UkcIAdcUXKyI9scHR1MY6I3jzUIZ2ODum6EgoaiEIrp9/YJmYP0QbMBnHLaCW2meqzsfm6AyYtX7S+id3W/vKle3e/OPRojdI/oDyOdRFVlrAORRx/igFKtQDte/oV654VGuvIKzMM2eCFuVB4SbD3CppXcXFE7i8guPY8i0l5XcpVqGsNjp1bjzGyCNLRgySyT5TY9R2fu2joo2cRhR6bsdCYa8P8MEJnzEqJpHiH6KEA6wXcCRHzMrwRovzykVEY/b/U/r81981+vfyb6M9H/MBF5RKaafwEjmLcIrlR0mgAAAAZiS0dEAP8A/wD/oL2nkwAAAAlwSFlzAAAuIwAALiMBeKU/dgAAAAd0SU1FB+MCAwojJyJFeN4AAAAZdEVYdENvbW1lbnQAQ3JlYXRlZCB3aXRoIEdJTVBXgQ4XAAAAd0lEQVR42u3YUQqAIBAFwLUDdf9zdCH7lwwEI2VnPkWQfWCvigAAAAAAgDTK1wecNWq7dpX+uaP7lw7gaZi3oUb3z3BkvwICEIAW+KcFRte3DWBGO7gCAhCAAHZ9FY6IpC3QG963gGeAAASgBRb6IwQAAAAAQCY34QUtIL9dJTwAAAAASUVORK5CYII="),e=new Va({map:t,sizeAttenuation:!1}),o=new $a(e);o.name=n.name+"_RETICLE",o.scale.multiplyScalar(.1),o.position.z=-5,n.add(o)}n.userData.inputSource=e}function c(t){const e=t.target;s.xrSession||e.removeEventListener("disconnected",c);for(let t=e.children.length-1;t>=0;t--){const n=e.children[t];n.name.indexOf(e.name)>-1&&(n.geometry.dispose(),n.material.dispose(),e.remove(n))}}const u={optionalFeatures:[e]};"immersive-ar"==t&&(u.optionalFeatures.push("hit-test"),r.domOverlay&&(u.optionalFeatures.push("dom-overlay"),u.domOverlay={root:s.container})),navigator.xr.requestSession(t,u).then(function(o){s.Gr.postprocessing=s.postprocessing,s.postprocessing=null,s.Gr.useOIT=s.renderer.useOIT,s.renderer.useOIT=!1,s.renderer.xr.setReferenceSpaceType(e),s.xrSession=o,o.addEventListener("end",a);const i="immersive-vr"==t?2:1;for(let t=0;t<i;t++){const e=s.renderer.xr.getController(t);s.scene.add(e),s.xrControllers.push(e),e.addEventListener("connected",l),e.addEventListener("disconnected",c)}if("immersive-vr"==t){const t=s.camera;t.parent&&t.parent.isScene&&(s.xrCameraParent=new mo,s.xrCameraParent.name="XR_CAMERA_CONTROL_OBJECT",s.scene.add(s.xrCameraParent),t.removeFromParent(),s.xrCameraParent.add(t))}else s.Gr.background=s.scene.background,s.scene.background=null;s.renderer.xr.enabled=!0,s.renderer.xr.setSession(o),r.domOverlay&&s.renderer.xr.addEventListener("sessionstart",function(){setTimeout(function(){s.renderer.domElement.style.width=s.getWidth()+"px",s.renderer.domElement.style.height=s.getHeight()+"px"},300)}),n()}).catch(o)}endWebXR(){this.xrSession&&this.xrSession.end()}printPerformanceInfo(t){op.printPerformanceInfo(this,t)}showFPS(){if(this.container){this.hideFPS();const t=new FC;t.showPanel(0),this.container.appendChild(t.dom),this.stats=t}}hideFPS(){this.container&&this.stats&&(this.container.removeChild(this.stats.dom),this.stats=null)}enableCSSRenderer(){this.cssRenderer=new up(this.container),this.cssRenderer.setSize(this.getWidth(),this.getHeight()),this.cssScene=new Ni,this.controls&&(this.disableControls(),this.enableControls(this.container),this.controls.allowMouseOverIframes=!0),this.renderer&&(this.renderer.domElement.style.pointerEvents="none")}disableCSSRenderer(){if(this.cssRenderer&&(this.cssRenderer=null,this.controls&&(this.disableControls(),this.enableControls(),this.controls.allowMouseOverIframes=!1),this.renderer&&(this.renderer.domElement.style.pointerEvents="auto"),this.cssScene)){const t=[];this.cssScene.traverse(e=>{t.push(e)}),t.forEach(t=>{t.removeFromParent()}),this.cssScene=null}}enableDebugMode(t){this.hasDebugMode(t)&&this.disableDebugMode(t),this.scene.traverse(e=>{let n=null,o=!1;if(!this.Dr.includes(e)&&!this.Dr.includes(e.parent)){if("wireframes"==t&&e.isMesh)n=new QC(e,"white");else if("lights"==t)e.isDirectionalLight?(n=new Bd(e,.5,"yellow"),o=!0):e.isSpotLight?(n=new Ed(e,"yellow"),o=!0):e.isPointLight?(n=new Sd(e,.1,"yellow"),o=!0):e.isRectAreaLight&&(n=new OC(e,"yellow"));else if("skeletons"==t&&e.isBone){let t=!1;e.traverseAncestors(e=>{e.isBone&&(t=!0)}),t||(n=new Id(e))}else"normals"==t&&e.isMesh&&(n=new GC(e,.1));null!==n&&(n.name=e.name+"Helper",n.visible=e.visible,e.add(n),o&&n.update(),this.Dr.push(n),this.Pr.add(t))}})}disableDebugMode(t){const e={wireframes:["WireframeHelper"],lights:["DirectionalLightHelper","SpotLightHelper","PointLightHelper","RectAreaLightHelper"],skeletons:["SkeletonHelper"],normals:["VertexNormalsHelper"]};for(let n=this.Dr.length-1;n>=0;n--){const o=this.Dr[n];e[t].includes(o.type)&&(o.removeFromParent(),this.Dr.splice(n,1))}this.Pr.delete(t)}hasDebugMode(t){return this.Pr.has(t)}},t.AppUtils=op,t.ArcCurve=class extends Ql{constructor(t,e,n,o,i,r){super(t,e,n,n,o,i,r),this.isArcCurve=!0,this.type="ArcCurve"}},t.ArrayCamera=ya,t.ArrowHelper=class extends mo{constructor(t=new An(0,0,1),e=new An(0,0,0),n=1,o=16776960,i=.2*n,r=.2*i){super(),this.type="ArrowHelper",void 0===Fd&&(Fd=new Xo,Fd.setAttribute("position",new Vo([0,0,0,0,1,0],3)),Ud=new ic(0,.5,1,5,1),Ud.translate(0,-.5,0)),this.position.copy(e),this.line=new Sl(Fd,new El({color:o,toneMapped:!1})),this.line.matrixAutoUpdate=!1,this.add(this.line),this.cone=new hi(Ud,new No({color:o,toneMapped:!1})),this.cone.matrixAutoUpdate=!1,this.add(this.cone),this.setDirection(t),this.setLength(n,i,r)}setDirection(t){if(t.y>.99999)this.quaternion.set(0,0,0,1);else if(t.y<-.99999)this.quaternion.set(1,0,0,0);else{Od.set(t.z,0,-t.x).normalize();const e=Math.acos(t.y);this.quaternion.setFromAxisAngle(Od,e)}}setLength(t,e=.2*t,n=.2*e){this.line.scale.set(1,Math.max(1e-4,t-e),1),this.line.updateMatrix(),this.cone.scale.set(n,e,n),this.cone.position.y=t,this.cone.updateMatrix()}setColor(t){this.line.material.color.set(t),this.cone.material.color.set(t)}copy(t){return super.copy(t,!1),this.line.copy(t.line),this.cone.copy(t.cone),this}dispose(){this.line.geometry.dispose(),this.line.material.dispose(),this.cone.geometry.dispose(),this.cone.material.dispose()}},t.Audio=Tf,t.AudioAnalyser=class{constructor(t,e=2048){this.analyser=t.context.createAnalyser(),this.analyser.fftSize=e,this.data=new Uint8Array(this.analyser.frequencyBinCount),t.getOutput().connect(this.analyser)}getFrequencyData(){return this.analyser.getByteFrequencyData(this.data),this.data}getAverageFrequency(){let t=0;const e=this.getFrequencyData();for(let n=0;n<e.length;n++)t+=e[n];return t/e.length}},t.AudioContext=jh,t.AudioListener=Rf,t.AudioLoader=class extends Vh{constructor(t){super(t)}load(t,e,n,o){const i=this,r=new zh(this.manager);r.setResponseType("arraybuffer"),r.setPath(this.path),r.setRequestHeader(this.requestHeader),r.setWithCredentials(this.withCredentials),r.load(t,function(n){try{const t=n.slice(0);jh.getContext().decodeAudioData(t,function(t){e(t)})}catch(e){o?o(e):console.error(e),i.manager.itemError(t)}},n,o)}},t.AxesHelper=class extends Rl{constructor(t=1){const e=[0,0,0,t,0,0,0,0,0,0,t,0,0,0,0,0,0,t],n=new Xo;n.setAttribute("position",new Vo(e,3)),n.setAttribute("color",new Vo([1,0,0,1,.6,0,0,1,0,.6,1,0,0,0,1,0,.6,1],3));super(n,new El({vertexColors:!0,toneMapped:!1})),this.type="AxesHelper"}setColors(t,e,n){const o=new tn,i=this.geometry.attributes.color.array;return o.set(t),o.toArray(i,0),o.toArray(i,3),o.set(e),o.toArray(i,6),o.toArray(i,9),o.set(n),o.toArray(i,12),o.toArray(i,15),this.geometry.attributes.color.needsUpdate=!0,this}dispose(){this.geometry.dispose(),this.material.dispose()}},t.BackSide=1,t.BasicDepthPacking=3200,t.BasicShadowMap=0,t.BilinearShadowMap=1,t.BlenderTextBufferGeometry=function(){console.error("v3d.BlenderTextBufferGeometry has been removed, use v3d.TextGeometry instead.")},t.BlenderTextGeometry=function(){console.error("v3d.BlenderTextGeometry has been removed, use v3d.TextGeometry instead.")},t.BloomPass=Wd,t.BokehPass=Yd,t.Bone=cl,t.BooleanKeyframeTrack=Zf,t.Box2=class{constructor(t=new we(1/0,1/0),e=new we(-1/0,-1/0)){this.isBox2=!0,this.min=t,this.max=e}set(t,e){return this.min.copy(t),this.max.copy(e),this}setFromPoints(t){this.makeEmpty();for(let e=0,n=t.length;e<n;e++)this.expandByPoint(t[e]);return this}setFromCenterAndSize(t,e){const n=vd.copy(e).multiplyScalar(.5);return this.min.copy(t).sub(n),this.max.copy(t).add(n),this}clone(){return(new this.constructor).copy(this)}copy(t){return this.min.copy(t.min),this.max.copy(t.max),this}makeEmpty(){return this.min.x=this.min.y=1/0,this.max.x=this.max.y=-1/0,this}isEmpty(){return this.max.x<this.min.x||this.max.y<this.min.y}getCenter(t){return this.isEmpty()?t.set(0,0):t.addVectors(this.min,this.max).multiplyScalar(.5)}getSize(t){return this.isEmpty()?t.set(0,0):t.subVectors(this.max,this.min)}expandByPoint(t){return this.min.min(t),this.max.max(t),this}expandByVector(t){return this.min.sub(t),this.max.add(t),this}expandByScalar(t){return this.min.addScalar(-t),this.max.addScalar(t),this}containsPoint(t){return!(t.x<this.min.x||t.x>this.max.x||t.y<this.min.y||t.y>this.max.y)}containsBox(t){return this.min.x<=t.min.x&&t.max.x<=this.max.x&&this.min.y<=t.min.y&&t.max.y<=this.max.y}getParameter(t,e){return e.set((t.x-this.min.x)/(this.max.x-this.min.x),(t.y-this.min.y)/(this.max.y-this.min.y))}intersectsBox(t){return!(t.max.x<this.min.x||t.min.x>this.max.x||t.max.y<this.min.y||t.min.y>this.max.y)}clampPoint(t,e){return e.copy(t).clamp(this.min,this.max)}distanceToPoint(t){return vd.copy(t).clamp(this.min,this.max).sub(t).length()}intersect(t){return this.min.max(t.min),this.max.min(t.max),this}union(t){return this.min.min(t.min),this.max.max(t.max),this}translate(t){return this.min.add(t),this.max.add(t),this}equals(t){return t.min.equals(this.min)&&t.max.equals(this.max)}},t.Box3=pn,t.Box3Helper=bd,t.BoxGeometry=di,t.BoxHelper=class extends Rl{constructor(t,e=16776960){const n=new Uint16Array([0,1,1,2,2,3,3,0,4,5,5,6,6,7,7,4,0,4,1,5,2,6,3,7]),o=new Float32Array(24),i=new Xo;i.setIndex(new Oo(n,1)),i.setAttribute("position",new Oo(o,3)),super(i,new El({color:e,toneMapped:!1})),this.object=t,this.type="BoxHelper",this.matrixAutoUpdate=!1,this.update()}update(t){if(void 0!==t&&console.warn("v3d.BoxHelper: .update() has no longer arguments."),void 0!==this.object&&Pd.setFromObject(this.object),Pd.isEmpty())return;const e=Pd.min,n=Pd.max,o=this.geometry.attributes.position,i=o.array;i[0]=n.x,i[1]=n.y,i[2]=n.z,i[3]=e.x,i[4]=n.y,i[5]=n.z,i[6]=e.x,i[7]=e.y,i[8]=n.z,i[9]=n.x,i[10]=e.y,i[11]=n.z,i[12]=n.x,i[13]=n.y,i[14]=e.z,i[15]=e.x,i[16]=n.y,i[17]=e.z,i[18]=e.x,i[19]=e.y,i[20]=e.z,i[21]=n.x,i[22]=e.y,i[23]=e.z,o.needsUpdate=!0,this.geometry.computeBoundingSphere()}setFromObject(t){return this.object=t,this.update(),this}copy(t,e){return super.copy(t,e),this.object=t.object,this}dispose(){this.geometry.dispose(),this.material.dispose()}},t.BrightnessContrastPass=Kd,t.BufferAttribute=Oo,t.BufferGeometry=Xo,t.BufferGeometryLoader=function(){console.error("v3d.BufferGeometryLoader has been removed, use glTF format for asset loading.")},t.BufferGeometryUtils=Gm,t.ByteType=1010,t.CENTER=0,t.CSS3DObject=class extends mo{constructor(t=document.createElement("div")){super(),this.isCSS3DObject=!0,this.element=t,this.element.style.position="absolute",this.element.style.userSelect="none",this.element.style.pointerEvents="auto",this.element.setAttribute("draggable",!1),this.addEventListener("removed",function(){this.traverse(function(t){t.element instanceof t.element.ownerDocument.defaultView.Element&&null!==t.element.parentNode&&t.element.remove()})})}copy(t,e){return super.copy(t,e),this.element=t.element.cloneNode(!0),this}},t.CSS3DRenderer=up,t.CSVParser=VI,t.Cache=Oh,t.Camera=_i,t.CameraHelper=class extends Rl{constructor(t){const e=new Xo,n=new El({color:16777215,vertexColors:!0,toneMapped:!1}),o=[],i=[],r={};function s(t,e){a(t),a(e)}function a(t){o.push(0,0,0),i.push(0,0,0),void 0===r[t]&&(r[t]=[]),r[t].push(o.length/3-1)}s("n1","n2"),s("n2","n4"),s("n4","n3"),s("n3","n1"),s("f1","f2"),s("f2","f4"),s("f4","f3"),s("f3","f1"),s("n1","f1"),s("n2","f2"),s("n3","f3"),s("n4","f4"),s("p","n1"),s("p","n2"),s("p","n3"),s("p","n4"),s("u1","u2"),s("u2","u3"),s("u3","u1"),s("c","t"),s("p","c"),s("cn1","cn2"),s("cn3","cn4"),s("cf1","cf2"),s("cf3","cf4"),e.setAttribute("position",new Vo(o,3)),e.setAttribute("color",new Vo(i,3)),super(e,n),this.type="CameraHelper",this.camera=t,this.camera.updateProjectionMatrix&&this.camera.updateProjectionMatrix(),this.matrix=t.matrixWorld,this.matrixAutoUpdate=!1,this.pointMap=r,this.update();const l=new tn(16755200),c=new tn(16711680),u=new tn(43775),h=new tn(16777215),f=new tn(3355443);this.setColors(l,c,u,h,f)}setColors(t,e,n,o,i){const r=this.geometry.getAttribute("color");r.setXYZ(0,t.r,t.g,t.b),r.setXYZ(1,t.r,t.g,t.b),r.setXYZ(2,t.r,t.g,t.b),r.setXYZ(3,t.r,t.g,t.b),r.setXYZ(4,t.r,t.g,t.b),r.setXYZ(5,t.r,t.g,t.b),r.setXYZ(6,t.r,t.g,t.b),r.setXYZ(7,t.r,t.g,t.b),r.setXYZ(8,t.r,t.g,t.b),r.setXYZ(9,t.r,t.g,t.b),r.setXYZ(10,t.r,t.g,t.b),r.setXYZ(11,t.r,t.g,t.b),r.setXYZ(12,t.r,t.g,t.b),r.setXYZ(13,t.r,t.g,t.b),r.setXYZ(14,t.r,t.g,t.b),r.setXYZ(15,t.r,t.g,t.b),r.setXYZ(16,t.r,t.g,t.b),r.setXYZ(17,t.r,t.g,t.b),r.setXYZ(18,t.r,t.g,t.b),r.setXYZ(19,t.r,t.g,t.b),r.setXYZ(20,t.r,t.g,t.b),r.setXYZ(21,t.r,t.g,t.b),r.setXYZ(22,t.r,t.g,t.b),r.setXYZ(23,t.r,t.g,t.b),r.setXYZ(24,e.r,e.g,e.b),r.setXYZ(25,e.r,e.g,e.b),r.setXYZ(26,e.r,e.g,e.b),r.setXYZ(27,e.r,e.g,e.b),r.setXYZ(28,e.r,e.g,e.b),r.setXYZ(29,e.r,e.g,e.b),r.setXYZ(30,e.r,e.g,e.b),r.setXYZ(31,e.r,e.g,e.b),r.setXYZ(32,n.r,n.g,n.b),r.setXYZ(33,n.r,n.g,n.b),r.setXYZ(34,n.r,n.g,n.b),r.setXYZ(35,n.r,n.g,n.b),r.setXYZ(36,n.r,n.g,n.b),r.setXYZ(37,n.r,n.g,n.b),r.setXYZ(38,o.r,o.g,o.b),r.setXYZ(39,o.r,o.g,o.b),r.setXYZ(40,i.r,i.g,i.b),r.setXYZ(41,i.r,i.g,i.b),r.setXYZ(42,i.r,i.g,i.b),r.setXYZ(43,i.r,i.g,i.b),r.setXYZ(44,i.r,i.g,i.b),r.setXYZ(45,i.r,i.g,i.b),r.setXYZ(46,i.r,i.g,i.b),r.setXYZ(47,i.r,i.g,i.b),r.setXYZ(48,i.r,i.g,i.b),r.setXYZ(49,i.r,i.g,i.b),r.needsUpdate=!0}update(){const t=this.geometry,e=this.pointMap;Nd.projectionMatrixInverse.copy(this.camera.projectionMatrixInverse),Dd("c",e,t,Nd,0,0,-1),Dd("t",e,t,Nd,0,0,1),Dd("n1",e,t,Nd,-1,-1,-1),Dd("n2",e,t,Nd,1,-1,-1),Dd("n3",e,t,Nd,-1,1,-1),Dd("n4",e,t,Nd,1,1,-1),Dd("f1",e,t,Nd,-1,-1,1),Dd("f2",e,t,Nd,1,-1,1),Dd("f3",e,t,Nd,-1,1,1),Dd("f4",e,t,Nd,1,1,1),Dd("u1",e,t,Nd,.7,1.1,-1),Dd("u2",e,t,Nd,-.7,1.1,-1),Dd("u3",e,t,Nd,0,2,-1),Dd("cf1",e,t,Nd,-1,0,1),Dd("cf2",e,t,Nd,1,0,1),Dd("cf3",e,t,Nd,0,-1,1),Dd("cf4",e,t,Nd,0,1,1),Dd("cn1",e,t,Nd,-1,0,-1),Dd("cn2",e,t,Nd,1,0,-1),Dd("cn3",e,t,Nd,0,-1,-1),Dd("cn4",e,t,Nd,0,1,-1),t.getAttribute("position").needsUpdate=!0}dispose(){this.geometry.dispose(),this.material.dispose()}},t.CameraUtils=UI,t.CanvasBreakpointsConstraint=E_,t.CanvasFitConstraint=__,t.CanvasTexture=Vl,t.CapsuleGeometry=class extends oc{constructor(t=1,e=1,n=4,o=8){const i=new nc;i.absarc(0,-e/2,t,1.5*Math.PI,0),i.absarc(0,e/2,t,0,.5*Math.PI),super(i.getPoints(n),o),this.type="CapsuleGeometry",this.parameters={radius:t,height:e,capSegments:n,radialSegments:o}}},t.CatmullRomCurve3=class extends Gl{constructor(t=[],e=!1,n="centripetal",o=.5){super(),this.isCatmullRomCurve3=!0,this.type="CatmullRomCurve3",this.points=t,this.closed=e,this.curveType=n,this.tension=o}getPoint(t,e=new An){const n=e,o=this.points,i=o.length,r=(i-(this.closed?0:1))*t;let s,a,l=Math.floor(r),c=r-l;this.closed?l+=l>0?0:(Math.floor(Math.abs(l)/i)+1)*i:0===c&&l===i-1&&(l=i-2,c=1),this.closed||l>0?s=o[(l-1)%i]:(kl.subVectors(o[0],o[1]).add(o[0]),s=kl);const u=o[l%i],h=o[(l+1)%i];if(this.closed||l+2<i?a=o[(l+2)%i]:(kl.subVectors(o[i-1],o[i-2]).add(o[i-1]),a=kl),"centripetal"===this.curveType||"chordal"===this.curveType){const t="chordal"===this.curveType?.5:.25;let e=Math.pow(s.distanceToSquared(u),t),n=Math.pow(u.distanceToSquared(h),t),o=Math.pow(h.distanceToSquared(a),t);n<1e-4&&(n=1),e<1e-4&&(e=n),o<1e-4&&(o=n),Hl.initNonuniformCatmullRom(s.x,u.x,h.x,a.x,e,n,o),Wl.initNonuniformCatmullRom(s.y,u.y,h.y,a.y,e,n,o),Yl.initNonuniformCatmullRom(s.z,u.z,h.z,a.z,e,n,o)}else"catmullrom"===this.curveType&&(Hl.initCatmullRom(s.x,u.x,h.x,a.x,this.tension),Wl.initCatmullRom(s.y,u.y,h.y,a.y,this.tension),Yl.initCatmullRom(s.z,u.z,h.z,a.z,this.tension));return n.set(Hl.calc(c),Wl.calc(c),Yl.calc(c)),n}copy(t){super.copy(t),this.points=[];for(let e=0,n=t.points.length;e<n;e++){const n=t.points[e];this.points.push(n.clone())}return this.closed=t.closed,this.curveType=t.curveType,this.tension=t.tension,this}},t.ChildOfConstraint=Kp,t.CineonToneMapping=3,t.CircleGeometry=class extends Xo{constructor(t=1,e=32,n=0,o=2*Math.PI){super(),this.type="CircleGeometry",this.parameters={radius:t,segments:e,thetaStart:n,thetaLength:o},e=Math.max(3,e);const i=[],r=[],s=[],a=[],l=new An,c=new we;r.push(0,0,0),s.push(0,0,1),a.push(.5,.5);for(let i=0,u=3;i<=e;i++,u+=3){const h=n+i/e*o;l.x=t*Math.cos(h),l.y=t*Math.sin(h),r.push(l.x,l.y,l.z),s.push(0,0,1),c.x=(r[u]/t+1)/2,c.y=(r[u+1]/t+1)/2,a.push(c.x,c.y)}for(let t=1;t<=e;t++)i.push(t,t+1,0);this.setIndex(i),this.setAttribute("position",new Vo(r,3)),this.setAttribute("normal",new Vo(s,3)),this.setAttribute("uv",new Vo(a,2))}},t.ClampToEdgeWrapping=y,t.ClearMaskPass=NA,t.Clock=If,t.Color=tn,t.ColorKeyframeTrack=jf,t.ColorManagement=Xe,t.Compat=ip,t.CompressedArrayTexture=class extends Ul{constructor(t,e,n,o,i,r){super(t,e,n,i,r),this.isCompressedArrayTexture=!0,this.image.depth=o,this.wrapR=y}},t.CompressedTexture=Ul,t.CompressedTextureLoader=class extends Vh{constructor(t){super(t)}load(t,e,n,o){const i=this,r=[],s=new Ul,a=new zh(this.manager);a.setPath(this.path),a.setResponseType("arraybuffer"),a.setRequestHeader(this.requestHeader),a.setWithCredentials(i.withCredentials);let l=0;function c(c){a.load(t[c],function(t){const n=i.parse(t,!0);r[c]={width:n.width,height:n.height,format:n.format,mipmaps:n.mipmaps},l+=1,6===l&&(1===n.mipmapCount&&(s.minFilter=N),s.image=r,s.format=n.format,s.needsUpdate=!0,e&&e(s))},n,o)}if(Array.isArray(t))for(let e=0,n=t.length;e<n;++e)c(e);else a.load(t,function(t){const n=i.parse(t,!0);if(n.isCubemap){const t=n.mipmaps.length/n.mipmapCount;for(let e=0;e<t;e++){r[e]={mipmaps:[]};for(let t=0;t<n.mipmapCount;t++)r[e].mipmaps.push(n.mipmaps[e*n.mipmapCount+t]),r[e].format=n.format,r[e].width=n.width,r[e].height=n.height}s.image=r}else s.image.width=n.width,s.image.height=n.height,s.mipmaps=n.mipmaps;1===n.mipmapCount&&(s.minFilter=N),s.format=n.format,s.needsUpdate=!0,e&&e(s)},n,o);return s}},t.ConeGeometry=class extends ic{constructor(t=1,e=1,n=32,o=1,i=!1,r=0,s=2*Math.PI){super(0,t,e,n,o,i,r,s),this.type="ConeGeometry",this.parameters={radius:t,height:e,radialSegments:n,heightSegments:o,openEnded:i,thetaStart:r,thetaLength:s}}},t.Constraint=Hp,t.ConstraintSpaceCustom=1,t.ConstraintSpaceLocal=2,t.ConstraintSpaceWorld=0,t.ControlSettings=Dm,t.CopyLocationConstraint=Jp,t.CopyRotationConstraint=og,t.CopyScaleConstraint=ag,t.CopyTransformsConstraint=dg,t.CubeCamera=wi,t.CubeCopy=hp,t.CubeReflectionMapping=w,t.CubeReflectionProbe=Ep,t.CubeRefractionMapping=x,t.CubeTexture=xi,t.CubeTextureHelper=WI,t.CubeTextureLoader=class extends Vh{constructor(t){super(t)}load(t,e,n,o){const i=new xi,r=new kh(this.manager);r.setCrossOrigin(this.crossOrigin),r.setPath(this.path);let s=0;function a(n){r.load(t[n],function(t){i.images[n]=t,s++,6===s&&(i.needsUpdate=!0,e&&e(i))},void 0,o)}for(let e=0;e<t.length;++e)a(e);return i}},t.CubeUVReflectionMapping=S,t.CubicBezierCurve=Zl,t.CubicBezierCurve3=class extends Gl{constructor(t=new An,e=new An,n=new An,o=new An){super(),this.isCubicBezierCurve3=!0,this.type="CubicBezierCurve3",this.v0=t,this.v1=e,this.v2=n,this.v3=o}getPoint(t,e=new An){const n=e,o=this.v0,i=this.v1,r=this.v2,s=this.v3;return n.set(jl(t,o.x,i.x,r.x,s.x),jl(t,o.y,i.y,r.y,s.y),jl(t,o.z,i.z,r.z,s.z)),n}copy(t){return super.copy(t),this.v0.copy(t.v0),this.v1.copy(t.v1),this.v2.copy(t.v2),this.v3.copy(t.v3),this}},t.CubicInterpolant=Pf,t.CullFaceBack=1,t.CullFaceFront=2,t.CullFaceFrontBack=3,t.CullFaceNone=0,t.Curve=Gl,t.CurvePath=ec,t.CustomBlending=5,t.CustomToneMapping=5,t.CylinderGeometry=ic,t.Cylindrical=class{constructor(t=1,e=0,n=0){return this.radius=t,this.theta=e,this.y=n,this}set(t,e,n){return this.radius=t,this.theta=e,this.y=n,this}copy(t){return this.radius=t.radius,this.theta=t.theta,this.y=t.y,this}setFromVector3(t){return this.setFromCartesianCoords(t.x,t.y,t.z)}setFromCartesianCoords(t,e,n){return this.radius=Math.sqrt(t*t+n*n),this.theta=Math.atan2(t,n),this.y=e,this}clone(){return(new this.constructor).copy(this)}},t.DampedTrackConstraint=Ig,t.Data3DTexture=hn,t.DataArrayTexture=un,t.DataTexture=ul,t.DataTextureLoader=Hh,t.DataUtils=kd,t.DecrementStencilOp=7683,t.DecrementWrapStencilOp=Yt,t.DefaultLoadingManager=Uh,t.DepthFormat=Y,t.DepthStencilFormat=X,t.DepthTexture=Er,t.Detector=Mi,t.DirectionalLight=Ef,t.DirectionalLightCSMHelper=class extends mo{constructor(t){super(),this.csm=t,this.displayFrustum=!0,this.displayPlanes=!0,this.displayShadowBounds=!0;const e=new Uint16Array([0,1,1,2,2,3,3,0,4,5,5,6,6,7,7,4,0,4,1,5,2,6,3,7]),n=new Float32Array(24),o=new Xo;o.setIndex(new Oo(e,1)),o.setAttribute("position",new Oo(n,3,!1));const i=new Rl(o,new El);this.add(i),this.frustumLines=i,this.cascadeLines=[],this.cascadePlanes=[],this.shadowLines=[]}updateVisibility(){const t=this.displayFrustum&&this.visible,e=this.displayPlanes&&this.visible,n=this.displayShadowBounds&&this.visible,o=this.frustumLines,i=this.cascadeLines,r=this.cascadePlanes,s=this.shadowLines;for(let o=0,a=i.length;o<a;o++){const a=i[o],l=r[o],c=s[o];a.visible=t,l.visible=t&&e,c.visible=n,c.traverse(t=>{t.visible=n})}o.visible=t}update(){const t=this.csm,e=t.be;if(!e||t.ts)return;const n=t.Ht,o=n.length,i=t.mainFrustum,r=t.Ie,s=this.frustumLines.geometry.getAttribute("position"),a=this.cascadeLines,l=this.cascadePlanes,c=this.shadowLines;for(this.position.copy(e.position),this.quaternion.copy(e.quaternion),this.scale.copy(e.scale),this.updateWorldMatrix(!1,!0);a.length>o;){this.remove(a.pop()),this.remove(l.pop());const t=c.pop();t.children[0].dispose(),this.remove(t)}for(;a.length<o;){const t=new bd(new pn,16777215),e=new No({transparent:!0,opacity:.1,depthWrite:!1,side:2}),n=new hi(new Oi,e),o=new Ra,i=new bd(new pn,16776960);o.add(i),this.add(t),this.add(n),this.add(o),a.push(t),l.push(n),c.push(o)}for(let t=0;t<o;t++){const e=r[t],o=n[t].camera,i=e.vertices.far,s=a[t],u=l[t],h=c[t],f=h.children[0];s.box.min.copy(i[2]),s.box.max.copy(i[0]),s.box.max.z+=1e-4,u.position.addVectors(i[0],i[2]),u.position.multiplyScalar(.5),u.scale.subVectors(i[0],i[2]),u.scale.z=1e-4,this.remove(h),h.position.copy(o.position),h.quaternion.copy(o.quaternion),h.scale.copy(o.scale),h.updateWorldMatrix(!1,!0),this.attach(h),f.box.min.set(o.bottom,o.left,-o.far),f.box.max.set(o.top,o.right,-o.near)}const u=i.vertices.near,h=i.vertices.far;s.setXYZ(0,h[0].x,h[0].y,h[0].z),s.setXYZ(1,h[3].x,h[3].y,h[3].z),s.setXYZ(2,h[2].x,h[2].y,h[2].z),s.setXYZ(3,h[1].x,h[1].y,h[1].z),s.setXYZ(4,u[0].x,u[0].y,u[0].z),s.setXYZ(5,u[3].x,u[3].y,u[3].z),s.setXYZ(6,u[2].x,u[2].y,u[2].z),s.setXYZ(7,u[1].x,u[1].y,u[1].z),s.needsUpdate=!0}dispose(){const t=this.frustumLines,e=this.cascadeLines,n=this.cascadePlanes,o=this.shadowLines;t.geometry.dispose(),t.material.dispose();const i=this.csm.cascades;for(let t=0;t<i;t++){const i=e[t],r=n[t],s=o[t].children[0];i.dispose(),r.geometry.dispose(),r.material.dispose(),s.dispose()}}},t.DirectionalLightHelper=Bd,t.DiscreteInterpolant=qc,t.DodecahedronGeometry=function(){console.error("v3d.DodecahedronGeometry has been removed in Verge3D 4.11.")},t.DoubleSide=2,t.DstAlphaFactor=206,t.DstColorFactor=208,t.DynamicCopyUsage=35050,t.DynamicDrawUsage=35048,t.DynamicReadUsage=35049,t.ESMDistancePacking=3302,t.ESMShadowMap=3,t.EdgesGeometry=class extends Xo{constructor(t=null,e=1){if(super(),this.type="EdgesGeometry",this.parameters={geometry:t,thresholdAngle:e},null!==t){const n=4,o=Math.pow(10,n),i=Math.cos(Jt*e),r=t.getIndex(),s=t.getAttribute("position"),a=r?r.count:s.count,l=[0,0,0],c=["a","b","c"],u=new Array(3),h={},f=[];for(let t=0;t<a;t+=3){r?(l[0]=r.getX(t),l[1]=r.getX(t+1),l[2]=r.getX(t+2)):(l[0]=t,l[1]=t+1,l[2]=t+2);const{a:e,b:n,c:a}=lc;if(e.fromBufferAttribute(s,l[0]),n.fromBufferAttribute(s,l[1]),a.fromBufferAttribute(s,l[2]),lc.getNormal(ac),u[0]=`${Math.round(e.x*o)},${Math.round(e.y*o)},${Math.round(e.z*o)}`,u[1]=`${Math.round(n.x*o)},${Math.round(n.y*o)},${Math.round(n.z*o)}`,u[2]=`${Math.round(a.x*o)},${Math.round(a.y*o)},${Math.round(a.z*o)}`,u[0]!==u[1]&&u[1]!==u[2]&&u[2]!==u[0])for(let t=0;t<3;t++){const e=(t+1)%3,n=u[t],o=u[e],r=lc[c[t]],s=lc[c[e]],a=`${n}_${o}`,d=`${o}_${n}`;d in h&&h[d]?(ac.dot(h[d].normal)<=i&&(f.push(r.x,r.y,r.z),f.push(s.x,s.y,s.z)),h[d]=null):a in h||(h[a]={index0:l[t],index1:l[e],normal:ac.clone()})}}for(const t in h)if(h[t]){const{index0:e,index1:n}=h[t];rc.fromBufferAttribute(s,e),sc.fromBufferAttribute(s,n),f.push(rc.x,rc.y,rc.z),f.push(sc.x,sc.y,sc.z)}this.setAttribute("position",new Vo(f,3))}}},t.EffectComposer=Cp,t.EllipseCurve=Ql,t.EqualDepth=4,t.EqualStencilFunc=514,t.EquirectangularReflectionMapping=I,t.EquirectangularRefractionMapping=M,t.Euler=to,t.EventDispatcher=Zt,t.ExtendedTriangle=Lw,t.ExtrudeGeometry=Uc,t.FXAAPass=jd,t.FileLoader=zh,t.FilmicBlenderToneMapping=8,t.FirstPersonControls=Rm,t.FixOrthoZoomConstraint=d_,t.Float16BufferAttribute=class extends Oo{constructor(t,e,n){super(new Uint16Array(t),e,n),this.isFloat16BufferAttribute=!0}},t.Float32BufferAttribute=Vo,t.Float64BufferAttribute=class extends Oo{constructor(t,e,n){super(new Float64Array(t),e,n)}},t.FloatType=G,t.FloorConstraint=Tg,t.FlyingControls=Lm,t.Fog=Ua,t.FogExp2=Fa,t.Font=Up,t.FramebufferTexture=class extends an{constructor(t,e,n){super({width:t,height:e}),this.isFramebufferTexture=!0,this.format=n,this.magFilter=T,this.minFilter=T,this.generateMipmaps=!1,this.needsUpdate=!0}},t.FrontSide=0,t.Frustum=Li,t.GLBufferAttribute=class{constructor(t,e,n,o,i){this.isGLBufferAttribute=!0,this.buffer=t,this.type=e,this.itemSize=n,this.elementSize=o,this.count=i,this.version=0}set needsUpdate(t){!0===t&&this.version++}setBuffer(t){return this.buffer=t,this}setType(t,e){return this.type=t,this.elementSize=e,this}setItemSize(t){return this.itemSize=t,this}setCount(t){return this.count=t,this}},t.GLSL1="100",t.GLSL3=Kt,t.GLTFExporter=nA,t.GLTFLoader=RE,t.GTAOMapGenerator=RC,t.GraphUtils=lu,t.GrayscalePass=Zd,t.GreaterDepth=6,t.GreaterEqualDepth=5,t.GreaterEqualStencilFunc=518,t.GreaterStencilFunc=516,t.GridHelper=class extends Rl{constructor(t=10,e=10,n=4473924,o=8947848){n=new tn(n),o=new tn(o);const i=e/2,r=t/e,s=t/2,a=[],l=[];for(let t=0,c=0,u=-s;t<=e;t++,u+=r){a.push(-s,0,u,s,0,u),a.push(u,0,-s,u,0,s);const e=t===i?n:o;e.toArray(l,c),c+=3,e.toArray(l,c),c+=3,e.toArray(l,c),c+=3,e.toArray(l,c),c+=3}const c=new Xo;c.setAttribute("position",new Vo(a,3)),c.setAttribute("color",new Vo(l,3));super(c,new El({vertexColors:!0,toneMapped:!1})),this.type="GridHelper"}dispose(){this.geometry.dispose(),this.material.dispose()}},t.Group=Ra,t.HalfFloatType=Q,t.HemisphereLight=function(){console.error("v3d.HemisphereLight has been removed in Verge3D 4.11, use IBL instead.")},t.HemisphereLightHelper=function(){console.error("v3d.HemisphereLightHelper has been removed in Verge3D 4.11.")},t.HemisphereLightProbe=function(){console.error("v3d.HemisphereLightProbe has been removed in Verge3D 4.11, use IBL instead.")},t.IBLEnvironmentNone=2,t.IBLEnvironmentPMREM=0,t.IBLEnvironmentProbe=1,t.IcosahedronGeometry=class extends Gc{constructor(t=1,e=0){const n=(1+Math.sqrt(5))/2;super([-1,n,0,1,n,0,-1,-n,0,1,-n,0,0,-1,n,0,1,n,0,-1,-n,0,1,-n,n,0,-1,n,0,1,-n,0,-1,-n,0,1],[0,11,5,0,5,1,0,1,7,0,7,10,0,10,11,1,5,9,5,11,4,11,10,2,10,7,6,7,1,8,3,9,4,3,4,2,3,2,6,3,6,8,3,8,9,4,9,5,2,4,11,6,2,10,8,6,7,9,8,1],t,e),this.type="IcosahedronGeometry",this.parameters={radius:t,detail:e}}},t.ImageBitmapLoader=Yh,t.ImageLoader=kh,t.ImageUtils=nn,t.IncrementStencilOp=7682,t.IncrementWrapStencilOp=Wt,t.InstancedBufferAttribute=Al,t.InstancedBufferGeometry=class extends Xo{constructor(){super(),this.isInstancedBufferGeometry=!0,this.type="InstancedBufferGeometry",this.instanceCount=1/0}copy(t){return super.copy(t),this.instanceCount=t.instanceCount,this}},t.InstancedInterleavedBuffer=function(){console.error("v3d.InstancedInterleavedBuffer has been removed, use tightly packed buffers instead.")},t.InstancedMesh=class extends hi{constructor(t,e,n){super(t,e),this.isInstancedMesh=!0,this.instanceMatrix=new Al(new Float32Array(16*n),16),this.instanceColor=null,this.count=n,this.frustumCulled=!1;for(let t=0;t<n;t++)this.setMatrixAt(t,gl)}copy(t,e){return super.copy(t,e),this.instanceMatrix.copy(t.instanceMatrix),null!==t.instanceColor&&(this.instanceColor=t.instanceColor.clone()),this.count=t.count,this}getColorAt(t,e){e.fromArray(this.instanceColor.array,3*t)}getMatrixAt(t,e){e.fromArray(this.instanceMatrix.array,16*t)}raycast(t,e){const n=this.matrixWorld,o=this.count;if(_l.geometry=this.geometry,_l.material=this.material,void 0!==_l.material)for(let i=0;i<o;i++){this.getMatrixAt(i,vl),ml.multiplyMatrices(n,vl),_l.matrixWorld=ml,_l.raycast(t,pl);for(let t=0,n=pl.length;t<n;t++){const n=pl[t];n.instanceId=i,n.object=this,e.push(n)}pl.length=0}}setColorAt(t,e){null===this.instanceColor&&(this.instanceColor=new Al(new Float32Array(3*this.instanceMatrix.count),3)),e.toArray(this.instanceColor.array,3*t)}setMatrixAt(t,e){e.toArray(this.instanceMatrix.array,16*t)}updateMorphTargets(){}dispose(){this.dispatchEvent({type:"dispose"})}},t.Int16BufferAttribute=class extends Oo{constructor(t,e,n){super(new Int16Array(t),e,n)}},t.Int32BufferAttribute=class extends Oo{constructor(t,e,n){super(new Int32Array(t),e,n)}},t.Int8BufferAttribute=class extends Oo{constructor(t,e,n){super(new Int8Array(t),e,n)}},t.IntType=U,t.InterleavedBuffer=function(){console.error("v3d.InterleavedBuffer has been removed, use tightly packed buffers instead.")},t.InterleavedBufferAttribute=function(){console.error("v3d.InterleavedBufferAttribute has been removed, use tightly packed buffers instead.")},t.Interpolant=Zc,t.InterpolateDiscrete=yt,t.InterpolateLinear=Rt,t.InterpolateSmooth=Tt,t.InvertStencilOp=5386,t.KeepStencilOp=kt,t.KeyframeTrack=kf,t.Keys=jv,t.LOD=class extends mo{constructor(){super(),this.es=0,this.type="LOD",Object.defineProperties(this,{levels:{enumerable:!0,value:[]},isLOD:{value:!0}}),this.autoUpdate=!0}copy(t){super.copy(t,!1);const e=t.levels;for(let t=0,n=e.length;t<n;t++){const n=e[t];this.addLevel(n.object.clone(),n.distance,n.hysteresis)}return this.autoUpdate=t.autoUpdate,this}addLevel(t,e=0,n=0){e=Math.abs(e);const o=this.levels;let i;for(i=0;i<o.length&&!(e<o[i].distance);i++);return o.splice(i,0,{distance:e,hysteresis:n,object:t}),this.add(t),this}getCurrentLevel(){return this.es}getObjectForDistance(t){const e=this.levels;if(e.length>0){let n,o;for(n=1,o=e.length;n<o;n++){let o=e[n].distance;if(e[n].object.visible&&(o-=o*e[n].hysteresis),t<o)break}return e[n-1].object}return null}raycast(t,e){if(this.levels.length>0){el.setFromMatrixPosition(this.matrixWorld);const n=t.ray.origin.distanceTo(el);this.getObjectForDistance(n).raycast(t,e)}}update(t){const e=this.levels;if(e.length>1){el.setFromMatrixPosition(t.matrixWorld),nl.setFromMatrixPosition(this.matrixWorld);const n=el.distanceTo(nl)/t.zoom;let o,i;for(e[0].object.visible=!0,o=1,i=e.length;o<i;o++){let t=e[o].distance;if(e[o].object.visible&&(t-=t*e[o].hysteresis),!(n>=t))break;e[o-1].object.visible=!1,e[o].object.visible=!0}for(this.es=o-1;o<i;o++)e[o].object.visible=!1}}},t.LatheGeometry=oc,t.Layers=eo,t.LessDepth=2,t.LessEqualDepth=3,t.LessEqualStencilFunc=515,t.LessStencilFunc=513,t.Light=Zh,t.LightProbe=xf,t.LightProbeGenerator=DC,t.LimitDistanceConstraint=Pg,t.LimitLocationConstraint=Gg,t.LimitRotationConstraint=zg,t.LimitScaleConstraint=kg,t.Line=Sl,t.Line3=gd,t.LineBasicMaterial=El,t.LineCurve=ql,t.LineCurve3=class extends Gl{constructor(t=new An,e=new An){super(),this.isLineCurve3=!0,this.type="LineCurve3",this.v1=t,this.v2=e}getPoint(t,e=new An){const n=e;return 1===t?n.copy(this.v2):(n.copy(this.v2).sub(this.v1),n.multiplyScalar(t).add(this.v1)),n}getPointAt(t,e){return this.getPoint(t,e)}copy(t){return super.copy(t),this.v1.copy(t.v1),this.v2.copy(t.v2),this}},t.LineDashedMaterial=class extends El{constructor(t){super(),this.isLineDashedMaterial=!0,this.type="LineDashedMaterial",this.scale=1,this.dashSize=3,this.gapSize=1,this.setValues(t)}copy(t){return super.copy(t),this.scale=t.scale,this.dashSize=t.dashSize,this.gapSize=t.gapSize,this}},t.LineHTML=class extends hi{constructor(t,e){t=void 0!==t?t:new tn(1,0,0),e=void 0!==e?e:2;const n=new PA;n.setGeometry([0,0,0,GI.x,GI.y,GI.z]);const o=new Kc({color:t,lineWidth:e,sizeAttenuation:0});super(n.geometry,o),this.isLineHTML=!0,this.elemHTML=null,this.offset=5}onBeforeRender(t,e,n,o,i,r){if(super.onBeforeRender(),!this.elemHTML)return;const s=t.domElement.offsetWidth,a=t.domElement.offsetHeight,l=this.elemHTML.getBoundingClientRect(),c=t.domElement.getBoundingClientRect(),u=l.left-c.left,h=l.right-c.left,f=l.top-c.top,d=l.bottom-c.top,A=(u+h)/2,v=(f+d)/2,m=this.getWorldPosition(QI).project(n),p=(m.x+1)/2*s,g=(1-m.y)/2*a,_=(v-g)/(A-p),E=(l.height+2*this.offset)/(l.width+2*this.offset);let C,w;Math.abs(_)>E?(w=g>v?Math.min(d+this.offset,g):Math.max(f-this.offset,g),C=(w-g)/_+p):(C=p<A?Math.max(u-this.offset,p):Math.min(h+this.offset,p),w=(C-p)*_+g);const x=2*C/s-1,I=1-2*w/a,M=zI.set(x,I,-1);M.unproject(n),this.parent&&this.parent.worldToLocal(M);const S=M.length();this.scale.setScalar(S),M.normalize();const b=kI.setFromUnitVectors(GI,M);this.setRotationFromQuaternion(b),this.updateMatrixWorld()}},t.LineLoop=Tl,t.LineSegments=Rl,t.LinearDepthPacking=Vt,t.LinearEncoding=Ot,t.LinearFilter=N,t.LinearInterpolant=cu,t.LinearMipMapLinearFilter=1008,t.LinearMipMapNearestFilter=1007,t.LinearMipmapLinearFilter=P,t.LinearMipmapNearestFilter=D,t.LinearSRGBColorSpace=zt,t.LinearToneMapping=1,t.Loader=Vh,t.LoaderUtils=Xh,t.LoadingManager=Fh,t.LockedTrackConstraint=t_,t.LogarithmicMaxToneMapping=6,t.LoopOnce=Mt,t.LoopPingPong=bt,t.LoopRepeat=St,t.LuminanceAlphaFormat=1025,t.LuminanceFormat=1024,t.MOD_SUITE=o,t.MOUSE=s,t.MaskPass=LA,t.Material=Lo,t.MaterialLoader=function(){console.error("v3d.MaterialLoader has been removed, use glTF format for asset loading.")},t.MaterialUtils=Wm,t.MathUtils=Ce,t.Matrix3=xe,t.Matrix4=Hn,t.MaxEquation=104,t.Mesh=hi,t.MeshBVH=uI,t.MeshBasicMaterial=No,t.MeshDepthMaterial=fa,t.MeshDistanceMaterial=da,t.MeshLambertMaterial=Xc,t.MeshLine=PA,t.MeshLineIndexed=VA,t.MeshLineMaterial=Kc,t.MeshMaskMaterial=jc,t.MeshMatcapMaterial=class extends Xc{constructor(t){console.error("v3d.MeshMatcapMaterial has been removed, use node-based material instead."),super(t)}},t.MeshNodeMaterial=Ph,t.MeshNormalMaterial=Yc,t.MeshPhongMaterial=class extends Xc{constructor(t){console.error("v3d.MeshPhongMaterial has been removed, use node-based or standard material instead."),super(t)}},t.MeshPhysicalMaterial=class extends Wc{constructor(t){console.error("v3d.MeshPhysicalMaterial has been removed, use MeshStandardMaterial or node-based material instead."),super(t)}},t.MeshStandardMaterial=Wc,t.MeshToonMaterial=class extends Xc{constructor(t){console.error("v3d.MeshToonMaterial has been removed, use node-based material instead."),super(t)}},t.MinEquation=103,t.MirroredRepeatWrapping=R,t.MixOperation=1,t.MotionPathConstraint=hE,t.MultiplyBlending=4,t.MultiplyOperation=0,t.NearestFilter=T,t.NearestMipMapLinearFilter=1005,t.NearestMipMapNearestFilter=1004,t.NearestMipmapLinearFilter=L,t.NearestMipmapNearestFilter=B,t.NeverDepth=0,t.NeverStencilFunc=512,t.NoBlending=0,t.NoColorSpace="",t.NoOIT=0,t.NoToneMapping=0,t.NormalAnimationBlendMode=Dt,t.NormalBlending=1,t.NotEqualDepth=7,t.NotEqualStencilFunc=517,t.NumberKeyframeTrack=Kf,t.OITWeighted=1,t.Object3D=mo,t.ObjectLoader=function(){console.error("v3d.ObjectLoader has been removed, use glTF format for asset loading.")},t.ObjectSpaceNormalMap=1,t.OctahedronGeometry=function(){console.error("v3d.OctahedronGeometry has been removed in Verge3D 4.11.")},t.OneFactor=h,t.OneMinusDstAlphaFactor=207,t.OneMinusDstColorFactor=209,t.OneMinusSrcAlphaFactor=v,t.OneMinusSrcColorFactor=203,t.OrbitControls=wm,t.OrthographicCamera=Xi,t.OutlinePass=GA,t.PCFShadowMap=2,t.PCFShadowMapPoissonDisk=2,t.PCFSoftShadowMap=2,t.PMREMGenerator=sr,t.Pass=Cr,t.Path=nc,t.PbrNeutralToneMapping=10,t.PerspectiveCamera=Ei,t.PhysicalMaxToneMapping=7,t.Plane=Ri,t.PlaneGeometry=Oi,t.PlaneHelper=class extends Sl{constructor(t,e=1,n=16776960){const o=n,i=new Xo;i.setAttribute("position",new Vo([1,-1,0,-1,1,0,-1,-1,0,1,1,0,-1,1,0,-1,-1,0,1,-1,0,1,1,0],3)),i.computeBoundingSphere(),super(i,new El({color:o,toneMapped:!1})),this.type="PlaneHelper",this.plane=t,this.size=e;const r=new Xo;r.setAttribute("position",new Vo([1,1,0,-1,1,0,-1,-1,0,1,1,0,-1,-1,0,1,-1,0],3)),r.computeBoundingSphere(),this.add(new hi(r,new No({color:o,opacity:.2,transparent:!0,depthWrite:!1,toneMapped:!1})))}updateMatrixWorld(t){this.position.set(0,0,0),this.scale.set(.5*this.size,.5*this.size,1),this.lookAt(this.plane.normal),this.translateZ(-this.plane.constant),super.updateMatrixWorld(t)}dispose(){this.geometry.dispose(),this.material.dispose(),this.children[0].geometry.dispose(),this.children[0].material.dispose()}},t.PointLight=of,t.PointLightHelper=Sd,t.Points=Ol,t.PointsMaterial=Bl,t.PolarGridHelper=class extends Rl{constructor(t=10,e=16,n=8,o=64,i=4473924,r=8947848){i=new tn(i),r=new tn(r);const s=[],a=[];if(e>1)for(let n=0;n<e;n++){const o=n/e*(2*Math.PI),l=Math.sin(o)*t,c=Math.cos(o)*t;s.push(0,0,0),s.push(l,0,c);const u=1&n?i:r;a.push(u.r,u.g,u.b),a.push(u.r,u.g,u.b)}for(let e=0;e<n;e++){const l=1&e?i:r,c=t-t/n*e;for(let t=0;t<o;t++){let e=t/o*(2*Math.PI),n=Math.sin(e)*c,i=Math.cos(e)*c;s.push(n,0,i),a.push(l.r,l.g,l.b),e=(t+1)/o*(2*Math.PI),n=Math.sin(e)*c,i=Math.cos(e)*c,s.push(n,0,i),a.push(l.r,l.g,l.b)}}const l=new Xo;l.setAttribute("position",new Vo(s,3)),l.setAttribute("color",new Vo(a,3));super(l,new El({vertexColors:!0,toneMapped:!1})),this.type="PolarGridHelper"}dispose(){this.geometry.dispose(),this.material.dispose()}},t.PolyhedronGeometry=Gc,t.PositionalAudio=class extends Tf{constructor(t){super(t),this.panner=this.context.createPanner(),this.panner.panningModel="HRTF",this.panner.connect(this.gain)}fromAudio(t){return this.panner.disconnect(this.gain),this.listener=t.listener,this.context=t.context,this.gain=t.gain,this.autoplay=t.autoplay,this.buffer=t.buffer,this.detune=t.detune,this.loop=t.loop,this.loopStart=t.loopStart,this.loopEnd=t.loopEnd,this.offset=t.offset,this.duration=t.duration,this.playbackRate=t.playbackRate,this.isPlaying=t.isPlaying,this.hasPlaybackControl=t.hasPlaybackControl,this.audio=t.audio,this.sourceType=t.sourceType,this.Te=t.Te,this.Be=t.Be,this.Le=t.Le,this.filters=t.filters.slice(0),this.panner.connect(this.gain),this}disconnect(){super.disconnect(),this.panner.disconnect(this.gain)}getOutput(){return this.panner}getRefDistance(){return this.panner.refDistance}setRefDistance(t){return this.panner.refDistance=t,this}getRolloffFactor(){return this.panner.rolloffFactor}setRolloffFactor(t){return this.panner.rolloffFactor=t,this}getDistanceModel(){return this.panner.distanceModel}setDistanceModel(t){return this.panner.distanceModel=t,this}getMaxDistance(){return this.panner.maxDistance}setMaxDistance(t){return this.panner.maxDistance=t,this}setDirectionalCone(t,e,n){return this.panner.coneInnerAngle=t,this.panner.coneOuterAngle=e,this.panner.coneOuterGain=n,this}updateMatrixWorld(t){if(super.updateMatrixWorld(t),!0===this.hasPlaybackControl&&!1===this.isPlaying)return;this.matrixWorld.decompose(Bf,Lf,Nf),Df.set(0,0,1).applyQuaternion(Lf);const e=this.panner;if(e.positionX){const t=this.context.currentTime+this.listener.timeDelta;e.positionX.linearRampToValueAtTime(Bf.x,t),e.positionY.linearRampToValueAtTime(Bf.y,t),e.positionZ.linearRampToValueAtTime(Bf.z,t),e.orientationX.linearRampToValueAtTime(Df.x,t),e.orientationY.linearRampToValueAtTime(Df.y,t),e.orientationZ.linearRampToValueAtTime(Df.z,t)}else e.setPosition(Bf.x,Bf.y,Bf.z),e.setOrientation(Df.x,Df.y,Df.z)}},t.Preloader=HI,t.PropertyBinding=ad,t.PropertyMixer=qf,t.PuzzlesLoader=class{ns(t){const e=new Error(t);return e.name="LogicFileLoadError",e}rs(t){const e=new Error(t);return e.name="EditorLoadError",e}async ss(t){const e=Fe(),n=new URL(t,document.baseURI).href;try{var o,i,r;const t=null==(o=(i=await import(/* webpackIgnore: true */n)).createPL)?void 0:o.call(i);return await(null==t||null==t.loadPhysics?void 0:t.loadPhysics()),null!=(r=null!=t?t:e.v3d.PL)?r:null}catch(t){throw this.ns(`Unable to load the logic file: '${n}'.`)}}ls(t,e){const n=this;return new Promise(function(e,o){op.loadScript(t,document.body,function(){e()},function(){o(n.rs("Unable to load the Puzzles Editor: '"+t+"'."))})})}async cs(t,e){const n=Fe();if(!n.v3d||!n.v3d.PE)throw this.rs("Unable to load Puzzles' logic. The Puzzles Editor isn't loaded.");const o=e.split(".");o[o.length-1]="xml";const i=o.join("."),{PL:r,logicXMLLoaded:s}=await n.v3d.PE.init(t,i);if(!s)throw this.ns(`Unable to load the Puzzles Editor's XML logic file: '${i}'.`);return r}us(){const t=document.getElementsByTagName("script");let e=!1;for(let n=t.length-1;n>=0;--n){if(t[n].src.search(/ammo.wasm.js/)>-1){e=!0;break}}return new Promise(function(t,n){if(e&&window.Ammo)console.warn("You have ammo.wasm.js assigned in app html, please remove it"),t();else if(e&&!window.Ammo){console.warn("You have ammo.wasm.js assigned in app html, please remove it and resave Puzzles");const e=Ve("ammo.wasm.js");import(/* webpackIgnore: true */e).then(e=>{let o=e.default;o?(new o).then(e=>{window.Ammo=e,t()}):n(new Error("Failed to load physics module"))})}else t()})}async loadLogic(t,e,n){try{const n=await this.ss(t);return await this.us(),e&&e(),n}catch(t){console.error(t),n&&n(t)}}async loadEditorWithLogic(t,e,n,o){try{let o=null;await this.ls(t+"puzzles.min.js");try{o=await this.cs(t,e)}catch(t){if("LogicFileLoadError"!==t.name)throw t}return await this.us(),n&&n(),o}catch(t){console.error(t),o&&o(t)}}},t.QuadraticBezierCurve=Jl,t.QuadraticBezierCurve3=$l,t.Quaternion=dn,t.QuaternionKeyframeTrack=Xf,t.QuaternionLinearInterpolant=Yf,t.REVISION=n,t.REVISION_EXPORT_MIN=i,t.RGBADepthPacking=Ut,t.RGBADistancePacking=Gt,t.RGBAFormat=W,t.RGBAIntegerFormat=J,t.RGBA_ASTC_10x10_Format=Ct,t.RGBA_ASTC_10x5_Format=gt,t.RGBA_ASTC_10x6_Format=_t,t.RGBA_ASTC_10x8_Format=Et,t.RGBA_ASTC_12x10_Format=wt,t.RGBA_ASTC_12x12_Format=xt,t.RGBA_ASTC_4x4_Format=ut,t.RGBA_ASTC_5x4_Format=ht,t.RGBA_ASTC_5x5_Format=ft,t.RGBA_ASTC_6x5_Format=dt,t.RGBA_ASTC_6x6_Format=At,t.RGBA_ASTC_8x5_Format=vt,t.RGBA_ASTC_8x6_Format=mt,t.RGBA_ASTC_8x8_Format=pt,t.RGBA_BPTC_Format=It,t.RGBA_ETC2_EAC_Format=ct,t.RGBA_PVRTC_2BPPV1_Format=st,t.RGBA_PVRTC_4BPPV1_Format=rt,t.RGBA_S3TC_DXT1_Format=tt,t.RGBA_S3TC_DXT3_Format=et,t.RGBA_S3TC_DXT5_Format=nt,t.RGBELoader=yp,t.RGB_ETC1_Format=at,t.RGB_ETC2_Format=lt,t.RGB_PVRTC_2BPPV1_Format=it,t.RGB_PVRTC_4BPPV1_Format=ot,t.RGB_S3TC_DXT1_Format=$,t.RGFormat=Z,t.RGIntegerFormat=q,t.RawShaderMaterial=Ki,t.Ray=kn,t.Raycaster=La,t.RectAreaLight=sf,t.RectAreaLightUniformsLib=Fp,t.RedFormat=K,t.RedIntegerFormat=j,t.ReflectionProbeTypeBox=2,t.ReflectionProbeTypeInfinite=0,t.ReflectionProbeTypeSphere=1,t.ReinhardToneMapping=2,t.RenderPass=QA,t.RenderUtils=Ap,t.RepeatWrapping=b,t.ReplaceStencilOp=Ht,t.ReverseSubtractEquation=102,t.RingGeometry=class extends Xo{constructor(t=.5,e=1,n=32,o=1,i=0,r=2*Math.PI){super(),this.type="RingGeometry",this.parameters={innerRadius:t,outerRadius:e,thetaSegments:n,phiSegments:o,thetaStart:i,thetaLength:r},n=Math.max(3,n);const s=[],a=[],l=[],c=[];let u=t;const h=(e-t)/(o=Math.max(1,o)),f=new An,d=new we;for(let t=0;t<=o;t++){for(let t=0;t<=n;t++){const o=i+t/n*r;f.x=u*Math.cos(o),f.y=u*Math.sin(o),a.push(f.x,f.y,f.z),l.push(0,0,1),d.x=(f.x/e+1)/2,d.y=(f.y/e+1)/2,c.push(d.x,d.y)}u+=h}for(let t=0;t<o;t++){const e=t*(n+1);for(let t=0;t<n;t++){const o=t+e,i=o,r=o+n+1,a=o+n+2,l=o+1;s.push(i,r,l),s.push(r,a,l)}}this.setIndex(s),this.setAttribute("position",new Vo(a,3)),this.setAttribute("normal",new Vo(l,3)),this.setAttribute("uv",new Vo(c,2))}},t.SAH=2,t.SRGBColorSpace=Qt,t.SSAARenderPass=kA,t.SSAOPass=function(){console.error("v3d.SSAOPass has been removed, use v3d.GTAOMapGenerator instead")},t.Scene=Ni,t.SceneBackground=tn,t.SceneUtils=tp,t.ShaderChunk=Fi,t.ShaderLib=Vi,t.ShaderMaterial=gi,t.ShaderPass=Xd,t.ShadowMaterial=class extends Lo{constructor(t){super(),this.isShadowMaterial=!0,this.type="ShadowMaterial",this.color=new tn(0),this.transparent=!0,this.fog=!0,this.setValues(t)}copy(t){return super.copy(t),this.color.copy(t.color),this.fog=t.fog,this}},t.Shape=cc,t.ShapeGeometry=class extends Xo{constructor(t=new cc([new we(0,.5),new we(-.5,-.5),new we(.5,-.5)]),e=12){super(),this.type="ShapeGeometry",this.parameters={shapes:t,curveSegments:e};const n=[],o=[],i=[],r=[];let s=0,a=0;if(!1===Array.isArray(t))l(t);else for(let e=0;e<t.length;e++)l(t[e]),this.addGroup(s,a,e),s+=a,a=0;function l(t){const s=o.length/3,l=t.extractPoints(e);let c=l.shape;const u=l.holes;!1===Pc.isClockWise(c)&&(c=c.reverse());for(let t=0,e=u.length;t<e;t++){const e=u[t];!0===Pc.isClockWise(e)&&(u[t]=e.reverse())}const h=Pc.triangulateShape(c,u);for(let t=0,e=u.length;t<e;t++){const e=u[t];c=c.concat(e)}for(let t=0,e=c.length;t<e;t++){const e=c[t];o.push(e.x,e.y,0),i.push(0,0,1),r.push(e.x,e.y)}for(let t=0,e=h.length;t<e;t++){const e=h[t],o=e[0]+s,i=e[1]+s,r=e[2]+s;n.push(o,i,r),a+=3}}this.setIndex(n),this.setAttribute("position",new Vo(o,3)),this.setAttribute("normal",new Vo(i,3)),this.setAttribute("uv",new Vo(r,2))}},t.ShapePath=Vd,t.ShapeUtils=Pc,t.ShortType=1011,t.SimplePreloader=class extends HI{constructor(t){super();for(let e in t){const n=t[e];if("container"===e)void 0===n?this.container=document.body:n instanceof HTMLElement?this.container=n:this.container=document.getElementById(n)}this.bar=document.createElement("div"),this.bar.setAttribute("class","v3d-simple-preloader-bar"),this.logo=document.createElement("div"),this.logo.setAttribute("class","v3d-simple-preloader-logo"),this.logoCont=document.createElement("div"),this.logoCont.setAttribute("id","v3d_preloader_container"),this.logoCont.setAttribute("class","v3d-simple-preloader-container"),this.background=document.createElement("div"),this.background.setAttribute("class","v3d-simple-preloader-background"),this.background.appendChild(this.logoCont),this.logoCont.appendChild(this.logo),this.logoCont.appendChild(this.bar),this.container.appendChild(this.background),this.clock=new If}onUpdate(t){super.onUpdate(t),t=Math.round(t),this.bar.style.width=t+"%"}onFinish(){super.onFinish(),this.container.removeChild(this.background)}},t.Skeleton=dl,t.SkeletonHelper=Id,t.SkinnedMesh=ll,t.Source=rn,t.Sphere=Pn,t.SphereGeometry=Qc,t.Spherical=uu,t.SphericalHarmonics3=wf,t.SplineCurve=tc,t.SpotLight=Jh,t.SpotLightHelper=Ed,t.Sprite=$a,t.SpriteMaterial=Va,t.SrcAlphaFactor=A,t.SrcAlphaSaturateFactor=210,t.SrcColorFactor=202,t.StaticCopyUsage=35046,t.StaticDrawUsage=Xt,t.StaticReadUsage=35045,t.Stats=FC,t.StereoCamera=function(){console.error("v3d.StereoCamera has been removed in Verge3D 4.11.")},t.StreamCopyUsage=35042,t.StreamDrawUsage=35040,t.StreamReadUsage=35041,t.StringKeyframeTrack=Wf,t.SubtractEquation=101,t.SubtractiveBlending=3,t.TOUCH={ROTATE:0,PAN:1,DOLLY_PAN:2,DOLLY_ROTATE:3},t.TTFLoader=bp,t.TangentSpaceNormalMap=0,t.TargetConstraint=Wp,t.TeapotGeometry=class extends Xo{constructor(t=1,e=10,n=!0,o=!0,i=!0,r=!0,s=!0){const a=[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,3,16,17,18,7,19,20,21,11,22,23,24,15,25,26,27,18,28,29,30,21,31,32,33,24,34,35,36,27,37,38,39,30,40,41,0,33,42,43,4,36,44,45,8,39,46,47,12,12,13,14,15,48,49,50,51,52,53,54,55,56,57,58,59,15,25,26,27,51,60,61,62,55,63,64,65,59,66,67,68,27,37,38,39,62,69,70,71,65,72,73,74,68,75,76,77,39,46,47,12,71,78,79,48,74,80,81,52,77,82,83,56,56,57,58,59,84,85,86,87,88,89,90,91,92,93,94,95,59,66,67,68,87,96,97,98,91,99,100,101,95,102,103,104,68,75,76,77,98,105,106,107,101,108,109,110,104,111,112,113,77,82,83,56,107,114,115,84,110,116,117,88,113,118,119,92,120,121,122,123,124,125,126,127,128,129,130,131,132,133,134,135,123,136,137,120,127,138,139,124,131,140,141,128,135,142,143,132,132,133,134,135,144,145,146,147,148,149,150,151,68,152,153,154,135,142,143,132,147,155,156,144,151,157,158,148,154,159,160,68,161,162,163,164,165,166,167,168,169,170,171,172,173,174,175,176,164,177,178,161,168,179,180,165,172,181,182,169,176,183,184,173,173,174,175,176,185,186,187,188,189,190,191,192,193,194,195,196,176,183,184,173,188,197,198,185,192,199,200,189,196,201,202,193,203,203,203,203,204,205,206,207,208,208,208,208,209,210,211,212,203,203,203,203,207,213,214,215,208,208,208,208,212,216,217,218,203,203,203,203,215,219,220,221,208,208,208,208,218,222,223,224,203,203,203,203,221,225,226,204,208,208,208,208,224,227,228,209,209,210,211,212,229,230,231,232,233,234,235,236,237,238,239,240,212,216,217,218,232,241,242,243,236,244,245,246,240,247,248,249,218,222,223,224,243,250,251,252,246,253,254,255,249,256,257,258,224,227,228,209,252,259,260,229,255,261,262,233,258,263,264,237,265,265,265,265,266,267,268,269,270,271,272,273,92,119,118,113,265,265,265,265,269,274,275,276,273,277,278,279,113,112,111,104,265,265,265,265,276,280,281,282,279,283,284,285,104,103,102,95,265,265,265,265,282,286,287,266,285,288,289,270,95,94,93,92],l=[1.4,0,2.4,1.4,-.784,2.4,.784,-1.4,2.4,0,-1.4,2.4,1.3375,0,2.53125,1.3375,-.749,2.53125,.749,-1.3375,2.53125,0,-1.3375,2.53125,1.4375,0,2.53125,1.4375,-.805,2.53125,.805,-1.4375,2.53125,0,-1.4375,2.53125,1.5,0,2.4,1.5,-.84,2.4,.84,-1.5,2.4,0,-1.5,2.4,-.784,-1.4,2.4,-1.4,-.784,2.4,-1.4,0,2.4,-.749,-1.3375,2.53125,-1.3375,-.749,2.53125,-1.3375,0,2.53125,-.805,-1.4375,2.53125,-1.4375,-.805,2.53125,-1.4375,0,2.53125,-.84,-1.5,2.4,-1.5,-.84,2.4,-1.5,0,2.4,-1.4,.784,2.4,-.784,1.4,2.4,0,1.4,2.4,-1.3375,.749,2.53125,-.749,1.3375,2.53125,0,1.3375,2.53125,-1.4375,.805,2.53125,-.805,1.4375,2.53125,0,1.4375,2.53125,-1.5,.84,2.4,-.84,1.5,2.4,0,1.5,2.4,.784,1.4,2.4,1.4,.784,2.4,.749,1.3375,2.53125,1.3375,.749,2.53125,.805,1.4375,2.53125,1.4375,.805,2.53125,.84,1.5,2.4,1.5,.84,2.4,1.75,0,1.875,1.75,-.98,1.875,.98,-1.75,1.875,0,-1.75,1.875,2,0,1.35,2,-1.12,1.35,1.12,-2,1.35,0,-2,1.35,2,0,.9,2,-1.12,.9,1.12,-2,.9,0,-2,.9,-.98,-1.75,1.875,-1.75,-.98,1.875,-1.75,0,1.875,-1.12,-2,1.35,-2,-1.12,1.35,-2,0,1.35,-1.12,-2,.9,-2,-1.12,.9,-2,0,.9,-1.75,.98,1.875,-.98,1.75,1.875,0,1.75,1.875,-2,1.12,1.35,-1.12,2,1.35,0,2,1.35,-2,1.12,.9,-1.12,2,.9,0,2,.9,.98,1.75,1.875,1.75,.98,1.875,1.12,2,1.35,2,1.12,1.35,1.12,2,.9,2,1.12,.9,2,0,.45,2,-1.12,.45,1.12,-2,.45,0,-2,.45,1.5,0,.225,1.5,-.84,.225,.84,-1.5,.225,0,-1.5,.225,1.5,0,.15,1.5,-.84,.15,.84,-1.5,.15,0,-1.5,.15,-1.12,-2,.45,-2,-1.12,.45,-2,0,.45,-.84,-1.5,.225,-1.5,-.84,.225,-1.5,0,.225,-.84,-1.5,.15,-1.5,-.84,.15,-1.5,0,.15,-2,1.12,.45,-1.12,2,.45,0,2,.45,-1.5,.84,.225,-.84,1.5,.225,0,1.5,.225,-1.5,.84,.15,-.84,1.5,.15,0,1.5,.15,1.12,2,.45,2,1.12,.45,.84,1.5,.225,1.5,.84,.225,.84,1.5,.15,1.5,.84,.15,-1.6,0,2.025,-1.6,-.3,2.025,-1.5,-.3,2.25,-1.5,0,2.25,-2.3,0,2.025,-2.3,-.3,2.025,-2.5,-.3,2.25,-2.5,0,2.25,-2.7,0,2.025,-2.7,-.3,2.025,-3,-.3,2.25,-3,0,2.25,-2.7,0,1.8,-2.7,-.3,1.8,-3,-.3,1.8,-3,0,1.8,-1.5,.3,2.25,-1.6,.3,2.025,-2.5,.3,2.25,-2.3,.3,2.025,-3,.3,2.25,-2.7,.3,2.025,-3,.3,1.8,-2.7,.3,1.8,-2.7,0,1.575,-2.7,-.3,1.575,-3,-.3,1.35,-3,0,1.35,-2.5,0,1.125,-2.5,-.3,1.125,-2.65,-.3,.9375,-2.65,0,.9375,-2,-.3,.9,-1.9,-.3,.6,-1.9,0,.6,-3,.3,1.35,-2.7,.3,1.575,-2.65,.3,.9375,-2.5,.3,1.125,-1.9,.3,.6,-2,.3,.9,1.7,0,1.425,1.7,-.66,1.425,1.7,-.66,.6,1.7,0,.6,2.6,0,1.425,2.6,-.66,1.425,3.1,-.66,.825,3.1,0,.825,2.3,0,2.1,2.3,-.25,2.1,2.4,-.25,2.025,2.4,0,2.025,2.7,0,2.4,2.7,-.25,2.4,3.3,-.25,2.4,3.3,0,2.4,1.7,.66,.6,1.7,.66,1.425,3.1,.66,.825,2.6,.66,1.425,2.4,.25,2.025,2.3,.25,2.1,3.3,.25,2.4,2.7,.25,2.4,2.8,0,2.475,2.8,-.25,2.475,3.525,-.25,2.49375,3.525,0,2.49375,2.9,0,2.475,2.9,-.15,2.475,3.45,-.15,2.5125,3.45,0,2.5125,2.8,0,2.4,2.8,-.15,2.4,3.2,-.15,2.4,3.2,0,2.4,3.525,.25,2.49375,2.8,.25,2.475,3.45,.15,2.5125,2.9,.15,2.475,3.2,.15,2.4,2.8,.15,2.4,0,0,3.15,.8,0,3.15,.8,-.45,3.15,.45,-.8,3.15,0,-.8,3.15,0,0,2.85,.2,0,2.7,.2,-.112,2.7,.112,-.2,2.7,0,-.2,2.7,-.45,-.8,3.15,-.8,-.45,3.15,-.8,0,3.15,-.112,-.2,2.7,-.2,-.112,2.7,-.2,0,2.7,-.8,.45,3.15,-.45,.8,3.15,0,.8,3.15,-.2,.112,2.7,-.112,.2,2.7,0,.2,2.7,.45,.8,3.15,.8,.45,3.15,.112,.2,2.7,.2,.112,2.7,.4,0,2.55,.4,-.224,2.55,.224,-.4,2.55,0,-.4,2.55,1.3,0,2.55,1.3,-.728,2.55,.728,-1.3,2.55,0,-1.3,2.55,1.3,0,2.4,1.3,-.728,2.4,.728,-1.3,2.4,0,-1.3,2.4,-.224,-.4,2.55,-.4,-.224,2.55,-.4,0,2.55,-.728,-1.3,2.55,-1.3,-.728,2.55,-1.3,0,2.55,-.728,-1.3,2.4,-1.3,-.728,2.4,-1.3,0,2.4,-.4,.224,2.55,-.224,.4,2.55,0,.4,2.55,-1.3,.728,2.55,-.728,1.3,2.55,0,1.3,2.55,-1.3,.728,2.4,-.728,1.3,2.4,0,1.3,2.4,.224,.4,2.55,.4,.224,2.55,.728,1.3,2.55,1.3,.728,2.55,.728,1.3,2.4,1.3,.728,2.4,0,0,0,1.425,0,0,1.425,.798,0,.798,1.425,0,0,1.425,0,1.5,0,.075,1.5,.84,.075,.84,1.5,.075,0,1.5,.075,-.798,1.425,0,-1.425,.798,0,-1.425,0,0,-.84,1.5,.075,-1.5,.84,.075,-1.5,0,.075,-1.425,-.798,0,-.798,-1.425,0,0,-1.425,0,-1.5,-.84,.075,-.84,-1.5,.075,0,-1.5,.075,.798,-1.425,0,1.425,-.798,0,.84,-1.5,.075,1.5,-.84,.075];super(),e=Math.max(2,Math.floor(e));const c=3.15*(s?1:1.3)/2,u=t/c;let h=n?(8*e-4)*e:0;h+=o?(16*e-4)*e:0,h+=i?40*e*e:0;const f=new Uint32Array(3*h);let d=n?4:0;d+=o?8:0,d+=i?20:0,d*=(e+1)*(e+1);const A=new Float32Array(3*d),v=new Float32Array(3*d),m=new Float32Array(2*d),p=new Hn;p.set(-1,3,-3,1,3,-6,3,0,-3,3,0,0,1,0,0,0);const g=[],_=[],E=[],C=[],w=[],x=[],I=[],M=[],S=[],b=new An;let y,R,T,B,L=0,N=0;const D=new An,P=new Hn,O=new Hn,F=new ln,U=new ln,V=new ln,G=new ln,Q=new An,z=new An,k=p.clone();k.transpose();const H=(t,e,n)=>!(A[3*t]===A[3*e]&&A[3*t+1]===A[3*e+1]&&A[3*t+2]===A[3*e+2]||A[3*t]===A[3*n]&&A[3*t+1]===A[3*n+1]&&A[3*t+2]===A[3*n+2]||A[3*e]===A[3*n]&&A[3*e+1]===A[3*n+1]&&A[3*e+2]===A[3*n+2]);for(let t=0;t<3;t++)x[t]=new Hn;const W=n?32:28,Y=e+1;let X=0,K=0,j=0,Z=0,q=0;for(let t=i?0:20;t<W;t++)if(o||t<20||t>=28){for(let e=0;e<3;e++){for(let n=0;n<4;n++)for(let o=0;o<4;o++)g[4*o+n]=l[3*a[16*t+4*n+o]+e],r&&t>=20&&t<28&&2!==e&&(g[4*o+n]*=1.077),s||2!==e||(g[4*o+n]*=1.3);P.set(g[0],g[1],g[2],g[3],g[4],g[5],g[6],g[7],g[8],g[9],g[10],g[11],g[12],g[13],g[14],g[15]),O.multiplyMatrices(P,p),x[e].multiplyMatrices(k,O)}for(let t=0;t<=e;t++){const n=t/e;for(let t=0;t<=e;t++){const o=t/e;for(B=4,R=T=1;B--;)_[B]=R,E[B]=T,R*=n,T*=o,3===B?(C[B]=w[B]=0,L=N=1):(C[B]=L*(3-B),w[B]=N*(3-B),L*=n,N*=o);F.fromArray(_),U.fromArray(E),V.fromArray(C),G.fromArray(w);for(let t=0;t<3;t++)y=F.clone(),y.applyMatrix4(x[t]),I[t]=y.dot(U),y=V.clone(),y.applyMatrix4(x[t]),M[t]=y.dot(U),y=F.clone(),y.applyMatrix4(x[t]),S[t]=y.dot(G);Q.fromArray(M),z.fromArray(S),b.crossVectors(z,Q),b.normalize(),0===I[0]&&0===I[1]?D.set(0,I[2]>c?1:-1,0):D.set(b.x,b.z,-b.y),A[K++]=u*I[0],A[K++]=u*(I[2]-c),A[K++]=-u*I[1],v[j++]=D.x,v[j++]=D.y,v[j++]=D.z,m[Z++]=1-o,m[Z++]=1-n}}for(let t=0;t<e;t++)for(let n=0;n<e;n++){const e=X*Y*Y+t*Y+n,o=e+1,i=o+Y,r=e+Y;H(e,o,i)&&(f[q++]=e,f[q++]=o,f[q++]=i),H(e,i,r)&&(f[q++]=e,f[q++]=i,f[q++]=r)}X++}this.setIndex(new Oo(f,1)),this.setAttribute("position",new Oo(A,3)),this.setAttribute("normal",new Oo(v,3)),this.setAttribute("uv",new Oo(m,2)),this.computeBoundingSphere()}},t.TetrahedronGeometry=function(){console.error("v3d.TetrahedronGeometry has been removed in Verge3D 4.11.")},t.TextGeometry=zc,t.Texture=an,t.TextureLoader=Wh,t.ToneMapPass=YA,t.ToneMappingLookAgXPunchy=1,t.ToneMappingLookNone=0,t.TorusGeometry=class extends Xo{constructor(t=1,e=.4,n=12,o=48,i=2*Math.PI){super(),this.type="TorusGeometry",this.parameters={radius:t,tube:e,radialSegments:n,tubularSegments:o,arc:i},n=Math.floor(n),o=Math.floor(o);const r=[],s=[],a=[],l=[],c=new An,u=new An,h=new An;for(let r=0;r<=n;r++)for(let f=0;f<=o;f++){const d=f/o*i,A=r/n*Math.PI*2;u.x=(t+e*Math.cos(A))*Math.cos(d),u.y=(t+e*Math.cos(A))*Math.sin(d),u.z=e*Math.sin(A),s.push(u.x,u.y,u.z),c.x=t*Math.cos(d),c.y=t*Math.sin(d),h.subVectors(u,c).normalize(),a.push(h.x,h.y,h.z),l.push(f/o),l.push(r/n)}for(let t=1;t<=n;t++)for(let e=1;e<=o;e++){const n=(o+1)*t+e-1,i=(o+1)*(t-1)+e-1,s=(o+1)*(t-1)+e,a=(o+1)*t+e;r.push(n,i,a),r.push(i,s,a)}this.setIndex(r),this.setAttribute("position",new Vo(s,3)),this.setAttribute("normal",new Vo(a,3)),this.setAttribute("uv",new Vo(l,2))}},t.TorusKnotGeometry=function(){console.error("v3d.TorusKnotGeometry has been removed in Verge3D 4.11.")},t.TrackToConstraint=f_,t.TransformationConstraint=bE,t.Triangle=To,t.TriangleFanDrawMode=2,t.TriangleStripDrawMode=1,t.TrianglesDrawMode=0,t.TubeGeometry=class extends Xo{constructor(t=new $l(new An(-1,-1,0),new An(-1,1,0),new An(1,1,0)),e=64,n=1,o=8,i=!1){super(),this.type="TubeGeometry",this.parameters={path:t,tubularSegments:e,radius:n,radialSegments:o,closed:i};const r=t.computeFrenetFrames(e,i);this.tangents=r.tangents,this.normals=r.normals,this.binormals=r.binormals;const s=new An,a=new An,l=new we;let c=new An;const u=[],h=[],f=[],d=[];function A(i){c=t.getPointAt(i/e,c);const l=r.normals[i],f=r.binormals[i];for(let t=0;t<=o;t++){const e=t/o*Math.PI*2,i=Math.sin(e),r=-Math.cos(e);a.x=r*l.x+i*f.x,a.y=r*l.y+i*f.y,a.z=r*l.z+i*f.z,a.normalize(),h.push(a.x,a.y,a.z),s.x=c.x+n*a.x,s.y=c.y+n*a.y,s.z=c.z+n*a.z,u.push(s.x,s.y,s.z)}}!function(){for(let t=0;t<e;t++)A(t);A(!1===i?e:0),function(){for(let t=0;t<=e;t++)for(let n=0;n<=o;n++)l.x=t/e,l.y=n/o,f.push(l.x,l.y)}(),function(){for(let t=1;t<=e;t++)for(let e=1;e<=o;e++){const n=(o+1)*(t-1)+(e-1),i=(o+1)*t+(e-1),r=(o+1)*t+e,s=(o+1)*(t-1)+e;d.push(n,i,s),d.push(i,r,s)}}()}(),this.setIndex(d),this.setAttribute("position",new Vo(u,3)),this.setAttribute("normal",new Vo(h,3)),this.setAttribute("uv",new Vo(f,2))}},t.TweenCameraController=tm,t.TweenLinear=0,t.TweenSpherical=1,t.TwoPassDoubleSide=3,t.USDZExporter=class{async parse(t,e={}){e=Object.assign({ar:{anchoring:{type:"plane"},planeAnchoring:{alignment:"horizontal"}},quickLookCompatible:!0,maxTextureSize:1024},e);const n={},o="model.usda";n[o]=null;let i=Gv();i+=function(t){return`def Xform "Root"\n{\n    def Scope "Scenes" (\n        kind = "sceneLibrary"\n    )\n    {\n        def Xform "Scene" (\n            customData = {\n                bool preliminary_collidesWithEnvironment = 0\n                string sceneName = "Scene"\n            }\n            sceneName = "Scene"\n        )\n        {\n        token preliminary:anchoring:type = "${t.ar.anchoring.type}"\n        token preliminary:planeAnchoring:alignment = "${t.ar.planeAnchoring.alignment}"\n\n`}(e);const r={},s={};t.traverseVisible(t=>{if(t.isMesh){const e=t.geometry,o=t.material;if(o.isMeshNodeMaterial||o.isMeshStandardMaterial){const s="geometries/Geometry_"+e.id+".usda";if(!(s in n)){const t=function(t){const e=function(t){const e="Geometry",n=t.attributes,o=n.position.count;return`\n    def Mesh "${e}"\n    {\n        int[] faceVertexCounts = [${function(t){const e=null!==t.index?t.index.count:t.attributes.position.count;return Array(e/3).fill(3).join(", ")}(t)}]\n        int[] faceVertexIndices = [${function(t){const e=t.index,n=[];if(null!==e)for(let t=0;t<e.count;t++)n.push(e.getX(t));else{const e=t.attributes.position.count;for(let t=0;t<e;t++)n.push(t)}return n.join(", ")}(t)}]\n        normal3f[] normals = [${kv(n.normal,o)}] (\n            interpolation = "vertex"\n        )\n        point3f[] points = [${kv(n.position,o)}]\n${function(t){let e="";for(let n=0;n<4;n++){const o=n>0?n:"",i=t["uv"+o];void 0!==i&&(e+=`\n        texCoord2f[] primvars:st${o} = [${Hv(i)}] (\n            interpolation = "vertex"\n        )`)}const n=t.color;if(void 0!==n){e+=`\n    color3f[] primvars:displayColor = [${kv(n,n.count)}] (\n        interpolation = "vertex"\n        )`}return e}(n)}\n        uniform token subdivisionScheme = "none"\n    }\n`}(t);return`\ndef "Geometry"\n{\n${e}\n}\n`}(e);n[s]=function(t){let e=Gv();return e+=t,Dv(e)}(t)}o.uuid in r||(r[o.uuid]=o),i+=function(t,e,n){const o="Object_"+t.id,i=Qv(t.matrixWorld);t.matrixWorld.determinant()<0&&console.warn("v3d.USDZExporter: USDZ does not support negative scales",t);return`def Xform "${o}" (\n    prepend references = @./geometries/Geometry_${e.id}.usda@</Geometry>\n    prepend apiSchemas = ["MaterialBindingAPI"]\n)\n{\n    matrix4d xformOp:transform = ${i}\n    uniform token[] xformOpOrder = ["xformOp:transform"]\n\n    rel material:binding = </Materials/Material_${n.id}>\n}\n\n`}(t,e,o)}else console.warn("v3d.USDZExporter: Unsupported material type (USDZ only supports MeshNodeMaterial and MeshStandardMaterial)",t)}else t.isCamera&&(i+=function(t){const e=t.name?t.name:"Camera_"+t.id,n=Qv(t.matrixWorld);t.matrixWorld.determinant()<0&&console.warn("v3d.USDZExporter: USDZ does not support negative scales",t);return t.isOrthographicCamera?`def Camera "${e}"\n        {\n            matrix4d xformOp:transform = ${n}\n            uniform token[] xformOpOrder = ["xformOp:transform"]\n\n            float2 clippingRange = (${t.near.toPrecision(Vv)}, ${t.far.toPrecision(Vv)})\n            float horizontalAperture = ${(10*(Math.abs(t.left)+Math.abs(t.right))).toPrecision(Vv)}\n            float verticalAperture = ${(10*(Math.abs(t.top)+Math.abs(t.bottom))).toPrecision(Vv)}\n            token projection = "orthographic"\n        }\n\n    `:`def Camera "${e}"\n        {\n            matrix4d xformOp:transform = ${n}\n            uniform token[] xformOpOrder = ["xformOp:transform"]\n\n            float2 clippingRange = (${t.near.toPrecision(Vv)}, ${t.far.toPrecision(Vv)})\n            float focalLength = ${t.getFocalLength().toPrecision(Vv)}\n            float focusDistance = ${t.focus.toPrecision(Vv)}\n            float horizontalAperture = ${t.getFilmWidth().toPrecision(Vv)}\n            token projection = "perspective"\n            float verticalAperture = ${t.getFilmHeight().toPrecision(Vv)}\n        }\n\n    `}(t))}),i+="\n        }\n    }\n}\n\n",i+=function(t,e,n=!1){const o=[];for(const i in t){const r=t[i];o.push(Wv(r,e,n))}return`def "Materials"\n{\n${o.join("")}\n}\n\n`}(r,s,e.quickLookCompatible),n[o]=Dv(i),i=null;for(const t in s){let o=s[t];!0===o.isCompressedTexture&&(o=eA(o));const i=Uv(o.image,o.flipY,e.maxTextureSize),r=await new Promise(t=>i.toBlob(t,"image/png",1));n[`textures/Texture_${t}.png`]=new Uint8Array(await r.arrayBuffer())}let a=0;for(const t in n){const e=n[t];a+=34+t.length;const o=63&a;if(4!==o){const i=new Uint8Array(64-o);n[t]=[e,{extra:{12345:i}}]}a=e.length}return Fv(n,{level:0})}},t.UVMapping=C,t.Uint16BufferAttribute=Fo,t.Uint32BufferAttribute=Uo,t.Uint8BufferAttribute=class extends Oo{constructor(t,e,n){super(new Uint8Array(t),e,n)}},t.Uint8ClampedBufferAttribute=class extends Oo{constructor(t,e,n){super(new Uint8ClampedArray(t),e,n)}},t.Uniform=dd,t.UniformsGroup=class extends Zt{constructor(){super(),this.isUniformsGroup=!0,Object.defineProperty(this,"id",{value:Ad++}),this.name="",this.usage=Xt,this.uniforms=[]}add(t){return this.uniforms.push(t),this}remove(t){const e=this.uniforms.indexOf(t);return-1!==e&&this.uniforms.splice(e,1),this}setName(t){return this.name=t,this}setUsage(t){return this.usage=t,this}dispose(){return this.dispatchEvent({type:"dispose"}),this}copy(t){this.name=t.name,this.usage=t.usage;const e=t.uniforms;this.uniforms.length=0;for(let t=0,n=e.length;t<n;t++)this.uniforms.push(e[t].clone());return this}clone(){return(new this.constructor).copy(this)}},t.UniformsLib=Ui,t.UniformsUtils=pi,t.UnsignedByteType=O,t.UnsignedInt248Type=H,t.UnsignedIntType=V,t.UnsignedShort4444Type=z,t.UnsignedShort5551Type=k,t.UnsignedShortType=F,t.V3DL=r,t.Vector2=we,t.Vector3=An,t.Vector4=ln,t.VectorKeyframeTrack=Hf,t.VideoTexture=class extends an{constructor(t,e,n,o,i,r,s,a,l){super(t,e,n,o,i,r,s,a,l),this.isVideoTexture=!0,this.minFilter=void 0!==r?r:N,this.magFilter=void 0!==i?i:N,this.generateMipmaps=!1;const c=this;"requestVideoFrameCallback"in t&&t.requestVideoFrameCallback(function e(){c.needsUpdate=!0,t.requestVideoFrameCallback(e)})}clone(){return new this.constructor(this.image).copy(this)}update(){const t=this.image;!1==="requestVideoFrameCallback"in t&&t.readyState>=t.HAVE_CURRENT_DATA&&(this.needsUpdate=!0)}},t.ViewportFitAuto=3,t.ViewportFitFill=4,t.ViewportFitHorizontal=2,t.ViewportFitNone=0,t.ViewportFitOverscan=5,t.ViewportFitVertical=1,t.WebGL3DRenderTarget=class extends cn{constructor(t=1,e=1,n=1){super(t,e),this.isWebGL3DRenderTarget=!0,this.depth=n,this.texture=new hn(null,t,e,n),this.texture.isRenderTargetTexture=!0}},t.WebGLArrayRenderTarget=class extends cn{constructor(t=1,e=1,n=1){super(t,e),this.isWebGLArrayRenderTarget=!0,this.depth=n,this.texture=new un(null,t,e,n),this.texture.isRenderTargetTexture=!0}},t.WebGLCubeRenderTarget=Ii,t.WebGLMultipleRenderTargets=fn,t.WebGLRenderTarget=cn,t.WebGLRenderer=Oa,t.WebGLUtils=ba,t.WebXRUtils=tM,t.WireframeGeometry=kc,t.WrapAroundEnding=Nt,t.XZ=xp,t.XZLoader=Sp,t.ZeroCurvatureEnding=Bt,t.ZeroFactor=u,t.ZeroSlopeEnding=Lt,t.ZeroStencilOp=0,t.hs=jt,t.acceleratedRaycast=EI,t.arrayMax=Me,t.arrayMin=function(t){if(0===t.length)return 1/0;let e=t[0];for(let n=1,o=t.length;n<o;++n)t[n]<e&&(e=t[n]);return e},t.clampArray=Re,t.computeBoundsTree=xI,t.disposeBoundsTree=II,t.engineVersionCmp=Pe,t.findModulePath=Ve,t.getGlobalScope=Fe,t.isDef=ye,t.loadModule=Ge,t.sRGBEncoding=Ft,t.shaderFloatStr=Oe});
